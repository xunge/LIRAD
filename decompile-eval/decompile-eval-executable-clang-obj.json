[
    {
        "task_id": 0,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmovss  %xmm0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11a6 <func0+0xa6>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1193 <func0+0x93>\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nsubss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm1\nmovaps 0xea3(%rip),%xmm0\npand   %xmm0,%xmm1\nmovss  -0x18(%rbp),%xmm0\ncvtss2sd %xmm0,%xmm0\nucomisd %xmm1,%xmm0\njbe    1180 <func0+0x80>\nmovl   $0x1,-0x4(%rbp)\njmp    11ad <func0+0xad>\njmp    1185 <func0+0x85>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    112c <func0+0x2c>\njmp    1198 <func0+0x98>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1117 <func0+0x17>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 0,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1171 <func0+0x71>\nmovslq %esi,%r8\nmov    %esi,%r9d\nxor    %esi,%esi\nmovaps 0xeed(%rip),%xmm1\nmov    %r9,%rdx\nmov    %rdi,%rax\njmp    112d <func0+0x2d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x4,%rax\nadd    $0xffffffffffffffff,%rdx\ncmp    %r9,%rsi\nje     1171 <func0+0x71>\nmov    %rsi,%rcx\nadd    $0x1,%rsi\ncmp    %r8,%rsi\njge    1120 <func0+0x20>\nmovss  (%rdi,%rcx,4),%xmm2\nmov    $0x1,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovaps %xmm2,%xmm3\nsubss  (%rax,%rcx,4),%xmm3\nandps  %xmm1,%xmm3\nucomiss %xmm3,%xmm0\nja     116b <func0+0x6b>\nadd    $0x1,%rcx\ncmp    %rcx,%rdx\njne    1150 <func0+0x50>\njmp    1120 <func0+0x20>\nmov    $0x1,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 0,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1171 <func0+0x71>\nmov    %esi,%r8d\nxor    %edx,%edx\nmovaps 0xef0(%rip),%xmm1\nmov    %r8,%rcx\nmov    %rdi,%rsi\njmp    112d <func0+0x2d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x4,%rsi\nadd    $0xffffffffffffffff,%rcx\ncmp    %r8,%rdx\nje     1171 <func0+0x71>\nmov    %rdx,%rax\nadd    $0x1,%rdx\ncmp    %r8,%rdx\njae    1120 <func0+0x20>\nmovss  (%rdi,%rax,4),%xmm2\nmov    $0x1,%eax\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovaps %xmm2,%xmm3\nsubss  (%rsi,%rax,4),%xmm3\nandps  %xmm1,%xmm3\nucomiss %xmm3,%xmm0\nja     116b <func0+0x6b>\nadd    $0x1,%rax\ncmp    %rax,%rcx\njne    1150 <func0+0x50>\njmp    1120 <func0+0x20>\nmov    $0x1,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 0,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1171 <func0+0x71>\nmov    %esi,%r8d\nxor    %edx,%edx\nmovaps 0xef0(%rip),%xmm1\nmov    %r8,%rcx\nmov    %rdi,%rsi\njmp    112d <func0+0x2d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x4,%rsi\nadd    $0xffffffffffffffff,%rcx\ncmp    %r8,%rdx\nje     1171 <func0+0x71>\nmov    %rdx,%rax\nadd    $0x1,%rdx\ncmp    %r8,%rdx\njae    1120 <func0+0x20>\nmovss  (%rdi,%rax,4),%xmm2\nmov    $0x1,%eax\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovaps %xmm2,%xmm3\nsubss  (%rsi,%rax,4),%xmm3\nandps  %xmm1,%xmm3\nucomiss %xmm3,%xmm0\nja     116b <func0+0x6b>\nadd    $0x1,%rax\ncmp    %rax,%rcx\njne    1150 <func0+0x50>\njmp    1120 <func0+0x20>\nmov    $0x1,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 1,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1040 <strlen@plt>\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0xa,-0x1c(%rbp)\nmovslq -0x1c(%rbp),%rdi\nshl    $0x3,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmov    -0x10(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    12bd <func0+0x16d>\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x39(%rbp)\nmovsbl -0x39(%rbp),%eax\ncmp    $0x28,%eax\njne    1202 <func0+0xb2>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x39(%rbp),%dl\nmov    -0x30(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x34(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\njmp    12aa <func0+0x15a>\nmovsbl -0x39(%rbp),%eax\ncmp    $0x29,%eax\njne    12a5 <func0+0x155>\nmov    -0x18(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x39(%rbp),%dl\nmov    -0x30(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x34(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\ncmpl   $0x0,-0x18(%rbp)\njne    12a0 <func0+0x150>\nmov    -0x30(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x30(%rbp),%rdi\ncall   1070 <strdup@plt>\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    -0x10(%rbp),%rcx\nmovslq (%rcx),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    -0x1c(%rbp),%eax\njl     1299 <func0+0x149>\nmov    -0x1c(%rbp),%eax\nshl    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x28(%rbp),%rdi\nmovslq -0x1c(%rbp),%rsi\nshl    $0x3,%rsi\ncall   1060 <realloc@plt>\nmov    %rax,-0x28(%rbp)\nmovl   $0x0,-0x34(%rbp)\njmp    12a5 <func0+0x155>\njmp    12aa <func0+0x15a>\njmp    12af <func0+0x15f>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    11b5 <func0+0x65>\nmov    -0x30(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x28(%rbp),%rax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 1,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,%rbx\nmov    %rdi,%rbp\ncall   1040 <strlen@plt>\nmov    %rax,%r13\nmov    $0x50,%edi\ncall   1050 <malloc@plt>\nmov    %rax,0x8(%rsp)\nlea    0x1(%r13),%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r12\nmov    %rbx,0x10(%rsp)\nmovl   $0x0,(%rbx)\ntest   %r13d,%r13d\njle    123c <func0+0xec>\nmov    %r13d,%ebx\nmov    $0xa,%r13d\nxor    %r14d,%r14d\nxor    %eax,%eax\nxor    %r15d,%r15d\njmp    11d9 <func0+0x89>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovslq %r15d,%rdx\nlea    0x1(%rdx),%r15\nmov    %cl,(%r12,%rdx,1)\nadd    $0xffffffff,%eax\nje     11f9 <func0+0xa9>\nadd    $0x1,%r14\ncmp    %r14,%rbx\nje     123c <func0+0xec>\nmovzbl 0x0(%rbp,%r14,1),%ecx\ncmp    $0x29,%cl\nje     11c0 <func0+0x70>\ncmp    $0x28,%cl\njne    11d0 <func0+0x80>\nadd    $0x1,%eax\nmovslq %r15d,%rdx\nadd    $0x1,%r15d\nmov    %cl,(%r12,%rdx,1)\njmp    11d0 <func0+0x80>\nmovb   $0x0,(%r12,%r15,1)\nmov    %r12,%rdi\ncall   1070 <strdup@plt>\nmov    0x10(%rsp),%rdx\nmovslq (%rdx),%rcx\nmov    0x8(%rsp),%rdi\nmov    %rax,(%rdi,%rcx,8)\nlea    0x1(%rcx),%eax\nmov    %eax,(%rdx)\nxor    %r15d,%r15d\ncmp    %r13d,%eax\njl     1238 <func0+0xe8>\nadd    %r13d,%r13d\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\ncall   1060 <realloc@plt>\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\njmp    11d0 <func0+0x80>\nmov    %r12,%rdi\ncall   1030 <free@plt>\nmov    0x8(%rsp),%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 1,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,%rbx\nmov    %rdi,%rbp\ncall   1040 <strlen@plt>\nmov    %rax,%r13\nmov    $0x50,%edi\ncall   1050 <malloc@plt>\nmov    %rax,0x8(%rsp)\nlea    0x1(%r13),%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r12\nmov    %rbx,0x10(%rsp)\nmovl   $0x0,(%rbx)\ntest   %r13d,%r13d\njle    123e <func0+0xee>\nmov    %r13d,%ebx\nmov    $0xa,%r13d\nxor    %r14d,%r14d\nxor    %eax,%eax\nxor    %r15d,%r15d\njmp    11da <func0+0x8a>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovslq %r15d,%rcx\nlea    0x1(%rcx),%r15\nmovb   $0x29,(%r12,%rcx,1)\nadd    $0xffffffff,%eax\nje     11fb <func0+0xab>\nadd    $0x1,%r14\ncmp    %r14,%rbx\nje     123e <func0+0xee>\nmovzbl 0x0(%rbp,%r14,1),%ecx\ncmp    $0x29,%cl\nje     11c0 <func0+0x70>\ncmp    $0x28,%cl\njne    11d1 <func0+0x81>\nadd    $0x1,%eax\nmovslq %r15d,%rcx\nadd    $0x1,%r15d\nmovb   $0x28,(%r12,%rcx,1)\njmp    11d1 <func0+0x81>\nmovb   $0x0,(%r12,%r15,1)\nmov    %r12,%rdi\ncall   1070 <strdup@plt>\nmov    0x10(%rsp),%rdx\nmovslq (%rdx),%rcx\nmov    0x8(%rsp),%rdi\nmov    %rax,(%rdi,%rcx,8)\nlea    0x1(%rcx),%eax\nmov    %eax,(%rdx)\nxor    %r15d,%r15d\ncmp    %r13d,%eax\njl     123a <func0+0xea>\nadd    %r13d,%r13d\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\ncall   1060 <realloc@plt>\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\njmp    11d1 <func0+0x81>\nmov    %r12,%rdi\ncall   1030 <free@plt>\nmov    0x8(%rsp),%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 1,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,%rbx\nmov    %rdi,%rbp\ncall   1040 <strlen@plt>\nmov    %rax,%r13\nmov    $0x50,%edi\ncall   1050 <malloc@plt>\nmov    %rax,0x8(%rsp)\nlea    0x1(%r13),%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r12\nmov    %rbx,0x10(%rsp)\nmovl   $0x0,(%rbx)\ntest   %r13d,%r13d\njle    123e <func0+0xee>\nmov    %r13d,%ebx\nmov    $0xa,%r13d\nxor    %r14d,%r14d\nxor    %eax,%eax\nxor    %r15d,%r15d\njmp    11da <func0+0x8a>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovslq %r15d,%rcx\nlea    0x1(%rcx),%r15\nmovb   $0x29,(%r12,%rcx,1)\nadd    $0xffffffff,%eax\nje     11fb <func0+0xab>\nadd    $0x1,%r14\ncmp    %r14,%rbx\nje     123e <func0+0xee>\nmovzbl 0x0(%rbp,%r14,1),%ecx\ncmp    $0x29,%cl\nje     11c0 <func0+0x70>\ncmp    $0x28,%cl\njne    11d1 <func0+0x81>\nadd    $0x1,%eax\nmovslq %r15d,%rcx\nadd    $0x1,%r15d\nmovb   $0x28,(%r12,%rcx,1)\njmp    11d1 <func0+0x81>\nmovb   $0x0,(%r12,%r15,1)\nmov    %r12,%rdi\ncall   1070 <strdup@plt>\nmov    0x10(%rsp),%rdx\nmovslq (%rdx),%rcx\nmov    0x8(%rsp),%rdi\nmov    %rax,(%rdi,%rcx,8)\nlea    0x1(%rcx),%eax\nmov    %eax,(%rdx)\nxor    %r15d,%r15d\ncmp    %r13d,%eax\njl     123a <func0+0xea>\nadd    %r13d,%r13d\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\ncall   1060 <realloc@plt>\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\njmp    11d1 <func0+0x81>\nmov    %r12,%rdi\ncall   1030 <free@plt>\nmov    0x8(%rsp),%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 2,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\ncvttss2si -0x4(%rbp),%eax\ncvtsi2ss %eax,%xmm1\nsubss  %xmm1,%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 2,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncvttps2dq %xmm0,%xmm1\ncvtdq2ps %xmm1,%xmm1\nsubss  %xmm1,%xmm0\nret\n"
    },
    {
        "task_id": 2,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncvttps2dq %xmm0,%xmm1\ncvtdq2ps %xmm1,%xmm1\nsubss  %xmm1,%xmm0\nret\n"
    },
    {
        "task_id": 2,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncvttps2dq %xmm0,%xmm1\ncvtdq2ps %xmm1,%xmm1\nsubss  %xmm1,%xmm0\nret\n"
    },
    {
        "task_id": 3,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    115f <func0+0x5f>\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nadd    -0x18(%rbp),%eax\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njge    114c <func0+0x4c>\nmovl   $0x1,-0x4(%rbp)\njmp    1166 <func0+0x66>\njmp    1151 <func0+0x51>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1119 <func0+0x19>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 3,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\nsetg   %cl\njle    1137 <func0+0x37>\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     1137 <func0+0x37>\nmovslq %esi,%r8\nmov    %esi,%edx\nmov    $0x1,%ecx\nnopw   0x0(%rax,%rax,1)\nmov    %rcx,%rsi\ncmp    %rcx,%rdx\nje     1131 <func0+0x31>\nlea    0x1(%rsi),%rcx\nadd    (%rdi,%rsi,4),%eax\njns    1120 <func0+0x20>\ncmp    %r8,%rsi\nsetl   %cl\nmovzbl %cl,%eax\nret\n"
    },
    {
        "task_id": 3,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    113a <func0+0x3a>\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     113d <func0+0x3d>\nmov    %esi,%ecx\nmov    $0x1,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %rsi,%rdx\ncmp    %rsi,%rcx\nje     1131 <func0+0x31>\nlea    0x1(%rdx),%rsi\nadd    (%rdi,%rdx,4),%eax\njns    1120 <func0+0x20>\nxor    %eax,%eax\ncmp    %rcx,%rdx\nsetb   %al\nret\nxor    %eax,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 3,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    113a <func0+0x3a>\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     113d <func0+0x3d>\nmov    %esi,%ecx\nmov    $0x1,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %rsi,%rdx\ncmp    %rsi,%rcx\nje     1131 <func0+0x31>\nlea    0x1(%rdx),%rsi\nadd    (%rdi,%rdx,4),%eax\njns    1120 <func0+0x20>\nxor    %eax,%eax\ncmp    %rcx,%rdx\nsetb   %al\nret\nxor    %eax,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 4,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nxorps  %xmm0,%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1152 <func0+0x52>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\naddss  -0x10(%rbp),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1121 <func0+0x21>\nmovss  -0x10(%rbp),%xmm0\ncvtsi2ssl -0xc(%rbp),%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x14(%rbp)\nxorps  %xmm0,%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11c5 <func0+0xc5>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nsubss  -0x14(%rbp),%xmm0\ncvtss2sd %xmm0,%xmm1\nmovaps 0xe63(%rip),%xmm0\npand   %xmm0,%xmm1\nmovss  -0x18(%rbp),%xmm0\ncvtss2sd %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncvtsd2ss %xmm0,%xmm0\nmovss  %xmm0,-0x18(%rbp)\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1174 <func0+0x74>\nmovss  -0x18(%rbp),%xmm0\ncvtsi2ssl -0xc(%rbp),%xmm1\ndivss  %xmm1,%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 4,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxorps  %xmm0,%xmm0\nmov    %esi,%eax\nxorps  %xmm1,%xmm1\ntest   %esi,%esi\njle    112e <func0+0x2e>\nxorps  %xmm1,%xmm1\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\naddss  (%rdi,%rcx,4),%xmm1\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1120 <func0+0x20>\ncvtsi2ss %esi,%xmm2\ntest   %esi,%esi\njle    1169 <func0+0x69>\ndivss  %xmm2,%xmm1\nxorps  %xmm0,%xmm0\nxor    %ecx,%ecx\nmovaps 0xeba(%rip),%xmm3\ncs nopw 0x0(%rax,%rax,1)\nmovss  (%rdi,%rcx,4),%xmm4\nsubss  %xmm1,%xmm4\nandps  %xmm3,%xmm4\naddss  %xmm4,%xmm0\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1150 <func0+0x50>\ndivss  %xmm2,%xmm0\nret\n"
    },
    {
        "task_id": 4,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    111e <func0+0x1e>\nmov    %esi,%r9d\nlea    -0x1(%r9),%r8\nmov    %r9d,%ecx\nand    $0x7,%ecx\ncmp    $0x7,%r8\njae    1127 <func0+0x27>\nxorps  %xmm1,%xmm1\nxor    %edx,%edx\njmp    1178 <func0+0x78>\ncvtsi2ss %esi,%xmm2\njmp    11bd <func0+0xbd>\nmov    %r9d,%eax\nand    $0xfffffff8,%eax\nxorps  %xmm1,%xmm1\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\naddss  (%rdi,%rdx,4),%xmm1\naddss  0x4(%rdi,%rdx,4),%xmm1\naddss  0x8(%rdi,%rdx,4),%xmm1\naddss  0xc(%rdi,%rdx,4),%xmm1\naddss  0x10(%rdi,%rdx,4),%xmm1\naddss  0x14(%rdi,%rdx,4),%xmm1\naddss  0x18(%rdi,%rdx,4),%xmm1\naddss  0x1c(%rdi,%rdx,4),%xmm1\nadd    $0x8,%rdx\ncmp    %rdx,%rax\njne    1140 <func0+0x40>\ntest   %rcx,%rcx\nje     119e <func0+0x9e>\nlea    (%rdi,%rdx,4),%rax\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\naddss  (%rax,%rdx,4),%xmm1\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    1190 <func0+0x90>\ncvtsi2ss %esi,%xmm2\ntest   %esi,%esi\njle    11bd <func0+0xbd>\ndivss  %xmm2,%xmm1\nmov    %r9d,%ecx\nand    $0x3,%ecx\ncmp    $0x3,%r8\njae    11c5 <func0+0xc5>\nxorps  %xmm0,%xmm0\nxor    %edx,%edx\njmp    122c <func0+0x12c>\nxorps  %xmm0,%xmm0\ndivss  %xmm2,%xmm0\nret\nand    $0xfffffffc,%r9d\nxorps  %xmm0,%xmm0\nxor    %edx,%edx\nmovaps 0xe2b(%rip),%xmm3\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovss  (%rdi,%rdx,4),%xmm4\nmovss  0x4(%rdi,%rdx,4),%xmm5\nsubss  %xmm1,%xmm4\nandps  %xmm3,%xmm4\naddss  %xmm0,%xmm4\nsubss  %xmm1,%xmm5\nandps  %xmm3,%xmm5\naddss  %xmm4,%xmm5\nmovss  0x8(%rdi,%rdx,4),%xmm4\nsubss  %xmm1,%xmm4\nandps  %xmm3,%xmm4\naddss  %xmm5,%xmm4\nmovss  0xc(%rdi,%rdx,4),%xmm0\nsubss  %xmm1,%xmm0\nandps  %xmm3,%xmm0\naddss  %xmm4,%xmm0\nadd    $0x4,%rdx\ncmp    %rdx,%r9\njne    11e0 <func0+0xe0>\ntest   %rcx,%rcx\nje     1259 <func0+0x159>\nlea    (%rdi,%rdx,4),%rax\nxor    %edx,%edx\nmovaps 0xdc2(%rip),%xmm3\nxchg   %ax,%ax\nmovss  (%rax,%rdx,4),%xmm4\nsubss  %xmm1,%xmm4\nandps  %xmm3,%xmm4\naddss  %xmm4,%xmm0\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    1240 <func0+0x140>\ndivss  %xmm2,%xmm0\nret\n"
    },
    {
        "task_id": 4,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    111e <func0+0x1e>\nmov    %esi,%r9d\nlea    -0x1(%r9),%r8\nmov    %r9d,%ecx\nand    $0x7,%ecx\ncmp    $0x7,%r8\njae    112a <func0+0x2a>\nxorps  %xmm1,%xmm1\nxor    %edx,%edx\njmp    1178 <func0+0x78>\ncvtsi2ss %esi,%xmm2\nxorps  %xmm0,%xmm0\ndivss  %xmm2,%xmm0\nret\nmov    %r9d,%eax\nand    $0xfffffff8,%eax\nxorps  %xmm1,%xmm1\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnop\naddss  (%rdi,%rdx,4),%xmm1\naddss  0x4(%rdi,%rdx,4),%xmm1\naddss  0x8(%rdi,%rdx,4),%xmm1\naddss  0xc(%rdi,%rdx,4),%xmm1\naddss  0x10(%rdi,%rdx,4),%xmm1\naddss  0x14(%rdi,%rdx,4),%xmm1\naddss  0x18(%rdi,%rdx,4),%xmm1\naddss  0x1c(%rdi,%rdx,4),%xmm1\nadd    $0x8,%rdx\ncmp    %rdx,%rax\njne    1140 <func0+0x40>\ntest   %rcx,%rcx\nje     119e <func0+0x9e>\nlea    (%rdi,%rdx,4),%rax\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\naddss  (%rax,%rdx,4),%xmm1\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    1190 <func0+0x90>\ncvtsi2ss %esi,%xmm2\ntest   %esi,%esi\njle    11bd <func0+0xbd>\ndivss  %xmm2,%xmm1\nmov    %r9d,%ecx\nand    $0x3,%ecx\ncmp    $0x3,%r8\njae    11c5 <func0+0xc5>\nxorps  %xmm0,%xmm0\nxor    %edx,%edx\njmp    122c <func0+0x12c>\nxorps  %xmm0,%xmm0\ndivss  %xmm2,%xmm0\nret\nand    $0xfffffffc,%r9d\nxorps  %xmm0,%xmm0\nxor    %edx,%edx\nmovaps 0xe2b(%rip),%xmm3\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovss  (%rdi,%rdx,4),%xmm4\nmovss  0x4(%rdi,%rdx,4),%xmm5\nsubss  %xmm1,%xmm4\nandps  %xmm3,%xmm4\naddss  %xmm0,%xmm4\nsubss  %xmm1,%xmm5\nandps  %xmm3,%xmm5\naddss  %xmm4,%xmm5\nmovss  0x8(%rdi,%rdx,4),%xmm4\nsubss  %xmm1,%xmm4\nandps  %xmm3,%xmm4\naddss  %xmm5,%xmm4\nmovss  0xc(%rdi,%rdx,4),%xmm0\nsubss  %xmm1,%xmm0\nandps  %xmm3,%xmm0\naddss  %xmm4,%xmm0\nadd    $0x4,%rdx\ncmp    %rdx,%r9\njne    11e0 <func0+0xe0>\ntest   %rcx,%rcx\nje     1259 <func0+0x159>\nlea    (%rdi,%rdx,4),%rax\nxor    %edx,%edx\nmovaps 0xdc2(%rip),%xmm3\nxchg   %ax,%ax\nmovss  (%rax,%rdx,4),%xmm4\nsubss  %xmm1,%xmm4\nandps  %xmm3,%xmm4\naddss  %xmm4,%xmm0\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    1240 <func0+0x140>\ndivss  %xmm2,%xmm0\nret\n"
    },
    {
        "task_id": 5,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\nmov    %rcx,-0x18(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njle    1141 <func0+0x31>\nmov    -0xc(%rbp),%eax\nshl    $0x1,%eax\nsub    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    114b <func0+0x3b>\nxor    %eax,%eax\nmov    %eax,-0x2c(%rbp)\njmp    114b <func0+0x3b>\nmov    -0x2c(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x18(%rbp),%rax\nmovslq (%rax),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x20(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njle    117e <func0+0x6e>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x20(%rbp),%rax\nmov    %ecx,(%rax)\nmovl   $0x1,-0x24(%rbp)\nmovl   $0x1,-0x28(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11de <func0+0xce>\nmov    -0x10(%rbp),%edx\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x28(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x28(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    118c <func0+0x7c>\nmov    -0x20(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 5,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %esi,%r14d\nxor    %eax,%eax\ntest   %esi,%esi\nlea    -0x1(%r14,%r14,1),%esi\ncmovle %eax,%esi\nmov    %edx,%ebp\nmov    %rdi,%rbx\nmov    %esi,(%rcx)\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\ntest   %r14d,%r14d\njle    113f <func0+0x2f>\nmov    (%rbx),%ecx\nmov    %ecx,(%rax)\ncmp    $0x2,%r14d\njl     1163 <func0+0x53>\nmov    %r14d,%ecx\nmov    $0x1,%edx\nnopl   (%rax)\nmov    %ebp,-0x4(%rax,%rdx,8)\nmov    (%rbx,%rdx,4),%esi\nmov    %esi,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    1150 <func0+0x40>\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 5,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %esi,%ebp\nxor    %eax,%eax\ntest   %esi,%esi\nlea    -0x1(%rbp,%rbp,1),%esi\ncmovle %eax,%esi\nmov    %edx,%r14d\nmov    %rdi,%rbx\nmov    %esi,(%rcx)\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\ntest   %ebp,%ebp\njle    1274 <func0+0x164>\nmov    (%rbx),%ecx\nmov    %ecx,(%rax)\ncmp    $0x1,%ebp\nje     1274 <func0+0x164>\nmov    %ebp,%ecx\nlea    -0x1(%rcx),%r8\nmov    $0x1,%edi\nmov    $0x1,%esi\ncmp    $0x4,%r8\njb     124d <func0+0x13d>\nmov    %r8,%rsi\nand    $0xfffffffffffffffc,%rsi\nmovd   %r14d,%xmm0\npshufd $0x50,%xmm0,%xmm0\nlea    -0x4(%rsi),%rdi\nmov    %rdi,%rdx\nshr    $0x2,%rdx\nadd    $0x1,%rdx\ntest   %rdi,%rdi\nje     1279 <func0+0x169>\nmov    %rdx,%rbp\nand    $0xfffffffffffffffe,%rbp\nxor    %edi,%edi\ncs nopw 0x0(%rax,%rax,1)\nmovq   0x4(%rbx,%rdi,4),%xmm1\nmovq   0xc(%rbx,%rdi,4),%xmm2\nmovdqa %xmm0,%xmm3\npunpckldq %xmm1,%xmm3\nmovdqu %xmm3,0x4(%rax,%rdi,8)\nmovdqa %xmm0,%xmm1\npunpckldq %xmm2,%xmm1\nmovdqu %xmm1,0x14(%rax,%rdi,8)\nmovq   0x14(%rbx,%rdi,4),%xmm1\nmovq   0x1c(%rbx,%rdi,4),%xmm2\nmovdqa %xmm0,%xmm3\npunpckldq %xmm1,%xmm3\nmovdqu %xmm3,0x24(%rax,%rdi,8)\nmovdqa %xmm0,%xmm1\npunpckldq %xmm2,%xmm1\nmovdqu %xmm1,0x34(%rax,%rdi,8)\nadd    $0x8,%rdi\nadd    $0xfffffffffffffffe,%rbp\njne    11a0 <func0+0x90>\ntest   $0x1,%dl\nje     123d <func0+0x12d>\nlea    0x0(,%rdi,4),%rdx\nshl    $0x3,%rdi\nor     $0x4,%rdx\nmovq   (%rbx,%rdx,1),%xmm1\nmovq   0x8(%rbx,%rdx,1),%xmm2\nmov    %rdi,%rdx\nor     $0x8,%rdx\nor     $0x18,%rdi\nmovdqa %xmm0,%xmm3\npunpckldq %xmm1,%xmm3\nmovdqu %xmm3,-0x4(%rax,%rdx,1)\npunpckldq %xmm2,%xmm0\nmovdqu %xmm0,-0x4(%rax,%rdi,1)\ncmp    %rsi,%r8\nje     1274 <func0+0x164>\nlea    0x1(%rsi),%rdi\nadd    %rsi,%rsi\nadd    $0x1,%rsi\nlea    (%rbx,%rdi,4),%rdx\nsub    %rdi,%rcx\nlea    (%rax,%rsi,4),%rsi\nadd    $0x4,%rsi\nxor    %edi,%edi\nxchg   %ax,%ax\nmov    %r14d,-0x4(%rsi,%rdi,8)\nmov    (%rdx,%rdi,4),%ebp\nmov    %ebp,(%rsi,%rdi,8)\nadd    $0x1,%rdi\ncmp    %rdi,%rcx\njne    1260 <func0+0x150>\npop    %rbx\npop    %r14\npop    %rbp\nret\nxor    %edi,%edi\ntest   $0x1,%dl\njne    11ff <func0+0xef>\njmp    123d <func0+0x12d>\n"
    },
    {
        "task_id": 5,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %esi,%ebp\nxor    %eax,%eax\ntest   %esi,%esi\nlea    -0x1(%rbp,%rbp,1),%esi\ncmovle %eax,%esi\nmov    %edx,%r14d\nmov    %rdi,%rbx\nmov    %esi,(%rcx)\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\ntest   %ebp,%ebp\njle    1274 <func0+0x164>\nmov    (%rbx),%ecx\nmov    %ecx,(%rax)\ncmp    $0x1,%ebp\nje     1274 <func0+0x164>\nmov    %ebp,%ecx\nlea    -0x1(%rcx),%r8\nmov    $0x1,%edi\nmov    $0x1,%esi\ncmp    $0x4,%r8\njb     124d <func0+0x13d>\nmov    %r8,%rsi\nand    $0xfffffffffffffffc,%rsi\nmovd   %r14d,%xmm0\npshufd $0x50,%xmm0,%xmm0\nlea    -0x4(%rsi),%rdi\nmov    %rdi,%rdx\nshr    $0x2,%rdx\nadd    $0x1,%rdx\ntest   %rdi,%rdi\nje     1279 <func0+0x169>\nmov    %rdx,%rbp\nand    $0xfffffffffffffffe,%rbp\nxor    %edi,%edi\ncs nopw 0x0(%rax,%rax,1)\nmovq   0x4(%rbx,%rdi,4),%xmm1\nmovq   0xc(%rbx,%rdi,4),%xmm2\nmovdqa %xmm0,%xmm3\npunpckldq %xmm1,%xmm3\nmovdqu %xmm3,0x4(%rax,%rdi,8)\nmovdqa %xmm0,%xmm1\npunpckldq %xmm2,%xmm1\nmovdqu %xmm1,0x14(%rax,%rdi,8)\nmovq   0x14(%rbx,%rdi,4),%xmm1\nmovq   0x1c(%rbx,%rdi,4),%xmm2\nmovdqa %xmm0,%xmm3\npunpckldq %xmm1,%xmm3\nmovdqu %xmm3,0x24(%rax,%rdi,8)\nmovdqa %xmm0,%xmm1\npunpckldq %xmm2,%xmm1\nmovdqu %xmm1,0x34(%rax,%rdi,8)\nadd    $0x8,%rdi\nadd    $0xfffffffffffffffe,%rbp\njne    11a0 <func0+0x90>\ntest   $0x1,%dl\nje     123d <func0+0x12d>\nlea    0x0(,%rdi,4),%rdx\nshl    $0x3,%rdi\nor     $0x4,%rdx\nmovq   (%rbx,%rdx,1),%xmm1\nmovq   0x8(%rbx,%rdx,1),%xmm2\nmov    %rdi,%rdx\nor     $0x8,%rdx\nor     $0x18,%rdi\nmovdqa %xmm0,%xmm3\npunpckldq %xmm1,%xmm3\nmovdqu %xmm3,-0x4(%rax,%rdx,1)\npunpckldq %xmm2,%xmm0\nmovdqu %xmm0,-0x4(%rax,%rdi,1)\ncmp    %rsi,%r8\nje     1274 <func0+0x164>\nlea    0x1(%rsi),%rdi\nadd    %rsi,%rsi\nadd    $0x1,%rsi\nlea    (%rbx,%rdi,4),%rdx\nsub    %rdi,%rcx\nlea    (%rax,%rsi,4),%rsi\nadd    $0x4,%rsi\nxor    %edi,%edi\nxchg   %ax,%ax\nmov    %r14d,-0x4(%rsi,%rdi,8)\nmov    (%rdx,%rdi,4),%ebp\nmov    %ebp,(%rsi,%rdi,8)\nadd    $0x1,%rdi\ncmp    %rdi,%rcx\njne    1260 <func0+0x150>\npop    %rbx\npop    %r14\npop    %rbp\nret\nxor    %edi,%edi\ntest   $0x1,%dl\njne    11ff <func0+0xef>\njmp    123d <func0+0x12d>\n"
    },
    {
        "task_id": 6,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovq   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1211 <func0+0x101>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x29(%rbp)\nmovsbl -0x29(%rbp),%eax\ncmp    $0x28,%eax\njne    119b <func0+0x8b>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njle    1196 <func0+0x86>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x20(%rbp)\njmp    11fe <func0+0xee>\nmovsbl -0x29(%rbp),%eax\ncmp    $0x29,%eax\njne    11f9 <func0+0xe9>\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njne    11f4 <func0+0xe4>\nmov    -0x18(%rbp),%rdi\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rsi\nshl    $0x2,%rsi\ncall   1030 <realloc@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x20(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x28(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nmovl   $0x0,-0x20(%rbp)\njmp    11f9 <func0+0xe9>\njmp    11fe <func0+0xee>\njmp    1203 <func0+0xf3>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    114b <func0+0x3b>\nmov    -0x28(%rbp),%ecx\nmov    -0x10(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 6,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rsi,%r14\nmov    %rdi,%rbx\nxor    %ecx,%ecx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\nxor    %eax,%eax\njmp    1138 <func0+0x28>\nnopl   0x0(%rax)\ntest   %dl,%dl\nje     117e <func0+0x6e>\nadd    $0x1,%rbx\nmovzbl (%rbx),%edx\ncmp    $0x28,%dl\nje     1170 <func0+0x60>\ncmp    $0x29,%dl\njne    1130 <func0+0x20>\nadd    $0xffffffff,%ecx\njne    1134 <func0+0x24>\nmovslq %r15d,%r12\nadd    $0x1,%r15d\nlea    0x4(,%r12,4),%rsi\nmov    %rax,%rdi\ncall   1030 <realloc@plt>\nmov    %ebp,(%rax,%r12,4)\nxor    %ecx,%ecx\nxor    %ebp,%ebp\njmp    1134 <func0+0x24>\nnopl   0x0(%rax,%rax,1)\ncmp    %ebp,%ecx\nlea    0x1(%rcx),%ecx\ncmovge %ecx,%ebp\nadd    $0x1,%rbx\njmp    1138 <func0+0x28>\nmov    %r15d,(%r14)\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 6,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rsi,%r14\nmov    %rdi,%rbx\nxor    %ecx,%ecx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\nxor    %eax,%eax\njmp    1138 <func0+0x28>\nnopl   0x0(%rax)\ntest   %dl,%dl\nje     117e <func0+0x6e>\nadd    $0x1,%rbx\nmovzbl (%rbx),%edx\ncmp    $0x28,%dl\nje     1170 <func0+0x60>\ncmp    $0x29,%dl\njne    1130 <func0+0x20>\nadd    $0xffffffff,%ecx\njne    1134 <func0+0x24>\nmovslq %r15d,%r12\nadd    $0x1,%r15d\nlea    0x4(,%r12,4),%rsi\nmov    %rax,%rdi\ncall   1030 <realloc@plt>\nmov    %ebp,(%rax,%r12,4)\nxor    %ecx,%ecx\nxor    %ebp,%ebp\njmp    1134 <func0+0x24>\nnopl   0x0(%rax,%rax,1)\ncmp    %ebp,%ecx\nlea    0x1(%rcx),%ecx\ncmovge %ecx,%ebp\nadd    $0x1,%rbx\njmp    1138 <func0+0x28>\nmov    %r15d,(%r14)\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 6,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rsi,%r14\nmov    %rdi,%rbx\nxor    %ecx,%ecx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\nxor    %eax,%eax\nmov    (%rbx),%dl\ncmp    $0x28,%dl\njne    1154 <func0+0x44>\njmp    1140 <func0+0x30>\ntest   %dl,%dl\nje     117f <func0+0x6f>\nadd    $0x1,%rbx\nmovzbl (%rbx),%edx\ncmp    $0x28,%dl\njne    1154 <func0+0x44>\ncmp    %ebp,%ecx\nlea    0x1(%rcx),%ecx\ncmovge %ecx,%ebp\nadd    $0x1,%rbx\nmovzbl (%rbx),%edx\ncmp    $0x28,%dl\nje     1140 <func0+0x30>\ncmp    $0x29,%dl\njne    1130 <func0+0x20>\nadd    $0xffffffff,%ecx\njne    1134 <func0+0x24>\nmovslq %r15d,%r12\nadd    $0x1,%r15d\nlea    0x4(,%r12,4),%rsi\nmov    %rax,%rdi\ncall   1030 <realloc@plt>\nmov    %ebp,(%rax,%r12,4)\nxor    %ecx,%ecx\nxor    %ebp,%ebp\njmp    1134 <func0+0x24>\nmov    %r15d,(%r14)\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 7,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11c6 <func0+0xa6>\nmov    -0x8(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nmov    -0x18(%rbp),%rsi\ncall   1040 <strstr@plt>\ncmp    $0x0,%rax\nje     11b3 <func0+0x93>\nmov    -0x28(%rbp),%rdi\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rsi\nshl    $0x3,%rsi\ncall   1030 <realloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdx\nmov    -0x28(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    11b8 <func0+0x98>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    114d <func0+0x2d>\nmov    -0x2c(%rbp),%ecx\nmov    -0x20(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x28(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 7,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,0x8(%rsp)\nmov    %rdx,0x10(%rsp)\ntest   %esi,%esi\njle    118f <func0+0x6f>\nmov    %rdi,%r12\nmov    %esi,%r13d\nxor    %r14d,%r14d\nxor    %ebp,%ebp\nxor    %ebx,%ebx\njmp    1159 <func0+0x39>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r14\ncmp    %r14,%r13\nje     1193 <func0+0x73>\nmov    (%r12,%r14,8),%rdi\nmov    0x10(%rsp),%rsi\ncall   1040 <strstr@plt>\ntest   %rax,%rax\nje     1150 <func0+0x30>\nmovslq %ebp,%r15\nadd    $0x1,%ebp\nlea    0x8(,%r15,8),%rsi\nmov    %rbx,%rdi\ncall   1030 <realloc@plt>\nmov    %rax,%rbx\nmov    (%r12,%r14,8),%rax\nmov    %rax,(%rbx,%r15,8)\njmp    1150 <func0+0x30>\nxor    %ebx,%ebx\nxor    %ebp,%ebp\nmov    0x8(%rsp),%rax\nmov    %ebp,(%rax)\nmov    %rbx,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 7,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,0x8(%rsp)\nmov    %rdx,0x10(%rsp)\ntest   %esi,%esi\njle    118f <func0+0x6f>\nmov    %rdi,%r12\nmov    %esi,%r13d\nxor    %r14d,%r14d\nxor    %ebp,%ebp\nxor    %ebx,%ebx\njmp    1159 <func0+0x39>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r14\ncmp    %r14,%r13\nje     1193 <func0+0x73>\nmov    (%r12,%r14,8),%rdi\nmov    0x10(%rsp),%rsi\ncall   1040 <strstr@plt>\ntest   %rax,%rax\nje     1150 <func0+0x30>\nmovslq %ebp,%r15\nadd    $0x1,%ebp\nlea    0x8(,%r15,8),%rsi\nmov    %rbx,%rdi\ncall   1030 <realloc@plt>\nmov    %rax,%rbx\nmov    (%r12,%r14,8),%rax\nmov    %rax,(%rbx,%r15,8)\njmp    1150 <func0+0x30>\nxor    %ebx,%ebx\nxor    %ebp,%ebp\nmov    0x8(%rsp),%rax\nmov    %ebp,(%rax)\nmov    %rbx,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 7,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,0x8(%rsp)\nmov    %rdx,0x10(%rsp)\ntest   %esi,%esi\njle    118f <func0+0x6f>\nmov    %rdi,%r12\nmov    %esi,%r13d\nxor    %r14d,%r14d\nxor    %ebp,%ebp\nxor    %ebx,%ebx\njmp    1159 <func0+0x39>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r14\ncmp    %r14,%r13\nje     1193 <func0+0x73>\nmov    (%r12,%r14,8),%rdi\nmov    0x10(%rsp),%rsi\ncall   1040 <strstr@plt>\ntest   %rax,%rax\nje     1150 <func0+0x30>\nmovslq %ebp,%r15\nadd    $0x1,%ebp\nlea    0x8(,%r15,8),%rsi\nmov    %rbx,%rdi\ncall   1030 <realloc@plt>\nmov    %rax,%rbx\nmov    (%r12,%r14,8),%rax\nmov    %rax,(%rbx,%r15,8)\njmp    1150 <func0+0x30>\nxor    %ebx,%ebx\nxor    %ebp,%ebp\nmov    0x8(%rsp),%rax\nmov    %ebp,(%rax)\nmov    %rbx,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 8,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x1,-0x20(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1161 <func0+0x61>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nadd    -0x1c(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nimul   -0x20(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1124 <func0+0x24>\nmov    -0x1c(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x20(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,0x4(%rax)\npop    %rbp\nret\n"
    },
    {
        "task_id": 8,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1126 <func0+0x26>\nmov    %esi,%r8d\nxor    %ecx,%ecx\nmov    $0x1,%eax\nxor    %esi,%esi\nmov    (%rdi,%rcx,4),%r9d\nadd    %r9d,%esi\nimul   %r9d,%eax\nadd    $0x1,%rcx\ncmp    %rcx,%r8\njne    1110 <func0+0x10>\njmp    112d <func0+0x2d>\nmov    $0x1,%eax\nxor    %esi,%esi\nmov    %esi,(%rdx)\nmov    %eax,0x4(%rdx)\nret\n"
    },
    {
        "task_id": 8,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    111b <func0+0x1b>\nmov    %esi,%r9d\ncmp    $0x8,%esi\njae    1127 <func0+0x27>\nxor    %r10d,%r10d\nmov    $0x1,%esi\nxor    %eax,%eax\njmp    12c0 <func0+0x1c0>\nmov    $0x1,%esi\nxor    %eax,%eax\njmp    12d2 <func0+0x1d2>\nmov    %r9d,%r10d\nand    $0xfffffff8,%r10d\nlea    -0x8(%r10),%rax\nmov    %rax,%r8\nshr    $0x3,%r8\nadd    $0x1,%r8\ntest   %rax,%rax\nje     12d8 <func0+0x1d8>\nmov    %r8,%rax\nand    $0xfffffffffffffffe,%rax\npxor   %xmm9,%xmm9\nmovdqa 0xea6(%rip),%xmm1\nxor    %esi,%esi\nmovdqa %xmm1,%xmm3\npxor   %xmm2,%xmm2\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovdqu (%rdi,%rsi,4),%xmm6\nmovdqu 0x10(%rdi,%rsi,4),%xmm4\nmovdqu 0x20(%rdi,%rsi,4),%xmm7\nmovdqu 0x30(%rdi,%rsi,4),%xmm8\npaddd  %xmm6,%xmm9\npaddd  %xmm4,%xmm2\npshufd $0xf5,%xmm6,%xmm5\npshufd $0xf5,%xmm1,%xmm0\npmuludq %xmm5,%xmm0\npmuludq %xmm1,%xmm6\npshufd $0xf5,%xmm4,%xmm1\npshufd $0xf5,%xmm3,%xmm5\npmuludq %xmm1,%xmm5\npmuludq %xmm3,%xmm4\npaddd  %xmm7,%xmm9\npaddd  %xmm8,%xmm2\npmuludq %xmm7,%xmm6\npshufd $0xe8,%xmm6,%xmm1\npshufd $0xf5,%xmm7,%xmm3\npmuludq %xmm0,%xmm3\npshufd $0xe8,%xmm3,%xmm0\npunpckldq %xmm0,%xmm1\npmuludq %xmm8,%xmm4\npshufd $0xe8,%xmm4,%xmm3\npshufd $0xf5,%xmm8,%xmm0\npmuludq %xmm5,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npunpckldq %xmm0,%xmm3\nadd    $0x10,%rsi\nadd    $0xfffffffffffffffe,%rax\njne    1170 <func0+0x70>\ntest   $0x1,%r8b\nje     1267 <func0+0x167>\nmovdqu (%rdi,%rsi,4),%xmm0\nmovdqu 0x10(%rdi,%rsi,4),%xmm4\npaddd  %xmm0,%xmm9\npaddd  %xmm4,%xmm2\npshufd $0xf5,%xmm0,%xmm5\npmuludq %xmm1,%xmm0\npshufd $0xf5,%xmm1,%xmm1\npshufd $0xe8,%xmm0,%xmm0\npmuludq %xmm5,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm0\npshufd $0xf5,%xmm4,%xmm1\npmuludq %xmm3,%xmm4\npshufd $0xf5,%xmm3,%xmm3\npshufd $0xe8,%xmm4,%xmm4\npmuludq %xmm1,%xmm3\npshufd $0xe8,%xmm3,%xmm1\npunpckldq %xmm1,%xmm4\nmovdqa %xmm0,%xmm1\nmovdqa %xmm4,%xmm3\npaddd  %xmm2,%xmm9\npshufd $0xee,%xmm9,%xmm0\npaddd  %xmm9,%xmm0\npshufd $0x55,%xmm0,%xmm2\npaddd  %xmm0,%xmm2\nmovd   %xmm2,%eax\npshufd $0xf5,%xmm1,%xmm0\npshufd $0xf5,%xmm3,%xmm2\npmuludq %xmm0,%xmm2\npmuludq %xmm1,%xmm3\npshufd $0xee,%xmm3,%xmm0\npmuludq %xmm3,%xmm0\npshufd $0xaa,%xmm2,%xmm1\npmuludq %xmm2,%xmm1\npmuludq %xmm0,%xmm1\nmovd   %xmm1,%esi\ncmp    %r9,%r10\nje     12d2 <func0+0x1d2>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    (%rdi,%r10,4),%ecx\nadd    %ecx,%eax\nimul   %ecx,%esi\nadd    $0x1,%r10\ncmp    %r10,%r9\njne    12c0 <func0+0x1c0>\nmov    %eax,(%rdx)\nmov    %esi,0x4(%rdx)\nret\npxor   %xmm9,%xmm9\nmovdqa 0xd1b(%rip),%xmm1\nxor    %esi,%esi\nmovdqa %xmm1,%xmm3\npxor   %xmm2,%xmm2\ntest   $0x1,%r8b\njne    120b <func0+0x10b>\njmp    1267 <func0+0x167>\n"
    },
    {
        "task_id": 8,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    111b <func0+0x1b>\nmov    %esi,%r9d\ncmp    $0x8,%esi\njae    1127 <func0+0x27>\nxor    %r10d,%r10d\nmov    $0x1,%esi\nxor    %eax,%eax\njmp    12c0 <func0+0x1c0>\nmov    $0x1,%esi\nxor    %eax,%eax\njmp    12d2 <func0+0x1d2>\nmov    %r9d,%r10d\nand    $0xfffffff8,%r10d\nlea    -0x8(%r10),%rax\nmov    %rax,%r8\nshr    $0x3,%r8\nadd    $0x1,%r8\ntest   %rax,%rax\nje     12d8 <func0+0x1d8>\nmov    %r8,%rax\nand    $0xfffffffffffffffe,%rax\npxor   %xmm9,%xmm9\nmovdqa 0xea6(%rip),%xmm1\nxor    %esi,%esi\nmovdqa %xmm1,%xmm3\npxor   %xmm2,%xmm2\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovdqu (%rdi,%rsi,4),%xmm6\nmovdqu 0x10(%rdi,%rsi,4),%xmm4\nmovdqu 0x20(%rdi,%rsi,4),%xmm7\nmovdqu 0x30(%rdi,%rsi,4),%xmm8\npaddd  %xmm6,%xmm9\npaddd  %xmm4,%xmm2\npshufd $0xf5,%xmm6,%xmm5\npshufd $0xf5,%xmm1,%xmm0\npmuludq %xmm5,%xmm0\npmuludq %xmm1,%xmm6\npshufd $0xf5,%xmm4,%xmm1\npshufd $0xf5,%xmm3,%xmm5\npmuludq %xmm1,%xmm5\npmuludq %xmm3,%xmm4\npaddd  %xmm7,%xmm9\npaddd  %xmm8,%xmm2\npmuludq %xmm7,%xmm6\npshufd $0xe8,%xmm6,%xmm1\npshufd $0xf5,%xmm7,%xmm3\npmuludq %xmm0,%xmm3\npshufd $0xe8,%xmm3,%xmm0\npunpckldq %xmm0,%xmm1\npmuludq %xmm8,%xmm4\npshufd $0xe8,%xmm4,%xmm3\npshufd $0xf5,%xmm8,%xmm0\npmuludq %xmm5,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npunpckldq %xmm0,%xmm3\nadd    $0x10,%rsi\nadd    $0xfffffffffffffffe,%rax\njne    1170 <func0+0x70>\ntest   $0x1,%r8b\nje     1267 <func0+0x167>\nmovdqu (%rdi,%rsi,4),%xmm0\nmovdqu 0x10(%rdi,%rsi,4),%xmm4\npaddd  %xmm0,%xmm9\npaddd  %xmm4,%xmm2\npshufd $0xf5,%xmm0,%xmm5\npmuludq %xmm1,%xmm0\npshufd $0xf5,%xmm1,%xmm1\npshufd $0xe8,%xmm0,%xmm0\npmuludq %xmm5,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm0\npshufd $0xf5,%xmm4,%xmm1\npmuludq %xmm3,%xmm4\npshufd $0xf5,%xmm3,%xmm3\npshufd $0xe8,%xmm4,%xmm4\npmuludq %xmm1,%xmm3\npshufd $0xe8,%xmm3,%xmm1\npunpckldq %xmm1,%xmm4\nmovdqa %xmm0,%xmm1\nmovdqa %xmm4,%xmm3\npaddd  %xmm2,%xmm9\npshufd $0xee,%xmm9,%xmm0\npaddd  %xmm9,%xmm0\npshufd $0x55,%xmm0,%xmm2\npaddd  %xmm0,%xmm2\nmovd   %xmm2,%eax\npshufd $0xf5,%xmm1,%xmm0\npshufd $0xf5,%xmm3,%xmm2\npmuludq %xmm0,%xmm2\npmuludq %xmm1,%xmm3\npshufd $0xee,%xmm3,%xmm0\npmuludq %xmm3,%xmm0\npshufd $0xaa,%xmm2,%xmm1\npmuludq %xmm2,%xmm1\npmuludq %xmm0,%xmm1\nmovd   %xmm1,%esi\ncmp    %r9,%r10\nje     12d2 <func0+0x1d2>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    (%rdi,%r10,4),%ecx\nadd    %ecx,%eax\nimul   %ecx,%esi\nadd    $0x1,%r10\ncmp    %r10,%r9\njne    12c0 <func0+0x1c0>\nmov    %eax,(%rdx)\nmov    %esi,0x4(%rdx)\nret\npxor   %xmm9,%xmm9\nmovdqa 0xd1b(%rip),%xmm1\nxor    %esi,%esi\nmovdqa %xmm1,%xmm3\npxor   %xmm2,%xmm2\ntest   $0x1,%r8b\njne    120b <func0+0x10b>\njmp    1267 <func0+0x167>\n"
    },
    {
        "task_id": 9,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     1136 <func0+0x26>\nmovq   $0x0,-0x8(%rbp)\njmp    11c1 <func0+0xb1>\nmovslq -0x14(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x20(%rbp)\ncmpq   $0x0,-0x20(%rbp)\njne    115f <func0+0x4f>\nmovq   $0x0,-0x8(%rbp)\njmp    11c1 <func0+0xb1>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x24(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11b9 <func0+0xa9>\nmov    -0x10(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x24(%rbp),%eax\njle    119d <func0+0x8d>\nmov    -0x10(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%edx\nmov    -0x20(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    116f <func0+0x5f>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 9,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\ntest   %esi,%esi\njle    1156 <func0+0x46>\nmov    %esi,%ebp\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\ntest   %rax,%rax\nje     1156 <func0+0x46>\ntest   %ebp,%ebp\njle    1158 <func0+0x48>\nmov    (%rbx),%ecx\nmov    %ebp,%edx\nxor    %esi,%esi\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx,%rsi,4),%edi\ncmp    %ecx,%edi\ncmovg  %edi,%ecx\nmov    %ecx,(%rax,%rsi,4)\nadd    $0x1,%rsi\ncmp    %rsi,%rdx\njne    1140 <func0+0x30>\njmp    1158 <func0+0x48>\nxor    %eax,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 9,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\ntest   %esi,%esi\njle    11b2 <func0+0xa2>\nmov    %esi,%ebp\nmov    %rdi,%rbx\nmov    %esi,%r14d\nlea    0x0(,%r14,4),%rdi\ncall   1030 <malloc@plt>\ntest   %rax,%rax\nje     11b2 <func0+0xa2>\nmov    (%rbx),%edx\nmov    %edx,(%rax)\ncmp    $0x1,%ebp\nje     11b4 <func0+0xa4>\nlea    -0x1(%r14),%rdi\nadd    $0xfffffffffffffffe,%r14\nmov    %edi,%r8d\nand    $0x3,%r8d\nmov    $0x1,%esi\ncmp    $0x3,%r14\njb     11bd <func0+0xad>\nand    $0xfffffffffffffffc,%rdi\nxor    %esi,%esi\njmp    117d <func0+0x6d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %edx,0x10(%rax,%rsi,4)\nadd    $0x4,%rsi\ncmp    %rsi,%rdi\nje     11b9 <func0+0xa9>\nmov    0x4(%rbx,%rsi,4),%ecx\ncmp    %edx,%ecx\ncmovg  %ecx,%edx\nmov    %edx,0x4(%rax,%rsi,4)\nmov    0x8(%rbx,%rsi,4),%ebp\ncmp    %edx,%ebp\njg     1194 <func0+0x84>\nmov    %edx,%ebp\nmov    %ebp,0x8(%rax,%rsi,4)\nmov    0xc(%rbx,%rsi,4),%ecx\ncmp    %ebp,%ecx\njg     11a2 <func0+0x92>\nmov    %ebp,%ecx\nmov    %ecx,0xc(%rax,%rsi,4)\nmov    0x10(%rbx,%rsi,4),%edx\ncmp    %ecx,%edx\njg     1170 <func0+0x60>\nmov    %ecx,%edx\njmp    1170 <func0+0x60>\nxor    %eax,%eax\npop    %rbx\npop    %r14\npop    %rbp\nret\nadd    $0x1,%rsi\ntest   %r8,%r8\nje     11b4 <func0+0xa4>\nlea    (%rax,%rsi,4),%rdi\nlea    (%rbx,%rsi,4),%rsi\nxor    %ebp,%ebp\nnopl   0x0(%rax)\nmov    (%rsi,%rbp,4),%ecx\ncmp    %edx,%ecx\ncmovg  %ecx,%edx\nmov    %edx,(%rdi,%rbp,4)\nadd    $0x1,%rbp\ncmp    %rbp,%r8\njne    11d0 <func0+0xc0>\njmp    11b4 <func0+0xa4>\n"
    },
    {
        "task_id": 9,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\ntest   %esi,%esi\njle    11d0 <func0+0xc0>\nmov    %esi,%ebp\nmov    %rdi,%rbx\nmov    %esi,%r14d\nlea    0x0(,%r14,4),%rdi\ncall   1030 <malloc@plt>\ntest   %rax,%rax\nje     11d7 <func0+0xc7>\nmov    (%rbx),%edx\nmov    %edx,(%rax)\ncmp    $0x1,%ebp\nje     11d2 <func0+0xc2>\nlea    -0x1(%r14),%rdi\nadd    $0xfffffffffffffffe,%r14\nmov    %edi,%r8d\nand    $0x3,%r8d\nmov    $0x1,%esi\ncmp    $0x3,%r14\njb     11e2 <func0+0xd2>\nand    $0xfffffffffffffffc,%rdi\nxor    %esi,%esi\njmp    117d <func0+0x6d>\nnopl   (%rax)\nmov    %edx,0x10(%rax,%rsi,4)\nadd    $0x4,%rsi\ncmp    %rsi,%rdi\nje     11de <func0+0xce>\nmov    0x4(%rbx,%rsi,4),%ecx\ncmp    %edx,%ecx\ncmovg  %ecx,%edx\nmov    %edx,0x4(%rax,%rsi,4)\nmov    0x8(%rbx,%rsi,4),%ebp\ncmp    %edx,%ebp\njle    11b0 <func0+0xa0>\nmov    %ebp,0x8(%rax,%rsi,4)\nmov    0xc(%rbx,%rsi,4),%ecx\ncmp    %ebp,%ecx\njle    11be <func0+0xae>\nmov    %ecx,0xc(%rax,%rsi,4)\nmov    0x10(%rbx,%rsi,4),%edx\ncmp    %ecx,%edx\njg     1170 <func0+0x60>\njmp    11cc <func0+0xbc>\nnopl   0x0(%rax)\nmov    %edx,%ebp\nmov    %ebp,0x8(%rax,%rsi,4)\nmov    0xc(%rbx,%rsi,4),%ecx\ncmp    %ebp,%ecx\njg     119e <func0+0x8e>\nmov    %ebp,%ecx\nmov    %ecx,0xc(%rax,%rsi,4)\nmov    0x10(%rbx,%rsi,4),%edx\ncmp    %ecx,%edx\njg     1170 <func0+0x60>\nmov    %ecx,%edx\njmp    1170 <func0+0x60>\nxor    %eax,%eax\npop    %rbx\npop    %r14\npop    %rbp\nret\nxor    %eax,%eax\npop    %rbx\npop    %r14\npop    %rbp\nret\nadd    $0x1,%rsi\ntest   %r8,%r8\nje     11d2 <func0+0xc2>\nlea    (%rax,%rsi,4),%rdi\nlea    (%rbx,%rsi,4),%rsi\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    (%rsi,%rbp,4),%ecx\ncmp    %edx,%ecx\ncmovg  %ecx,%edx\nmov    %edx,(%rdi,%rbp,4)\nadd    $0x1,%rbp\ncmp    %rbp,%r8\njne    1200 <func0+0xf0>\njmp    11d2 <func0+0xc2>\n"
    },
    {
        "task_id": 10,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1040 <strlen@plt>\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nshl    $0x1,%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x28(%rbp)\ncmpq   $0x0,-0x28(%rbp)\njne    1175 <func0+0x45>\nmovq   $0x0,-0x8(%rbp)\njmp    1301 <func0+0x1d1>\nmovl   $0x0,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1293 <func0+0x163>\nmovl   $0x1,-0x2c(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x30(%rbp)\nmov    -0x14(%rbp),%eax\nsub    -0x18(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x30(%rbp),%eax\ncmp    %ecx,%eax\njge    1203 <func0+0xd3>\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nadd    -0x1c(%rbp),%ecx\nmovslq %ecx,%rcx\nmovsbl (%rax,%rcx,1),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x14(%rbp),%edx\nsub    $0x1,%edx\nsub    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nmovsbl (%rcx,%rdx,1),%ecx\ncmp    %ecx,%eax\nje     11f0 <func0+0xc0>\nmovl   $0x0,-0x2c(%rbp)\njmp    1203 <func0+0xd3>\njmp    11f5 <func0+0xc5>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1196 <func0+0x66>\ncmpl   $0x0,-0x2c(%rbp)\nje     1280 <func0+0x150>\nmov    -0x28(%rbp),%rdi\nmov    -0x10(%rbp),%rsi\nmovslq -0x14(%rbp),%rdx\ncall   1030 <strncpy@plt>\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njge    1262 <func0+0x132>\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nsub    -0x1c(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,1),%dl\nmov    -0x28(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nadd    -0x1c(%rbp),%ecx\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1225 <func0+0xf5>\nmov    -0x28(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nadd    -0x18(%rbp),%ecx\nmovslq %ecx,%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    1301 <func0+0x1d1>\njmp    1285 <func0+0x155>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    117c <func0+0x4c>\nmov    -0x28(%rbp),%rdi\nmov    -0x10(%rbp),%rsi\nmovslq -0x14(%rbp),%rdx\ncall   1030 <strncpy@plt>\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    12e8 <func0+0x1b8>\nmov    -0x10(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nsub    -0x1c(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,1),%dl\nmov    -0x28(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nadd    -0x1c(%rbp),%ecx\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    12ab <func0+0x17b>\nmov    -0x28(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nshl    $0x1,%ecx\nmovslq %ecx,%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 10,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%r13\ncall   1040 <strlen@plt>\nmov    %rax,%rbp\nmovslq %ebp,%rbx\nadd    %rbx,%rbx\nlea    0x1(%rbx),%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\ntest   %rax,%rax\nje     1317 <func0+0x1e7>\nmov    %rax,%rdi\nmov    %rbx,0x10(%rsp)\nmov    %rbp,0x8(%rsp)\ntest   %ebp,%ebp\njle    12af <func0+0x17f>\nmov    0x8(%rsp),%rcx\nmov    %rcx,%rax\nshl    $0x20,%rax\nmovslq %ecx,%r12\nmov    %r12d,%ecx\nmov    %rcx,0x30(%rsp)\nmovabs $0xffffffff00000000,%rcx\nff ff ff\nadd    %rax,%rcx\nsar    $0x20,%rcx\nmov    %rcx,0x28(%rsp)\nmovabs $0xfffffffe00000000,%rcx\nff ff ff\nadd    %rax,%rcx\nmov    %rcx,0x18(%rsp)\nlea    (%rdi,%r12,1),%rax\nmov    %rax,0x20(%rsp)\nxor    %r15d,%r15d\nmov    %r13,%rbx\ncs nopw 0x0(%rax,%rax,1)\nmov    %r12,%rax\nsub    %r15,%rax\ncmp    $0x2,%rax\nsetge  %r14b\njl     1252 <func0+0x122>\nmov    0x0(%r13,%r15,1),%cl\nmov    0x28(%rsp),%rdx\ncmp    0x0(%r13,%rdx,1),%cl\njne    1293 <func0+0x163>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\nmovslq %ecx,%r8\nmov    %r8d,%edx\nmov    $0x1,%ecx\nmov    0x18(%rsp),%rsi\nmovabs $0xffffffff00000000,%r9\nff ff ff\nnopl   0x0(%rax,%rax,1)\ncmp    %rcx,%rdx\nje     124b <func0+0x11b>\nmovzbl (%rbx,%rcx,1),%eax\nmov    %rsi,%rbp\nsar    $0x20,%rbp\nadd    $0x1,%rcx\nadd    %r9,%rsi\ncmp    0x0(%r13,%rbp,1),%al\nje     1220 <func0+0xf0>\nadd    $0xffffffffffffffff,%rcx\ncmp    %r8,%rcx\nsetl   %r14b\njmp    1293 <func0+0x163>\ncmp    %r8,%rcx\nsetl   %r14b\nmov    %rdi,%rbp\nmov    %r13,%rsi\nmov    %r12,%rdx\ncall   1030 <strncpy@plt>\ntest   %r15,%r15\nje     1287 <func0+0x157>\nxor    %eax,%eax\nmov    0x20(%rsp),%rcx\nnopl   0x0(%rax)\nmovzbl -0x1(%rbx,%rax,1),%edx\nmov    %dl,(%rcx)\nadd    $0x1,%rcx\nadd    $0xffffffffffffffff,%rax\nmov    %r15,%rdx\nadd    %rax,%rdx\njne    1270 <func0+0x140>\nlea    (%r15,%r12,1),%rax\nmov    %rbp,%rdi\nmovb   $0x0,0x0(%rbp,%rax,1)\ntest   %r14b,%r14b\nje     1319 <func0+0x1e9>\nadd    $0x1,%r15\nadd    $0x1,%rbx\ncmp    0x30(%rsp),%r15\njne    11d0 <func0+0xa0>\nmov    0x8(%rsp),%rbx\nmovslq %ebx,%rdx\nmov    %r13,%rsi\nmov    %rdi,%rbp\ncall   1030 <strncpy@plt>\nmov    %rbp,%rdi\ntest   %ebx,%ebx\nmovabs $0xffffffff00000000,%r8\nff ff ff\njle    130c <func0+0x1dc>\nmov    %rbx,%rbp\nshl    $0x20,%rbp\nmovslq %ebx,%rsi\nmov    %esi,%ecx\nadd    %r8,%rbp\nmov    %rdi,%rdx\nadd    %rsi,%rdx\nxor    %esi,%esi\nnopw   0x0(%rax,%rax,1)\nmov    %rbp,%rax\nsar    $0x20,%rax\nmovzbl 0x0(%r13,%rax,1),%ebx\nmov    %bl,(%rdx,%rsi,1)\nadd    $0x1,%rsi\nadd    %r8,%rbp\ncmp    %rsi,%rcx\njne    12f0 <func0+0x1c0>\nmov    0x10(%rsp),%rax\nmovb   $0x0,(%rdi,%rax,1)\njmp    1319 <func0+0x1e9>\nxor    %edi,%edi\nmov    %rdi,%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 10,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,%r14\ncall   1040 <strlen@plt>\nmov    %rax,0x10(%rsp)\ncltq\nadd    %rax,%rax\nmov    %rax,0x8(%rsp)\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%rdi\ntest   %rax,%rax\nje     14b5 <func0+0x385>\nmov    0x10(%rsp),%rax\nmovslq %eax,%rdx\ntest   %eax,%eax\nmov    %rdi,(%rsp)\njle    13dd <func0+0x2ad>\nmovabs $0xffffffff00000000,%r13\nff ff ff\nmov    %rax,%rcx\nshl    $0x20,%rcx\nmovslq %eax,%r10\nmov    %r10d,%r9d\nmov    %rcx,0x20(%rsp)\nlea    (%rcx,%r13,1),%rax\nmov    %rax,0x30(%rsp)\nlea    0x10(%rdi,%r10,1),%rax\nmov    %rax,0x28(%rsp)\nlea    (%rdi,%r10,1),%rax\nmov    %rax,0x18(%rsp)\nxor    %r15d,%r15d\nmov    %r14,%r12\nmov    %r9,0x40(%rsp)\nmov    %r10,0x38(%rsp)\njmp    11fd <func0+0xcd>\nnopw   0x0(%rax,%rax,1)\nlea    (%r15,%r10,1),%rax\nmov    (%rsp),%rdi\nmovb   $0x0,(%rdi,%rax,1)\ntest   %bl,%bl\nmov    0x40(%rsp),%r9\nmov    %rbp,%rdx\nje     14b5 <func0+0x385>\nadd    $0x1,%r15\nadd    $0x1,%r12\ncmp    %r9,%r15\nje     13f3 <func0+0x2c3>\nmov    %r10,%rax\nsub    %r15,%rax\ncmp    $0x2,%rax\njl     1250 <func0+0x120>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\nmovslq %ecx,%r8\nmov    %r8d,%ecx\nmov    0x30(%rsp),%rbp\nxor    %ebx,%ebx\nnop\nmovzbl (%r12,%rbx,1),%eax\nmov    %rbp,%rsi\nsar    $0x20,%rsi\ncmp    (%r14,%rsi,1),%al\njne    11ec <func0+0xbc>\nadd    $0x1,%rbx\nadd    %r13,%rbp\ncmp    %rbx,%rcx\njne    1220 <func0+0xf0>\ncmp    %r8,%rbx\nsetl   %bl\njmp    1252 <func0+0x122>\ncs nopw 0x0(%rax,%rax,1)\nxor    %ebx,%ebx\nmov    %r14,%rsi\nmov    %rdx,%rbp\ncall   1030 <strncpy@plt>\ntest   %r15,%r15\nmov    0x38(%rsp),%r10\npxor   %xmm3,%xmm3\nje     11d0 <func0+0xa0>\ncmp    $0x8,%r15\njae    1280 <func0+0x150>\nxor    %eax,%eax\njmp    13a8 <func0+0x278>\nnopl   0x0(%rax)\ncmp    $0x20,%r15\njae    128d <func0+0x15d>\nxor    %eax,%eax\njmp    133f <func0+0x20f>\nmov    %r15,%rcx\nand    $0xffffffffffffffe0,%rcx\nneg    %rcx\nmov    %r15,%rax\nmovabs $0x7fffffffffffffe0,%rdx\nff ff 7f\nand    %rdx,%rax\nmov    0x28(%rsp),%rdx\nxor    %esi,%esi\nxchg   %ax,%ax\nmovdqu -0x20(%r12,%rsi,1),%xmm0\nmovdqu -0x10(%r12,%rsi,1),%xmm1\nmovdqa %xmm1,%xmm2\npunpcklbw %xmm3,%xmm2\npshufd $0x4e,%xmm2,%xmm2\npshuflw $0x1b,%xmm2,%xmm2\npshufhw $0x1b,%xmm2,%xmm2\npunpckhbw %xmm3,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm2,%xmm1\nmovdqa %xmm0,%xmm2\npunpcklbw %xmm3,%xmm2\npshufd $0x4e,%xmm2,%xmm2\npshuflw $0x1b,%xmm2,%xmm2\npshufhw $0x1b,%xmm2,%xmm2\npunpckhbw %xmm3,%xmm0\npshufd $0x4e,%xmm0,%xmm0\npshuflw $0x1b,%xmm0,%xmm0\npshufhw $0x1b,%xmm0,%xmm0\npackuswb %xmm2,%xmm0\nmovdqu %xmm1,-0x10(%rdx)\nmovdqu %xmm0,(%rdx)\nadd    $0xffffffffffffffe0,%rsi\nadd    $0x20,%rdx\ncmp    %rsi,%rcx\njne    12b0 <func0+0x180>\ncmp    %rax,%r15\nje     11d0 <func0+0xa0>\ntest   $0x18,%r15b\nje     13a8 <func0+0x278>\nmov    %rax,%rcx\nmov    %r15,%rdx\nand    $0xfffffffffffffff8,%rdx\nneg    %rdx\nmovabs $0x7fffffffffffffe0,%rax\nff ff 7f\nadd    $0x18,%rax\nand    %r15,%rax\nmov    0x18(%rsp),%rsi\nadd    %rcx,%rsi\nneg    %rcx\nnopl   0x0(%rax,%rax,1)\nmovq   -0x8(%r12,%rcx,1),%xmm0\npunpcklbw %xmm3,%xmm0\npshufd $0x4e,%xmm0,%xmm0\npshuflw $0x1b,%xmm0,%xmm0\npshufhw $0x1b,%xmm0,%xmm0\npackuswb %xmm0,%xmm0\nmovq   %xmm0,(%rsi)\nadd    $0xfffffffffffffff8,%rcx\nadd    $0x8,%rsi\ncmp    %rcx,%rdx\njne    1370 <func0+0x240>\ncmp    %rax,%r15\nje     11d0 <func0+0xa0>\nmov    0x18(%rsp),%rcx\nadd    %rax,%rcx\nneg    %rax\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovzbl -0x1(%r12,%rax,1),%edx\nmov    %dl,(%rcx)\nadd    $0x1,%rcx\nadd    $0xffffffffffffffff,%rax\nmov    %r15,%rdx\nadd    %rax,%rdx\njne    13c0 <func0+0x290>\njmp    11d0 <func0+0xa0>\nmov    %r14,%rsi\ncall   1030 <strncpy@plt>\nmov    (%rsp),%rdi\nmov    0x8(%rsp),%r9\njmp    14b0 <func0+0x380>\nmov    %r14,%rsi\nmov    %r9,%rbx\ncall   1030 <strncpy@plt>\nmov    (%rsp),%rdi\nmov    0x10(%rsp),%r11\ntest   %r11d,%r11d\nmov    0x8(%rsp),%r9\njle    14b0 <func0+0x380>\nmovslq %r11d,%r8\ncmp    $0x8,%ebx\nmov    %rbx,%r15\njae    14c7 <func0+0x397>\nxor    %r10d,%r10d\nmov    %r11d,%eax\nsub    %r10d,%eax\nlea    0x1(%r10),%rdx\ntest   $0x1,%al\nje     144d <func0+0x31d>\nmov    %r10d,%eax\nnot    %eax\nadd    %r11d,%eax\ncltq\nmov    (%r14,%rax,1),%al\nadd    %r8,%r10\nmov    %al,(%rdi,%r10,1)\nmov    %rdx,%r10\ncmp    %rdx,%r15\nje     14b0 <func0+0x380>\nmovabs $0xfffffffe00000000,%rdx\nff ff ff\nmov    %r11d,%esi\nsub    %r10d,%esi\nadd    $0xfffffffe,%esi\nshl    $0x20,%rsi\nmov    %r10d,%ebp\nnot    %ebp\nadd    %r11d,%ebp\nshl    $0x20,%rbp\nlea    (%r8,%rdi,1),%rax\nadd    $0x1,%rax\nnopl   (%rax)\nmov    %rbp,%rcx\nsar    $0x20,%rcx\nmovzbl (%r14,%rcx,1),%ebx\nmov    %bl,-0x1(%rax,%r10,1)\nmov    %rsi,%rcx\nsar    $0x20,%rcx\nmovzbl (%r14,%rcx,1),%ebx\nmov    %bl,(%rax,%r10,1)\nadd    $0x2,%r10\nadd    %rdx,%rsi\nadd    %rdx,%rbp\ncmp    %r10,%r15\njne    1480 <func0+0x350>\nmovb   $0x0,(%rdi,%r9,1)\nmov    %rdi,%rax\nadd    $0x48,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\nlea    -0x1(%rbx),%rdx\nlea    -0x1(%r11),%esi\nmov    %esi,%eax\nsub    %edx,%eax\nxor    %r10d,%r10d\ncmp    %esi,%eax\njg     1427 <func0+0x2f7>\nshr    $0x20,%rdx\njne    1427 <func0+0x2f7>\nmov    %r15,%rax\ncmp    $0x20,%eax\nmov    %r15,%r10\njae    14fe <func0+0x3ce>\nmov    %r10,%rax\nxor    %r10d,%r10d\njmp    15d1 <func0+0x4a1>\nmov    %r11d,%edx\nand    $0x1f,%edx\nsub    %rdx,%r10\nmov    0x20(%rsp),%rbp\nadd    %r13,%rbp\nlea    (%r8,%rdi,1),%rsi\nadd    $0x10,%rsi\nxor    %ecx,%ecx\npxor   %xmm0,%xmm0\nmovabs $0xffffffe000000000,%rax\nff ff ff\nnopw   0x0(%rax,%rax,1)\nmov    %rbp,%rbx\nsar    $0x20,%rbx\nmovdqu -0x1f(%r14,%rbx,1),%xmm1\nmovdqu -0xf(%r14,%rbx,1),%xmm2\nmovdqa %xmm2,%xmm3\npunpcklbw %xmm0,%xmm3\npshufd $0x4e,%xmm3,%xmm3\npshuflw $0x1b,%xmm3,%xmm3\npshufhw $0x1b,%xmm3,%xmm3\npunpckhbw %xmm0,%xmm2\npshufd $0x4e,%xmm2,%xmm2\npshuflw $0x1b,%xmm2,%xmm2\npshufhw $0x1b,%xmm2,%xmm2\npackuswb %xmm3,%xmm2\nmovdqa %xmm1,%xmm3\npunpcklbw %xmm0,%xmm3\npshufd $0x4e,%xmm3,%xmm3\npshuflw $0x1b,%xmm3,%xmm3\npshufhw $0x1b,%xmm3,%xmm3\npunpckhbw %xmm0,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm3,%xmm1\nmovdqu %xmm2,-0x10(%rsi,%rcx,1)\nmovdqu %xmm1,(%rsi,%rcx,1)\nadd    $0x20,%rcx\nadd    %rax,%rbp\ncmp    %rcx,%r10\njne    1530 <func0+0x400>\ntest   %rdx,%rdx\nje     14b0 <func0+0x380>\nmov    %r15,%rax\ncmp    $0x8,%edx\njb     1427 <func0+0x2f7>\nmov    %r10,%rsi\nmov    %r11d,%ebp\nand    $0x7,%ebp\nmov    %rax,%r10\nsub    %rbp,%r10\nmov    %esi,%eax\nnot    %eax\nadd    %r11d,%eax\nshl    $0x20,%rax\nlea    (%rdi,%r8,1),%rcx\npxor   %xmm0,%xmm0\nmovabs $0xfffffff800000000,%rbx\nff ff ff\nnopl   (%rax)\nmov    %rax,%rdx\nsar    $0x20,%rdx\nmovq   -0x7(%r14,%rdx,1),%xmm1\npunpcklbw %xmm0,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm1,%xmm1\nmovq   %xmm1,(%rcx,%rsi,1)\nadd    $0x8,%rsi\nadd    %rbx,%rax\ncmp    %rsi,%r10\njne    1600 <func0+0x4d0>\ntest   %rbp,%rbp\njne    1427 <func0+0x2f7>\njmp    14b0 <func0+0x380>\n"
    },
    {
        "task_id": 10,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,%r14\ncall   1040 <strlen@plt>\nmov    %rax,0x10(%rsp)\ncltq\nadd    %rax,%rax\nmov    %rax,0x8(%rsp)\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%rdi\ntest   %rax,%rax\nje     14b5 <func0+0x385>\nmov    0x10(%rsp),%rax\nmovslq %eax,%rdx\ntest   %eax,%eax\nmov    %rdi,(%rsp)\njle    13dd <func0+0x2ad>\nmovabs $0xffffffff00000000,%r13\nff ff ff\nmov    %rax,%rcx\nshl    $0x20,%rcx\nmovslq %eax,%r10\nmov    %r10d,%r9d\nmov    %rcx,0x20(%rsp)\nlea    (%rcx,%r13,1),%rax\nmov    %rax,0x30(%rsp)\nlea    0x10(%rdi,%r10,1),%rax\nmov    %rax,0x28(%rsp)\nlea    (%rdi,%r10,1),%rax\nmov    %rax,0x18(%rsp)\nxor    %r15d,%r15d\nmov    %r14,%r12\nmov    %r9,0x40(%rsp)\nmov    %r10,0x38(%rsp)\njmp    11fd <func0+0xcd>\nnopw   0x0(%rax,%rax,1)\nlea    (%r15,%r10,1),%rax\nmov    (%rsp),%rdi\nmovb   $0x0,(%rdi,%rax,1)\ntest   %bl,%bl\nmov    0x40(%rsp),%r9\nmov    %rbp,%rdx\nje     14b5 <func0+0x385>\nadd    $0x1,%r15\nadd    $0x1,%r12\ncmp    %r9,%r15\nje     13f3 <func0+0x2c3>\nmov    %r10,%rax\nsub    %r15,%rax\ncmp    $0x2,%rax\njl     1250 <func0+0x120>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\nmovslq %ecx,%r8\nmov    %r8d,%ecx\nmov    0x30(%rsp),%rbp\nxor    %ebx,%ebx\nnop\nmovzbl (%r12,%rbx,1),%eax\nmov    %rbp,%rsi\nsar    $0x20,%rsi\ncmp    (%r14,%rsi,1),%al\njne    11ec <func0+0xbc>\nadd    $0x1,%rbx\nadd    %r13,%rbp\ncmp    %rbx,%rcx\njne    1220 <func0+0xf0>\ncmp    %r8,%rbx\nsetl   %bl\njmp    1252 <func0+0x122>\ncs nopw 0x0(%rax,%rax,1)\nxor    %ebx,%ebx\nmov    %r14,%rsi\nmov    %rdx,%rbp\ncall   1030 <strncpy@plt>\ntest   %r15,%r15\nmov    0x38(%rsp),%r10\npxor   %xmm3,%xmm3\nje     11d0 <func0+0xa0>\ncmp    $0x8,%r15\njae    1280 <func0+0x150>\nxor    %eax,%eax\njmp    13a8 <func0+0x278>\nnopl   0x0(%rax)\ncmp    $0x20,%r15\njae    128d <func0+0x15d>\nxor    %eax,%eax\njmp    133f <func0+0x20f>\nmov    %r15,%rcx\nand    $0xffffffffffffffe0,%rcx\nneg    %rcx\nmov    %r15,%rax\nmovabs $0x7fffffffffffffe0,%rdx\nff ff 7f\nand    %rdx,%rax\nmov    0x28(%rsp),%rdx\nxor    %esi,%esi\nxchg   %ax,%ax\nmovdqu -0x20(%r12,%rsi,1),%xmm0\nmovdqu -0x10(%r12,%rsi,1),%xmm1\nmovdqa %xmm1,%xmm2\npunpcklbw %xmm3,%xmm2\npshufd $0x4e,%xmm2,%xmm2\npshuflw $0x1b,%xmm2,%xmm2\npshufhw $0x1b,%xmm2,%xmm2\npunpckhbw %xmm3,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm2,%xmm1\nmovdqa %xmm0,%xmm2\npunpcklbw %xmm3,%xmm2\npshufd $0x4e,%xmm2,%xmm2\npshuflw $0x1b,%xmm2,%xmm2\npshufhw $0x1b,%xmm2,%xmm2\npunpckhbw %xmm3,%xmm0\npshufd $0x4e,%xmm0,%xmm0\npshuflw $0x1b,%xmm0,%xmm0\npshufhw $0x1b,%xmm0,%xmm0\npackuswb %xmm2,%xmm0\nmovdqu %xmm1,-0x10(%rdx)\nmovdqu %xmm0,(%rdx)\nadd    $0xffffffffffffffe0,%rsi\nadd    $0x20,%rdx\ncmp    %rsi,%rcx\njne    12b0 <func0+0x180>\ncmp    %rax,%r15\nje     11d0 <func0+0xa0>\ntest   $0x18,%r15b\nje     13a8 <func0+0x278>\nmov    %rax,%rcx\nmov    %r15,%rdx\nand    $0xfffffffffffffff8,%rdx\nneg    %rdx\nmovabs $0x7fffffffffffffe0,%rax\nff ff 7f\nadd    $0x18,%rax\nand    %r15,%rax\nmov    0x18(%rsp),%rsi\nadd    %rcx,%rsi\nneg    %rcx\nnopl   0x0(%rax,%rax,1)\nmovq   -0x8(%r12,%rcx,1),%xmm0\npunpcklbw %xmm3,%xmm0\npshufd $0x4e,%xmm0,%xmm0\npshuflw $0x1b,%xmm0,%xmm0\npshufhw $0x1b,%xmm0,%xmm0\npackuswb %xmm0,%xmm0\nmovq   %xmm0,(%rsi)\nadd    $0xfffffffffffffff8,%rcx\nadd    $0x8,%rsi\ncmp    %rcx,%rdx\njne    1370 <func0+0x240>\ncmp    %rax,%r15\nje     11d0 <func0+0xa0>\nmov    0x18(%rsp),%rcx\nadd    %rax,%rcx\nneg    %rax\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovzbl -0x1(%r12,%rax,1),%edx\nmov    %dl,(%rcx)\nadd    $0x1,%rcx\nadd    $0xffffffffffffffff,%rax\nmov    %r15,%rdx\nadd    %rax,%rdx\njne    13c0 <func0+0x290>\njmp    11d0 <func0+0xa0>\nmov    %r14,%rsi\ncall   1030 <strncpy@plt>\nmov    (%rsp),%rdi\nmov    0x8(%rsp),%r9\njmp    14b0 <func0+0x380>\nmov    %r14,%rsi\nmov    %r9,%rbx\ncall   1030 <strncpy@plt>\nmov    (%rsp),%rdi\nmov    0x10(%rsp),%r11\ntest   %r11d,%r11d\nmov    0x8(%rsp),%r9\njle    14b0 <func0+0x380>\nmovslq %r11d,%r8\ncmp    $0x8,%ebx\nmov    %rbx,%r15\njae    14c7 <func0+0x397>\nxor    %r10d,%r10d\nmov    %r11d,%eax\nsub    %r10d,%eax\nlea    0x1(%r10),%rdx\ntest   $0x1,%al\nje     144d <func0+0x31d>\nmov    %r10d,%eax\nnot    %eax\nadd    %r11d,%eax\ncltq\nmov    (%r14,%rax,1),%al\nadd    %r8,%r10\nmov    %al,(%rdi,%r10,1)\nmov    %rdx,%r10\ncmp    %rdx,%r15\nje     14b0 <func0+0x380>\nmovabs $0xfffffffe00000000,%rdx\nff ff ff\nmov    %r11d,%esi\nsub    %r10d,%esi\nadd    $0xfffffffe,%esi\nshl    $0x20,%rsi\nmov    %r10d,%ebp\nnot    %ebp\nadd    %r11d,%ebp\nshl    $0x20,%rbp\nlea    (%r8,%rdi,1),%rax\nadd    $0x1,%rax\nnopl   (%rax)\nmov    %rbp,%rcx\nsar    $0x20,%rcx\nmovzbl (%r14,%rcx,1),%ebx\nmov    %bl,-0x1(%rax,%r10,1)\nmov    %rsi,%rcx\nsar    $0x20,%rcx\nmovzbl (%r14,%rcx,1),%ebx\nmov    %bl,(%rax,%r10,1)\nadd    $0x2,%r10\nadd    %rdx,%rsi\nadd    %rdx,%rbp\ncmp    %r10,%r15\njne    1480 <func0+0x350>\nmovb   $0x0,(%rdi,%r9,1)\nmov    %rdi,%rax\nadd    $0x48,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\nlea    -0x1(%rbx),%rdx\nlea    -0x1(%r11),%esi\nmov    %esi,%eax\nsub    %edx,%eax\nxor    %r10d,%r10d\ncmp    %esi,%eax\njg     1427 <func0+0x2f7>\nshr    $0x20,%rdx\njne    1427 <func0+0x2f7>\nmov    %r15,%rax\ncmp    $0x20,%eax\nmov    %r15,%r10\njae    14fe <func0+0x3ce>\nmov    %r10,%rax\nxor    %r10d,%r10d\njmp    15d1 <func0+0x4a1>\nmov    %r11d,%edx\nand    $0x1f,%edx\nsub    %rdx,%r10\nmov    0x20(%rsp),%rbp\nadd    %r13,%rbp\nlea    (%r8,%rdi,1),%rsi\nadd    $0x10,%rsi\nxor    %ecx,%ecx\npxor   %xmm0,%xmm0\nmovabs $0xffffffe000000000,%rax\nff ff ff\nnopw   0x0(%rax,%rax,1)\nmov    %rbp,%rbx\nsar    $0x20,%rbx\nmovdqu -0x1f(%r14,%rbx,1),%xmm1\nmovdqu -0xf(%r14,%rbx,1),%xmm2\nmovdqa %xmm2,%xmm3\npunpcklbw %xmm0,%xmm3\npshufd $0x4e,%xmm3,%xmm3\npshuflw $0x1b,%xmm3,%xmm3\npshufhw $0x1b,%xmm3,%xmm3\npunpckhbw %xmm0,%xmm2\npshufd $0x4e,%xmm2,%xmm2\npshuflw $0x1b,%xmm2,%xmm2\npshufhw $0x1b,%xmm2,%xmm2\npackuswb %xmm3,%xmm2\nmovdqa %xmm1,%xmm3\npunpcklbw %xmm0,%xmm3\npshufd $0x4e,%xmm3,%xmm3\npshuflw $0x1b,%xmm3,%xmm3\npshufhw $0x1b,%xmm3,%xmm3\npunpckhbw %xmm0,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm3,%xmm1\nmovdqu %xmm2,-0x10(%rsi,%rcx,1)\nmovdqu %xmm1,(%rsi,%rcx,1)\nadd    $0x20,%rcx\nadd    %rax,%rbp\ncmp    %rcx,%r10\njne    1530 <func0+0x400>\ntest   %rdx,%rdx\nje     14b0 <func0+0x380>\nmov    %r15,%rax\ncmp    $0x8,%edx\njb     1427 <func0+0x2f7>\nmov    %r10,%rsi\nmov    %r11d,%ebp\nand    $0x7,%ebp\nmov    %rax,%r10\nsub    %rbp,%r10\nmov    %esi,%eax\nnot    %eax\nadd    %r11d,%eax\nshl    $0x20,%rax\nlea    (%rdi,%r8,1),%rcx\npxor   %xmm0,%xmm0\nmovabs $0xfffffff800000000,%rbx\nff ff ff\nnopl   (%rax)\nmov    %rax,%rdx\nsar    $0x20,%rdx\nmovq   -0x7(%r14,%rdx,1),%xmm1\npunpcklbw %xmm0,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm1,%xmm1\nmovq   %xmm1,(%rcx,%rsi,1)\nadd    $0x8,%rsi\nadd    %rbx,%rax\ncmp    %rsi,%r10\njne    1600 <func0+0x4d0>\ntest   %rbp,%rbp\njne    1427 <func0+0x2f7>\njmp    14b0 <func0+0x380>\n"
    },
    {
        "task_id": 11,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x1c(%rbp)\nmov    -0x18(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x20(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    115f <func0+0x3f>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x38(%rbp)\njmp    1165 <func0+0x45>\nmov    -0x20(%rbp),%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\nshl    $0x0,%rdi\ncall   1040 <malloc@plt>\nmov    %rax,-0x30(%rbp)\ncmpq   $0x0,-0x30(%rbp)\njne    1199 <func0+0x79>\nmovq   $0x0,-0x8(%rbp)\njmp    1202 <func0+0xe2>\nmovl   $0x0,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njge    11ee <func0+0xce>\nmov    -0x10(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%esi\nmov    $0x31,%eax\nmov    $0x30,%ecx\ncmp    %esi,%edx\ncmove  %ecx,%eax\nmov    %al,%dl\nmov    -0x30(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    11a0 <func0+0x80>\nmov    -0x30(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 11,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nmov    %rsi,%r14\nmov    %rdi,%r13\ncall   1030 <strlen@plt>\nmov    %rax,%r12\nmov    %r14,%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%r15\ncmp    %r15d,%r12d\ncmovl  %r12d,%r15d\nlea    0x1(%r15),%eax\nmovslq %eax,%rdi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     1195 <func0+0x75>\ntest   %r15d,%r15d\njle    118c <func0+0x6c>\nmov    %r15d,%ecx\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovzbl 0x0(%r13,%rdx,1),%ebx\ncmp    (%r14,%rdx,1),%bl\nsete   %bl\nxor    $0x31,%bl\nmov    %bl,(%rax,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    1170 <func0+0x50>\nmovslq %r15d,%rcx\nmovb   $0x0,(%rax,%rcx,1)\njmp    1197 <func0+0x77>\nxor    %eax,%eax\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 11,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nmov    %rax,%r12\nmov    %r14,%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%r15\ncmp    %r15d,%r12d\ncmovl  %r12d,%r15d\nlea    0x1(%r15),%eax\nmovslq %eax,%rdi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     12e1 <func0+0x1c1>\ntest   %r15d,%r15d\njle    12da <func0+0x1ba>\nmov    %r15d,%r9d\ncmp    $0x8,%r15d\njae    1176 <func0+0x56>\nxor    %edx,%edx\njmp    12c0 <func0+0x1a0>\ncmp    $0x20,%r15d\njae    1183 <func0+0x63>\nxor    %edx,%edx\njmp    127f <func0+0x15f>\nmov    %r9d,%edx\nand    $0xffffffe0,%edx\nlea    -0x20(%rdx),%rsi\nmov    %rsi,%r8\nshr    $0x5,%r8\nadd    $0x1,%r8\ntest   %rsi,%rsi\nje     12ed <func0+0x1cd>\nmov    %r8,%rdi\nand    $0xfffffffffffffffe,%rdi\nxor    %esi,%esi\nmovdqa 0xe4e(%rip),%xmm0\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovdqu (%rbx,%rsi,1),%xmm1\nmovdqu 0x10(%rbx,%rsi,1),%xmm2\nmovdqu (%r14,%rsi,1),%xmm3\npcmpeqb %xmm1,%xmm3\nmovdqu 0x10(%r14,%rsi,1),%xmm1\npcmpeqb %xmm2,%xmm1\npaddb  %xmm0,%xmm3\npaddb  %xmm0,%xmm1\nmovdqu %xmm3,(%rax,%rsi,1)\nmovdqu %xmm1,0x10(%rax,%rsi,1)\nmovdqu 0x20(%rbx,%rsi,1),%xmm1\nmovdqu 0x30(%rbx,%rsi,1),%xmm2\nmovdqu 0x20(%r14,%rsi,1),%xmm3\npcmpeqb %xmm1,%xmm3\nmovdqu 0x30(%r14,%rsi,1),%xmm1\npcmpeqb %xmm2,%xmm1\npaddb  %xmm0,%xmm3\npaddb  %xmm0,%xmm1\nmovdqu %xmm3,0x20(%rax,%rsi,1)\nmovdqu %xmm1,0x30(%rax,%rsi,1)\nadd    $0x40,%rsi\nadd    $0xfffffffffffffffe,%rdi\njne    11c0 <func0+0xa0>\ntest   $0x1,%r8b\nje     1274 <func0+0x154>\nmovdqu (%rbx,%rsi,1),%xmm0\nmovdqu 0x10(%rbx,%rsi,1),%xmm1\nmovdqu (%r14,%rsi,1),%xmm2\npcmpeqb %xmm0,%xmm2\nmovdqu 0x10(%r14,%rsi,1),%xmm0\npcmpeqb %xmm1,%xmm0\nmovdqa 0xd9f(%rip),%xmm1\npaddb  %xmm1,%xmm2\npaddb  %xmm1,%xmm0\nmovdqu %xmm2,(%rax,%rsi,1)\nmovdqu %xmm0,0x10(%rax,%rsi,1)\ncmp    %r9,%rdx\nje     12da <func0+0x1ba>\ntest   $0x18,%r9b\nje     12c0 <func0+0x1a0>\nmov    %rdx,%rsi\nmov    %r9d,%edx\nand    $0xfffffff8,%edx\nmovdqa 0xd80(%rip),%xmm0\nmovq   (%rbx,%rsi,1),%xmm1\nmovq   (%r14,%rsi,1),%xmm2\npcmpeqb %xmm1,%xmm2\npaddb  %xmm0,%xmm2\nmovq   %xmm2,(%rax,%rsi,1)\nadd    $0x8,%rsi\ncmp    %rsi,%rdx\njne    1290 <func0+0x170>\ncmp    %r9,%rdx\nje     12da <func0+0x1ba>\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%rbx,%rdx,1),%ecx\ncmp    (%r14,%rdx,1),%cl\nsete   %cl\nxor    $0x31,%cl\nmov    %cl,(%rax,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%r9\njne    12c0 <func0+0x1a0>\nmovslq %r15d,%rcx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\nret\nxor    %esi,%esi\ntest   $0x1,%r8b\njne    1239 <func0+0x119>\njmp    1274 <func0+0x154>\n"
    },
    {
        "task_id": 11,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nmov    %rax,%r12\nmov    %r14,%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%r15\ncmp    %r15d,%r12d\ncmovl  %r12d,%r15d\nlea    0x1(%r15),%eax\nmovslq %eax,%rdi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     12e1 <func0+0x1c1>\ntest   %r15d,%r15d\njle    12da <func0+0x1ba>\nmov    %r15d,%r9d\ncmp    $0x8,%r15d\njae    1176 <func0+0x56>\nxor    %edx,%edx\njmp    12c0 <func0+0x1a0>\ncmp    $0x20,%r15d\njae    1183 <func0+0x63>\nxor    %edx,%edx\njmp    127f <func0+0x15f>\nmov    %r9d,%edx\nand    $0xffffffe0,%edx\nlea    -0x20(%rdx),%rsi\nmov    %rsi,%r8\nshr    $0x5,%r8\nadd    $0x1,%r8\ntest   %rsi,%rsi\nje     12ed <func0+0x1cd>\nmov    %r8,%rdi\nand    $0xfffffffffffffffe,%rdi\nxor    %esi,%esi\nmovdqa 0xe4e(%rip),%xmm0\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovdqu (%rbx,%rsi,1),%xmm1\nmovdqu 0x10(%rbx,%rsi,1),%xmm2\nmovdqu (%r14,%rsi,1),%xmm3\npcmpeqb %xmm1,%xmm3\nmovdqu 0x10(%r14,%rsi,1),%xmm1\npcmpeqb %xmm2,%xmm1\npaddb  %xmm0,%xmm3\npaddb  %xmm0,%xmm1\nmovdqu %xmm3,(%rax,%rsi,1)\nmovdqu %xmm1,0x10(%rax,%rsi,1)\nmovdqu 0x20(%rbx,%rsi,1),%xmm1\nmovdqu 0x30(%rbx,%rsi,1),%xmm2\nmovdqu 0x20(%r14,%rsi,1),%xmm3\npcmpeqb %xmm1,%xmm3\nmovdqu 0x30(%r14,%rsi,1),%xmm1\npcmpeqb %xmm2,%xmm1\npaddb  %xmm0,%xmm3\npaddb  %xmm0,%xmm1\nmovdqu %xmm3,0x20(%rax,%rsi,1)\nmovdqu %xmm1,0x30(%rax,%rsi,1)\nadd    $0x40,%rsi\nadd    $0xfffffffffffffffe,%rdi\njne    11c0 <func0+0xa0>\ntest   $0x1,%r8b\nje     1274 <func0+0x154>\nmovdqu (%rbx,%rsi,1),%xmm0\nmovdqu 0x10(%rbx,%rsi,1),%xmm1\nmovdqu (%r14,%rsi,1),%xmm2\npcmpeqb %xmm0,%xmm2\nmovdqu 0x10(%r14,%rsi,1),%xmm0\npcmpeqb %xmm1,%xmm0\nmovdqa 0xd9f(%rip),%xmm1\npaddb  %xmm1,%xmm2\npaddb  %xmm1,%xmm0\nmovdqu %xmm2,(%rax,%rsi,1)\nmovdqu %xmm0,0x10(%rax,%rsi,1)\ncmp    %r9,%rdx\nje     12da <func0+0x1ba>\ntest   $0x18,%r9b\nje     12c0 <func0+0x1a0>\nmov    %rdx,%rsi\nmov    %r9d,%edx\nand    $0xfffffff8,%edx\nmovdqa 0xd80(%rip),%xmm0\nmovq   (%rbx,%rsi,1),%xmm1\nmovq   (%r14,%rsi,1),%xmm2\npcmpeqb %xmm1,%xmm2\npaddb  %xmm0,%xmm2\nmovq   %xmm2,(%rax,%rsi,1)\nadd    $0x8,%rsi\ncmp    %rsi,%rdx\njne    1290 <func0+0x170>\ncmp    %r9,%rdx\nje     12da <func0+0x1ba>\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%rbx,%rdx,1),%ecx\ncmp    (%r14,%rdx,1),%cl\nsete   %cl\nxor    $0x31,%cl\nmov    %cl,(%rax,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%r9\njne    12c0 <func0+0x1a0>\nmovslq %r15d,%rcx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\nret\nxor    %esi,%esi\ntest   $0x1,%r8b\njne    1239 <func0+0x119>\njmp    1274 <func0+0x154>\n"
    },
    {
        "task_id": 12,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nlea    0xeda(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    118d <func0+0x7d>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njle    117a <func0+0x6a>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\njmp    117f <func0+0x6f>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1138 <func0+0x28>\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 12,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ntest   %esi,%esi\njle    1150 <func0+0x40>\nmov    %rdi,%r14\nmov    %esi,%r12d\nxor    %ebx,%ebx\nlea    0xed2(%rip),%r13\nxor    %ebp,%ebp\nmov    (%r14,%rbx,8),%r15\nmov    %r15,%rdi\ncall   1030 <strlen@plt>\ncmp    %eax,%ebp\ncmovl  %eax,%ebp\ncmovl  %r15,%r13\nadd    $0x1,%rbx\ncmp    %rbx,%r12\njne    1130 <func0+0x20>\njmp    1157 <func0+0x47>\nlea    0xea9(%rip),%r13\nmov    %r13,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 12,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ntest   %esi,%esi\njle    1150 <func0+0x40>\nmov    %rdi,%r14\nmov    %esi,%r12d\nxor    %ebx,%ebx\nlea    0xed2(%rip),%r13\nxor    %ebp,%ebp\nmov    (%r14,%rbx,8),%r15\nmov    %r15,%rdi\ncall   1030 <strlen@plt>\ncmp    %eax,%ebp\ncmovl  %eax,%ebp\ncmovl  %r15,%r13\nadd    $0x1,%rbx\ncmp    %rbx,%r12\njne    1130 <func0+0x20>\njmp    1157 <func0+0x47>\nlea    0xea9(%rip),%r13\nmov    %r13,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 12,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ntest   %esi,%esi\njle    1150 <func0+0x40>\nmov    %rdi,%r14\nmov    %esi,%r12d\nxor    %ebx,%ebx\nlea    0xed2(%rip),%r13\nxor    %ebp,%ebp\nmov    (%r14,%rbx,8),%r15\nmov    %r15,%rdi\ncall   1030 <strlen@plt>\ncmp    %eax,%ebp\ncmovl  %eax,%ebp\ncmovl  %r15,%r13\nadd    $0x1,%rbx\ncmp    %rbx,%r12\njne    1130 <func0+0x20>\njmp    1157 <func0+0x47>\nlea    0xea9(%rip),%r13\nmov    %r13,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 13,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\nje     112f <func0+0x2f>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    -0x8(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x8(%rbp)\njmp    110a <func0+0xa>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 13,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\ntest   %esi,%esi\nje     111d <func0+0x1d>\nmov    %esi,%edx\nnopl   0x0(%rax,%rax,1)\nmov    %edx,%ecx\ncltd\nidiv   %ecx\nmov    %ecx,%eax\ntest   %edx,%edx\njne    1110 <func0+0x10>\nmov    %ecx,%eax\nret\n"
    },
    {
        "task_id": 13,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\ntest   %esi,%esi\nje     111d <func0+0x1d>\nmov    %esi,%edx\nnopl   0x0(%rax,%rax,1)\nmov    %edx,%ecx\ncltd\nidiv   %ecx\nmov    %ecx,%eax\ntest   %edx,%edx\njne    1110 <func0+0x10>\nmov    %ecx,%eax\nret\n"
    },
    {
        "task_id": 13,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\ntest   %esi,%esi\nje     111d <func0+0x1d>\nmov    %esi,%edx\nnopl   0x0(%rax,%rax,1)\nmov    %edx,%ecx\ncltd\nidiv   %ecx\nmov    %ecx,%eax\ntest   %edx,%edx\njne    1110 <func0+0x10>\nmov    %ecx,%eax\nret\n"
    },
    {
        "task_id": 14,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %eax,-0x14(%rbp)\nmovslq -0x14(%rbp),%rdi\nshl    $0x3,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1235 <func0+0xe5>\nmov    -0x28(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %rax,-0x38(%rbp)\nmov    -0x28(%rbp),%rdi\nmov    -0x38(%rbp),%rsi\nadd    $0x2,%rsi\ncall   1070 <realloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,1),%dl\nmov    -0x28(%rbp),%rax\nmov    -0x38(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x28(%rbp),%rax\nmov    -0x38(%rbp),%rcx\nmovb   $0x0,0x1(%rax,%rcx,1)\nmov    -0x28(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %rax,%rdi\nadd    $0x1,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x20(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nmov    -0x28(%rbp),%rsi\ncall   1040 <strcpy@plt>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    119d <func0+0x4d>\nmov    -0x28(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x14(%rbp),%ecx\nmov    -0x10(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 14,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,0x10(%rsp)\nmov    %rdi,%r12\ncall   1050 <strlen@plt>\nmov    %rax,%rbp\nmov    %rax,%rbx\nshl    $0x20,%rbx\nmov    %rbx,%rdi\nsar    $0x1d,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r13\nmovabs $0x100000000,%rdi\nadd    %rbx,%rdi\nsar    $0x20,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rbx\nmovb   $0x0,(%rax)\ntest   %ebp,%ebp\nmov    %rbp,0x8(%rsp)\njle    1201 <func0+0xb1>\nmov    %ebp,%r14d\nxor    %r15d,%r15d\nnop\nmov    %rbx,%rdi\ncall   1050 <strlen@plt>\nmov    %rax,%rbp\nlea    0x2(%rax),%rsi\nmov    %rbx,%rdi\ncall   1070 <realloc@plt>\nmov    %rax,%rbx\nmovzbl (%r12,%r15,1),%eax\nmov    %al,(%rbx,%rbp,1)\nmovb   $0x0,0x1(%rbx,%rbp,1)\nmov    %rbx,%rdi\ncall   1050 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1060 <malloc@plt>\nmov    %rax,0x0(%r13,%r15,8)\nmov    %rax,%rdi\nmov    %rbx,%rsi\ncall   1040 <strcpy@plt>\nadd    $0x1,%r15\ncmp    %r15,%r14\njne    11b0 <func0+0x60>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    0x10(%rsp),%rax\nmov    0x8(%rsp),%rcx\nmov    %ecx,(%rax)\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 14,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,0x10(%rsp)\nmov    %rdi,%r12\ncall   1050 <strlen@plt>\nmov    %rax,%rbp\nmov    %rax,%rbx\nshl    $0x20,%rbx\nmov    %rbx,%rdi\nsar    $0x1d,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r13\nmovabs $0x100000000,%rdi\nadd    %rbx,%rdi\nsar    $0x20,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rbx\nmovb   $0x0,(%rax)\ntest   %ebp,%ebp\nmov    %rbp,0x8(%rsp)\njle    1201 <func0+0xb1>\nmov    %ebp,%r14d\nxor    %r15d,%r15d\nnop\nmov    %rbx,%rdi\ncall   1050 <strlen@plt>\nmov    %rax,%rbp\nlea    0x2(%rax),%rsi\nmov    %rbx,%rdi\ncall   1070 <realloc@plt>\nmov    %rax,%rbx\nmovzbl (%r12,%r15,1),%eax\nmov    %al,(%rbx,%rbp,1)\nmovb   $0x0,0x1(%rbx,%rbp,1)\nmov    %rbx,%rdi\ncall   1050 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1060 <malloc@plt>\nmov    %rax,0x0(%r13,%r15,8)\nmov    %rax,%rdi\nmov    %rbx,%rsi\ncall   1040 <strcpy@plt>\nadd    $0x1,%r15\ncmp    %r15,%r14\njne    11b0 <func0+0x60>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    0x10(%rsp),%rax\nmov    0x8(%rsp),%rcx\nmov    %ecx,(%rax)\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 14,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,0x10(%rsp)\nmov    %rdi,%r12\ncall   1050 <strlen@plt>\nmov    %rax,%rbp\nmov    %rax,%rbx\nshl    $0x20,%rbx\nmov    %rbx,%rdi\nsar    $0x1d,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r13\nmovabs $0x100000000,%rdi\nadd    %rbx,%rdi\nsar    $0x20,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rbx\nmovb   $0x0,(%rax)\ntest   %ebp,%ebp\nmov    %rbp,0x8(%rsp)\njle    1201 <func0+0xb1>\nmov    %ebp,%r14d\nxor    %r15d,%r15d\nnop\nmov    %rbx,%rdi\ncall   1050 <strlen@plt>\nmov    %rax,%rbp\nlea    0x2(%rax),%rsi\nmov    %rbx,%rdi\ncall   1070 <realloc@plt>\nmov    %rax,%rbx\nmovzbl (%r12,%r15,1),%eax\nmov    %al,(%rbx,%rbp,1)\nmovb   $0x0,0x1(%rbx,%rbp,1)\nmov    %rbx,%rdi\ncall   1050 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1060 <malloc@plt>\nmov    %rax,0x0(%r13,%r15,8)\nmov    %rax,%rdi\nmov    %rbx,%rsi\ncall   1040 <strcpy@plt>\nadd    $0x1,%r15\ncmp    %r15,%r14\njne    11b0 <func0+0x60>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    0x10(%rsp),%rax\nmov    0x8(%rsp),%rcx\nmov    %ecx,(%rax)\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 15,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0xc(%rbp)\nmovl   $0x2,-0x10(%rbp)\nmovl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njg     1181 <func0+0x51>\nmov    -0x14(%rbp),%ecx\nxor    %eax,%eax\nmov    %eax,%esi\nlea    0xe9d(%rip),%rdx\nmov    %rsi,%rdi\nmov    $0x0,%al\ncall   1030 <snprintf@plt>\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1149 <func0+0x19>\nmovslq -0x10(%rbp),%rdi\ncall   1040 <malloc@plt>\nmov    %rax,-0x20(%rbp)\ncmpq   $0x0,-0x20(%rbp)\njne    11a6 <func0+0x76>\nmovq   $0x0,-0x8(%rbp)\njmp    121e <func0+0xee>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rdi\nlea    0xe4b(%rip),%rsi\nmov    $0x0,%al\ncall   1050 <sprintf@plt>\nmov    %eax,%ecx\nmov    -0x28(%rbp),%rax\nmovslq %ecx,%rcx\nadd    %rcx,%rax\nmov    %rax,-0x28(%rbp)\nmovl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njg     1216 <func0+0xe6>\nmov    -0x28(%rbp),%rdi\nmov    -0x2c(%rbp),%edx\nlea    0xe0f(%rip),%rsi\nmov    $0x0,%al\ncall   1050 <sprintf@plt>\nmov    %eax,%ecx\nmov    -0x28(%rbp),%rax\nmovslq %ecx,%rcx\nadd    %rcx,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    11d7 <func0+0xa7>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 15,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %edi,%r15d\ntest   %edi,%edi\njle    118a <func0+0x5a>\nmov    %r15d,%r12d\nneg    %r12d\nmov    $0x2,%ebp\nmov    $0x1,%ebx\nlea    0xea7(%rip),%r14\nnopl   0x0(%rax)\nxor    %edi,%edi\nxor    %esi,%esi\nmov    %r14,%rdx\nmov    %ebx,%ecx\nxor    %eax,%eax\ncall   1030 <snprintf@plt>\nadd    %eax,%ebp\nlea    (%r12,%rbx,1),%eax\nadd    $0x1,%eax\nmov    %ebx,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%ebx\ncmp    $0x1,%eax\njne    1160 <func0+0x30>\nmovslq %ebp,%rdi\njmp    118f <func0+0x5f>\nmov    $0x2,%edi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     11ec <func0+0xbc>\nmov    %rax,%r14\nmovw   $0x30,(%rax)\ntest   %r15d,%r15d\njle    11ef <func0+0xbf>\nmov    %r14,%rbx\nadd    $0x1,%rbx\nneg    %r15d\nmov    $0x1,%r13d\nlea    0xe43(%rip),%r12\nnopl   (%rax)\nmov    %rbx,%rdi\nmov    %r12,%rsi\nmov    %r13d,%edx\nxor    %eax,%eax\ncall   1050 <sprintf@plt>\ncltq\nadd    %rax,%rbx\nlea    (%r15,%r13,1),%eax\nadd    $0x1,%eax\nmov    %r13d,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%r13d\ncmp    $0x1,%eax\njne    11c0 <func0+0x90>\njmp    11ef <func0+0xbf>\nxor    %r14d,%r14d\nmov    %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 15,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\ntest   %edi,%edi\njle    11e9 <func0+0xb9>\nmov    %edi,%r14d\nmov    %edi,%r12d\nneg    %r12d\nmov    $0x2,%ebx\nmov    $0x1,%ebp\nlea    0xea6(%rip),%r15\nnopw   0x0(%rax,%rax,1)\nxor    %edi,%edi\nxor    %esi,%esi\nmov    %r15,%rdx\nmov    %ebp,%ecx\nxor    %eax,%eax\ncall   1030 <snprintf@plt>\nadd    %eax,%ebx\nlea    (%r12,%rbp,1),%eax\nadd    $0x1,%eax\nmov    %ebp,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%ebp\ncmp    $0x1,%eax\njne    1160 <func0+0x30>\nmovslq %ebx,%rdi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     1202 <func0+0xd2>\nmov    %rax,%r15\nmovw   $0x30,(%rax)\ntest   %r14d,%r14d\njle    1205 <func0+0xd5>\nmov    %r15,%rbx\nadd    $0x1,%rbx\nmov    $0x1,%ebp\nlea    0xe4e(%rip),%r14\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %rbx,%rdi\nmov    %r14,%rsi\nmov    %ebp,%edx\nxor    %eax,%eax\ncall   1050 <sprintf@plt>\ncltq\nadd    %rax,%rbx\nlea    (%r12,%rbp,1),%eax\nadd    $0x1,%eax\nmov    %ebp,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%ebp\ncmp    $0x1,%eax\njne    11c0 <func0+0x90>\njmp    1205 <func0+0xd5>\nmov    $0x2,%edi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     1202 <func0+0xd2>\nmov    %rax,%r15\nmovw   $0x30,(%rax)\njmp    1205 <func0+0xd5>\nxor    %r15d,%r15d\nmov    %r15,%rax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 15,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\ntest   %edi,%edi\njle    11e9 <func0+0xb9>\nmov    %edi,%r14d\nmov    %edi,%r12d\nneg    %r12d\nmov    $0x2,%ebx\nmov    $0x1,%ebp\nlea    0xea6(%rip),%r15\nnopw   0x0(%rax,%rax,1)\nxor    %edi,%edi\nxor    %esi,%esi\nmov    %r15,%rdx\nmov    %ebp,%ecx\nxor    %eax,%eax\ncall   1030 <snprintf@plt>\nadd    %eax,%ebx\nlea    (%r12,%rbp,1),%eax\nadd    $0x1,%eax\nmov    %ebp,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%ebp\ncmp    $0x1,%eax\njne    1160 <func0+0x30>\nmovslq %ebx,%rdi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     1202 <func0+0xd2>\nmov    %rax,%r15\nmovw   $0x30,(%rax)\ntest   %r14d,%r14d\njle    1205 <func0+0xd5>\nmov    %r15,%rbx\nadd    $0x1,%rbx\nmov    $0x1,%ebp\nlea    0xe4e(%rip),%r14\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %rbx,%rdi\nmov    %r14,%rsi\nmov    %ebp,%edx\nxor    %eax,%eax\ncall   1050 <sprintf@plt>\ncltq\nadd    %rax,%rbx\nlea    (%r12,%rbp,1),%eax\nadd    $0x1,%eax\nmov    %ebp,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%ebp\ncmp    $0x1,%eax\njne    11c0 <func0+0x90>\njmp    1205 <func0+0xd5>\nmov    $0x2,%edi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     1202 <func0+0xd2>\nmov    %rax,%r15\nmovw   $0x30,(%rax)\njmp    1205 <func0+0xd5>\nxor    %r15d,%r15d\nmov    %r15,%rax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 16,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x420,%rsp\nmov    %rdi,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\nlea    -0x410(%rbp),%rdi\nxor    %esi,%esi\nmov    $0x400,%edx\ncall   1030 <memset@plt>\nmovl   $0x0,-0x414(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x414(%rbp),%rcx\ncmpb   $0x0,(%rax,%rcx,1)\nje     1201 <func0+0xd1>\nmov    -0x8(%rbp),%rax\nmovslq -0x414(%rbp),%rcx\nmovzbl (%rax,%rcx,1),%edi\ncall   1040 <tolower@plt>\nmov    %al,-0x415(%rbp)\nmovsbq -0x415(%rbp),%rax\nff\ncmpl   $0x0,-0x410(%rbp,%rax,4)\njne    11e8 <func0+0xb8>\ncall   1050 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmovzbl -0x415(%rbp),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x400,%eax\ncmp    $0x0,%eax\nje     11e8 <func0+0xb8>\nmovsbq -0x415(%rbp),%rax\nff\nmovl   $0x1,-0x410(%rbp,%rax,4)\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    11ed <func0+0xbd>\nmov    -0x414(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x414(%rbp)\njmp    1163 <func0+0x33>\nmov    -0xc(%rbp),%eax\nadd    $0x420,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 16,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x400,%rsp\nmov    %rdi,%rbp\nmov    %rsp,%rdi\nxor    %r14d,%r14d\nmov    $0x400,%edx\nxor    %esi,%esi\ncall   1030 <memset@plt>\nmov    0x0(%rbp),%bl\ntest   %bl,%bl\nje     11ae <func0+0x7e>\ncall   1040 <__ctype_tolower_loc@plt>\nmov    (%rax),%r15\nadd    $0x1,%rbp\nxor    %r14d,%r14d\njmp    117c <func0+0x4c>\nnopl   0x0(%rax)\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\ntest   %bl,%bl\nje     11ae <func0+0x7e>\nmovzbl %bl,%eax\nmov    (%r15,%rax,4),%ebx\nmovsbq %bl,%r12\ncmpl   $0x0,(%rsp,%r12,4)\njne    1170 <func0+0x40>\ncall   1050 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmovzbl %bl,%ecx\ntestb  $0x4,0x1(%rax,%rcx,2)\nje     1170 <func0+0x40>\nmovl   $0x1,(%rsp,%r12,4)\nadd    $0x1,%r14d\njmp    1170 <func0+0x40>\nmov    %r14d,%eax\nadd    $0x400,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 16,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x400,%rsp\nmov    %rdi,%rbp\nmov    %rsp,%rdi\nxor    %r14d,%r14d\nmov    $0x400,%edx\nxor    %esi,%esi\ncall   1030 <memset@plt>\nmov    0x0(%rbp),%bl\ntest   %bl,%bl\nje     11ae <func0+0x7e>\ncall   1040 <__ctype_tolower_loc@plt>\nmov    (%rax),%r15\nadd    $0x1,%rbp\nxor    %r14d,%r14d\njmp    117c <func0+0x4c>\nnopl   0x0(%rax)\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\ntest   %bl,%bl\nje     11ae <func0+0x7e>\nmovzbl %bl,%eax\nmov    (%r15,%rax,4),%ebx\nmovsbq %bl,%r12\ncmpl   $0x0,(%rsp,%r12,4)\njne    1170 <func0+0x40>\ncall   1050 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmovzbl %bl,%ecx\ntestb  $0x4,0x1(%rax,%rcx,2)\nje     1170 <func0+0x40>\nmovl   $0x1,(%rsp,%r12,4)\nadd    $0x1,%r14d\njmp    1170 <func0+0x40>\nmov    %r14d,%eax\nadd    $0x400,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 16,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x400,%rsp\nmov    %rdi,%rbp\nmov    %rsp,%rdi\nxor    %r14d,%r14d\nmov    $0x400,%edx\nxor    %esi,%esi\ncall   1030 <memset@plt>\nmov    0x0(%rbp),%bl\ntest   %bl,%bl\nje     11ae <func0+0x7e>\ncall   1040 <__ctype_tolower_loc@plt>\nmov    (%rax),%r15\nadd    $0x1,%rbp\nxor    %r14d,%r14d\njmp    117c <func0+0x4c>\nnopl   0x0(%rax)\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\ntest   %bl,%bl\nje     11ae <func0+0x7e>\nmovzbl %bl,%eax\nmov    (%r15,%rax,4),%ebx\nmovsbq %bl,%r12\ncmpl   $0x0,(%rsp,%r12,4)\njne    1170 <func0+0x40>\ncall   1050 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmovzbl %bl,%ecx\ntestb  $0x4,0x1(%rax,%rcx,2)\nje     1170 <func0+0x40>\nmovl   $0x1,(%rsp,%r12,4)\nadd    $0x1,%r14d\njmp    1170 <func0+0x40>\nmov    %r14d,%eax\nadd    $0x400,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 17,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovq   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nlea    -0x23(%rbp),%rdi\nxor    %esi,%esi\nmov    $0x3,%edx\ncall   1060 <memset@plt>\nmov    -0x8(%rbp),%rdi\ncall   1050 <strlen@plt>\nadd    $0x1,%rax\nmov    %eax,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1080 <malloc@plt>\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rdi\nmov    -0x8(%rbp),%rsi\ncall   1040 <strcpy@plt>\nmov    -0x30(%rbp),%rdi\nlea    0xe10(%rip),%rsi\ncall   10a0 <strcat@plt>\nmovl   $0x0,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njge    13f8 <func0+0x278>\nmov    -0x30(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x20,%eax\njne    13ac <func0+0x22c>\nlea    -0x23(%rbp),%rdi\nlea    0xdda(%rip),%rsi\ncall   1070 <strcmp@plt>\ncmp    $0x0,%eax\njne    129b <func0+0x11b>\nmov    -0x1c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njne    1282 <func0+0x102>\ncmpl   $0x0,-0x20(%rbp)\njle    125a <func0+0xda>\nmov    -0x20(%rbp),%eax\nshl    $0x1,%eax\nmov    %eax,-0x44(%rbp)\njmp    1267 <func0+0xe7>\nmov    $0x4,%eax\nmov    %eax,-0x44(%rbp)\njmp    1267 <func0+0xe7>\nmov    -0x44(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x18(%rbp),%rdi\nmovslq -0x20(%rbp),%rsi\nshl    $0x2,%rsi\ncall   1090 <realloc@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %ecx,%rcx\nmovl   $0x4,(%rax,%rcx,4)\nlea    -0x23(%rbp),%rdi\nlea    0xd5e(%rip),%rsi\ncall   1070 <strcmp@plt>\ncmp    $0x0,%eax\njne    1319 <func0+0x199>\nmov    -0x1c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njne    1300 <func0+0x180>\ncmpl   $0x0,-0x20(%rbp)\njle    12d8 <func0+0x158>\nmov    -0x20(%rbp),%eax\nshl    $0x1,%eax\nmov    %eax,-0x48(%rbp)\njmp    12e5 <func0+0x165>\nmov    $0x4,%eax\nmov    %eax,-0x48(%rbp)\njmp    12e5 <func0+0x165>\nmov    -0x48(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x18(%rbp),%rdi\nmovslq -0x20(%rbp),%rsi\nshl    $0x2,%rsi\ncall   1090 <realloc@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %ecx,%rcx\nmovl   $0x2,(%rax,%rcx,4)\nlea    -0x23(%rbp),%rdi\nlea    0xce3(%rip),%rsi\ncall   1070 <strcmp@plt>\ncmp    $0x0,%eax\njne    1397 <func0+0x217>\nmov    -0x1c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njne    137e <func0+0x1fe>\ncmpl   $0x0,-0x20(%rbp)\njle    1356 <func0+0x1d6>\nmov    -0x20(%rbp),%eax\nshl    $0x1,%eax\nmov    %eax,-0x4c(%rbp)\njmp    1363 <func0+0x1e3>\nmov    $0x4,%eax\nmov    %eax,-0x4c(%rbp)\njmp    1363 <func0+0x1e3>\nmov    -0x4c(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x18(%rbp),%rdi\nmovslq -0x20(%rbp),%rsi\nshl    $0x2,%rsi\ncall   1090 <realloc@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %ecx,%rcx\nmovl   $0x1,(%rax,%rcx,4)\nlea    -0x23(%rbp),%rdi\nlea    0xc5f(%rip),%rsi\ncall   1040 <strcpy@plt>\njmp    13e5 <func0+0x265>\nlea    -0x23(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %rax,-0x40(%rbp)\ncmpq   $0x2,-0x40(%rbp)\njae    13e0 <func0+0x260>\nmov    -0x30(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmov    -0x40(%rbp),%rax\nmov    %cl,-0x23(%rbp,%rax,1)\nmov    -0x40(%rbp),%rax\nmovb   $0x0,-0x22(%rbp,%rax,1)\njmp    13e5 <func0+0x265>\njmp    13ea <func0+0x26a>\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    11fc <func0+0x7c>\nmov    -0x30(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x1c(%rbp),%ecx\nmov    -0x10(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x50,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 17,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,0x8(%rsp)\nmov    %rdi,%r15\nmovb   $0x0,0x6(%rsp)\nmovw   $0x0,0x4(%rsp)\ncall   1050 <strlen@plt>\nmov    %rax,%rbx\nadd    $0x2,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r12\nmov    %rax,%rdi\nmov    %r15,%rsi\ncall   1040 <strcpy@plt>\nmov    %r12,%rdi\ncall   1050 <strlen@plt>\nmovw   $0x20,(%r12,%rax,1)\ncmp    $0x7ffffffe,%ebx\nja     1303 <func0+0x1b3>\nadd    $0x1,%ebx\ncmp    $0x2,%ebx\nmov    $0x1,%eax\ncmovge %ebx,%eax\nmov    %rax,0x10(%rsp)\nxor    %r14d,%r14d\nxor    %r13d,%r13d\nxor    %ebx,%ebx\nxor    %r15d,%r15d\njmp    11f1 <func0+0xa1>\nmovslq %ebx,%rax\nadd    $0x1,%ebx\nmovl   $0x1,0x0(%r13,%rax,4)\nmovb   $0x0,0x4(%rsp)\nadd    $0x1,%r14\ncmp    %r14,0x10(%rsp)\nje     1308 <func0+0x1b8>\nmovzbl (%r12,%r14,1),%ebp\ncmp    $0x20,%bpl\njne    12e0 <func0+0x190>\ncmpw   $0x6f,0x4(%rsp)\njne    1240 <func0+0xf0>\ncmp    %r15d,%ebx\njne    1231 <func0+0xe1>\nlea    (%r15,%r15,1),%ebp\ntest   %r15d,%r15d\nmov    $0x4,%eax\ncmovle %eax,%ebp\nmovslq %ebp,%rsi\nshl    $0x2,%rsi\nmov    %r13,%rdi\ncall   1070 <realloc@plt>\nmov    %rax,%r13\nmov    %ebp,%r15d\nmovslq %ebx,%rax\nadd    $0x1,%ebx\nmovl   $0x4,0x0(%r13,%rax,4)\nmovzwl 0x4(%rsp),%eax\nxor    $0x7c6f,%eax\nmovzbl 0x6(%rsp),%ecx\nor     %ax,%cx\njne    128c <func0+0x13c>\ncmp    %r15d,%ebx\njne    127d <func0+0x12d>\nlea    (%r15,%r15,1),%ebp\ntest   %r15d,%r15d\nmov    $0x4,%eax\ncmovle %eax,%ebp\nmovslq %ebp,%rsi\nshl    $0x2,%rsi\nmov    %r13,%rdi\ncall   1070 <realloc@plt>\nmov    %rax,%r13\nmov    %ebp,%r15d\nmovslq %ebx,%rax\nadd    $0x1,%ebx\nmovl   $0x2,0x0(%r13,%rax,4)\nmovzwl 0x4(%rsp),%eax\nxor    $0x7c2e,%eax\nmovzbl 0x6(%rsp),%ecx\nor     %ax,%cx\njne    11dd <func0+0x8d>\ncmp    %r15d,%ebx\njne    11ce <func0+0x7e>\nlea    (%r15,%r15,1),%ebp\ntest   %r15d,%r15d\nmov    $0x4,%eax\ncmovle %eax,%ebp\nmovslq %ebp,%rsi\nshl    $0x2,%rsi\nmov    %r13,%rdi\ncall   1070 <realloc@plt>\nmov    %rax,%r13\nmov    %ebp,%r15d\njmp    11ce <func0+0x7e>\ncs nopw 0x0(%rax,%rax,1)\nlea    0x4(%rsp),%rdi\ncall   1050 <strlen@plt>\ncmp    $0x1,%rax\nja     11e2 <func0+0x92>\nmov    %bpl,0x4(%rsp,%rax,1)\nmovb   $0x0,0x5(%rsp,%rax,1)\njmp    11e2 <func0+0x92>\nxor    %ebx,%ebx\nxor    %r13d,%r13d\nmov    %r12,%rdi\ncall   1030 <free@plt>\nmov    0x8(%rsp),%rax\nmov    %ebx,(%rax)\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 17,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %rsi,0x20(%rsp)\nmov    %rdi,%rbx\nmovb   $0x0,0xe(%rsp)\nmovw   $0x0,0xc(%rsp)\ncall   1050 <strlen@plt>\nmov    %rax,%rbp\nadd    $0x2,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rdi\nmov    %rbx,%rsi\nmov    %rax,%rbx\ncall   1040 <strcpy@plt>\nmov    %rbx,%rdi\ncall   1050 <strlen@plt>\nmov    %rbp,%rdx\nmovw   $0x20,(%rbx,%rax,1)\ncmp    $0x7ffffffe,%edx\nja     1314 <func0+0x1c4>\nadd    $0x1,%edx\nxor    %r14d,%r14d\nxor    %r13d,%r13d\nxor    %ebp,%ebp\nxor    %r12d,%r12d\nmov    %rbx,0x18(%rsp)\nmov    %rdx,0x10(%rsp)\njmp    11eb <func0+0x9b>\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmovl   $0x1,0x0(%r13,%rax,4)\nmovb   $0x0,0xc(%rsp)\nadd    $0x1,%r14\ncmp    %r14,%rdx\nje     1319 <func0+0x1c9>\nmovzbl (%rbx,%r14,1),%r15d\ncmp    $0x20,%r15b\njne    12f0 <func0+0x1a0>\ncmpw   $0x6f,0xc(%rsp)\njne    123d <func0+0xed>\ncmp    %r12d,%ebp\njne    122e <func0+0xde>\nlea    0x0(%rbp,%rbp,1),%r12d\ntest   %ebp,%ebp\nmov    $0x4,%eax\ncmovle %eax,%r12d\nmovslq %r12d,%rsi\nshl    $0x2,%rsi\nmov    %r13,%rdi\ncall   1070 <realloc@plt>\nmov    0x10(%rsp),%rdx\nmov    %rax,%r13\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmovl   $0x4,0x0(%r13,%rax,4)\nmovzwl 0xc(%rsp),%eax\nxor    $0x7c6f,%eax\nmovzbl 0xe(%rsp),%ecx\nor     %ax,%cx\njne    1293 <func0+0x143>\ncmp    %r12d,%ebp\njne    1284 <func0+0x134>\nlea    (%r12,%r12,1),%ebx\ntest   %r12d,%r12d\nmov    $0x4,%eax\ncmovle %eax,%ebx\nmovslq %ebx,%rsi\nshl    $0x2,%rsi\nmov    %r13,%rdi\ncall   1070 <realloc@plt>\nmov    0x10(%rsp),%rdx\nmov    %rax,%r13\nmov    %ebx,%r12d\nmov    0x18(%rsp),%rbx\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmovl   $0x2,0x0(%r13,%rax,4)\nmovzwl 0xc(%rsp),%eax\nxor    $0x7c2e,%eax\nmovzbl 0xe(%rsp),%ecx\nor     %ax,%cx\njne    11d9 <func0+0x89>\ncmp    %r12d,%ebp\njne    11ca <func0+0x7a>\nlea    (%r12,%r12,1),%ebx\ntest   %r12d,%r12d\nmov    $0x4,%eax\ncmovle %eax,%ebx\nmovslq %ebx,%rsi\nshl    $0x2,%rsi\nmov    %r13,%rdi\ncall   1070 <realloc@plt>\nmov    0x10(%rsp),%rdx\nmov    %rax,%r13\nmov    %ebx,%r12d\nmov    0x18(%rsp),%rbx\njmp    11ca <func0+0x7a>\nnopw   0x0(%rax,%rax,1)\nlea    0xc(%rsp),%rdi\ncall   1050 <strlen@plt>\ncmp    $0x1,%rax\nja     130a <func0+0x1ba>\nmov    %r15b,0xc(%rsp,%rax,1)\nmovb   $0x0,0xd(%rsp,%rax,1)\nmov    0x10(%rsp),%rdx\njmp    11de <func0+0x8e>\nxor    %ebp,%ebp\nxor    %r13d,%r13d\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    0x20(%rsp),%rax\nmov    %ebp,(%rax)\nmov    %r13,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 17,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %rsi,0x20(%rsp)\nmov    %rdi,%rbx\nmovb   $0x0,0xe(%rsp)\nmovw   $0x0,0xc(%rsp)\ncall   1050 <strlen@plt>\nmov    %rax,%rbp\nadd    $0x2,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rdi\nmov    %rbx,%rsi\nmov    %rax,%rbx\ncall   1040 <strcpy@plt>\nmov    %rbx,%rdi\ncall   1050 <strlen@plt>\nmov    %rbp,%rdx\nmovw   $0x20,(%rbx,%rax,1)\ncmp    $0x7ffffffe,%edx\nja     131e <func0+0x1ce>\nadd    $0x1,%edx\nxor    %r14d,%r14d\nxor    %r13d,%r13d\nxor    %ebp,%ebp\nxor    %r12d,%r12d\nmov    %rbx,0x18(%rsp)\nmov    %rdx,0x10(%rsp)\njmp    11eb <func0+0x9b>\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmovl   $0x1,0x0(%r13,%rax,4)\nmovb   $0x0,0xc(%rsp)\nadd    $0x1,%r14\ncmp    %r14,%rdx\nje     1323 <func0+0x1d3>\nmovzbl (%rbx,%r14,1),%r15d\ncmp    $0x20,%r15b\njne    12f0 <func0+0x1a0>\ncmpw   $0x6f,0xc(%rsp)\njne    123d <func0+0xed>\ncmp    %r12d,%ebp\njne    122e <func0+0xde>\nlea    0x0(%rbp,%rbp,1),%r12d\ntest   %ebp,%ebp\nmov    $0x4,%eax\ncmovle %eax,%r12d\nmovslq %r12d,%rsi\nshl    $0x2,%rsi\nmov    %r13,%rdi\ncall   1070 <realloc@plt>\nmov    0x10(%rsp),%rdx\nmov    %rax,%r13\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmovl   $0x4,0x0(%r13,%rax,4)\nmovzwl 0xc(%rsp),%eax\nxor    $0x7c6f,%eax\nmovzbl 0xe(%rsp),%ecx\nor     %ax,%cx\njne    1293 <func0+0x143>\ncmp    %r12d,%ebp\njne    1284 <func0+0x134>\nlea    (%r12,%r12,1),%ebx\ntest   %r12d,%r12d\nmov    $0x4,%eax\ncmovle %eax,%ebx\nmovslq %ebx,%rsi\nshl    $0x2,%rsi\nmov    %r13,%rdi\ncall   1070 <realloc@plt>\nmov    0x10(%rsp),%rdx\nmov    %rax,%r13\nmov    %ebx,%r12d\nmov    0x18(%rsp),%rbx\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmovl   $0x2,0x0(%r13,%rax,4)\nmovzwl 0xc(%rsp),%eax\nxor    $0x7c2e,%eax\nmovzbl 0xe(%rsp),%ecx\nor     %ax,%cx\njne    11d9 <func0+0x89>\ncmp    %r12d,%ebp\njne    11ca <func0+0x7a>\nlea    (%r12,%r12,1),%ebx\ntest   %r12d,%r12d\nmov    $0x4,%eax\ncmovle %eax,%ebx\nmovslq %ebx,%rsi\nshl    $0x2,%rsi\nmov    %r13,%rdi\ncall   1070 <realloc@plt>\nmov    0x10(%rsp),%rdx\nmov    %rax,%r13\nmov    %ebx,%r12d\nmov    0x18(%rsp),%rbx\njmp    11ca <func0+0x7a>\nnopw   0x0(%rax,%rax,1)\nlea    0xc(%rsp),%rdi\ncall   1050 <strlen@plt>\ncmp    $0x1,%rax\nja     130a <func0+0x1ba>\nmov    %r15b,0xc(%rsp,%rax,1)\nmovb   $0x0,0xd(%rsp,%rax,1)\nmov    0x10(%rsp),%rdx\nadd    $0x1,%r14\ncmp    %r14,%rdx\njne    11eb <func0+0x9b>\njmp    1323 <func0+0x1d3>\nxor    %ebp,%ebp\nxor    %r13d,%r13d\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    0x20(%rsp),%rax\nmov    %ebp,(%rax)\nmov    %r13,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 18,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %rsi,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1040 <strlen@plt>\nmov    %eax,-0x20(%rbp)\nmov    -0x18(%rbp),%rdi\ncall   1040 <strlen@plt>\nmov    %eax,-0x24(%rbp)\ncmpl   $0x0,-0x20(%rbp)\njne    1165 <func0+0x45>\nmovl   $0x0,-0x4(%rbp)\njmp    11c0 <func0+0xa0>\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nmov    -0x20(%rbp),%ecx\nsub    -0x24(%rbp),%ecx\ncmp    %ecx,%eax\njg     11ba <func0+0x9a>\nmov    -0x10(%rbp),%rdi\nmovslq -0x28(%rbp),%rax\nadd    %rax,%rdi\nmov    -0x18(%rbp),%rsi\nmovslq -0x24(%rbp),%rdx\ncall   1030 <strncmp@plt>\ncmp    $0x0,%eax\njne    11a7 <func0+0x87>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    11ac <func0+0x8c>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    116c <func0+0x4c>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 18,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rsi,%r14\nmov    %rdi,%rbx\ncall   1040 <strlen@plt>\nmov    %rax,%r15\nmov    %r14,%rdi\ncall   1040 <strlen@plt>\nxor    %ebp,%ebp\ntest   %r15d,%r15d\nje     117e <func0+0x5e>\ncmp    %eax,%r15d\njl     117e <func0+0x5e>\nmovslq %eax,%r12\nsub    %r12d,%r15d\nadd    $0x1,%r15d\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nmov    %rbx,%rdi\nmov    %r14,%rsi\nmov    %r12,%rdx\ncall   1030 <strncmp@plt>\ncmp    $0x1,%eax\nadc    $0x0,%ebp\nadd    $0x1,%rbx\nadd    $0xffffffffffffffff,%r15\njne    1160 <func0+0x40>\nmov    %ebp,%eax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 18,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rsi,%r14\nmov    %rdi,%rbx\ncall   1040 <strlen@plt>\nmov    %rax,%r15\nmov    %r14,%rdi\ncall   1040 <strlen@plt>\nxor    %ebp,%ebp\ntest   %r15d,%r15d\nje     117e <func0+0x5e>\ncmp    %eax,%r15d\njl     117e <func0+0x5e>\nmovslq %eax,%r12\nsub    %r12d,%r15d\nadd    $0x1,%r15d\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nmov    %rbx,%rdi\nmov    %r14,%rsi\nmov    %r12,%rdx\ncall   1030 <strncmp@plt>\ncmp    $0x1,%eax\nadc    $0x0,%ebp\nadd    $0x1,%rbx\nadd    $0xffffffffffffffff,%r15\njne    1160 <func0+0x40>\nmov    %ebp,%eax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 18,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rsi,%r14\nmov    %rdi,%rbx\ncall   1040 <strlen@plt>\nmov    %rax,%r15\nmov    %r14,%rdi\ncall   1040 <strlen@plt>\nxor    %ebp,%ebp\ntest   %r15d,%r15d\nje     117e <func0+0x5e>\ncmp    %eax,%r15d\njl     117e <func0+0x5e>\nmovslq %eax,%r12\nsub    %r12d,%r15d\nadd    $0x1,%r15d\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nmov    %rbx,%rdi\nmov    %r14,%rsi\nmov    %r12,%rdx\ncall   1030 <strncmp@plt>\ncmp    $0x1,%eax\nadc    $0x0,%ebp\nadd    $0x1,%rbx\nadd    $0xffffffffffffffff,%r15\njne    1160 <func0+0x40>\nmov    %ebp,%eax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 19,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xa0,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    -0x30(%rbp),%rdi\nxor    %esi,%esi\nmov    $0x28,%edx\ncall   1030 <memset@plt>\nlea    -0x80(%rbp),%rdi\nlea    0x2c76(%rip),%rsi\nmov    $0x50,%edx\ncall   1050 <memcpy@plt>\nmovl   $0x0,-0x84(%rbp)\nmov    -0x8(%rbp),%rax\ncmpb   $0x0,(%rax)\nje     12a9 <func0+0x179>\njmp    1180 <func0+0x50>\nmovl   $0x0,-0x88(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x88(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%ecx\nxor    %eax,%eax\ncmp    $0x20,%ecx\nmov    %al,-0x97(%rbp)\nje     11c5 <func0+0x95>\nmov    -0x8(%rbp),%rax\nmovslq -0x88(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nsetne  %al\nmov    %al,-0x97(%rbp)\nmov    -0x97(%rbp),%al\ntest   $0x1,%al\njne    11d8 <func0+0xa8>\njmp    1208 <func0+0xd8>\nmov    -0x8(%rbp),%rax\nmovslq -0x88(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmovslq -0x88(%rbp),%rax\nmov    %cl,-0x96(%rbp,%rax,1)\nmov    -0x88(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x88(%rbp)\njmp    118a <func0+0x5a>\nmovslq -0x88(%rbp),%rax\nmovb   $0x0,-0x96(%rbp,%rax,1)\nmovl   $0x0,-0x8c(%rbp)\ncmpl   $0xa,-0x8c(%rbp)\njge    127f <func0+0x14f>\nlea    -0x96(%rbp),%rdi\nmovslq -0x8c(%rbp),%rax\nmov    -0x80(%rbp,%rax,8),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\njne    1266 <func0+0x136>\nmovslq -0x8c(%rbp),%rax\nmov    -0x30(%rbp,%rax,4),%ecx\nadd    $0x1,%ecx\nmov    %ecx,-0x30(%rbp,%rax,4)\njmp    127f <func0+0x14f>\njmp    126b <func0+0x13b>\nmov    -0x8c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8c(%rbp)\njmp    1221 <func0+0xf1>\nmov    -0x88(%rbp),%ecx\nadd    $0x1,%ecx\nmov    -0x8(%rbp),%rax\nmovslq %ecx,%rcx\nadd    %rcx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmpb   $0x0,-0x1(%rax)\njne    1180 <func0+0x50>\njmp    12a9 <func0+0x179>\nmovl   $0x0,-0x88(%rbp)\ncmpl   $0xa,-0x88(%rbp)\njge    13a1 <func0+0x271>\nmovl   $0x0,-0x8c(%rbp)\nmov    -0x8c(%rbp),%eax\nmovslq -0x88(%rbp),%rcx\ncmp    -0x30(%rbp,%rcx,4),%eax\njge    1388 <func0+0x258>\nmovl   $0x0,-0x90(%rbp)\nmovslq -0x88(%rbp),%rax\nmov    -0x80(%rbp,%rax,8),%rax\nmovslq -0x90(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1355 <func0+0x225>\nmovslq -0x88(%rbp),%rax\nmov    -0x80(%rbp,%rax,8),%rax\nmovslq -0x90(%rbp),%rcx\nmov    (%rax,%rcx,1),%dl\nmovslq -0x84(%rbp),%rcx\nlea    0x2d21(%rip),%rax\nmov    %dl,(%rax,%rcx,1)\nmov    -0x90(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x90(%rbp)\nmov    -0x84(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x84(%rbp)\njmp    12eb <func0+0x1bb>\nmov    -0x84(%rbp),%eax\nmov    %eax,%ecx\nadd    $0x1,%ecx\nmov    %ecx,-0x84(%rbp)\nmovslq %eax,%rcx\nlea    0x2ce0(%rip),%rax\nmovb   $0x20,(%rax,%rcx,1)\nmov    -0x8c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8c(%rbp)\njmp    12ca <func0+0x19a>\njmp    138d <func0+0x25d>\nmov    -0x88(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x88(%rbp)\njmp    12b3 <func0+0x183>\ncmpl   $0x0,-0x84(%rbp)\njle    13ca <func0+0x29a>\nmov    -0x84(%rbp),%eax\nsub    $0x1,%eax\nmovslq %eax,%rcx\nlea    0x2c8f(%rip),%rax\nmovb   $0x0,(%rax,%rcx,1)\njmp    13d1 <func0+0x2a1>\nmovb   $0x0,0x2c7f(%rip)\nlea    0x2c78(%rip),%rax\nadd    $0xa0,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 19,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x38,%rsp\nxorps  %xmm0,%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovq   $0x0,0x30(%rsp)\ncmpb   $0x0,(%rdi)\nje     11c0 <func0+0xb0>\nmov    %rdi,%r13\nlea    0x2c89(%rip),%r12\nlea    0xa(%rsp),%r14\njmp    1164 <func0+0x54>\nxchg   %ax,%ax\naddl   $0x1,0x0(%rbp)\nadd    $0x1,%ebx\ncmpb   $0x0,-0x1(%r13,%rbx,1)\nlea    0x0(%r13,%rbx,1),%r13\nje     11c0 <func0+0xb0>\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nmovzbl 0x0(%r13,%rbx,1),%eax\ntest   $0xdf,%al\nje     1190 <func0+0x80>\nmov    %al,0xa(%rsp,%rbx,1)\nadd    $0x1,%rbx\njmp    1170 <func0+0x60>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %ebx,%eax\nmovb   $0x0,0xa(%rsp,%rax,1)\nxor    %r15d,%r15d\nlea    0x10(%rsp),%rbp\nnop\nmov    (%r15,%r12,1),%rsi\nmov    %r14,%rdi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nje     1150 <func0+0x40>\nadd    $0x4,%rbp\nadd    $0x8,%r15\ncmp    $0x50,%r15\njne    11a0 <func0+0x90>\njmp    1154 <func0+0x44>\nxor    %r9d,%r9d\nlea    0x2c06(%rip),%r8\nlea    0x2e6f(%rip),%rax\nxor    %r11d,%r11d\njmp    11ea <func0+0xda>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%r9\ncmp    $0xa,%r9\nje     1239 <func0+0x129>\nmov    0x10(%rsp,%r9,4),%r10d\ntest   %r10d,%r10d\njle    11e0 <func0+0xd0>\nmov    (%r8,%r9,8),%rbx\nxor    %esi,%esi\njmp    1213 <func0+0x103>\nnopl   0x0(%rax)\nmovslq %r11d,%rcx\nadd    $0x1,%r11d\nmovb   $0x20,(%rcx,%rax,1)\nadd    $0x1,%esi\ncmp    %r10d,%esi\nje     11e0 <func0+0xd0>\nmov    (%rbx),%dl\ntest   %dl,%dl\nje     1200 <func0+0xf0>\nmovslq %r11d,%rdi\nxor    %ebp,%ebp\nxchg   %ax,%ax\nlea    (%rdi,%rbp,1),%rcx\nmov    %dl,(%rax,%rcx,1)\nmovzbl 0x1(%rbx,%rbp,1),%edx\nadd    $0x1,%rbp\ntest   %dl,%dl\njne    1220 <func0+0x110>\nadd    %ebp,%r11d\njmp    1200 <func0+0xf0>\ntest   %r11d,%r11d\njle    1249 <func0+0x139>\nadd    $0xffffffff,%r11d\nmovb   $0x0,(%r11,%rax,1)\njmp    1250 <func0+0x140>\nmovb   $0x0,0x2df0(%rip)\nlea    0x2de9(%rip),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 19,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\nxorps  %xmm0,%xmm0\nmovaps %xmm0,-0x18(%rsp)\nmovaps %xmm0,-0x28(%rsp)\nmovq   $0x0,-0x8(%rsp)\ncmpb   $0x0,(%rdi)\nje     12a7 <func0+0x1a7>\nmov    $0x6f72657a,%eax\nmov    $0x65726874,%ecx\nmov    $0x72756f66,%edx\nmov    $0x65766966,%r11d\nmov    $0x65766573,%r8d\nmov    $0x68676965,%r9d\nmov    $0x656e696e,%r10d\nnopl   0x0(%rax,%rax,1)\nxor    %esi,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovzbl (%rdi,%rsi,1),%ebx\ntest   $0xdf,%bl\nje     1180 <func0+0x80>\nmov    %bl,-0x2e(%rsp,%rsi,1)\nadd    $0x1,%rsi\njmp    1160 <func0+0x60>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %esi,%ebx\nmovb   $0x0,-0x2e(%rsp,%rbx,1)\nmov    -0x2e(%rsp),%ebx\nxor    %eax,%ebx\nmovzbl -0x2a(%rsp),%ebp\nor     %ebx,%ebp\nje     1240 <func0+0x140>\ncmpl   $0x656e6f,-0x2e(%rsp)\nje     1250 <func0+0x150>\ncmpl   $0x6f7774,-0x2e(%rsp)\nje     1257 <func0+0x157>\nmov    -0x2e(%rsp),%ebx\nxor    %ecx,%ebx\nmovzwl -0x2a(%rsp),%ebp\nxor    $0x65,%ebp\nor     %ebx,%ebp\nje     125e <func0+0x15e>\nmov    -0x2e(%rsp),%ebx\nxor    %edx,%ebx\nmovzbl -0x2a(%rsp),%ebp\nor     %ebx,%ebp\nje     1265 <func0+0x165>\nmov    -0x2e(%rsp),%ebx\nxor    %r11d,%ebx\nmovzbl -0x2a(%rsp),%ebp\nor     %ebx,%ebp\nje     126c <func0+0x16c>\ncmpl   $0x786973,-0x2e(%rsp)\nje     1273 <func0+0x173>\nmov    -0x2e(%rsp),%ebx\nxor    %r8d,%ebx\nmovzwl -0x2a(%rsp),%ebp\nxor    $0x6e,%ebp\nor     %ebx,%ebp\nje     127a <func0+0x17a>\nmov    -0x2e(%rsp),%ebx\nxor    %r9d,%ebx\nmovzwl -0x2a(%rsp),%ebp\nxor    $0x74,%ebp\nor     %ebx,%ebp\nje     1281 <func0+0x181>\nmov    -0x2e(%rsp),%ebx\nxor    %r10d,%ebx\nmovzbl -0x2a(%rsp),%ebp\nor     %ebx,%ebp\njne    1295 <func0+0x195>\nmov    $0x9,%ebx\njmp    1290 <func0+0x190>\nnopw   0x0(%rax,%rax,1)\nxor    %ebx,%ebx\njmp    1290 <func0+0x190>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    $0x1,%ebx\njmp    1290 <func0+0x190>\nmov    $0x2,%ebx\njmp    1290 <func0+0x190>\nmov    $0x3,%ebx\njmp    1290 <func0+0x190>\nmov    $0x4,%ebx\njmp    1290 <func0+0x190>\nmov    $0x5,%ebx\njmp    1290 <func0+0x190>\nmov    $0x6,%ebx\njmp    1290 <func0+0x190>\nmov    $0x7,%ebx\njmp    1290 <func0+0x190>\nmov    $0x8,%ebx\ncs nopw 0x0(%rax,%rax,1)\naddl   $0x1,-0x28(%rsp,%rbx,4)\nadd    $0x1,%esi\ncmpb   $0x0,-0x1(%rdi,%rsi,1)\nlea    (%rdi,%rsi,1),%rdi\njne    1150 <func0+0x50>\nxor    %r9d,%r9d\nlea    0x2b4f(%rip),%r8\nlea    0x2d78(%rip),%rax\nxor    %r11d,%r11d\njmp    12ca <func0+0x1ca>\nnopl   (%rax)\nadd    $0x1,%r9\ncmp    $0xa,%r9\nje     1319 <func0+0x219>\nmov    -0x28(%rsp,%r9,4),%r10d\ntest   %r10d,%r10d\njle    12c0 <func0+0x1c0>\nmov    (%r8,%r9,8),%rsi\nxor    %edx,%edx\njmp    12f3 <func0+0x1f3>\nnopl   0x0(%rax)\nmovslq %r11d,%rcx\nadd    $0x1,%r11d\nmovb   $0x20,(%rcx,%rax,1)\nadd    $0x1,%edx\ncmp    %r10d,%edx\nje     12c0 <func0+0x1c0>\nmov    (%rsi),%bl\ntest   %bl,%bl\nje     12e0 <func0+0x1e0>\nmovslq %r11d,%rcx\nxor    %edi,%edi\nxchg   %ax,%ax\nlea    (%rcx,%rdi,1),%rbp\nmov    %bl,(%rax,%rbp,1)\nmovzbl 0x1(%rsi,%rdi,1),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    1300 <func0+0x200>\nadd    %edi,%r11d\njmp    12e0 <func0+0x1e0>\ntest   %r11d,%r11d\njle    1329 <func0+0x229>\nadd    $0xffffffff,%r11d\nmovb   $0x0,(%r11,%rax,1)\njmp    1330 <func0+0x230>\nmovb   $0x0,0x2d00(%rip)\nlea    0x2cf9(%rip),%rax\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 19,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\nxorps  %xmm0,%xmm0\nmovaps %xmm0,-0x18(%rsp)\nmovaps %xmm0,-0x28(%rsp)\nmovq   $0x0,-0x8(%rsp)\ncmpb   $0x0,(%rdi)\nje     12f5 <func0+0x1f5>\nmov    $0x6f72657a,%eax\nmov    $0x65726874,%ecx\nmov    $0x72756f66,%edx\nmov    $0x65766966,%r11d\nmov    $0x65766573,%r8d\nmov    $0x68676965,%r9d\nmov    $0x656e696e,%r10d\nnopl   0x0(%rax,%rax,1)\nxor    %esi,%esi\nmov    (%rdi,%rsi,1),%bl\ntest   $0xdf,%bl\nje     1171 <func0+0x71>\nnopw   0x0(%rax,%rax,1)\nmov    %bl,-0x2e(%rsp,%rsi,1)\nadd    $0x1,%rsi\nmovzbl (%rdi,%rsi,1),%ebx\ntest   $0xdf,%bl\njne    1160 <func0+0x60>\nmov    %esi,%ebx\nmovb   $0x0,-0x2e(%rsp,%rbx,1)\nmov    -0x2e(%rsp),%ebx\nxor    %eax,%ebx\nmovzbl -0x2a(%rsp),%ebp\nor     %ebx,%ebp\nje     1250 <func0+0x150>\ncmpl   $0x656e6f,-0x2e(%rsp)\nje     1260 <func0+0x160>\ncmpl   $0x6f7774,-0x2e(%rsp)\nje     1267 <func0+0x167>\nmov    -0x2e(%rsp),%ebx\nxor    %ecx,%ebx\nmovzwl -0x2a(%rsp),%ebp\nxor    $0x65,%ebp\nor     %ebx,%ebp\nje     126e <func0+0x16e>\nmov    -0x2e(%rsp),%ebx\nxor    %edx,%ebx\nmovzbl -0x2a(%rsp),%ebp\nor     %ebx,%ebp\nje     1275 <func0+0x175>\nmov    -0x2e(%rsp),%ebx\nxor    %r11d,%ebx\nmovzbl -0x2a(%rsp),%ebp\nor     %ebx,%ebp\nje     127c <func0+0x17c>\ncmpl   $0x786973,-0x2e(%rsp)\nje     1283 <func0+0x183>\nmov    -0x2e(%rsp),%ebx\nxor    %r8d,%ebx\nmovzwl -0x2a(%rsp),%ebp\nxor    $0x6e,%ebp\nor     %ebx,%ebp\nje     128a <func0+0x18a>\nmov    -0x2e(%rsp),%ebx\nxor    %r9d,%ebx\nmovzwl -0x2a(%rsp),%ebp\nxor    $0x74,%ebp\nor     %ebx,%ebp\nje     1291 <func0+0x191>\nmov    -0x2e(%rsp),%ebx\nxor    %r10d,%ebx\nmovzbl -0x2a(%rsp),%ebp\nor     %ebx,%ebp\nje     1298 <func0+0x198>\nnopl   0x0(%rax)\nadd    $0x1,%esi\ncmpb   $0x0,-0x1(%rdi,%rsi,1)\nlea    (%rdi,%rsi,1),%rdi\njne    1150 <func0+0x50>\njmp    12b7 <func0+0x1b7>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nxor    %ebx,%ebx\njmp    12a0 <func0+0x1a0>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    $0x1,%ebx\njmp    12a0 <func0+0x1a0>\nmov    $0x2,%ebx\njmp    12a0 <func0+0x1a0>\nmov    $0x3,%ebx\njmp    12a0 <func0+0x1a0>\nmov    $0x4,%ebx\njmp    12a0 <func0+0x1a0>\nmov    $0x5,%ebx\njmp    12a0 <func0+0x1a0>\nmov    $0x6,%ebx\njmp    12a0 <func0+0x1a0>\nmov    $0x7,%ebx\njmp    12a0 <func0+0x1a0>\nmov    $0x8,%ebx\njmp    12a0 <func0+0x1a0>\nmov    $0x9,%ebx\nnopl   (%rax)\naddl   $0x1,-0x28(%rsp,%rbx,4)\nadd    $0x1,%esi\ncmpb   $0x0,-0x1(%rdi,%rsi,1)\nlea    (%rdi,%rsi,1),%rdi\njne    1150 <func0+0x50>\nmov    -0x28(%rsp),%ecx\nxor    %eax,%eax\ntest   %ecx,%ecx\njle    12eb <func0+0x1eb>\nlea    0x2d68(%rip),%rdx\nnopl   0x0(%rax,%rax,1)\ncltq\nmovl   $0x6f72657a,(%rax,%rdx,1)\nlea    0x4(%rax),%esi\nadd    $0x5,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    12d0 <func0+0x1d0>\nmov    -0x24(%rsp),%ecx\ntest   %ecx,%ecx\njg     12ff <func0+0x1ff>\njmp    132f <func0+0x22f>\nxor    %eax,%eax\nmov    -0x24(%rsp),%ecx\ntest   %ecx,%ecx\njle    132f <func0+0x22f>\nlea    0x2d2a(%rip),%rdx\ncs nopw 0x0(%rax,%rax,1)\ncltq\nmovw   $0x6e6f,(%rax,%rdx,1)\nmovb   $0x65,0x2(%rax,%rdx,1)\nlea    0x3(%rax),%esi\nadd    $0x4,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    1310 <func0+0x210>\nmov    -0x20(%rsp),%ecx\ntest   %ecx,%ecx\njle    135f <func0+0x25f>\nlea    0x2cf2(%rip),%rdx\nxchg   %ax,%ax\ncltq\nmovw   $0x7774,(%rax,%rdx,1)\nmovb   $0x6f,0x2(%rax,%rdx,1)\nlea    0x3(%rax),%esi\nadd    $0x4,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    1340 <func0+0x240>\nmov    -0x1c(%rsp),%ecx\ntest   %ecx,%ecx\njle    1390 <func0+0x290>\nlea    0x2cc2(%rip),%rdx\nxchg   %ax,%ax\ncltq\nmovl   $0x65726874,(%rax,%rdx,1)\nmovb   $0x65,0x4(%rax,%rdx,1)\nlea    0x5(%rax),%esi\nadd    $0x6,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    1370 <func0+0x270>\nmov    -0x18(%rsp),%ecx\ntest   %ecx,%ecx\njle    13bb <func0+0x2bb>\nlea    0x2c91(%rip),%rdx\nnop\ncltq\nmovl   $0x72756f66,(%rax,%rdx,1)\nlea    0x4(%rax),%esi\nadd    $0x5,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    13a0 <func0+0x2a0>\nmov    -0x14(%rsp),%ecx\ntest   %ecx,%ecx\njle    13eb <func0+0x2eb>\nlea    0x2c66(%rip),%rdx\nnopw   0x0(%rax,%rax,1)\ncltq\nmovl   $0x65766966,(%rax,%rdx,1)\nlea    0x4(%rax),%esi\nadd    $0x5,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    13d0 <func0+0x2d0>\nmov    -0x10(%rsp),%ecx\ntest   %ecx,%ecx\njle    141f <func0+0x31f>\nlea    0x2c36(%rip),%rdx\nnopw   0x0(%rax,%rax,1)\ncltq\nmovw   $0x6973,(%rax,%rdx,1)\nmovb   $0x78,0x2(%rax,%rdx,1)\nlea    0x3(%rax),%esi\nadd    $0x4,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    1400 <func0+0x300>\nmov    -0xc(%rsp),%ecx\ntest   %ecx,%ecx\njle    1450 <func0+0x350>\nlea    0x2c02(%rip),%rdx\nxchg   %ax,%ax\ncltq\nmovl   $0x65766573,(%rax,%rdx,1)\nmovb   $0x6e,0x4(%rax,%rdx,1)\nlea    0x5(%rax),%esi\nadd    $0x6,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    1430 <func0+0x330>\nmov    -0x8(%rsp),%ecx\ntest   %ecx,%ecx\njle    1480 <func0+0x380>\nlea    0x2bd1(%rip),%rdx\nnop\ncltq\nmovl   $0x68676965,(%rax,%rdx,1)\nmovb   $0x74,0x4(%rax,%rdx,1)\nlea    0x5(%rax),%esi\nadd    $0x6,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    1460 <func0+0x360>\nmov    -0x4(%rsp),%ecx\ntest   %ecx,%ecx\njle    14ab <func0+0x3ab>\nlea    0x2ba1(%rip),%rdx\nnop\ncltq\nmovl   $0x656e696e,(%rax,%rdx,1)\nlea    0x4(%rax),%esi\nadd    $0x5,%eax\nmovslq %esi,%rsi\nmovb   $0x20,(%rsi,%rdx,1)\nadd    $0xffffffff,%ecx\njne    1490 <func0+0x390>\ntest   %eax,%eax\njle    14c7 <func0+0x3c7>\nadd    $0xffffffff,%eax\nlea    0x2b77(%rip),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nlea    0x2b6c(%rip),%rax\npop    %rbx\npop    %rbp\nret\nmovb   $0x0,0x2b62(%rip)\nlea    0x2b5b(%rip),%rax\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 20,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovss  0xee9(%rip),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1206 <func0+0x106>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11f3 <func0+0xf3>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nsubss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovaps 0xe85(%rip),%xmm1\npand   %xmm1,%xmm0\ncvtsd2ss %xmm0,%xmm0\nmovss  %xmm0,-0x28(%rbp)\nmovss  -0x28(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\nucomiss %xmm1,%xmm0\njbe    11e0 <func0+0xe0>\nmovss  -0x28(%rbp),%xmm0\nmovss  %xmm0,-0x1c(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\njmp    11e5 <func0+0xe5>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    115a <func0+0x5a>\njmp    11f8 <func0+0xf8>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1145 <func0+0x45>\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nucomiss 0x4(%rax),%xmm0\njbe    1248 <func0+0x148>\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x2c(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,(%rax)\nmovss  -0x2c(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovss  %xmm0,0x4(%rax)\npop    %rbp\nret\n"
    },
    {
        "task_id": 20,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmovss  (%rdi),%xmm0\nmovss  %xmm0,(%rdx)\nmovss  0x4(%rdi),%xmm0\nmovss  %xmm0,0x4(%rdx)\ntest   %esi,%esi\njle    1191 <func0+0x91>\nmovslq %esi,%r8\nmov    %esi,%r9d\nmovss  0xedc(%rip),%xmm1\nxor    %r10d,%r10d\nmovaps 0xee2(%rip),%xmm0\nmov    %r9,%r11\nmov    %rdi,%rcx\njmp    114d <func0+0x4d>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x4,%rcx\nadd    $0xffffffffffffffff,%r11\ncmp    %r9,%r10\nje     1191 <func0+0x91>\nmov    %r10,%rax\nadd    $0x1,%r10\ncmp    %r8,%r10\njge    1140 <func0+0x40>\nmov    $0x1,%esi\njmp    1169 <func0+0x69>\nadd    $0x1,%rsi\ncmp    %rsi,%r11\nje     1140 <func0+0x40>\nmovss  (%rdi,%rax,4),%xmm3\nmovaps %xmm3,%xmm2\nsubss  (%rcx,%rsi,4),%xmm2\nandps  %xmm0,%xmm2\nucomiss %xmm2,%xmm1\njbe    1160 <func0+0x60>\nmovss  %xmm3,(%rdx)\nmovss  (%rcx,%rsi,4),%xmm1\nmovss  %xmm1,0x4(%rdx)\nmovaps %xmm2,%xmm1\njmp    1160 <func0+0x60>\nmovss  (%rdx),%xmm0\nmovss  0x4(%rdx),%xmm1\nucomiss %xmm1,%xmm0\njbe    11a8 <func0+0xa8>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,0x4(%rdx)\nret\n"
    },
    {
        "task_id": 20,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmovss  (%rdi),%xmm1\nmovss  %xmm1,(%rdx)\nmovss  0x4(%rdi),%xmm0\nmovss  %xmm0,0x4(%rdx)\ntest   %esi,%esi\njle    1194 <func0+0x94>\nmov    %esi,%r8d\nmovss  0xedf(%rip),%xmm3\nxor    %r9d,%r9d\nmovaps 0xee5(%rip),%xmm2\nmov    %r8,%r10\nmov    %rdi,%rsi\njmp    114d <func0+0x4d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x4,%rsi\nadd    $0xffffffffffffffff,%r10\ncmp    %r8,%r9\nje     1194 <func0+0x94>\nmov    %r9,%rax\nadd    $0x1,%r9\ncmp    %r8,%r9\njae    1140 <func0+0x40>\nmov    $0x1,%ecx\njmp    1169 <func0+0x69>\nadd    $0x1,%rcx\ncmp    %rcx,%r10\nje     1140 <func0+0x40>\nmovss  (%rdi,%rax,4),%xmm4\nmovaps %xmm4,%xmm5\nsubss  (%rsi,%rcx,4),%xmm5\nandps  %xmm2,%xmm5\nucomiss %xmm5,%xmm3\njbe    1160 <func0+0x60>\nmovss  %xmm4,(%rdx)\nmovss  (%rsi,%rcx,4),%xmm0\nmovss  %xmm0,0x4(%rdx)\nmovaps %xmm4,%xmm1\nmovaps %xmm5,%xmm3\njmp    1160 <func0+0x60>\nucomiss %xmm0,%xmm1\njbe    11a2 <func0+0xa2>\nmovss  %xmm0,(%rdx)\nmovss  %xmm1,0x4(%rdx)\nret\n"
    },
    {
        "task_id": 20,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmovss  (%rdi),%xmm1\nmovss  %xmm1,(%rdx)\nmovss  0x4(%rdi),%xmm0\nmovss  %xmm0,0x4(%rdx)\ntest   %esi,%esi\njle    1194 <func0+0x94>\nmov    %esi,%r8d\nmovss  0xedf(%rip),%xmm3\nxor    %r9d,%r9d\nmovaps 0xee5(%rip),%xmm2\nmov    %r8,%r10\nmov    %rdi,%rsi\njmp    114d <func0+0x4d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x4,%rsi\nadd    $0xffffffffffffffff,%r10\ncmp    %r8,%r9\nje     1194 <func0+0x94>\nmov    %r9,%rax\nadd    $0x1,%r9\ncmp    %r8,%r9\njae    1140 <func0+0x40>\nmov    $0x1,%ecx\njmp    1169 <func0+0x69>\nadd    $0x1,%rcx\ncmp    %rcx,%r10\nje     1140 <func0+0x40>\nmovss  (%rdi,%rax,4),%xmm4\nmovaps %xmm4,%xmm5\nsubss  (%rsi,%rcx,4),%xmm5\nandps  %xmm2,%xmm5\nucomiss %xmm5,%xmm3\njbe    1160 <func0+0x60>\nmovss  %xmm4,(%rdx)\nmovss  (%rsi,%rcx,4),%xmm0\nmovss  %xmm0,0x4(%rdx)\nmovaps %xmm4,%xmm1\nmovaps %xmm5,%xmm3\njmp    1160 <func0+0x60>\nucomiss %xmm0,%xmm1\njbe    11a2 <func0+0xa2>\nmovss  %xmm0,(%rdx)\nmovss  %xmm1,0x4(%rdx)\nret\n"
    },
    {
        "task_id": 21,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11a1 <func0+0xa1>\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm1\nmovss  -0x10(%rbp),%xmm0\nucomiss %xmm1,%xmm0\njbe    1165 <func0+0x65>\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nucomiss -0x14(%rbp),%xmm0\njbe    118e <func0+0x8e>\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmovss  %xmm0,-0x14(%rbp)\njmp    1193 <func0+0x93>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    112c <func0+0x2c>\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11ef <func0+0xef>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nsubss  -0x10(%rbp),%xmm0\nmovss  -0x14(%rbp),%xmm1\nsubss  -0x10(%rbp),%xmm1\ndivss  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  %xmm0,(%rax,%rcx,4)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    11a8 <func0+0xa8>\npop    %rbp\nret\n"
    },
    {
        "task_id": 21,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmovss  (%rdi),%xmm2\nmov    %esi,%eax\ncmp    $0x2,%esi\njl     1145 <func0+0x45>\nmov    $0x1,%ecx\nmovaps %xmm2,%xmm3\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovss  (%rdi,%rcx,4),%xmm1\nmovaps %xmm1,%xmm0\nminss  %xmm3,%xmm0\nmaxss  %xmm2,%xmm1\nadd    $0x1,%rcx\nmovaps %xmm1,%xmm2\nmovaps %xmm0,%xmm3\ncmp    %rcx,%rax\njne    1120 <func0+0x20>\ntest   %esi,%esi\njg     114f <func0+0x4f>\njmp    117b <func0+0x7b>\nmovaps %xmm2,%xmm0\nmovaps %xmm2,%xmm1\ntest   %esi,%esi\njle    117b <func0+0x7b>\nsubss  %xmm0,%xmm1\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovss  (%rdi,%rcx,4),%xmm2\nsubss  %xmm0,%xmm2\ndivss  %xmm1,%xmm2\nmovss  %xmm2,(%rdi,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1160 <func0+0x60>\nret\n"
    },
    {
        "task_id": 21,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmovss  (%rdi),%xmm2\nmov    %esi,%r8d\nmovaps %xmm2,%xmm0\nmovaps %xmm2,%xmm1\ncmp    $0x2,%esi\njl     11df <func0+0xdf>\nlea    -0x1(%r8),%rcx\nlea    -0x2(%r8),%rdx\nmov    %ecx,%eax\nand    $0x3,%eax\ncmp    $0x3,%rdx\njae    1136 <func0+0x36>\nmov    $0x1,%edx\nmovaps %xmm2,%xmm3\nmovaps %xmm2,%xmm4\njmp    11a1 <func0+0xa1>\nand    $0xfffffffffffffffc,%rcx\nxor    %edx,%edx\nmovaps %xmm2,%xmm3\nmovaps %xmm2,%xmm4\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovss  0x4(%rdi,%rdx,4),%xmm0\nmovss  0x8(%rdi,%rdx,4),%xmm1\nmovaps %xmm0,%xmm5\nminss  %xmm4,%xmm5\nmaxss  %xmm3,%xmm0\nmovaps %xmm1,%xmm3\nminss  %xmm5,%xmm3\nmaxss  %xmm0,%xmm1\nmovss  0xc(%rdi,%rdx,4),%xmm0\nmovaps %xmm0,%xmm5\nminss  %xmm3,%xmm5\nmaxss  %xmm1,%xmm0\nmovss  0x10(%rdi,%rdx,4),%xmm3\nmovaps %xmm3,%xmm4\nminss  %xmm5,%xmm4\nmaxss  %xmm0,%xmm3\nadd    $0x4,%rdx\ncmp    %rdx,%rcx\njne    1150 <func0+0x50>\nadd    $0x1,%rdx\nmovaps %xmm4,%xmm0\nmovaps %xmm3,%xmm1\ntest   %rax,%rax\nje     11df <func0+0xdf>\nlea    (%rdi,%rdx,4),%rcx\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovss  (%rcx,%rdx,4),%xmm1\nmovaps %xmm1,%xmm0\nminss  %xmm4,%xmm0\nmaxss  %xmm3,%xmm1\nadd    $0x1,%rdx\nmovaps %xmm1,%xmm3\nmovaps %xmm0,%xmm4\ncmp    %rdx,%rax\njne    11c0 <func0+0xc0>\ntest   %esi,%esi\njle    12bb <func0+0x1bb>\nsubss  %xmm0,%xmm1\nsubss  %xmm0,%xmm2\ndivss  %xmm1,%xmm2\nmovss  %xmm2,(%rdi)\ncmp    $0x1,%esi\nje     12bb <func0+0x1bb>\nlea    -0x1(%r8),%r9\nmov    $0x1,%ecx\ncmp    $0x4,%r9\njb     12a0 <func0+0x1a0>\nmov    %r9,%rcx\nand    $0xfffffffffffffffc,%rcx\nmovaps %xmm0,%xmm2\nshufps $0x0,%xmm0,%xmm2\nmovaps %xmm1,%xmm3\nshufps $0x0,%xmm1,%xmm3\nlea    -0x4(%rcx),%rax\nmov    %rax,%rdx\nshr    $0x2,%rdx\nadd    $0x1,%rdx\ntest   %rax,%rax\nje     12bc <func0+0x1bc>\nmov    %rdx,%rax\nand    $0xfffffffffffffffe,%rax\nmov    $0x1,%esi\nnopl   0x0(%rax)\nmovups (%rdi,%rsi,4),%xmm4\nmovups 0x10(%rdi,%rsi,4),%xmm5\nsubps  %xmm2,%xmm4\ndivps  %xmm3,%xmm4\nmovups %xmm4,(%rdi,%rsi,4)\nsubps  %xmm2,%xmm5\ndivps  %xmm3,%xmm5\nmovups %xmm5,0x10(%rdi,%rsi,4)\nadd    $0x8,%rsi\nadd    $0xfffffffffffffffe,%rax\njne    1250 <func0+0x150>\ntest   $0x1,%dl\nje     128b <func0+0x18b>\nmovups (%rdi,%rsi,4),%xmm4\nsubps  %xmm2,%xmm4\ndivps  %xmm3,%xmm4\nmovups %xmm4,(%rdi,%rsi,4)\ncmp    %rcx,%r9\nje     12bb <func0+0x1bb>\nor     $0x1,%rcx\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovss  (%rdi,%rcx,4),%xmm2\nsubss  %xmm0,%xmm2\ndivss  %xmm1,%xmm2\nmovss  %xmm2,(%rdi,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%r8\njne    12a0 <func0+0x1a0>\nret\nmov    $0x1,%esi\ntest   $0x1,%dl\njne    127d <func0+0x17d>\njmp    128b <func0+0x18b>\n"
    },
    {
        "task_id": 21,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmovss  (%rdi),%xmm2\nmov    %esi,%r8d\nmovaps %xmm2,%xmm0\nmovaps %xmm2,%xmm1\ncmp    $0x2,%esi\njl     11df <func0+0xdf>\nlea    -0x1(%r8),%rcx\nlea    -0x2(%r8),%rdx\nmov    %ecx,%eax\nand    $0x3,%eax\ncmp    $0x3,%rdx\njae    1144 <func0+0x44>\nmov    $0x1,%edx\nmovaps %xmm2,%xmm3\nmovaps %xmm2,%xmm4\nmovaps %xmm4,%xmm0\nmovaps %xmm3,%xmm1\ntest   %rax,%rax\njne    11ac <func0+0xac>\njmp    11df <func0+0xdf>\nand    $0xfffffffffffffffc,%rcx\nxor    %edx,%edx\nmovaps %xmm2,%xmm3\nmovaps %xmm2,%xmm4\nmovss  0x4(%rdi,%rdx,4),%xmm0\nmovss  0x8(%rdi,%rdx,4),%xmm1\nmovaps %xmm0,%xmm5\nminss  %xmm4,%xmm5\nmaxss  %xmm3,%xmm0\nmovaps %xmm1,%xmm3\nminss  %xmm5,%xmm3\nmaxss  %xmm0,%xmm1\nmovss  0xc(%rdi,%rdx,4),%xmm0\nmovaps %xmm0,%xmm5\nminss  %xmm3,%xmm5\nmaxss  %xmm1,%xmm0\nmovss  0x10(%rdi,%rdx,4),%xmm3\nmovaps %xmm3,%xmm4\nminss  %xmm5,%xmm4\nmaxss  %xmm0,%xmm3\nadd    $0x4,%rdx\ncmp    %rdx,%rcx\njne    1150 <func0+0x50>\nadd    $0x1,%rdx\nmovaps %xmm4,%xmm0\nmovaps %xmm3,%xmm1\ntest   %rax,%rax\nje     11df <func0+0xdf>\nlea    (%rdi,%rdx,4),%rcx\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovss  (%rcx,%rdx,4),%xmm1\nmovaps %xmm1,%xmm0\nminss  %xmm4,%xmm0\nmaxss  %xmm3,%xmm1\nadd    $0x1,%rdx\nmovaps %xmm1,%xmm3\nmovaps %xmm0,%xmm4\ncmp    %rdx,%rax\njne    11c0 <func0+0xc0>\ntest   %esi,%esi\njle    12bb <func0+0x1bb>\nsubss  %xmm0,%xmm1\nsubss  %xmm0,%xmm2\ndivss  %xmm1,%xmm2\nmovss  %xmm2,(%rdi)\ncmp    $0x1,%esi\nje     12bb <func0+0x1bb>\nlea    -0x1(%r8),%r9\nmov    $0x1,%ecx\ncmp    $0x4,%r9\njb     12a0 <func0+0x1a0>\nmov    %r9,%rcx\nand    $0xfffffffffffffffc,%rcx\nmovaps %xmm0,%xmm2\nshufps $0x0,%xmm0,%xmm2\nmovaps %xmm1,%xmm3\nshufps $0x0,%xmm1,%xmm3\nlea    -0x4(%rcx),%rax\nmov    %rax,%rdx\nshr    $0x2,%rdx\nadd    $0x1,%rdx\ntest   %rax,%rax\nje     12bc <func0+0x1bc>\nmov    %rdx,%rax\nand    $0xfffffffffffffffe,%rax\nmov    $0x1,%esi\nnopl   0x0(%rax)\nmovups (%rdi,%rsi,4),%xmm4\nmovups 0x10(%rdi,%rsi,4),%xmm5\nsubps  %xmm2,%xmm4\ndivps  %xmm3,%xmm4\nmovups %xmm4,(%rdi,%rsi,4)\nsubps  %xmm2,%xmm5\ndivps  %xmm3,%xmm5\nmovups %xmm5,0x10(%rdi,%rsi,4)\nadd    $0x8,%rsi\nadd    $0xfffffffffffffffe,%rax\njne    1250 <func0+0x150>\ntest   $0x1,%dl\nje     128b <func0+0x18b>\nmovups (%rdi,%rsi,4),%xmm4\nsubps  %xmm2,%xmm4\ndivps  %xmm3,%xmm4\nmovups %xmm4,(%rdi,%rsi,4)\ncmp    %rcx,%r9\nje     12bb <func0+0x1bb>\nor     $0x1,%rcx\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovss  (%rdi,%rcx,4),%xmm2\nsubss  %xmm0,%xmm2\ndivss  %xmm1,%xmm2\nmovss  %xmm2,(%rdi,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%r8\njne    12a0 <func0+0x1a0>\nret\nmov    $0x1,%esi\ntest   $0x1,%dl\njne    127d <func0+0x17d>\njmp    128b <func0+0x18b>\n"
    },
    {
        "task_id": 22,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmpb   $0x0,(%rax)\nje     1293 <func0+0x173>\njmp    1151 <func0+0x31>\nmov    -0x20(%rbp),%rax\nmovsbl (%rax),%ecx\nxor    %eax,%eax\ncmp    $0x0,%ecx\nmov    %al,-0x2d(%rbp)\nje     11a0 <func0+0x80>\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x20(%rbp),%rcx\nmovsbl (%rcx),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%ecx\nand    $0x800,%ecx\nxor    %eax,%eax\ncmp    $0x0,%ecx\nmov    %al,-0x2d(%rbp)\njne    11a0 <func0+0x80>\nmov    -0x20(%rbp),%rax\nmovsbl (%rax),%eax\ncmp    $0x2d,%eax\nsetne  %al\nmov    %al,-0x2d(%rbp)\nmov    -0x2d(%rbp),%al\ntest   $0x1,%al\njne    11b0 <func0+0x90>\njmp    11c1 <func0+0xa1>\nmov    -0x20(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x20(%rbp)\njmp    1151 <func0+0x31>\nmov    -0x20(%rbp),%rax\ncmpb   $0x0,(%rax)\njne    11d3 <func0+0xb3>\njmp    1293 <func0+0x173>\nmov    -0x20(%rbp),%rdi\nlea    -0x28(%rbp),%rsi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %eax,-0x2c(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x28(%rbp),%rax\nje     1236 <func0+0x116>\nmov    -0x28(%rbp),%rax\nmovsbl (%rax),%eax\ncmp    $0x2c,%eax\nje     1216 <func0+0xf6>\nmov    -0x28(%rbp),%rax\nmovsbl (%rax),%eax\ncmp    $0x0,%eax\njne    1236 <func0+0x116>\nmov    -0x2c(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nadd    $0x1,%ecx\nmov    %ecx,-0x14(%rbp)\nmovslq %eax,%rcx\nlea    0x2e12(%rip),%rax\nmov    %edx,(%rax,%rcx,4)\njmp    1286 <func0+0x166>\njmp    123b <func0+0x11b>\nmov    -0x28(%rbp),%rax\nmovsbl (%rax),%ecx\nxor    %eax,%eax\ncmp    $0x0,%ecx\nmov    %al,-0x2e(%rbp)\nje     1260 <func0+0x140>\nmov    -0x28(%rbp),%rax\nmovsbl (%rax),%eax\ncmp    $0x2c,%eax\nsetne  %al\nmov    %al,-0x2e(%rbp)\nmov    -0x2e(%rbp),%al\ntest   $0x1,%al\njne    1270 <func0+0x150>\njmp    1281 <func0+0x161>\nmov    -0x28(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x28(%rbp)\njmp    123b <func0+0x11b>\njmp    1286 <func0+0x166>\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x20(%rbp)\njmp    113f <func0+0x1f>\nmov    -0x14(%rbp),%ecx\nmov    -0x10(%rbp),%rax\nmov    %ecx,(%rax)\nlea    0x2d9d(%rip),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 22,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r15\ncmpb   $0x0,(%rdi)\nje     1223 <func0+0x103>\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nmov    %rsp,%r14\nmovsbq (%rbx),%r12\ntest   %r12,%r12\nsete   %r13b\nje     1225 <func0+0x105>\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\ntestb  $0x8,0x1(%rax,%r12,2)\njne    11a0 <func0+0x80>\ncmp    $0x2d,%r12b\nje     11a0 <func0+0x80>\ncs nopw 0x0(%rax,%rax,1)\nmovsbq 0x1(%rbx),%rcx\ntest   %rcx,%rcx\nsete   %r13b\nje     1225 <func0+0x105>\nadd    $0x1,%rbx\ntestb  $0x8,0x1(%rax,%rcx,2)\njne    11a0 <func0+0x80>\ncmp    $0x2d,%cl\njne    1170 <func0+0x50>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ntest   %r13b,%r13b\njne    1225 <func0+0x105>\nmov    %rbx,%rdi\nmov    %r14,%rsi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    (%rsp),%rcx\ncmp    %rcx,%rbx\nje     11e0 <func0+0xc0>\nmov    (%rcx),%cl\ncmp    $0x2c,%cl\nje     11cd <func0+0xad>\ntest   %cl,%cl\njne    11e0 <func0+0xc0>\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nlea    0x2e66(%rip),%rdx\nmov    %eax,(%rdx,%rcx,4)\njmp    1214 <func0+0xf4>\nnop\nmov    (%rsp),%rax\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovzbl (%rax),%ecx\ntest   %cl,%cl\nje     1210 <func0+0xf0>\ncmp    $0x2c,%cl\nje     1210 <func0+0xf0>\nadd    $0x1,%rax\njmp    11f0 <func0+0xd0>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %rax,(%rsp)\nmov    (%rsp),%rbx\ncmpb   $0x0,(%rbx)\njne    113f <func0+0x1f>\njmp    1225 <func0+0x105>\nxor    %ebp,%ebp\nmov    %ebp,(%r15)\nlea    0x2e11(%rip),%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 22,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    (%rdi),%r15b\ntest   %r15b,%r15b\nje     11f3 <func0+0xd3>\nmov    %rdi,%r13\nxor    %ebp,%ebp\ncall   1040 <__ctype_b_loc@plt>\nmov    %rax,%r12\nmov    (%r12),%rax\nmov    %r13,%rbx\nxchg   %ax,%ax\nmovsbq %r15b,%rcx\ntestb  $0x8,0x1(%rax,%rcx,2)\njne    1180 <func0+0x60>\ncmp    $0x2d,%r15b\nje     1180 <func0+0x60>\nmovzbl 0x1(%rbx),%r15d\nadd    $0x1,%rbx\ntest   %r15b,%r15b\njne    1150 <func0+0x30>\njmp    11f5 <func0+0xd5>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %rbx,%rdi\nmov    %rsp,%rsi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    (%rsp),%r13\ncmp    %r13,%rbx\nje     11d4 <func0+0xb4>\nmov    0x0(%r13),%cl\ncmp    $0x2c,%cl\nje     11a6 <func0+0x86>\ntest   %cl,%cl\njne    11d4 <func0+0xb4>\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nlea    0x2e8d(%rip),%rdx\nmov    %eax,(%rdx,%rcx,4)\nmov    0x0(%r13),%r15b\ntest   %r15b,%r15b\njne    1147 <func0+0x27>\njmp    11f5 <func0+0xd5>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r13\nmovzbl 0x0(%r13),%r15d\ntest   %r15b,%r15b\nje     11e4 <func0+0xc4>\ncmp    $0x2c,%r15b\njne    11d0 <func0+0xb0>\nmov    %r13,(%rsp)\ntest   %r15b,%r15b\njne    1147 <func0+0x27>\njmp    11f5 <func0+0xd5>\nxor    %ebp,%ebp\nmov    %ebp,(%r14)\nlea    0x2e41(%rip),%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 22,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    (%rdi),%r15b\ntest   %r15b,%r15b\nje     11f3 <func0+0xd3>\nmov    %rdi,%r13\nxor    %ebp,%ebp\ncall   1040 <__ctype_b_loc@plt>\nmov    %rax,%r12\nmov    (%r12),%rax\nmov    %r13,%rbx\nxchg   %ax,%ax\nmovsbq %r15b,%rcx\ntestb  $0x8,0x1(%rax,%rcx,2)\njne    1180 <func0+0x60>\ncmp    $0x2d,%r15b\nje     1180 <func0+0x60>\nmovzbl 0x1(%rbx),%r15d\nadd    $0x1,%rbx\ntest   %r15b,%r15b\njne    1150 <func0+0x30>\njmp    11f5 <func0+0xd5>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %rbx,%rdi\nmov    %rsp,%rsi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    (%rsp),%r13\ncmp    %r13,%rbx\nje     11d4 <func0+0xb4>\nmov    0x0(%r13),%cl\ncmp    $0x2c,%cl\nje     11a6 <func0+0x86>\ntest   %cl,%cl\njne    11d4 <func0+0xb4>\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nlea    0x2e8d(%rip),%rdx\nmov    %eax,(%rdx,%rcx,4)\nmov    0x0(%r13),%r15b\ntest   %r15b,%r15b\njne    1147 <func0+0x27>\njmp    11f5 <func0+0xd5>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r13\nmovzbl 0x0(%r13),%r15d\ntest   %r15b,%r15b\nje     11e4 <func0+0xc4>\ncmp    $0x2c,%r15b\njne    11d0 <func0+0xb0>\nmov    %r13,(%rsp)\ntest   %r15b,%r15b\njne    1147 <func0+0x27>\njmp    11f5 <func0+0xd5>\nxor    %ebp,%ebp\nmov    %ebp,(%r14)\nlea    0x2e41(%rip),%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 23,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0xc(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1132 <func0+0x32>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    110f <func0+0xf>\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 23,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x1,%eax\ncmpb   $0x0,(%rdi)\nlea    0x1(%rdi),%rdi\njne    1110 <func0+0x10>\nret\n"
    },
    {
        "task_id": 23,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x1,%eax\ncmpb   $0x0,(%rdi)\nlea    0x1(%rdi),%rdi\njne    1110 <func0+0x10>\nret\n"
    },
    {
        "task_id": 23,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x1,%eax\ncmpb   $0x0,(%rdi)\nlea    0x1(%rdi),%rdi\njne    1110 <func0+0x10>\nret\n"
    },
    {
        "task_id": 24,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x8(%rbp)\nmovl   $0x2,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nimul   -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njg     1150 <func0+0x50>\nmov    -0x8(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\ncmp    $0x0,%edx\njne    113d <func0+0x3d>\nmov    -0x8(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %eax,-0x4(%rbp)\njmp    1157 <func0+0x57>\njmp    1142 <func0+0x42>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    110e <func0+0xe>\nmovl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 24,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%ecx\ncmp    $0x4,%edi\njl     1125 <func0+0x25>\nmov    $0x2,%esi\nnop\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1127 <func0+0x27>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njle    1110 <func0+0x10>\nmov    %ecx,%eax\nret\n"
    },
    {
        "task_id": 24,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%ecx\ncmp    $0x4,%edi\njl     1125 <func0+0x25>\nmov    $0x2,%esi\nnop\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1127 <func0+0x27>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njle    1110 <func0+0x10>\nmov    %ecx,%eax\nret\n"
    },
    {
        "task_id": 24,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%ecx\ncmp    $0x4,%edi\njl     1125 <func0+0x25>\nmov    $0x2,%esi\nnop\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1127 <func0+0x27>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njle    1110 <func0+0x10>\nmov    %ecx,%eax\nret\n"
    },
    {
        "task_id": 25,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    $0x100,%edi\ncall   1030 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x2,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nimul   -0x1c(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     119f <func0+0x8f>\njmp    1153 <func0+0x43>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x1c(%rbp)\ncmp    $0x0,%edx\njne    118c <func0+0x7c>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x1c(%rbp)\nmov    %eax,-0x4(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    -0x10(%rbp),%rsi\nmov    (%rsi),%ecx\nmov    %ecx,%edi\nadd    $0x1,%edi\nmov    %edi,(%rsi)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1153 <func0+0x43>\njmp    1191 <func0+0x81>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    113e <func0+0x2e>\ncmpl   $0x1,-0x4(%rbp)\njle    11c3 <func0+0xb3>\nmov    -0x4(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    -0x10(%rbp),%rsi\nmov    (%rsi),%ecx\nmov    %ecx,%edi\nadd    $0x1,%edi\nmov    %edi,(%rsi)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 25,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %rsi,%rbx\nmov    %edi,%ebp\nmov    $0x100,%edi\ncall   1030 <malloc@plt>\nmov    %rax,%r8\nmovl   $0x0,(%rbx)\ncmp    $0x4,%ebp\njge    114b <func0+0x3b>\ncmp    $0x1,%ebp\njle    1141 <func0+0x31>\nmovslq (%rbx),%rax\nlea    0x1(%rax),%ecx\nmov    %ecx,(%rbx)\nmov    %ebp,(%r8,%rax,4)\nmov    %r8,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nmov    $0x2,%esi\njmp    116c <func0+0x5c>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ebp,%eax\njg     1130 <func0+0x20>\nmov    %ebp,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\njne    1160 <func0+0x50>\nmovslq (%rbx),%rdi\nlea    (%r8,%rdi,4),%rcx\nnopl   0x0(%rax)\nmov    %ebp,%eax\ncltd\nidiv   %esi\nmov    %esi,(%rcx)\nmov    %eax,%ebp\ncltd\nidiv   %esi\nadd    $0x4,%rcx\nadd    $0x1,%edi\ntest   %edx,%edx\nje     1180 <func0+0x70>\nmov    %edi,(%rbx)\njmp    1160 <func0+0x50>\n"
    },
    {
        "task_id": 25,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %rsi,%r14\nmov    %edi,%ebp\nmov    $0x100,%edi\ncall   1030 <malloc@plt>\nmov    %rax,%rcx\nmovl   $0x0,(%r14)\nxor    %esi,%esi\ncmp    $0x4,%ebp\njge    114d <func0+0x3d>\ncmp    $0x1,%ebp\njle    1145 <func0+0x35>\nlea    0x1(%rsi),%eax\nmov    %eax,(%r14)\nmovslq %esi,%rax\nmov    %ebp,(%rcx,%rax,4)\nmov    %rcx,%rax\npop    %rbx\npop    %r14\npop    %rbp\nret\nmov    $0x2,%edi\nxor    %esi,%esi\njmp    116c <func0+0x5c>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%edi\nmov    %edi,%eax\nimul   %edi,%eax\ncmp    %ebp,%eax\njg     1134 <func0+0x24>\nmov    %ebp,%eax\ncltd\nidiv   %edi\ntest   %edx,%edx\njne    1160 <func0+0x50>\nmovslq %esi,%rax\nlea    (%rcx,%rax,4),%rbx\nnopl   0x0(%rax)\nmov    %ebp,%eax\ncltd\nidiv   %edi\nmov    %edi,(%rbx)\nmov    %eax,%ebp\ncltd\nidiv   %edi\nadd    $0x4,%rbx\nadd    $0x1,%esi\ntest   %edx,%edx\nje     1180 <func0+0x70>\nmov    %esi,(%r14)\njmp    1160 <func0+0x50>\n"
    },
    {
        "task_id": 25,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %rsi,%r14\nmov    %edi,%ebp\nmov    $0x100,%edi\ncall   1030 <malloc@plt>\nmov    %rax,%rcx\nmovl   $0x0,(%r14)\nxor    %esi,%esi\ncmp    $0x4,%ebp\njge    114d <func0+0x3d>\ncmp    $0x1,%ebp\njle    1145 <func0+0x35>\nlea    0x1(%rsi),%eax\nmov    %eax,(%r14)\nmovslq %esi,%rax\nmov    %ebp,(%rcx,%rax,4)\nmov    %rcx,%rax\npop    %rbx\npop    %r14\npop    %rbp\nret\nmov    $0x2,%edi\nxor    %esi,%esi\njmp    116c <func0+0x5c>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%edi\nmov    %edi,%eax\nimul   %edi,%eax\ncmp    %ebp,%eax\njg     1134 <func0+0x24>\nmov    %ebp,%eax\ncltd\nidiv   %edi\ntest   %edx,%edx\njne    1160 <func0+0x50>\nmovslq %esi,%rax\nlea    (%rcx,%rax,4),%rbx\nnopl   0x0(%rax)\nmov    %ebp,%eax\ncltd\nidiv   %edi\nmov    %edi,(%rbx)\nmov    %eax,%ebp\ncltd\nidiv   %edi\nadd    $0x4,%rbx\nadd    $0x1,%esi\ntest   %edx,%edx\nje     1180 <func0+0x70>\nmov    %esi,(%r14)\njmp    1160 <func0+0x50>\n"
    },
    {
        "task_id": 26,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovslq -0xc(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmovslq -0xc(%rbp),%rdi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,-0x28(%rbp)\nmovslq -0xc(%rbp),%rdi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    12a9 <func0+0x179>\nmov    -0x8(%rbp),%rax\nmovslq -0x40(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x44(%rbp)\nmovl   $0x0,-0x48(%rbp)\nmovl   $0x0,-0x4c(%rbp)\nmov    -0x4c(%rbp),%eax\ncmp    -0x38(%rbp),%eax\njge    11fb <func0+0xcb>\nmov    -0x30(%rbp),%rax\nmovslq -0x4c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x44(%rbp),%eax\njne    11e8 <func0+0xb8>\nmovl   $0x1,-0x48(%rbp)\njmp    11fb <func0+0xcb>\njmp    11ed <func0+0xbd>\nmov    -0x4c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4c(%rbp)\njmp    11bc <func0+0x8c>\ncmpl   $0x0,-0x48(%rbp)\nje     120a <func0+0xda>\njmp    129b <func0+0x16b>\nmovl   $0x0,-0x50(%rbp)\nmovl   $0x0,-0x54(%rbp)\nmov    -0x54(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njge    1257 <func0+0x127>\nmov    -0x28(%rbp),%rax\nmovslq -0x54(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x44(%rbp),%eax\njne    1244 <func0+0x114>\nmovl   $0x1,-0x50(%rbp)\njmp    1257 <func0+0x127>\njmp    1249 <func0+0x119>\nmov    -0x54(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x54(%rbp)\njmp    1218 <func0+0xe8>\ncmpl   $0x0,-0x50(%rbp)\nje     127e <func0+0x14e>\nmov    -0x44(%rbp),%edx\nmov    -0x30(%rbp),%rax\nmov    -0x38(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x38(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1296 <func0+0x166>\nmov    -0x44(%rbp),%edx\nmov    -0x28(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x34(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    129b <func0+0x16b>\nmov    -0x40(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x40(%rbp)\njmp    1194 <func0+0x64>\nmovl   $0x0,-0x58(%rbp)\nmov    -0x58(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    134c <func0+0x21c>\nmov    -0x8(%rbp),%rax\nmovslq -0x58(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x5c(%rbp)\nmovl   $0x0,-0x60(%rbp)\nmovl   $0x0,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x38(%rbp),%eax\njge    1317 <func0+0x1e7>\nmov    -0x30(%rbp),%rax\nmovslq -0x64(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x5c(%rbp),%eax\njne    1304 <func0+0x1d4>\nmovl   $0x1,-0x60(%rbp)\njmp    1317 <func0+0x1e7>\njmp    1309 <func0+0x1d9>\nmov    -0x64(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x64(%rbp)\njmp    12d8 <func0+0x1a8>\ncmpl   $0x0,-0x60(%rbp)\njne    1339 <func0+0x209>\nmov    -0x5c(%rbp),%edx\nmov    -0x20(%rbp),%rax\nmov    -0x3c(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x3c(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    133e <func0+0x20e>\nmov    -0x58(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x58(%rbp)\njmp    12b0 <func0+0x180>\nmov    -0x3c(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x28(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x30(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x20(%rbp),%rax\nadd    $0x70,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 26,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdx,(%rsp)\nmov    %esi,%ebx\nmov    %rdi,%r12\nmovslq %esi,%r14\nlea    0x0(,%r14,4),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    $0x4,%esi\nmov    %r14,%rdi\ncall   1040 <calloc@plt>\nmov    %rax,%r13\nmov    $0x4,%esi\nmov    %r14,%rdi\ncall   1040 <calloc@plt>\nmov    %ebx,%r10d\nmov    %rax,%rbx\nxor    %r9d,%r9d\nmov    %r10d,%r8d\nmov    $0x0,%edx\ntest   %r14d,%r14d\njle    121a <func0+0xea>\nxor    %esi,%esi\nxor    %edi,%edi\nxor    %edx,%edx\njmp    11b6 <func0+0x86>\ncs nopw 0x0(%rax,%rax,1)\nmov    %edi,%eax\nadd    $0x1,%edi\nmov    %r13,%rcx\ncltq\nmov    %ebp,(%rcx,%rax,4)\nadd    $0x1,%rsi\ncmp    %r8,%rsi\nje     121a <func0+0xea>\nmov    (%r12,%rsi,4),%ebp\ntest   %edx,%edx\njle    11de <func0+0xae>\nmov    %edx,%eax\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ncmp    %ebp,(%rbx,%rcx,4)\nje     11ad <func0+0x7d>\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    11d0 <func0+0xa0>\ntest   %edi,%edi\njle    11a0 <func0+0x70>\nmov    %edi,%eax\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\ncmp    %ebp,0x0(%r13,%rcx,4)\nje     1210 <func0+0xe0>\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    11f0 <func0+0xc0>\njmp    11a0 <func0+0x70>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %edx,%eax\nadd    $0x1,%edx\nmov    %rbx,%rcx\njmp    11a8 <func0+0x78>\ntest   %r10d,%r10d\njle    1260 <func0+0x130>\nmov    %edx,%esi\nxor    %edi,%edi\nxor    %r9d,%r9d\njmp    1244 <func0+0x114>\nnopl   0x0(%rax,%rax,1)\nmovslq %r9d,%rax\nadd    $0x1,%r9d\nmov    %ebp,(%r15,%rax,4)\nadd    $0x1,%rdi\ncmp    %r8,%rdi\nje     1260 <func0+0x130>\nmov    (%r12,%rdi,4),%ebp\ntest   %edx,%edx\njle    1230 <func0+0x100>\nxor    %eax,%eax\nxchg   %ax,%ax\ncmp    %ebp,(%rbx,%rax,4)\nje     123b <func0+0x10b>\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    1250 <func0+0x120>\njmp    1230 <func0+0x100>\nmov    (%rsp),%rax\nmov    %r9d,(%rax)\nmov    %r13,%rdi\ncall   1030 <free@plt>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %r15,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 26,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdx,(%rsp)\nmov    %esi,%ebp\nmov    %rdi,%r12\nmovslq %esi,%r14\nlea    0x0(,%r14,4),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    $0x4,%esi\nmov    %r14,%rdi\ncall   1040 <calloc@plt>\nmov    %rax,%r13\nmov    $0x4,%esi\nmov    %r14,%rdi\ncall   1040 <calloc@plt>\nmov    %rax,%rbx\ntest   %r14d,%r14d\njle    1260 <func0+0x130>\nmov    %ebp,%r8d\nxor    %edx,%edx\nxor    %esi,%esi\nxor    %ecx,%ecx\nmov    (%rsp),%r9\nmov    %ebp,%r10d\njmp    11b7 <func0+0x87>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %esi,%eax\nadd    $0x1,%esi\nmov    %r13,%rbp\ncltq\nmov    %edi,0x0(%rbp,%rax,4)\nadd    $0x1,%rdx\ncmp    %r8,%rdx\nje     121a <func0+0xea>\nmov    (%r12,%rdx,4),%edi\ntest   %ecx,%ecx\njle    11de <func0+0xae>\nmov    %ecx,%ebp\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\ncmp    %edi,(%rbx,%rax,4)\nje     11ae <func0+0x7e>\nadd    $0x1,%rax\ncmp    %rax,%rbp\njne    11d0 <func0+0xa0>\ntest   %esi,%esi\njle    11a0 <func0+0x70>\nmov    %esi,%ebp\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\ncmp    %edi,0x0(%r13,%rax,4)\nje     1210 <func0+0xe0>\nadd    $0x1,%rax\ncmp    %rax,%rbp\njne    11f0 <func0+0xc0>\njmp    11a0 <func0+0x70>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %ecx,%eax\nadd    $0x1,%ecx\nmov    %rbx,%rbp\njmp    11a8 <func0+0x78>\ntest   %r10d,%r10d\njle    1268 <func0+0x138>\nmov    %ecx,%esi\nxor    %edi,%edi\nxor    %edx,%edx\njmp    1243 <func0+0x113>\nnopw   0x0(%rax,%rax,1)\nmovslq %edx,%rax\nadd    $0x1,%edx\nmov    %ebp,(%r15,%rax,4)\nadd    $0x1,%rdi\ncmp    %r8,%rdi\nje     126a <func0+0x13a>\nmov    (%r12,%rdi,4),%ebp\ntest   %ecx,%ecx\njle    1230 <func0+0x100>\nxor    %eax,%eax\nnopl   (%rax)\ncmp    %ebp,(%rbx,%rax,4)\nje     123a <func0+0x10a>\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    1250 <func0+0x120>\njmp    1230 <func0+0x100>\nxor    %edx,%edx\nmov    (%rsp),%r9\njmp    126a <func0+0x13a>\nxor    %edx,%edx\nmov    %edx,(%r9)\nmov    %r13,%rdi\ncall   1030 <free@plt>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %r15,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 26,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdx,(%rsp)\nmov    %esi,%r12d\nmov    %rdi,%r13\nmovslq %esi,%r14\nlea    0x0(,%r14,4),%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r15\nmov    $0x4,%esi\nmov    %r14,%rdi\ncall   1040 <calloc@plt>\nmov    %rax,%rbx\nmov    $0x4,%esi\nmov    %r14,%rdi\ncall   1040 <calloc@plt>\nmov    %rax,%rbp\ntest   %r14d,%r14d\njle    125c <func0+0x11c>\nmov    %r12d,%edx\nxor    %ecx,%ecx\nxor    %r9d,%r9d\nxor    %r8d,%r8d\njmp    11b8 <func0+0x78>\nxchg   %ax,%ax\nmov    %r9d,%eax\nadd    $0x1,%r9d\nmov    %rbx,%rsi\ncltq\nmov    %edi,(%rsi,%rax,4)\nadd    $0x1,%rcx\ncmp    %rdx,%rcx\nje     120c <func0+0xcc>\nmov    0x0(%r13,%rcx,4),%edi\ntest   %r8d,%r8d\njle    11df <func0+0x9f>\nmov    %r8d,%eax\nxor    %esi,%esi\nnopw   0x0(%rax,%rax,1)\ncmp    %edi,0x0(%rbp,%rsi,4)\nje     11af <func0+0x6f>\nadd    $0x1,%rsi\ncmp    %rsi,%rax\njne    11d0 <func0+0x90>\ntest   %r9d,%r9d\njle    11a0 <func0+0x60>\nmov    %r9d,%eax\nxor    %esi,%esi\nnopl   0x0(%rax)\ncmp    %edi,(%rbx,%rsi,4)\nje     1200 <func0+0xc0>\nadd    $0x1,%rsi\ncmp    %rsi,%rax\njne    11f0 <func0+0xb0>\njmp    11a0 <func0+0x60>\nmov    %r8d,%eax\nadd    $0x1,%r8d\nmov    %rbp,%rsi\njmp    11aa <func0+0x6a>\ntest   %r12d,%r12d\njle    125c <func0+0x11c>\ntest   %r8d,%r8d\njle    1261 <func0+0x121>\nmov    %r8d,%eax\nxor    %ecx,%ecx\nxor    %r12d,%r12d\nmov    (%rsp),%r8\njmp    1239 <func0+0xf9>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nadd    $0x1,%rcx\ncmp    %rdx,%rcx\nje     1274 <func0+0x134>\nmov    0x0(%r13,%rcx,4),%esi\nxor    %edi,%edi\ncmp    %esi,0x0(%rbp,%rdi,4)\nje     1230 <func0+0xf0>\nadd    $0x1,%rdi\ncmp    %rdi,%rax\njne    1240 <func0+0x100>\nmovslq %r12d,%rdi\nadd    $0x1,%r12d\nmov    %esi,(%r15,%rdi,4)\njmp    1230 <func0+0xf0>\nxor    %r12d,%r12d\njmp    1270 <func0+0x130>\nshl    $0x2,%rdx\nmov    %r15,%rdi\nmov    %r13,%rsi\ncall   1050 <memcpy@plt>\nmov    (%rsp),%r8\nmov    %r12d,(%r8)\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %rbp,%rdi\ncall   1030 <free@plt>\nmov    %r15,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 27,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11bb <func0+0xab>\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x19(%rbp)\nmovsbl -0x19(%rbp),%eax\ncmp    $0x61,%eax\njl     1176 <func0+0x66>\nmovsbl -0x19(%rbp),%eax\ncmp    $0x7a,%eax\njg     1176 <func0+0x66>\nmovsbl -0x19(%rbp),%eax\nsub    $0x20,%eax\nmov    %al,-0x19(%rbp)\njmp    119f <func0+0x8f>\nmovsbl -0x19(%rbp),%eax\ncmp    $0x41,%eax\njl     119a <func0+0x8a>\nmovsbl -0x19(%rbp),%eax\ncmp    $0x5a,%eax\njg     119a <func0+0x8a>\nmovsbl -0x19(%rbp),%eax\nadd    $0x20,%eax\nmov    %al,-0x19(%rbp)\njmp    119f <func0+0x8f>\nmov    -0x19(%rbp),%dl\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1133 <func0+0x23>\nmov    -0x10(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 27,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %rbx\nmov    %rsi,%r14\nmov    %rdi,%r15\ncall   1030 <strlen@plt>\ntest   %eax,%eax\njle    1165 <func0+0x55>\nmov    %eax,%ecx\nxor    %edx,%edx\njmp    1151 <func0+0x41>\nnopw   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%edi\nlea    0x20(%rsi),%ebx\ncmp    $0x1a,%dil\nmovzbl %sil,%edi\nmovzbl %bl,%esi\ncmovae %edi,%esi\nmov    %sil,(%r14,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\nje     1165 <func0+0x55>\nmovzbl (%r15,%rdx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     1130 <func0+0x20>\nadd    $0xe0,%sil\njmp    1144 <func0+0x34>\ncltq\nmovb   $0x0,(%r14,%rax,1)\npop    %rbx\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 27,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\ntest   %eax,%eax\njle    12cc <func0+0x1bc>\nmov    %eax,%r8d\ncmp    $0x8,%r8\njae    1137 <func0+0x27>\nxor    %edx,%edx\njmp    1301 <func0+0x1f1>\nlea    (%rbx,%r8,1),%rdx\ncmp    %r14,%rdx\njbe    1150 <func0+0x40>\nlea    (%r14,%r8,1),%rdx\ncmp    %rbx,%rdx\njbe    1150 <func0+0x40>\nxor    %edx,%edx\njmp    1301 <func0+0x1f1>\ncmp    $0x10,%r8d\njae    115d <func0+0x4d>\nxor    %edx,%edx\njmp    1214 <func0+0x104>\nmov    %eax,%esi\nand    $0xf,%esi\nmov    %r8,%rdx\nsub    %rsi,%rdx\nxor    %edi,%edi\nmovdqa 0xe8d(%rip),%xmm8\nmovdqa 0xe94(%rip),%xmm9\nmovdqa 0xe9c(%rip),%xmm2\nmovdqa 0xea4(%rip),%xmm3\nmovdqa 0xeac(%rip),%xmm4\nmovdqa 0xeb4(%rip),%xmm5\nnopl   0x0(%rax)\nmovdqu (%rbx,%rdi,1),%xmm1\nmovdqa %xmm1,%xmm6\npaddb  %xmm8,%xmm6\nmovdqa %xmm6,%xmm7\npminub %xmm9,%xmm7\npcmpeqb %xmm6,%xmm7\nmovdqa %xmm1,%xmm0\npaddb  %xmm2,%xmm0\nmovdqa %xmm0,%xmm6\npminub %xmm3,%xmm6\npcmpeqb %xmm0,%xmm6\nmovdqa %xmm1,%xmm0\npaddb  %xmm4,%xmm0\npand   %xmm6,%xmm0\npandn  %xmm1,%xmm6\npor    %xmm0,%xmm6\npaddb  %xmm5,%xmm1\npand   %xmm7,%xmm6\npandn  %xmm1,%xmm7\npor    %xmm6,%xmm7\nmovdqu %xmm7,(%r14,%rdi,1)\nadd    $0x10,%rdi\ncmp    %rdi,%rdx\njne    11a0 <func0+0x90>\ntest   %rsi,%rsi\nje     12cc <func0+0x1bc>\ncmp    $0x8,%esi\njb     1301 <func0+0x1f1>\nmov    %rdx,%rsi\nmov    %eax,%edi\nand    $0x7,%edi\nmov    %r8,%rdx\nsub    %rdi,%rdx\nmovdqa 0xe35(%rip),%xmm8\nmovdqa 0xe3c(%rip),%xmm9\nmovdqa 0xe43(%rip),%xmm10\nmovdqa 0xe4b(%rip),%xmm3\nmovdqa 0xe53(%rip),%xmm4\nmovdqa 0xe5b(%rip),%xmm5\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovq   (%rbx,%rsi,1),%xmm6\nmovdqa %xmm6,%xmm7\npaddb  %xmm8,%xmm7\nmovdqa %xmm7,%xmm0\npmaxub %xmm9,%xmm0\npcmpeqb %xmm7,%xmm0\nmovdqa %xmm6,%xmm1\npaddb  %xmm10,%xmm1\nmovdqa %xmm1,%xmm7\npmaxub %xmm3,%xmm7\npcmpeqb %xmm1,%xmm7\nmovdqa %xmm6,%xmm1\npaddb  %xmm4,%xmm1\nmovdqa %xmm7,%xmm2\npand   %xmm6,%xmm2\npandn  %xmm1,%xmm7\npor    %xmm2,%xmm7\npaddb  %xmm5,%xmm6\npand   %xmm0,%xmm6\npandn  %xmm7,%xmm0\npor    %xmm0,%xmm6\nmovq   %xmm6,(%r14,%rsi,1)\nadd    $0x8,%rsi\ncmp    %rsi,%rdx\njne    1260 <func0+0x150>\ntest   %rdi,%rdi\njne    1301 <func0+0x1f1>\ncltq\nmovb   $0x0,(%r14,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%edi\nlea    0x20(%rsi),%ecx\ncmp    $0x1a,%dil\nmovzbl %sil,%edi\nmovzbl %cl,%esi\ncmovae %edi,%esi\nmov    %sil,(%r14,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%r8\nje     12cc <func0+0x1bc>\nmovzbl (%rbx,%rdx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     12e0 <func0+0x1d0>\nadd    $0xe0,%sil\njmp    12f4 <func0+0x1e4>\n"
    },
    {
        "task_id": 27,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\ntest   %eax,%eax\njle    130f <func0+0x1ff>\nmov    %eax,%r8d\ncmp    $0x8,%r8\njae    1137 <func0+0x27>\nxor    %edx,%edx\njmp    12f1 <func0+0x1e1>\nlea    (%rbx,%r8,1),%rdx\ncmp    %r14,%rdx\njbe    1150 <func0+0x40>\nlea    (%r14,%r8,1),%rdx\ncmp    %rbx,%rdx\njbe    1150 <func0+0x40>\nxor    %edx,%edx\njmp    12f1 <func0+0x1e1>\ncmp    $0x10,%r8d\njae    115d <func0+0x4d>\nxor    %edx,%edx\njmp    1214 <func0+0x104>\nmov    %eax,%esi\nand    $0xf,%esi\nmov    %r8,%rdx\nsub    %rsi,%rdx\nxor    %edi,%edi\nmovdqa 0xe8d(%rip),%xmm8\nmovdqa 0xe94(%rip),%xmm9\nmovdqa 0xe9c(%rip),%xmm2\nmovdqa 0xea4(%rip),%xmm3\nmovdqa 0xeac(%rip),%xmm4\nmovdqa 0xeb4(%rip),%xmm5\nnopl   0x0(%rax)\nmovdqu (%rbx,%rdi,1),%xmm1\nmovdqa %xmm1,%xmm6\npaddb  %xmm8,%xmm6\nmovdqa %xmm6,%xmm7\npminub %xmm9,%xmm7\npcmpeqb %xmm6,%xmm7\nmovdqa %xmm1,%xmm0\npaddb  %xmm2,%xmm0\nmovdqa %xmm0,%xmm6\npminub %xmm3,%xmm6\npcmpeqb %xmm0,%xmm6\nmovdqa %xmm1,%xmm0\npaddb  %xmm4,%xmm0\npand   %xmm6,%xmm0\npandn  %xmm1,%xmm6\npor    %xmm0,%xmm6\npaddb  %xmm5,%xmm1\npand   %xmm7,%xmm6\npandn  %xmm1,%xmm7\npor    %xmm6,%xmm7\nmovdqu %xmm7,(%r14,%rdi,1)\nadd    $0x10,%rdi\ncmp    %rdi,%rdx\njne    11a0 <func0+0x90>\ntest   %rsi,%rsi\nje     130f <func0+0x1ff>\ncmp    $0x8,%esi\njb     12f1 <func0+0x1e1>\nmov    %rdx,%rsi\nmov    %eax,%edi\nand    $0x7,%edi\nmov    %r8,%rdx\nsub    %rdi,%rdx\nmovdqa 0xe35(%rip),%xmm8\nmovdqa 0xe3c(%rip),%xmm9\nmovdqa 0xe43(%rip),%xmm10\nmovdqa 0xe4b(%rip),%xmm3\nmovdqa 0xe53(%rip),%xmm4\nmovdqa 0xe5b(%rip),%xmm5\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovq   (%rbx,%rsi,1),%xmm6\nmovdqa %xmm6,%xmm7\npaddb  %xmm8,%xmm7\nmovdqa %xmm7,%xmm0\npmaxub %xmm9,%xmm0\npcmpeqb %xmm7,%xmm0\nmovdqa %xmm6,%xmm1\npaddb  %xmm10,%xmm1\nmovdqa %xmm1,%xmm7\npmaxub %xmm3,%xmm7\npcmpeqb %xmm1,%xmm7\nmovdqa %xmm6,%xmm1\npaddb  %xmm4,%xmm1\nmovdqa %xmm7,%xmm2\npand   %xmm6,%xmm2\npandn  %xmm1,%xmm7\npor    %xmm2,%xmm7\npaddb  %xmm5,%xmm6\npand   %xmm0,%xmm6\npandn  %xmm7,%xmm0\npor    %xmm0,%xmm6\nmovq   %xmm6,(%r14,%rsi,1)\nadd    $0x8,%rsi\ncmp    %rsi,%rdx\njne    1260 <func0+0x150>\ntest   %rdi,%rdi\njne    12f1 <func0+0x1e1>\njmp    130f <func0+0x1ff>\nxchg   %ax,%ax\nlea    -0x41(%rsi),%edi\nlea    0x20(%rsi),%ecx\ncmp    $0x1a,%dil\nmovzbl %sil,%edi\nmovzbl %cl,%esi\ncmovae %edi,%esi\nmov    %sil,(%r14,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%r8\nje     130f <func0+0x1ff>\nmovzbl (%rbx,%rdx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     12d0 <func0+0x1c0>\nadd    $0xe0,%sil\nmov    %sil,(%r14,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%r8\njne    12f1 <func0+0x1e1>\ncltq\nmovb   $0x0,(%r14,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 28,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1185 <func0+0x55>\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\nmovslq -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    %eax,-0x18(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    114d <func0+0x1d>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1040 <malloc@plt>\nmov    %rax,-0x28(%rbp)\ncmpq   $0x0,-0x28(%rbp)\njne    11af <func0+0x7f>\nmovq   $0x0,-0x8(%rbp)\njmp    11f4 <func0+0xc4>\nmov    -0x28(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11ec <func0+0xbc>\nmov    -0x28(%rbp),%rdi\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rsi\ncall   1050 <strcat@plt>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    11bd <func0+0x8d>\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 28,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %esi,%r14d\nmov    %rdi,%r12\nmov    %esi,%r13d\ntest   %esi,%esi\njle    116c <func0+0x3c>\nxor    %ebp,%ebp\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmov    (%r12,%rbp,8),%rdi\ncall   1030 <strlen@plt>\nadd    %eax,%ebx\nadd    $0x1,%rbp\ncmp    %rbp,%r13\njne    1150 <func0+0x20>\nadd    $0x1,%ebx\nmovslq %ebx,%rdi\njmp    1171 <func0+0x41>\nmov    $0x1,%edi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     11a7 <func0+0x77>\nmov    %rax,%r15\nmovb   $0x0,(%rax)\ntest   %r14d,%r14d\njle    11aa <func0+0x7a>\nxor    %ebx,%ebx\nnopl   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,8),%rsi\nmov    %r15,%rdi\ncall   1050 <strcat@plt>\nadd    $0x1,%rbx\ncmp    %rbx,%r13\njne    1190 <func0+0x60>\njmp    11aa <func0+0x7a>\nxor    %r15d,%r15d\nmov    %r15,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 28,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ntest   %esi,%esi\njle    11a7 <func0+0x77>\nmov    %esi,%r15d\nmov    %rdi,%r12\nmov    %esi,%r13d\nxor    %ebp,%ebp\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmov    (%r12,%rbp,8),%rdi\ncall   1030 <strlen@plt>\nadd    %eax,%ebx\nadd    $0x1,%rbp\ncmp    %rbp,%r13\njne    1150 <func0+0x20>\nadd    $0x1,%ebx\nmovslq %ebx,%rdi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     11be <func0+0x8e>\nmov    %rax,%r14\nmovb   $0x0,(%rax)\ntest   %r15d,%r15d\njle    11c1 <func0+0x91>\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,8),%rsi\nmov    %r14,%rdi\ncall   1050 <strcat@plt>\nadd    $0x1,%rbx\ncmp    %rbx,%r13\njne    1190 <func0+0x60>\njmp    11c1 <func0+0x91>\nmov    $0x1,%edi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     11be <func0+0x8e>\nmov    %rax,%r14\nmovb   $0x0,(%rax)\njmp    11c1 <func0+0x91>\nxor    %r14d,%r14d\nmov    %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 28,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ntest   %esi,%esi\njle    11a7 <func0+0x77>\nmov    %esi,%r15d\nmov    %rdi,%r12\nmov    %esi,%r13d\nxor    %ebp,%ebp\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmov    (%r12,%rbp,8),%rdi\ncall   1030 <strlen@plt>\nadd    %eax,%ebx\nadd    $0x1,%rbp\ncmp    %rbp,%r13\njne    1150 <func0+0x20>\nadd    $0x1,%ebx\nmovslq %ebx,%rdi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     11be <func0+0x8e>\nmov    %rax,%r14\nmovb   $0x0,(%rax)\ntest   %r15d,%r15d\njle    11c1 <func0+0x91>\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,8),%rsi\nmov    %r14,%rdi\ncall   1050 <strcat@plt>\nadd    $0x1,%rbx\ncmp    %rbx,%r13\njne    1190 <func0+0x60>\njmp    11c1 <func0+0x91>\nmov    $0x1,%edi\ncall   1040 <malloc@plt>\ntest   %rax,%rax\nje     11be <func0+0x8e>\nmov    %rax,%r14\nmovb   $0x0,(%rax)\njmp    11c1 <func0+0x91>\nxor    %r14d,%r14d\nmov    %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 29,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    -0x18(%rbp),%rdi\ncall   1040 <strlen@plt>\nmov    %eax,-0x24(%rbp)\nmovslq -0xc(%rbp),%rdi\nshl    $0x3,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%rcx\nmov    -0x20(%rbp),%rax\nmov    %rcx,(%rax)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11de <func0+0xae>\nmov    -0x8(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nmov    -0x18(%rbp),%rsi\nmovslq -0x24(%rbp),%rdx\ncall   1030 <strncmp@plt>\ncmp    $0x0,%eax\njne    11cb <func0+0x9b>\nmov    -0x8(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x28(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x28(%rbp)\nmovslq %ecx,%rcx\nmov    %rdx,(%rax,%rcx,8)\njmp    11d0 <func0+0xa0>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1178 <func0+0x48>\nmov    -0x28(%rbp),%eax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 29,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,%rbp\nmov    %rdx,%r12\nmov    %esi,%r15d\nmov    %rdi,0x10(%rsp)\nmov    %rdx,%rdi\ncall   1040 <strlen@plt>\nmov    %rax,%r14\nmovslq %r15d,%rbx\nlea    0x0(,%rbx,8),%rdi\ncall   1050 <malloc@plt>\nmov    %rbp,0x8(%rsp)\nmov    %rax,0x0(%rbp)\ntest   %ebx,%ebx\njle    11c8 <func0+0x98>\nmovslq %r14d,%r13\nmov    %r15d,%r14d\nxor    %r15d,%r15d\nxor    %ebp,%ebp\njmp    1199 <func0+0x69>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r15\ncmp    %r15,%r14\nje     11ca <func0+0x9a>\nmov    0x10(%rsp),%rax\nmov    (%rax,%r15,8),%rbx\nmov    %rbx,%rdi\nmov    %r12,%rsi\nmov    %r13,%rdx\ncall   1030 <strncmp@plt>\ntest   %eax,%eax\njne    1190 <func0+0x60>\nmov    0x8(%rsp),%rax\nmov    (%rax),%rax\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nmov    %rbx,(%rax,%rcx,8)\njmp    1190 <func0+0x60>\nxor    %ebp,%ebp\nmov    %ebp,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 29,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,%rbp\nmov    %rdx,%r12\nmov    %esi,%r15d\nmov    %rdi,0x10(%rsp)\nmov    %rdx,%rdi\ncall   1040 <strlen@plt>\nmov    %rax,%r14\nmovslq %r15d,%rbx\nlea    0x0(,%rbx,8),%rdi\ncall   1050 <malloc@plt>\nmov    %rbp,0x8(%rsp)\nmov    %rax,0x0(%rbp)\ntest   %ebx,%ebx\njle    11c8 <func0+0x98>\nmovslq %r14d,%r13\nmov    %r15d,%r14d\nxor    %r15d,%r15d\nxor    %ebp,%ebp\njmp    1199 <func0+0x69>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r15\ncmp    %r15,%r14\nje     11ca <func0+0x9a>\nmov    0x10(%rsp),%rax\nmov    (%rax,%r15,8),%rbx\nmov    %rbx,%rdi\nmov    %r12,%rsi\nmov    %r13,%rdx\ncall   1030 <strncmp@plt>\ntest   %eax,%eax\njne    1190 <func0+0x60>\nmov    0x8(%rsp),%rax\nmov    (%rax),%rax\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nmov    %rbx,(%rax,%rcx,8)\njmp    1190 <func0+0x60>\nxor    %ebp,%ebp\nmov    %ebp,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 29,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,%rbp\nmov    %rdx,%r12\nmov    %esi,%r15d\nmov    %rdi,0x10(%rsp)\nmov    %rdx,%rdi\ncall   1040 <strlen@plt>\nmov    %rax,%r14\nmovslq %r15d,%rbx\nlea    0x0(,%rbx,8),%rdi\ncall   1050 <malloc@plt>\nmov    %rbp,0x8(%rsp)\nmov    %rax,0x0(%rbp)\ntest   %ebx,%ebx\njle    11c8 <func0+0x98>\nmovslq %r14d,%r13\nmov    %r15d,%r14d\nxor    %r15d,%r15d\nxor    %ebp,%ebp\njmp    1199 <func0+0x69>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r15\ncmp    %r15,%r14\nje     11ca <func0+0x9a>\nmov    0x10(%rsp),%rax\nmov    (%rax,%r15,8),%rbx\nmov    %rbx,%rdi\nmov    %r12,%rsi\nmov    %r13,%rdx\ncall   1030 <strncmp@plt>\ntest   %eax,%eax\njne    1190 <func0+0x60>\nmov    0x8(%rsp),%rax\nmov    (%rax),%rax\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nmov    %rbx,(%rax,%rcx,8)\njmp    1190 <func0+0x60>\nxor    %ebp,%ebp\nmov    %ebp,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 30,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovslq -0xc(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11a3 <func0+0x93>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nxorps  %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njbe    1190 <func0+0x80>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    (%rdx),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,(%rdx)\nmovslq %ecx,%rcx\nmovss  %xmm0,(%rax,%rcx,4)\njmp    1195 <func0+0x85>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1145 <func0+0x35>\nmov    -0x20(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 30,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdx,%rbx\nmov    %esi,%r15d\nmov    %rdi,%r14\nmovslq %esi,%rbp\nlea    0x0(,%rbp,4),%rdi\ncall   1030 <malloc@plt>\nmovl   $0x0,(%rbx)\ntest   %ebp,%ebp\njle    1173 <func0+0x63>\nmov    %r15d,%ecx\nxor    %edx,%edx\nxorps  %xmm0,%xmm0\njmp    1159 <func0+0x49>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\nje     1173 <func0+0x63>\nmovss  (%r14,%rdx,4),%xmm1\nucomiss %xmm0,%xmm1\njbe    1150 <func0+0x40>\nmovslq (%rbx),%rsi\nlea    0x1(%rsi),%edi\nmov    %edi,(%rbx)\nmovss  %xmm1,(%rax,%rsi,4)\njmp    1150 <func0+0x40>\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 30,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%rbx\nmovslq %esi,%rbp\nlea    0x0(,%rbp,4),%rdi\ncall   1030 <malloc@plt>\nmovl   $0x0,(%r14)\ntest   %ebp,%ebp\njle    1168 <func0+0x58>\nmov    %r15d,%ecx\ncmp    $0x1,%r15d\njne    1173 <func0+0x63>\nxor    %edx,%edx\nxor    %esi,%esi\ntest   $0x1,%cl\nje     1168 <func0+0x58>\nmovss  (%rbx,%rsi,4),%xmm0\nxorps  %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njbe    1168 <func0+0x58>\nlea    0x1(%rdx),%ecx\nmov    %ecx,(%r14)\nmovslq %edx,%rcx\nmovss  %xmm0,(%rax,%rcx,4)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\nmov    %ecx,%edi\nand    $0xfffffffe,%edi\nxor    %edx,%edx\nxorps  %xmm0,%xmm0\nxor    %esi,%esi\njmp    1199 <func0+0x89>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x2,%rsi\ncmp    %rsi,%rdi\nje     1148 <func0+0x38>\nmovss  (%rbx,%rsi,4),%xmm1\nucomiss %xmm0,%xmm1\njbe    11b1 <func0+0xa1>\nmovslq %edx,%rbp\nadd    $0x1,%edx\nmov    %edx,(%r14)\nmovss  %xmm1,(%rax,%rbp,4)\nmovss  0x4(%rbx,%rsi,4),%xmm1\nucomiss %xmm0,%xmm1\njbe    1190 <func0+0x80>\nmovslq %edx,%rbp\nadd    $0x1,%edx\nmov    %edx,(%r14)\nmovss  %xmm1,(%rax,%rbp,4)\njmp    1190 <func0+0x80>\n"
    },
    {
        "task_id": 30,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%rbx\nmovslq %esi,%rbp\nlea    0x0(,%rbp,4),%rdi\ncall   1030 <malloc@plt>\nmovl   $0x0,(%r14)\ntest   %ebp,%ebp\njle    1168 <func0+0x58>\nmov    %r15d,%ecx\ncmp    $0x1,%r15d\njne    1173 <func0+0x63>\nxor    %edx,%edx\nxor    %esi,%esi\ntest   $0x1,%cl\nje     1168 <func0+0x58>\nmovss  (%rbx,%rsi,4),%xmm0\nxorps  %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njbe    1168 <func0+0x58>\nlea    0x1(%rdx),%ecx\nmov    %ecx,(%r14)\nmovslq %edx,%rcx\nmovss  %xmm0,(%rax,%rcx,4)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\nmov    %ecx,%edi\nand    $0xfffffffe,%edi\nxor    %edx,%edx\nxorps  %xmm0,%xmm0\nxor    %esi,%esi\njmp    1199 <func0+0x89>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x2,%rsi\ncmp    %rsi,%rdi\nje     1148 <func0+0x38>\nmovss  (%rbx,%rsi,4),%xmm1\nucomiss %xmm0,%xmm1\nja     11b0 <func0+0xa0>\nmovss  0x4(%rbx,%rsi,4),%xmm1\nucomiss %xmm0,%xmm1\njbe    1190 <func0+0x80>\njmp    11c9 <func0+0xb9>\nmovslq %edx,%rbp\nadd    $0x1,%edx\nmov    %edx,(%r14)\nmovss  %xmm1,(%rax,%rbp,4)\nmovss  0x4(%rbx,%rsi,4),%xmm1\nucomiss %xmm0,%xmm1\njbe    1190 <func0+0x80>\nmovslq %edx,%rbp\nadd    $0x1,%edx\nmov    %edx,(%r14)\nmovss  %xmm1,(%rax,%rbp,4)\njmp    1190 <func0+0x80>\n"
    },
    {
        "task_id": 31,
        "type": "O0",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\ncmpq   $0x2,-0x10(%rbp)\njge    111c <func0+0x1c>\nmovb   $0x0,-0x1(%rbp)\njmp    116e <func0+0x6e>\nmovq   $0x2,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nimul   -0x18(%rbp),%rax\ncmp    -0x10(%rbp),%rax\njg     116a <func0+0x6a>\nmov    -0x10(%rbp),%rax\ncqto\nidivq  -0x18(%rbp)\ncmp    $0x0,%rdx\njne    1154 <func0+0x54>\nmovb   $0x0,-0x1(%rbp)\njmp    116e <func0+0x6e>\njmp    1159 <func0+0x59>\nmov    -0x18(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x18(%rbp)\njmp    1124 <func0+0x24>\nmovb   $0x1,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 31,
        "type": "O1",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    $0x2,%rdi\njge    110b <func0+0xb>\nxor    %ecx,%ecx\nmov    %ecx,%eax\nret\ncmp    $0x4,%rdi\nsetl   %cl\njl     1150 <func0+0x50>\nmov    %edi,%eax\nand    $0x1,%eax\ntest   %rax,%rax\nje     1150 <func0+0x50>\nmov    $0x3,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %rsi,%rax\nimul   %rsi,%rax\ncmp    %rdi,%rax\nsetg   %cl\njg     1150 <func0+0x50>\nmov    %rdi,%rax\ncqto\nidiv   %rsi\nadd    $0x1,%rsi\ntest   %rdx,%rdx\njne    1130 <func0+0x30>\nmov    %ecx,%eax\nret\n"
    },
    {
        "task_id": 31,
        "type": "O2",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    $0x2,%rdi\njge    1109 <func0+0x9>\nxor    %eax,%eax\nret\nmov    $0x1,%al\ncmp    $0x4,%rdi\njb     1161 <func0+0x61>\nmov    $0x2,%ecx\ncs nopw 0x0(%rax,%rax,1)\nmov    %rdi,%rax\nor     %rcx,%rax\nshr    $0x20,%rax\nje     1140 <func0+0x40>\nmov    %rdi,%rax\ncqto\nidiv   %rcx\ntest   %rdx,%rdx\njne    114b <func0+0x4b>\njmp    115b <func0+0x5b>\nnopl   0x0(%rax,%rax,1)\nmov    %edi,%eax\nxor    %edx,%edx\ndiv    %ecx\ntest   %rdx,%rdx\nje     115b <func0+0x5b>\nadd    $0x1,%rcx\nmov    %rcx,%rax\nimul   %rcx,%rax\ncmp    %rdi,%rax\njle    1120 <func0+0x20>\ntest   %rdx,%rdx\nsetne  %al\nret\n"
    },
    {
        "task_id": 31,
        "type": "O3",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    $0x2,%rdi\njge    1109 <func0+0x9>\nxor    %eax,%eax\nret\nmov    $0x1,%al\ncmp    $0x4,%rdi\njb     1161 <func0+0x61>\nmov    $0x2,%ecx\ncs nopw 0x0(%rax,%rax,1)\nmov    %rdi,%rax\nor     %rcx,%rax\nshr    $0x20,%rax\nje     1140 <func0+0x40>\nmov    %rdi,%rax\ncqto\nidiv   %rcx\ntest   %rdx,%rdx\njne    114b <func0+0x4b>\njmp    115b <func0+0x5b>\nnopl   0x0(%rax,%rax,1)\nmov    %edi,%eax\nxor    %edx,%edx\ndiv    %ecx\ntest   %rdx,%rdx\nje     115b <func0+0x5b>\nadd    $0x1,%rcx\nmov    %rcx,%rax\nimul   %rcx,%rax\ncmp    %rdi,%rax\njle    1120 <func0+0x20>\ntest   %rdx,%rdx\nsetne  %al\nret\n"
    },
    {
        "task_id": 32,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nxorps  %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11a2 <func0+0xa2>\nmovsd  0xecd(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njge    1170 <func0+0x70>\nmovsd  -0x18(%rbp),%xmm0\nmulsd  -0x30(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    1147 <func0+0x47>\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovsd  (%rax,%rcx,8),%xmm0\nmovsd  -0x30(%rbp),%xmm2\nmovsd  -0x20(%rbp),%xmm1\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    1127 <func0+0x27>\njmp    11a7 <func0+0xa7>\nmovsd  -0x20(%rbp),%xmm0\nmovaps 0xe5d(%rip),%xmm1\npand   %xmm1,%xmm0\nmovsd  0xe41(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    1304 <func0+0x204>\nxorps  %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1258 <func0+0x158>\nmovsd  0xe1c(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovl   $0x1,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njge    1221 <func0+0x121>\nmovsd  -0x18(%rbp),%xmm0\nmulsd  -0x30(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmov    -0x3c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x3c(%rbp)\njmp    11f8 <func0+0xf8>\ncvtsi2sdl -0x34(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmulsd  (%rax,%rcx,8),%xmm0\nmovsd  -0x30(%rbp),%xmm2\nmovsd  -0x28(%rbp),%xmm1\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    11d8 <func0+0xd8>\nmovsd  -0x18(%rbp),%xmm0\nmovsd  -0x20(%rbp),%xmm1\ndivsd  -0x28(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    12ff <func0+0x1ff>\nmovsd  0xd70(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njge    12cd <func0+0x1cd>\nmovsd  -0x18(%rbp),%xmm0\nmulsd  -0x30(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmov    -0x40(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x40(%rbp)\njmp    12a4 <func0+0x1a4>\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovsd  (%rax,%rcx,8),%xmm0\nmovsd  -0x30(%rbp),%xmm2\nmovsd  -0x20(%rbp),%xmm1\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    1284 <func0+0x184>\njmp    11a7 <func0+0xa7>\nmovsd  -0x18(%rbp),%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 32,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmovsd  (%rdi),%xmm1\nmov    %esi,%r8d\nmovapd %xmm1,%xmm2\ncmp    $0x2,%esi\njl     115c <func0+0x5c>\nmov    $0x1,%ecx\nmovsd  0xee3(%rip),%xmm0\nxorpd  %xmm3,%xmm3\nmovapd %xmm1,%xmm2\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %rcx,%rax\nmovapd %xmm0,%xmm4\nnopw   0x0(%rax,%rax,1)\nmulsd  %xmm3,%xmm4\nadd    $0xffffffffffffffff,%rax\njne    1140 <func0+0x40>\nmulsd  (%rdi,%rcx,8),%xmm4\naddsd  %xmm4,%xmm2\nadd    $0x1,%rcx\ncmp    %r8,%rcx\njne    1130 <func0+0x30>\nmovapd 0xeac(%rip),%xmm3\nandpd  %xmm2,%xmm3\nxorpd  %xmm0,%xmm0\nucomisd 0xe94(%rip),%xmm3\njbe    1271 <func0+0x171>\nxorpd  %xmm0,%xmm0\nmovsd  0xe7a(%rip),%xmm3\nmovapd 0xe81(%rip),%xmm8\nmovsd  0xe71(%rip),%xmm5\njmp    11b3 <func0+0xb3>\nnopl   0x0(%rax)\nmovapd %xmm2,%xmm6\nandpd  %xmm8,%xmm6\nucomisd %xmm5,%xmm6\njbe    1271 <func0+0x171>\nxorpd  %xmm6,%xmm6\ncmp    $0x2,%esi\njl     1220 <func0+0x120>\nxorpd  %xmm6,%xmm6\nmov    $0x1,%ecx\nxor    %eax,%eax\njmp    11f1 <func0+0xf1>\nnopl   0x0(%rax)\nxorps  %xmm4,%xmm4\ncvtsi2sd %ecx,%xmm4\nmulsd  (%rdi,%rcx,8),%xmm4\nmulsd  %xmm7,%xmm4\naddsd  %xmm4,%xmm6\nadd    $0x1,%rcx\nadd    $0x1,%rax\ncmp    %r8,%rcx\nje     1220 <func0+0x120>\nmovapd %xmm3,%xmm7\ncmp    $0x2,%rcx\njb     11d0 <func0+0xd0>\nmov    %rax,%rdx\nmovapd %xmm3,%xmm7\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmulsd  %xmm0,%xmm7\nadd    $0xffffffffffffffff,%rdx\njne    1210 <func0+0x110>\njmp    11d0 <func0+0xd0>\nnopl   0x0(%rax)\ndivsd  %xmm6,%xmm2\nsubsd  %xmm2,%xmm0\nmovapd %xmm1,%xmm2\ncmp    $0x2,%esi\njl     11a0 <func0+0xa0>\nmov    $0x1,%ecx\nmovapd %xmm1,%xmm2\nxchg   %ax,%ax\nmov    %rcx,%rax\nmovapd %xmm3,%xmm6\nnopw   0x0(%rax,%rax,1)\nmulsd  %xmm0,%xmm6\nadd    $0xffffffffffffffff,%rax\njne    1250 <func0+0x150>\nmulsd  (%rdi,%rcx,8),%xmm6\naddsd  %xmm6,%xmm2\nadd    $0x1,%rcx\ncmp    %r8,%rcx\njne    1240 <func0+0x140>\njmp    11a0 <func0+0xa0>\nret\n"
    },
    {
        "task_id": 32,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmovsd  (%rdi),%xmm1\nmov    %esi,%r9d\nmovapd %xmm1,%xmm2\ncmp    $0x2,%esi\njl     119c <func0+0x9c>\nmov    $0x1,%edx\nxor    %r8d,%r8d\nmovsd  0xedc(%rip),%xmm0\nxorpd  %xmm3,%xmm3\nmovapd %xmm1,%xmm2\njmp    1146 <func0+0x46>\nxchg   %ax,%ax\nmulsd  (%rdi,%rdx,8),%xmm4\naddsd  %xmm4,%xmm2\nadd    $0x1,%rdx\nadd    $0x1,%r8\ncmp    %r9,%rdx\nje     119c <func0+0x9c>\nmovapd %xmm0,%xmm4\ncmp    $0x7,%r8\njb     1186 <func0+0x86>\nmov    %rdx,%rcx\nand    $0xfffffffffffffff8,%rcx\nmovapd %xmm0,%xmm4\nnopl   0x0(%rax,%rax,1)\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nadd    $0xfffffffffffffff8,%rcx\njne    1160 <func0+0x60>\ntest   $0x7,%dl\nje     1130 <func0+0x30>\nmov    %edx,%eax\nand    $0x7,%eax\nmulsd  %xmm3,%xmm4\nadd    $0xffffffffffffffff,%rax\njne    1190 <func0+0x90>\njmp    1130 <func0+0x30>\nmovapd 0xe7c(%rip),%xmm3\nandpd  %xmm2,%xmm3\nxorpd  %xmm0,%xmm0\nucomisd 0xe54(%rip),%xmm3\njbe    134c <func0+0x24c>\nxorpd  %xmm0,%xmm0\nmovsd  0xe3a(%rip),%xmm6\nmovapd 0xe51(%rip),%xmm9\nmovsd  0xe31(%rip),%xmm5\nmovsd  0xe30(%rip),%xmm8\njmp    1210 <func0+0x110>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ndivsd  %xmm8,%xmm2\naddsd  %xmm2,%xmm0\nmovapd %xmm1,%xmm2\nmovapd %xmm2,%xmm3\nandpd  %xmm9,%xmm3\nucomisd %xmm5,%xmm3\njbe    134c <func0+0x24c>\ncmp    $0x2,%esi\njl     11f0 <func0+0xf0>\nxorpd  %xmm7,%xmm7\nmov    $0x1,%ecx\nxor    %eax,%eax\njmp    1251 <func0+0x151>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nxorps  %xmm4,%xmm4\ncvtsi2sd %ecx,%xmm4\nmulsd  (%rdi,%rcx,8),%xmm4\nmulsd  %xmm3,%xmm4\naddsd  %xmm4,%xmm7\nadd    $0x1,%rcx\nadd    $0x1,%rax\ncmp    %r9,%rcx\nje     12c0 <func0+0x1c0>\nmovapd %xmm6,%xmm3\ncmp    $0x2,%rcx\njb     1230 <func0+0x130>\nlea    -0x1(%rax),%rdx\nmovapd %xmm6,%xmm3\ncmp    $0x7,%rdx\njb     12a6 <func0+0x1a6>\nmov    %rax,%rdx\nand    $0xfffffffffffffff8,%rdx\nmovapd %xmm6,%xmm3\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nadd    $0xfffffffffffffff8,%rdx\njne    1280 <func0+0x180>\ntest   $0x7,%al\nje     1230 <func0+0x130>\nmov    %eax,%edx\nand    $0x7,%edx\nnop\nmulsd  %xmm0,%xmm3\nadd    $0xffffffffffffffff,%rdx\njne    12b0 <func0+0x1b0>\njmp    1230 <func0+0x130>\nnop\ndivsd  %xmm7,%xmm2\nsubsd  %xmm2,%xmm0\ncmp    $0x2,%esi\njl     11f9 <func0+0xf9>\nmov    $0x1,%ecx\nxor    %edx,%edx\nmovapd %xmm1,%xmm2\njmp    12fa <func0+0x1fa>\nxchg   %ax,%ax\nmulsd  (%rdi,%rcx,8),%xmm3\naddsd  %xmm3,%xmm2\nadd    $0x1,%rcx\nadd    $0x1,%rdx\ncmp    %r9,%rcx\nje     11fd <func0+0xfd>\nmovapd %xmm6,%xmm3\ncmp    $0x7,%rdx\njb     1336 <func0+0x236>\nmov    %rcx,%rax\nand    $0xfffffffffffffff8,%rax\nmovapd %xmm6,%xmm3\nnop\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\nadd    $0xfffffffffffffff8,%rax\njne    1310 <func0+0x210>\ntest   $0x7,%cl\nje     12e0 <func0+0x1e0>\nmov    %ecx,%eax\nand    $0x7,%eax\nmulsd  %xmm0,%xmm3\nadd    $0xffffffffffffffff,%rax\njne    1340 <func0+0x240>\njmp    12e0 <func0+0x1e0>\nret\n"
    },
    {
        "task_id": 32,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmovsd  (%rdi),%xmm1\ncmp    $0x2,%esi\njl     119c <func0+0x9c>\nmov    %esi,%r8d\nmov    $0x1,%eax\nxor    %edx,%edx\nmovsd  0xef9(%rip),%xmm0\nxorpd  %xmm3,%xmm3\nmovapd %xmm1,%xmm2\njmp    1146 <func0+0x46>\nnopl   0x0(%rax)\nmulsd  (%rdi,%rax,8),%xmm4\naddsd  %xmm4,%xmm2\nadd    $0x1,%rax\nadd    $0x1,%rdx\ncmp    %r8,%rax\nje     11bf <func0+0xbf>\nmovapd %xmm0,%xmm4\ncmp    $0x7,%rdx\njb     1186 <func0+0x86>\nmov    %rax,%rcx\nand    $0xfffffffffffffff8,%rcx\nmovapd %xmm0,%xmm4\nnopl   0x0(%rax,%rax,1)\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nmulsd  %xmm3,%xmm4\nadd    $0xfffffffffffffff8,%rcx\njne    1160 <func0+0x60>\ntest   $0x7,%al\nje     1130 <func0+0x30>\nmov    %eax,%ecx\nand    $0x7,%ecx\nnop\nmulsd  %xmm3,%xmm4\nadd    $0xffffffffffffffff,%rcx\njne    1190 <func0+0x90>\njmp    1130 <func0+0x30>\nmovapd 0xe5c(%rip),%xmm2\nandpd  %xmm1,%xmm2\nxorpd  %xmm0,%xmm0\nucomisd 0xe5c(%rip),%xmm2\nmovapd %xmm1,%xmm2\nja     134c <func0+0x24c>\nret\nmovapd 0xe39(%rip),%xmm3\nandpd  %xmm2,%xmm3\nxorpd  %xmm0,%xmm0\nucomisd 0xe39(%rip),%xmm3\njbe    11be <func0+0xbe>\ncmp    $0x2,%esi\njl     134c <func0+0x24c>\nxorpd  %xmm0,%xmm0\nmovsd  0xe2a(%rip),%xmm3\nmovapd 0xe09(%rip),%xmm8\nmovsd  0xe11(%rip),%xmm5\njmp    121f <func0+0x11f>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovapd %xmm2,%xmm4\nandpd  %xmm8,%xmm4\nucomisd %xmm5,%xmm4\njbe    11be <func0+0xbe>\nmov    $0x1,%ecx\nxor    %edx,%edx\nxorpd  %xmm6,%xmm6\njmp    1251 <func0+0x151>\nnopl   0x0(%rax)\nxorps  %xmm4,%xmm4\ncvtsi2sd %ecx,%xmm4\nmulsd  (%rdi,%rcx,8),%xmm4\nmulsd  %xmm7,%xmm4\naddsd  %xmm4,%xmm6\nadd    $0x1,%rcx\nadd    $0x1,%rdx\ncmp    %r8,%rcx\nje     12c0 <func0+0x1c0>\nmovapd %xmm3,%xmm7\ncmp    $0x2,%rcx\njb     1230 <func0+0x130>\nlea    -0x1(%rdx),%rax\nmovapd %xmm3,%xmm7\ncmp    $0x7,%rax\njb     12a6 <func0+0x1a6>\nmov    %rdx,%rsi\nand    $0xfffffffffffffff8,%rsi\nmovapd %xmm3,%xmm7\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmulsd  %xmm0,%xmm7\nmulsd  %xmm0,%xmm7\nmulsd  %xmm0,%xmm7\nmulsd  %xmm0,%xmm7\nmulsd  %xmm0,%xmm7\nmulsd  %xmm0,%xmm7\nmulsd  %xmm0,%xmm7\nmulsd  %xmm0,%xmm7\nadd    $0xfffffffffffffff8,%rsi\njne    1280 <func0+0x180>\ntest   $0x7,%dl\nje     1230 <func0+0x130>\nmov    %edx,%eax\nand    $0x7,%eax\nmulsd  %xmm0,%xmm7\nadd    $0xffffffffffffffff,%rax\njne    12b0 <func0+0x1b0>\njmp    1230 <func0+0x130>\nnop\ndivsd  %xmm6,%xmm2\nsubsd  %xmm2,%xmm0\nmov    $0x1,%ecx\nxor    %edx,%edx\nmovapd %xmm1,%xmm2\njmp    12fa <func0+0x1fa>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmulsd  (%rdi,%rcx,8),%xmm6\naddsd  %xmm6,%xmm2\nadd    $0x1,%rcx\nadd    $0x1,%rdx\ncmp    %r8,%rcx\nje     1210 <func0+0x110>\nmovapd %xmm3,%xmm6\ncmp    $0x7,%rdx\njb     1336 <func0+0x236>\nmov    %rcx,%rsi\nand    $0xfffffffffffffff8,%rsi\nmovapd %xmm3,%xmm6\nnop\nmulsd  %xmm0,%xmm6\nmulsd  %xmm0,%xmm6\nmulsd  %xmm0,%xmm6\nmulsd  %xmm0,%xmm6\nmulsd  %xmm0,%xmm6\nmulsd  %xmm0,%xmm6\nmulsd  %xmm0,%xmm6\nmulsd  %xmm0,%xmm6\nadd    $0xfffffffffffffff8,%rsi\njne    1310 <func0+0x210>\ntest   $0x7,%cl\nje     12e0 <func0+0x1e0>\nmov    %ecx,%eax\nand    $0x7,%eax\nmulsd  %xmm0,%xmm6\nadd    $0xffffffffffffffff,%rax\njne    1340 <func0+0x240>\njmp    12e0 <func0+0x1e0>\nandpd  0xcac(%rip),%xmm1\nucomisd 0xcb4(%rip),%xmm1\njbe    1362 <func0+0x262>\nxchg   %ax,%ax\njmp    1360 <func0+0x260>\nxorpd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm0\nret\n"
    },
    {
        "task_id": 33,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\nmov    $0x3,%ecx\ncltd\nidiv   %ecx\nadd    $0x1,%eax\nmovslq %eax,%rdi\nshl    $0x2,%rdi\ncall   1040 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmovl   $0x0,-0x24(%rbp)\nimul   $0x3,-0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11a3 <func0+0x83>\nmov    -0x8(%rbp),%rax\nimul   $0x3,-0x24(%rbp),%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x20(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1166 <func0+0x46>\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nmov    -0x2c(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    125c <func0+0x13c>\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x30(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njge    120b <func0+0xeb>\nmov    -0x20(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x20(%rbp),%rcx\nmovslq -0x30(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njge    11f8 <func0+0xd8>\nmov    -0x28(%rbp),%eax\nmov    %eax,-0x30(%rbp)\njmp    11fd <func0+0xdd>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    11ca <func0+0xaa>\nmov    -0x30(%rbp),%eax\ncmp    -0x24(%rbp),%eax\nje     1249 <func0+0x129>\nmov    -0x20(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x20(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x20(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x34(%rbp),%edx\nmov    -0x20(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    124e <func0+0x12e>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    11aa <func0+0x8a>\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    12db <func0+0x1bb>\nmov    -0x24(%rbp),%eax\nmov    $0x3,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    12b2 <func0+0x192>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmov    -0x24(%rbp),%eax\nmov    $0x3,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x40(%rbp),%rax\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    12c8 <func0+0x1a8>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    12cd <func0+0x1ad>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1263 <func0+0x143>\nmov    -0x20(%rbp),%rdi\ncall   1030 <free@plt>\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 33,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%r12\nmovslq %esi,%rbx\nimul   $0x55555556,%rbx,%rax\nmov    %rax,%rcx\nshr    $0x3f,%rcx\nshr    $0x20,%rax\nadd    %ecx,%eax\ncltq\nlea    0x4(,%rax,4),%rdi\ncall   1040 <malloc@plt>\ntest   %ebx,%ebx\njle    117c <func0+0x5c>\nxor    %ecx,%ecx\nxor    %edx,%edx\nnop\nmov    %ecx,%esi\nmov    (%r12,%rsi,4),%esi\nmov    %esi,(%rax,%rdx,4)\nadd    $0x1,%rdx\nadd    $0x3,%ecx\ncmp    %r15d,%ecx\njl     1160 <func0+0x40>\ncmp    $0x2,%edx\njge    1183 <func0+0x63>\njmp    11fa <func0+0xda>\nxor    %edx,%edx\ncmp    $0x2,%edx\njl     11fa <func0+0xda>\nlea    -0x1(%rdx),%r8d\nmov    %edx,%edx\nmov    $0x1,%r11d\nxor    %r9d,%r9d\njmp    11a9 <func0+0x89>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nadd    $0x1,%r11\ncmp    %r8,%r9\nje     11fa <func0+0xda>\nmov    %r9,%r10\nadd    $0x1,%r9\nmov    %r11,%rsi\nmov    %r10d,%ebp\njmp    11cb <func0+0xab>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rsi\nmov    %ebx,%ebp\ncmp    %rsi,%rdx\nje     11e0 <func0+0xc0>\nmov    (%rax,%rsi,4),%edi\nmovslq %ebp,%rcx\nmov    %esi,%ebx\ncmp    (%rax,%rcx,4),%edi\njl     11c0 <func0+0xa0>\nmov    %ebp,%ebx\njmp    11c0 <func0+0xa0>\nnopl   0x0(%rax)\nmov    %ebx,%ecx\ncmp    %rcx,%r10\nje     11a0 <func0+0x80>\nmov    (%rax,%r10,4),%ecx\nmovslq %ebx,%rsi\nmov    (%rax,%rsi,4),%edi\nmov    %edi,(%rax,%r10,4)\nmov    %ecx,(%rax,%rsi,4)\njmp    11a0 <func0+0x80>\ntest   %r15d,%r15d\njle    123a <func0+0x11a>\nmov    %r15d,%ecx\nxor    %edx,%edx\nmov    $0xaaaaaaab,%esi\nnopl   0x0(%rax)\nmov    %edx,%edi\nimul   %rsi,%rdi\nshr    $0x21,%rdi\nlea    (%rdi,%rdi,2),%ebp\ncmp    %ebp,%edx\nlea    (%rax,%rdi,4),%rdi\ncmovne %r12,%rdi\nmov    (%rdi),%edi\nmov    %edi,(%r14,%rdx,4)\nadd    $0x1,%rdx\nadd    $0x4,%r12\ncmp    %rdx,%rcx\njne    1210 <func0+0xf0>\nmov    %rax,%rdi\ncall   1030 <free@plt>\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 33,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%r12\nmovslq %esi,%rbx\nimul   $0x55555556,%rbx,%rax\nmov    %rax,%rcx\nshr    $0x3f,%rcx\nshr    $0x20,%rax\nadd    %ecx,%eax\ncltq\nlea    0x4(,%rax,4),%rdi\ncall   1040 <malloc@plt>\ntest   %ebx,%ebx\njle    123a <func0+0x11a>\nxor    %edx,%edx\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %edx,%esi\nmov    (%r12,%rsi,4),%esi\nmov    %esi,(%rax,%rcx,4)\nadd    $0x1,%rcx\nadd    $0x3,%edx\ncmp    %r15d,%edx\njl     1170 <func0+0x50>\ncmp    $0x2,%ecx\njl     11fa <func0+0xda>\nlea    -0x1(%rcx),%rdx\nmov    %edx,%r8d\nmov    %ecx,%edx\nmov    $0x1,%r11d\nxor    %r9d,%r9d\njmp    11a9 <func0+0x89>\nxchg   %ax,%ax\nadd    $0x1,%r11\ncmp    %r8,%r9\nje     11fa <func0+0xda>\nmov    %r9,%r10\nadd    $0x1,%r9\nmov    %r11,%rsi\nmov    %r10d,%ecx\njmp    11cb <func0+0xab>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rsi\nmov    %ebx,%ecx\ncmp    %rsi,%rdx\nje     11e0 <func0+0xc0>\nmov    (%rax,%rsi,4),%edi\nmovslq %ecx,%rbp\nmov    %esi,%ebx\ncmp    (%rax,%rbp,4),%edi\njl     11c0 <func0+0xa0>\nmov    %ecx,%ebx\njmp    11c0 <func0+0xa0>\nnopl   0x0(%rax)\nmov    %ebx,%ecx\ncmp    %rcx,%r10\nje     11a0 <func0+0x80>\nmov    (%rax,%r10,4),%ecx\nmovslq %ebx,%rsi\nmov    (%rax,%rsi,4),%edi\nmov    %edi,(%rax,%r10,4)\nmov    %ecx,(%rax,%rsi,4)\njmp    11a0 <func0+0x80>\ntest   %r15d,%r15d\njle    123a <func0+0x11a>\nmov    %r15d,%ecx\nxor    %edx,%edx\nmov    $0xaaaaaaab,%esi\nnopl   0x0(%rax)\nmov    %edx,%edi\nimul   %rsi,%rdi\nshr    $0x21,%rdi\nlea    (%rdi,%rdi,2),%ebp\ncmp    %ebp,%edx\nlea    (%rax,%rdi,4),%rdi\ncmovne %r12,%rdi\nmov    (%rdi),%edi\nmov    %edi,(%r14,%rdx,4)\nadd    $0x1,%rdx\nadd    $0x4,%r12\ncmp    %rdx,%rcx\njne    1210 <func0+0xf0>\nmov    %rax,%rdi\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\njmp    1030 <free@plt>\n"
    },
    {
        "task_id": 33,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%r12\nmovslq %esi,%rbx\nimul   $0x55555556,%rbx,%rax\nmov    %rax,%rcx\nshr    $0x3f,%rcx\nshr    $0x20,%rax\nadd    %ecx,%eax\ncltq\nlea    0x4(,%rax,4),%rdi\ncall   1040 <malloc@plt>\ntest   %ebx,%ebx\njle    123a <func0+0x11a>\nxor    %edx,%edx\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %edx,%esi\nmov    (%r12,%rsi,4),%esi\nmov    %esi,(%rax,%rcx,4)\nadd    $0x1,%rcx\nadd    $0x3,%edx\ncmp    %r15d,%edx\njl     1170 <func0+0x50>\ncmp    $0x2,%ecx\njl     11fa <func0+0xda>\nlea    -0x1(%rcx),%rdx\nmov    %edx,%r8d\nmov    %ecx,%edx\nmov    $0x1,%r11d\nxor    %r9d,%r9d\njmp    11a9 <func0+0x89>\nxchg   %ax,%ax\nadd    $0x1,%r11\ncmp    %r8,%r9\nje     11fa <func0+0xda>\nmov    %r9,%r10\nadd    $0x1,%r9\nmov    %r11,%rsi\nmov    %r10d,%ecx\njmp    11cb <func0+0xab>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rsi\nmov    %ebx,%ecx\ncmp    %rsi,%rdx\nje     11e0 <func0+0xc0>\nmov    (%rax,%rsi,4),%edi\nmovslq %ecx,%rbp\nmov    %esi,%ebx\ncmp    (%rax,%rbp,4),%edi\njl     11c0 <func0+0xa0>\nmov    %ecx,%ebx\njmp    11c0 <func0+0xa0>\nnopl   0x0(%rax)\nmov    %ebx,%ecx\ncmp    %rcx,%r10\nje     11a0 <func0+0x80>\nmov    (%rax,%r10,4),%ecx\nmovslq %ebx,%rsi\nmov    (%rax,%rsi,4),%edi\nmov    %edi,(%rax,%r10,4)\nmov    %ecx,(%rax,%rsi,4)\njmp    11a0 <func0+0x80>\ntest   %r15d,%r15d\njle    123a <func0+0x11a>\nmov    %r15d,%ecx\nxor    %edx,%edx\nmov    $0xaaaaaaab,%esi\nnopl   0x0(%rax)\nmov    %edx,%edi\nimul   %rsi,%rdi\nshr    $0x21,%rdi\nlea    (%rdi,%rdi,2),%ebp\ncmp    %ebp,%edx\nlea    (%rax,%rdi,4),%rdi\ncmovne %r12,%rdi\nmov    (%rdi),%edi\nmov    %edi,(%r14,%rdx,4)\nadd    $0x1,%rdx\nadd    $0x4,%r12\ncmp    %rdx,%rcx\njne    1210 <func0+0xf0>\nmov    %rax,%rdi\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\njmp    1030 <free@plt>\n"
    },
    {
        "task_id": 34,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovslq -0xc(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11e0 <func0+0xd0>\nmovl   $0x0,-0x24(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njge    11a3 <func0+0x93>\nmov    -0x8(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x20(%rbp),%rcx\nmovslq -0x30(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njne    1190 <func0+0x80>\nmovl   $0x1,-0x24(%rbp)\njmp    11a3 <func0+0x93>\njmp    1195 <func0+0x85>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    115c <func0+0x4c>\ncmpl   $0x0,-0x24(%rbp)\njne    11cd <func0+0xbd>\nmov    -0x8(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x28(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    11d2 <func0+0xc2>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1142 <func0+0x32>\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    -0x28(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    1281 <func0+0x171>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x28(%rbp),%eax\njge    126e <func0+0x15e>\nmov    -0x20(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x20(%rbp),%rcx\nmovslq -0x30(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njle    125b <func0+0x14b>\nmov    -0x20(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x20(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x20(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x34(%rbp),%edx\nmov    -0x20(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1260 <func0+0x150>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    1201 <func0+0xf1>\njmp    1273 <func0+0x163>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    11e7 <func0+0xd7>\nmov    -0x28(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 34,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%rbx\nmovslq %esi,%rbp\nlea    0x0(,%rbp,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebp,%ebp\njle    1180 <func0+0x70>\nmov    %r15d,%r8d\nxor    %esi,%esi\nxor    %r10d,%r10d\njmp    1156 <func0+0x46>\nxchg   %ax,%ax\nmov    (%rbx,%rsi,4),%ecx\nmovslq %r10d,%rdx\nadd    $0x1,%r10d\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rsi\ncmp    %r8,%rsi\nje     1183 <func0+0x73>\ntest   %r10d,%r10d\njle    1140 <func0+0x30>\nmov    (%rbx,%rsi,4),%edi\nmov    %r10d,%ebp\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\ncmp    (%rax,%rdx,4),%edi\nje     114d <func0+0x3d>\nadd    $0x1,%rdx\ncmp    %rdx,%rbp\njne    1170 <func0+0x60>\njmp    1140 <func0+0x30>\nxor    %r10d,%r10d\ncmp    $0x2,%r10d\njl     11dd <func0+0xcd>\nlea    -0x1(%r10),%r8d\nmovslq %r10d,%r9\nmov    %r10d,%edi\nxor    %r11d,%r11d\nmov    %rax,%rbp\njmp    11ad <func0+0x9d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x4,%rbp\nadd    $0xffffffffffffffff,%rdi\ncmp    %r8,%r11\nje     11dd <func0+0xcd>\nmov    %r11,%rbx\nadd    $0x1,%r11\ncmp    %r9,%r11\njge    11a0 <func0+0x90>\nmov    $0x1,%esi\njmp    11c9 <func0+0xb9>\nadd    $0x1,%rsi\ncmp    %rsi,%rdi\nje     11a0 <func0+0x90>\nmov    (%rax,%rbx,4),%ecx\nmov    0x0(%rbp,%rsi,4),%edx\ncmp    %edx,%ecx\njle    11c0 <func0+0xb0>\nmov    %edx,(%rax,%rbx,4)\nmov    %ecx,0x0(%rbp,%rsi,4)\njmp    11c0 <func0+0xb0>\nmov    %r10d,(%r14)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 34,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdx,%r14\nmov    %esi,%ebp\nmov    %rdi,%r15\nmovslq %esi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\njle    11dd <func0+0xcd>\nmov    %ebp,%edx\nxor    %esi,%esi\nxor    %r10d,%r10d\njmp    1153 <func0+0x43>\nmovslq %r10d,%rcx\nadd    $0x1,%r10d\nmov    %edi,(%rax,%rcx,4)\nadd    $0x1,%rsi\ncmp    %rdx,%rsi\nje     1180 <func0+0x70>\nmov    (%r15,%rsi,4),%edi\ntest   %r10d,%r10d\njle    1140 <func0+0x30>\nmov    %r10d,%ebp\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\ncmp    (%rax,%rbx,4),%edi\nje     114a <func0+0x3a>\nadd    $0x1,%rbx\ncmp    %rbx,%rbp\njne    1170 <func0+0x60>\njmp    1140 <func0+0x30>\ncmp    $0x2,%r10d\njl     11e0 <func0+0xd0>\nlea    -0x1(%r10),%r8d\nmov    %r10d,%r9d\nxor    %r11d,%r11d\nmov    %r9,%rdi\nmov    %rax,%rbp\njmp    11ad <func0+0x9d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x4,%rbp\nadd    $0xffffffffffffffff,%rdi\ncmp    %r8,%r11\nje     11e0 <func0+0xd0>\nmov    %r11,%rbx\nadd    $0x1,%r11\ncmp    %r9,%r11\njae    11a0 <func0+0x90>\nmov    $0x1,%esi\njmp    11c9 <func0+0xb9>\nadd    $0x1,%rsi\ncmp    %rsi,%rdi\nje     11a0 <func0+0x90>\nmov    (%rax,%rbx,4),%ecx\nmov    0x0(%rbp,%rsi,4),%edx\ncmp    %edx,%ecx\njle    11c0 <func0+0xb0>\nmov    %edx,(%rax,%rbx,4)\nmov    %ecx,0x0(%rbp,%rsi,4)\njmp    11c0 <func0+0xb0>\nxor    %r10d,%r10d\nmov    %r10d,(%r14)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 34,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdx,%r14\nmov    %esi,%ebp\nmov    %rdi,%r15\nmovslq %esi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\njle    11dd <func0+0xcd>\nmov    %ebp,%edx\nxor    %esi,%esi\nxor    %r10d,%r10d\njmp    1153 <func0+0x43>\nmovslq %r10d,%rcx\nadd    $0x1,%r10d\nmov    %edi,(%rax,%rcx,4)\nadd    $0x1,%rsi\ncmp    %rdx,%rsi\nje     1180 <func0+0x70>\nmov    (%r15,%rsi,4),%edi\ntest   %r10d,%r10d\njle    1140 <func0+0x30>\nmov    %r10d,%ebp\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\ncmp    (%rax,%rbx,4),%edi\nje     114a <func0+0x3a>\nadd    $0x1,%rbx\ncmp    %rbx,%rbp\njne    1170 <func0+0x60>\njmp    1140 <func0+0x30>\ncmp    $0x2,%r10d\njl     11e0 <func0+0xd0>\nlea    -0x1(%r10),%r8d\nmov    %r10d,%r9d\nxor    %r11d,%r11d\nmov    %r9,%rdi\nmov    %rax,%rbp\njmp    11ad <func0+0x9d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x4,%rbp\nadd    $0xffffffffffffffff,%rdi\ncmp    %r8,%r11\nje     11e0 <func0+0xd0>\nmov    %r11,%rbx\nadd    $0x1,%r11\ncmp    %r9,%r11\njae    11a0 <func0+0x90>\nmov    $0x1,%esi\njmp    11c9 <func0+0xb9>\nadd    $0x1,%rsi\ncmp    %rsi,%rdi\nje     11a0 <func0+0x90>\nmov    (%rax,%rbx,4),%ecx\nmov    0x0(%rbp,%rsi,4),%edx\ncmp    %edx,%ecx\njle    11c0 <func0+0xb0>\nmov    %edx,(%rax,%rbx,4)\nmov    %ecx,0x0(%rbp,%rsi,4)\njmp    11c0 <func0+0xb0>\nxor    %r10d,%r10d\nmov    %r10d,(%r14)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 35,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovss  0xeed(%rip),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    116b <func0+0x6b>\nmovss  -0x10(%rbp),%xmm1\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nucomiss %xmm1,%xmm0\njbe    1158 <func0+0x58>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmovss  %xmm0,-0x10(%rbp)\njmp    115d <func0+0x5d>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    111f <func0+0x1f>\nmovss  -0x10(%rbp),%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 35,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1126 <func0+0x26>\nmov    %esi,%eax\nmovss  0xef2(%rip),%xmm1\nxor    %ecx,%ecx\nmovss  (%rdi,%rcx,4),%xmm0\nmaxss  %xmm1,%xmm0\nadd    $0x1,%rcx\nmovaps %xmm0,%xmm1\ncmp    %rcx,%rax\njne    1110 <func0+0x10>\nret\nmovss  0xed2(%rip),%xmm0\nret\n"
    },
    {
        "task_id": 35,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1121 <func0+0x21>\nmov    %esi,%ecx\nlea    -0x1(%rcx),%rdx\nmov    %ecx,%eax\nand    $0x3,%eax\ncmp    $0x3,%rdx\njae    112a <func0+0x2a>\nmovss  0xee3(%rip),%xmm1\nxor    %edx,%edx\njmp    1170 <func0+0x70>\nmovss  0xed7(%rip),%xmm0\nret\nand    $0xfffffffc,%ecx\nmovss  0xecb(%rip),%xmm1\nxor    %edx,%edx\nnopw   0x0(%rax,%rax,1)\nmovss  (%rdi,%rdx,4),%xmm0\nmaxss  %xmm1,%xmm0\nmovss  0x4(%rdi,%rdx,4),%xmm1\nmaxss  %xmm0,%xmm1\nmovss  0x8(%rdi,%rdx,4),%xmm0\nmaxss  %xmm1,%xmm0\nmovss  0xc(%rdi,%rdx,4),%xmm1\nmaxss  %xmm0,%xmm1\nadd    $0x4,%rdx\ncmp    %rdx,%rcx\njne    1140 <func0+0x40>\nmovaps %xmm1,%xmm0\ntest   %rax,%rax\nje     1195 <func0+0x95>\nlea    (%rdi,%rdx,4),%rcx\nxor    %edx,%edx\nxchg   %ax,%ax\nmovss  (%rcx,%rdx,4),%xmm0\nmaxss  %xmm1,%xmm0\nadd    $0x1,%rdx\nmovaps %xmm0,%xmm1\ncmp    %rdx,%rax\njne    1180 <func0+0x80>\nret\n"
    },
    {
        "task_id": 35,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1121 <func0+0x21>\nmov    %esi,%ecx\nlea    -0x1(%rcx),%rdx\nmov    %ecx,%eax\nand    $0x3,%eax\ncmp    $0x3,%rdx\njae    112a <func0+0x2a>\nmovss  0xee3(%rip),%xmm1\nxor    %edx,%edx\njmp    1170 <func0+0x70>\nmovss  0xed7(%rip),%xmm0\nret\nand    $0xfffffffc,%ecx\nmovss  0xecb(%rip),%xmm1\nxor    %edx,%edx\nnopw   0x0(%rax,%rax,1)\nmovss  (%rdi,%rdx,4),%xmm0\nmaxss  %xmm1,%xmm0\nmovss  0x4(%rdi,%rdx,4),%xmm1\nmaxss  %xmm0,%xmm1\nmovss  0x8(%rdi,%rdx,4),%xmm0\nmaxss  %xmm1,%xmm0\nmovss  0xc(%rdi,%rdx,4),%xmm1\nmaxss  %xmm0,%xmm1\nadd    $0x4,%rdx\ncmp    %rdx,%rcx\njne    1140 <func0+0x40>\nmovaps %xmm1,%xmm0\ntest   %rax,%rax\nje     1195 <func0+0x95>\nlea    (%rdi,%rdx,4),%rcx\nxor    %edx,%edx\nxchg   %ax,%ax\nmovss  (%rcx,%rdx,4),%xmm0\nmaxss  %xmm1,%xmm0\nadd    $0x1,%rdx\nmovaps %xmm0,%xmm1\ncmp    %rdx,%rax\njne    1180 <func0+0x80>\nret\n"
    },
    {
        "task_id": 36,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    11a1 <func0+0xa1>\nmov    -0xc(%rbp),%eax\nmov    $0xb,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\nje     1149 <func0+0x49>\nmov    -0xc(%rbp),%eax\nmov    $0xd,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    118e <func0+0x8e>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njle    1189 <func0+0x89>\nmov    -0x10(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\ncmp    $0x7,%edx\njne    1176 <func0+0x76>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x10(%rbp)\njmp    114f <func0+0x4f>\njmp    118e <func0+0x8e>\njmp    1193 <func0+0x93>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    1115 <func0+0x15>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 36,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1187 <func0+0x87>\nxor    %r9d,%r9d\nxor    %eax,%eax\njmp    1119 <func0+0x19>\nnop\nadd    $0x1,%r9d\ncmp    %edi,%r9d\nje     1189 <func0+0x89>\nimul   $0xba2e8ba3,%r9d,%edx\ncmp    $0x1745d175,%edx\nsetae  %r8b\nimul   $0xc4ec4ec5,%r9d,%esi\ncmp    $0x13b13b14,%esi\nsetae  %dl\ntest   %dl,%r8b\njne    1110 <func0+0x10>\ntest   %r9d,%r9d\nje     1110 <func0+0x10>\nmov    %r9d,%edx\nnopw   0x0(%rax,%rax,1)\nmovslq %edx,%r10\nimul   $0x66666667,%r10,%rdx\nmov    %rdx,%rcx\nshr    $0x3f,%rcx\nsar    $0x22,%rdx\nadd    %ecx,%edx\nlea    (%rdx,%rdx,1),%ecx\nlea    (%rcx,%rcx,4),%r8d\nmov    %r10d,%ecx\nsub    %r8d,%ecx\nxor    %esi,%esi\ncmp    $0x7,%ecx\nsete   %sil\nadd    %esi,%eax\ncmp    $0x9,%r10d\njg     1150 <func0+0x50>\njmp    1110 <func0+0x10>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 36,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    118b <func0+0x8b>\nxor    %r10d,%r10d\nmov    $0xcccccccd,%r9d\nxor    %eax,%eax\njmp    1129 <func0+0x29>\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x1,%r10d\ncmp    %edi,%r10d\nje     118d <func0+0x8d>\nimul   $0xba2e8ba3,%r10d,%esi\ncmp    $0x1745d175,%esi\nsetae  %r8b\nimul   $0xc4ec4ec5,%r10d,%esi\ncmp    $0x13b13b14,%esi\nsetae  %dl\ntest   %dl,%r8b\njne    1120 <func0+0x20>\ntest   %r10d,%r10d\nje     1120 <func0+0x20>\nmov    %r10d,%r8d\nnopw   0x0(%rax,%rax,1)\nmov    %r8d,%edx\nimul   %r9,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,1),%ecx\nlea    (%rcx,%rcx,4),%ecx\nmov    %r8d,%esi\nsub    %ecx,%esi\nxor    %ecx,%ecx\ncmp    $0x7,%esi\nsete   %cl\nadd    %ecx,%eax\ncmp    $0x9,%r8d\nmov    %edx,%r8d\nja     1160 <func0+0x60>\njmp    1120 <func0+0x20>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 36,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    118b <func0+0x8b>\nxor    %r10d,%r10d\nmov    $0xcccccccd,%r9d\nxor    %eax,%eax\njmp    1129 <func0+0x29>\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x1,%r10d\ncmp    %edi,%r10d\nje     118d <func0+0x8d>\nimul   $0xba2e8ba3,%r10d,%esi\ncmp    $0x1745d175,%esi\nsetae  %r8b\nimul   $0xc4ec4ec5,%r10d,%esi\ncmp    $0x13b13b14,%esi\nsetae  %dl\ntest   %dl,%r8b\njne    1120 <func0+0x20>\ntest   %r10d,%r10d\nje     1120 <func0+0x20>\nmov    %r10d,%r8d\nnopw   0x0(%rax,%rax,1)\nmov    %r8d,%edx\nimul   %r9,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,1),%ecx\nlea    (%rcx,%rcx,4),%ecx\nmov    %r8d,%esi\nsub    %ecx,%esi\nxor    %ecx,%ecx\ncmp    $0x7,%esi\nsete   %cl\nadd    %ecx,%eax\ncmp    $0x9,%r8d\nmov    %edx,%r8d\nja     1160 <func0+0x60>\njmp    1120 <func0+0x20>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 37,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nadd    $0x1,%eax\nmovslq %eax,%rdi\nshl    $0x2,%rdi\ncall   1040 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    119d <func0+0x7d>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x20(%rbp),%rax\nmov    -0x2c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x2c(%rbp)\nmovslq %ecx,%rcx\nmovss  %xmm0,(%rax,%rcx,4)\nmov    -0x24(%rbp),%eax\nadd    $0x2,%eax\nmov    %eax,-0x24(%rbp)\njmp    115f <func0+0x3f>\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nmov    -0x2c(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    1262 <func0+0x142>\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nmov    -0x2c(%rbp),%ecx\nsub    -0x24(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    124f <func0+0x12f>\nmov    -0x20(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nucomiss (%rax,%rcx,4),%xmm0\njbe    123c <func0+0x11c>\nmov    -0x20(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmovss  %xmm0,-0x30(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x20(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovss  %xmm0,(%rax,%rcx,4)\nmovss  -0x30(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmovss  %xmm0,(%rax,%rcx,4)\njmp    1241 <func0+0x121>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    11bc <func0+0x9c>\njmp    1254 <func0+0x134>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    11a4 <func0+0x84>\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    12e9 <func0+0x1c9>\nmov    -0x24(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    12bc <func0+0x19c>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmov    -0x24(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x38(%rbp),%rax\nmovslq %ecx,%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x18(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovss  %xmm0,(%rax,%rcx,4)\njmp    12d6 <func0+0x1b6>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x18(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovss  %xmm0,(%rax,%rcx,4)\njmp    12db <func0+0x1bb>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1269 <func0+0x149>\nmov    -0x20(%rbp),%rdi\ncall   1030 <free@plt>\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 37,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%r12\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %esi,%eax\nsar    %eax\ncltq\nlea    0x4(,%rax,4),%rdi\ncall   1040 <malloc@plt>\ntest   %r15d,%r15d\njle    117b <func0+0x5b>\nlea    -0x1(%r15),%edx\nshr    %edx\nadd    $0x1,%edx\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nmovss  (%r12,%rcx,8),%xmm0\nmovss  %xmm0,(%rax,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rdx\njne    1160 <func0+0x40>\ncmp    $0x2,%ecx\njge    1182 <func0+0x62>\njmp    11d9 <func0+0xb9>\nxor    %ecx,%ecx\ncmp    $0x2,%ecx\njl     11d9 <func0+0xb9>\nlea    -0x1(%rcx),%r8d\nxor    %esi,%esi\nmov    %r8d,%edi\njmp    119b <func0+0x7b>\nnopl   (%rax)\nadd    $0x1,%esi\nadd    $0xffffffff,%edi\ncmp    %r8d,%esi\nje     11d9 <func0+0xb9>\nmov    %edi,%edi\nmov    %esi,%edx\nnot    %edx\nadd    %ecx,%edx\njle    1190 <func0+0x70>\nxor    %edx,%edx\njmp    11b8 <func0+0x98>\nnopl   0x0(%rax)\nmov    %rbx,%rdx\ncmp    %rbx,%rdi\nje     1190 <func0+0x70>\nmovss  (%rax,%rdx,4),%xmm0\nmovss  0x4(%rax,%rdx,4),%xmm1\nlea    0x1(%rdx),%rbx\nucomiss %xmm1,%xmm0\njbe    11b0 <func0+0x90>\nmovss  %xmm1,(%rax,%rdx,4)\nmovss  %xmm0,0x4(%rax,%rdx,4)\njmp    11b0 <func0+0x90>\ntest   %r15d,%r15d\njle    1217 <func0+0xf7>\nmov    %r15d,%ecx\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %edx,%esi\nand    $0xfffffffe,%esi\ntest   $0x1,%dl\nlea    (%rax,%rsi,2),%rsi\ncmovne %r12,%rsi\nmovss  (%rsi),%xmm0\nmovss  %xmm0,(%r14,%rdx,4)\nadd    $0x1,%rdx\nadd    $0x4,%r12\ncmp    %rdx,%rcx\njne    11f0 <func0+0xd0>\nmov    %rax,%rdi\ncall   1030 <free@plt>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 37,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%r12\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %esi,%eax\nsar    %eax\ncltq\nlea    0x4(,%rax,4),%rdi\ncall   1040 <malloc@plt>\ntest   %r15d,%r15d\njle    1301 <func0+0x1e1>\nlea    -0x1(%r15),%edx\nmov    %edx,%r8d\nshr    %r8d\nlea    0x1(%r8),%esi\ncmp    $0xf,%edx\nja     116b <func0+0x4b>\nxor    %edi,%edi\nxor    %ecx,%ecx\njmp    11c1 <func0+0xa1>\nmov    %esi,%ecx\nand    $0x7,%ecx\ntest   %rcx,%rcx\nmov    $0x8,%ebx\ncmovne %rcx,%rbx\nmov    %rsi,%rdi\nsub    %rbx,%rdi\nlea    (%rdi,%rdi,1),%rcx\nxor    %ebx,%ebx\nnopl   0x0(%rax,%rax,1)\nmovups (%r12,%rbx,8),%xmm0\nmovups 0x10(%r12,%rbx,8),%xmm1\nshufps $0x88,%xmm1,%xmm0\nmovups 0x20(%r12,%rbx,8),%xmm1\nmovups 0x30(%r12,%rbx,8),%xmm2\nshufps $0x88,%xmm2,%xmm1\nmovups %xmm0,(%rax,%rbx,4)\nmovups %xmm1,0x10(%rax,%rbx,4)\nadd    $0x8,%rbx\ncmp    %rbx,%rdi\njne    1190 <func0+0x70>\nlea    (%rax,%rdi,4),%rbx\nsub    %rdi,%rsi\nlea    (%r12,%rcx,4),%rcx\nxor    %edi,%edi\nxchg   %ax,%ax\nmovss  (%rcx,%rdi,8),%xmm0\nmovss  %xmm0,(%rbx,%rdi,4)\nadd    $0x1,%rdi\ncmp    %rdi,%rsi\njne    11d0 <func0+0xb0>\ncmp    $0x2,%edx\njae    1205 <func0+0xe5>\ntest   %r15d,%r15d\njle    1301 <func0+0x1e1>\nmov    %r15d,%edx\ncmp    $0x1,%r15d\njne    12a7 <func0+0x187>\nxor    %ecx,%ecx\njmp    12de <func0+0x1be>\nxor    %edx,%edx\nmov    %r8d,%esi\njmp    121b <func0+0xfb>\nnopl   0x0(%rax)\nadd    $0x1,%edx\nadd    $0xffffffff,%esi\ncmp    %r8d,%edx\nje     11e8 <func0+0xc8>\nmov    %esi,%esi\ncmp    %edx,%r8d\njbe    1210 <func0+0xf0>\nmovss  (%rax),%xmm0\ncmp    $0x1,%esi\njne    1250 <func0+0x130>\nxor    %ebx,%ebx\ntest   $0x1,%sil\nje     1210 <func0+0xf0>\nmovss  0x4(%rax,%rbx,4),%xmm1\nucomiss %xmm1,%xmm0\njbe    1210 <func0+0xf0>\nmovss  %xmm1,(%rax,%rbx,4)\nmovss  %xmm0,0x4(%rax,%rbx,4)\njmp    1210 <func0+0xf0>\nnopl   0x0(%rax,%rax,1)\nmov    %esi,%edi\nand    $0xfffffffe,%edi\nxor    %ecx,%ecx\njmp    1274 <func0+0x154>\nnopl   0x0(%rax)\nmovss  %xmm1,0x4(%rax,%rcx,4)\nmovss  %xmm0,0x8(%rax,%rcx,4)\nmov    %rbx,%rcx\ncmp    %rbx,%rdi\nje     122d <func0+0x10d>\nmovss  0x4(%rax,%rcx,4),%xmm1\nucomiss %xmm1,%xmm0\njbe    1290 <func0+0x170>\nmovss  %xmm1,(%rax,%rcx,4)\nmovss  %xmm0,0x4(%rax,%rcx,4)\njmp    1293 <func0+0x173>\nnopl   0x0(%rax)\nmovaps %xmm1,%xmm0\nlea    0x2(%rcx),%rbx\nmovss  0x8(%rax,%rcx,4),%xmm1\nucomiss %xmm1,%xmm0\nja     1260 <func0+0x140>\nmovaps %xmm1,%xmm0\njmp    126c <func0+0x14c>\nmov    %edx,%esi\nand    $0xfffffffe,%esi\nxor    %ebx,%ebx\nxor    %ecx,%ecx\nmov    %ebx,%edi\nand    $0x7fffffff,%edi\nmovss  (%rax,%rdi,4),%xmm0\nmovss  %xmm0,(%r14,%rcx,4)\nmovss  0x4(%r12,%rcx,4),%xmm0\nmovss  %xmm0,0x4(%r14,%rcx,4)\nadd    $0x2,%rcx\nadd    $0x1,%rbx\ncmp    %rcx,%rsi\njne    12b0 <func0+0x190>\ntest   $0x1,%dl\nje     1301 <func0+0x1e1>\nmov    %ecx,%edx\nand    $0xfffffffe,%edx\ntest   $0x1,%cl\nlea    (%rax,%rdx,2),%rdx\nlea    (%r12,%rcx,4),%rsi\ncmove  %rdx,%rsi\nmovss  (%rsi),%xmm0\nmovss  %xmm0,(%r14,%rcx,4)\nmov    %rax,%rdi\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\njmp    1030 <free@plt>\n"
    },
    {
        "task_id": 37,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%r12\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %esi,%eax\nsar    %eax\ncltq\nlea    0x4(,%rax,4),%rdi\ncall   1040 <malloc@plt>\ntest   %r15d,%r15d\njle    1321 <func0+0x201>\nlea    -0x1(%r15),%edx\nmov    %edx,%r8d\nshr    %r8d\nlea    0x1(%r8),%esi\ncmp    $0xf,%edx\nja     116b <func0+0x4b>\nxor    %edi,%edi\nxor    %ecx,%ecx\njmp    11c1 <func0+0xa1>\nmov    %esi,%ecx\nand    $0x7,%ecx\ntest   %rcx,%rcx\nmov    $0x8,%ebx\ncmovne %rcx,%rbx\nmov    %rsi,%rdi\nsub    %rbx,%rdi\nlea    (%rdi,%rdi,1),%rcx\nxor    %ebx,%ebx\nnopl   0x0(%rax,%rax,1)\nmovups (%r12,%rbx,8),%xmm0\nmovups 0x10(%r12,%rbx,8),%xmm1\nshufps $0x88,%xmm1,%xmm0\nmovups 0x20(%r12,%rbx,8),%xmm1\nmovups 0x30(%r12,%rbx,8),%xmm2\nshufps $0x88,%xmm2,%xmm1\nmovups %xmm0,(%rax,%rbx,4)\nmovups %xmm1,0x10(%rax,%rbx,4)\nadd    $0x8,%rbx\ncmp    %rbx,%rdi\njne    1190 <func0+0x70>\nlea    (%rax,%rdi,4),%rbx\nsub    %rdi,%rsi\nlea    (%r12,%rcx,4),%rcx\nxor    %edi,%edi\nxchg   %ax,%ax\nmovss  (%rcx,%rdi,8),%xmm0\nmovss  %xmm0,(%rbx,%rdi,4)\nadd    $0x1,%rdi\ncmp    %rdi,%rsi\njne    11d0 <func0+0xb0>\ncmp    $0x2,%edx\njae    1205 <func0+0xe5>\ntest   %r15d,%r15d\njle    1321 <func0+0x201>\nmov    %r15d,%edx\ncmp    $0x1,%r15d\njne    12c6 <func0+0x1a6>\nxor    %ecx,%ecx\njmp    12fe <func0+0x1de>\nxor    %edx,%edx\nmov    %r8d,%esi\njmp    121b <func0+0xfb>\nnopl   0x0(%rax)\nadd    $0x1,%edx\nadd    $0xffffffff,%esi\ncmp    %r8d,%edx\nje     11e8 <func0+0xc8>\nmov    %esi,%esi\ncmp    %edx,%r8d\njbe    1210 <func0+0xf0>\nmovss  (%rax),%xmm0\ncmp    $0x1,%esi\njne    1230 <func0+0x110>\nxor    %ebx,%ebx\njmp    129d <func0+0x17d>\nnop\nmov    %esi,%edi\nand    $0xfffffffe,%edi\nxor    %ecx,%ecx\njmp    1254 <func0+0x134>\nnopl   0x0(%rax)\nmovss  %xmm1,0x4(%rax,%rcx,4)\nmovss  %xmm0,0x8(%rax,%rcx,4)\nmov    %rbx,%rcx\ncmp    %rbx,%rdi\nje     129d <func0+0x17d>\nmovss  0x4(%rax,%rcx,4),%xmm1\nucomiss %xmm1,%xmm0\njbe    1280 <func0+0x160>\nmovss  %xmm1,(%rax,%rcx,4)\nmovss  %xmm0,0x4(%rax,%rcx,4)\nlea    0x2(%rcx),%rbx\nmovss  0x8(%rax,%rcx,4),%xmm1\nucomiss %xmm1,%xmm0\nja     1240 <func0+0x120>\njmp    1292 <func0+0x172>\nnopl   0x0(%rax,%rax,1)\nmovaps %xmm1,%xmm0\nlea    0x2(%rcx),%rbx\nmovss  0x8(%rax,%rcx,4),%xmm1\nucomiss %xmm1,%xmm0\nja     1240 <func0+0x120>\nmovaps %xmm1,%xmm0\nmov    %rbx,%rcx\ncmp    %rbx,%rdi\njne    1254 <func0+0x134>\ntest   $0x1,%sil\nje     1210 <func0+0xf0>\nmovss  0x4(%rax,%rbx,4),%xmm1\nucomiss %xmm1,%xmm0\njbe    1210 <func0+0xf0>\nmovss  %xmm1,(%rax,%rbx,4)\nmovss  %xmm0,0x4(%rax,%rbx,4)\njmp    1210 <func0+0xf0>\nmov    %edx,%esi\nand    $0xfffffffe,%esi\nxor    %ebx,%ebx\nxor    %ecx,%ecx\nnop\nmov    %ebx,%edi\nand    $0x7fffffff,%edi\nmovss  (%rax,%rdi,4),%xmm0\nmovss  %xmm0,(%r14,%rcx,4)\nmovss  0x4(%r12,%rcx,4),%xmm0\nmovss  %xmm0,0x4(%r14,%rcx,4)\nadd    $0x2,%rcx\nadd    $0x1,%rbx\ncmp    %rcx,%rsi\njne    12d0 <func0+0x1b0>\ntest   $0x1,%dl\nje     1321 <func0+0x201>\nmov    %ecx,%edx\nand    $0xfffffffe,%edx\ntest   $0x1,%cl\nlea    (%rax,%rdx,2),%rdx\nlea    (%r12,%rcx,4),%rsi\ncmove  %rdx,%rsi\nmovss  (%rsi),%xmm0\nmovss  %xmm0,(%r14,%rcx,4)\nmov    %rax,%rdi\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\njmp    1030 <free@plt>\n"
    },
    {
        "task_id": 38,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1040 <strlen@plt>\nmov    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nadd    $0x2,%eax\nmov    $0x3,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1227 <func0+0x107>\nimul   $0x3,-0x1c(%rbp),%eax\nadd    $0x3,%eax\ncmp    -0x10(%rbp),%eax\njg     117c <func0+0x5c>\nmov    $0x3,%eax\nmov    %eax,-0x28(%rbp)\njmp    1188 <func0+0x68>\nmov    -0x10(%rbp),%eax\nimul   $0x3,-0x1c(%rbp),%ecx\nsub    %ecx,%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nlea    -0x18(%rbp),%rdi\nmov    -0x8(%rbp),%rsi\nimul   $0x3,-0x1c(%rbp),%eax\ncltq\nadd    %rax,%rsi\nmovslq -0x20(%rbp),%rdx\ncall   1030 <strncpy@plt>\nmovslq -0x20(%rbp),%rax\nmovb   $0x0,-0x18(%rbp,%rax,1)\ncmpl   $0x3,-0x20(%rbp)\njne    11ff <func0+0xdf>\ncmpl   $0x0,-0xc(%rbp)\nje     11e2 <func0+0xc2>\nmov    -0x16(%rbp),%al\nmov    %al,-0x21(%rbp)\nmov    -0x17(%rbp),%al\nmov    %al,-0x16(%rbp)\nmov    -0x18(%rbp),%al\nmov    %al,-0x17(%rbp)\nmov    -0x21(%rbp),%al\nmov    %al,-0x18(%rbp)\njmp    11fa <func0+0xda>\nmov    -0x18(%rbp),%al\nmov    %al,-0x22(%rbp)\nmov    -0x17(%rbp),%al\nmov    %al,-0x18(%rbp)\nmov    -0x16(%rbp),%al\nmov    %al,-0x17(%rbp)\nmov    -0x22(%rbp),%al\nmov    %al,-0x16(%rbp)\njmp    11ff <func0+0xdf>\nmov    -0x8(%rbp),%rdi\nimul   $0x3,-0x1c(%rbp),%eax\ncltq\nadd    %rax,%rdi\nlea    -0x18(%rbp),%rsi\nmovslq -0x20(%rbp),%rdx\ncall   1030 <strncpy@plt>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1153 <func0+0x33>\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 38,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %esi,0x8(%rsp)\nmov    %rdi,0x20(%rsp)\ncall   1040 <strlen@plt>\nmov    %rax,0x10(%rsp)\ntest   %eax,%eax\njle    1238 <func0+0x118>\nmov    0x10(%rsp),%rax\nadd    $0x2,%eax\ncltq\nimul   $0x55555556,%rax,%rax\nmov    %rax,%rcx\nshr    $0x3f,%rcx\nshr    $0x20,%rax\nadd    %ecx,%eax\ncmp    $0x2,%eax\nmov    $0x1,%ecx\ncmovge %eax,%ecx\nlea    (%rcx,%rcx,2),%rax\nmov    %rax,0x18(%rsp)\nmov    $0x3,%eax\nxor    %r15d,%r15d\nlea    0x4(%rsp),%r14\nxor    %r12d,%r12d\njmp    11c4 <func0+0xa4>\nmovzbl 0x4(%rsp),%eax\nmovzwl 0x5(%rsp),%ecx\nmov    %cx,0x4(%rsp)\nmov    %al,0x6(%rsp)\nmov    %rbx,%rbp\nmov    %edi,%ebx\nmov    %rbp,%rdi\nmov    %r14,%rsi\ncall   1030 <strncpy@plt>\nadd    $0x3,%r12\nadd    $0x3,%ebx\nadd    $0xfffffffd,%r15d\ncmp    %r12,0x18(%rsp)\nmov    %ebx,%eax\nje     1238 <func0+0x118>\nmov    %eax,0xc(%rsp)\nmov    0x10(%rsp),%r13\ncmp    %r13d,%eax\ncmovl  %eax,%r13d\nlea    (%r15,%r13,1),%eax\nadd    $0xfffffffd,%r13d\nmov    0x20(%rsp),%rcx\nlea    (%rcx,%r12,1),%rbp\nmovslq %eax,%rbx\nmov    %r14,%rdi\nmov    %rbp,%rsi\nmov    %rbx,%rdx\ncall   1030 <strncpy@plt>\nmov    %rbx,%rdx\nmov    0xc(%rsp),%ebx\nmovb   $0x0,0x4(%rsp,%rdx,1)\ncmp    %r12d,%r13d\njne    11a5 <func0+0x85>\nmov    %ebx,%edi\nmov    %rbp,%rbx\ncmpl   $0x0,0x8(%rsp)\nje     118d <func0+0x6d>\nmovzbl 0x6(%rsp),%esi\nmovzbl 0x4(%rsp),%ecx\nmovzbl 0x5(%rsp),%eax\nmov    %al,0x6(%rsp)\nmov    %cl,0x5(%rsp)\nmov    %sil,0x4(%rsp)\njmp    11a0 <func0+0x80>\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 38,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %esi,0x4(%rsp)\nmov    %rdi,%rbx\ncall   1040 <strlen@plt>\nmov    %rax,0x8(%rsp)\ntest   %eax,%eax\njle    11f6 <func0+0xd6>\nmov    0x8(%rsp),%rax\nadd    $0x2,%eax\nmov    $0xaaaaaaab,%ecx\nimul   %rax,%rcx\nshr    $0x21,%rcx\nmov    $0x3,%r14d\nxor    %r15d,%r15d\nmov    %rsp,%r13\njmp    11a5 <func0+0x85>\nmovzbl (%rsp),%eax\nmovzwl 0x1(%rsp),%ecx\nmov    %cx,(%rsp)\nmov    %al,0x2(%rsp)\nnopl   0x0(%rax,%rax,1)\nmov    %rbx,%rdi\nmov    %r13,%rsi\nmov    %rbp,%rdx\ncall   1030 <strncpy@plt>\nadd    $0x3,%r14d\nadd    $0x3,%rbx\nadd    $0xfffffffd,%r15d\nmov    0x10(%rsp),%rcx\nadd    $0xffffffffffffffff,%rcx\nje     11f6 <func0+0xd6>\nmov    %rcx,0x10(%rsp)\nmov    0x8(%rsp),%r12\ncmp    %r12d,%r14d\ncmovl  %r14d,%r12d\nlea    (%r12,%r15,1),%eax\nmovslq %eax,%rbp\nmov    %r13,%rdi\nmov    %rbx,%rsi\nmov    %rbp,%rdx\ncall   1030 <strncpy@plt>\nmovb   $0x0,(%rsp,%rbp,1)\ncmp    %r14d,%r12d\njne    1180 <func0+0x60>\ncmpl   $0x0,0x4(%rsp)\nje     116a <func0+0x4a>\nmovzbl 0x2(%rsp),%eax\nmovzbl (%rsp),%ecx\nmovzbl 0x1(%rsp),%edx\nmov    %dl,0x2(%rsp)\nmov    %cl,0x1(%rsp)\nmov    %al,(%rsp)\njmp    1180 <func0+0x60>\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 38,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %esi,%ebp\nmov    %rdi,0x18(%rsp)\ncall   1040 <strlen@plt>\nmov    %rax,0x10(%rsp)\ntest   %eax,%eax\njle    12af <func0+0x18f>\nmov    0x10(%rsp),%rax\nadd    $0x2,%eax\ncltq\nimul   $0x55555556,%rax,%rcx\nmov    %rcx,%rax\nshr    $0x3f,%rax\nshr    $0x20,%rcx\nadd    %eax,%ecx\ncmp    $0x2,%ecx\nmov    $0x1,%eax\ncmovge %ecx,%eax\nlea    (%rax,%rax,2),%rax\ntest   %ebp,%ebp\nje     121e <func0+0xfe>\nmov    %rax,0x8(%rsp)\nmov    $0x3,%r14d\nxor    %r13d,%r13d\nlea    0x4(%rsp),%rdi\nxor    %r15d,%r15d\njmp    11cd <func0+0xad>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %r12,%rdi\nlea    0x4(%rsp),%rbx\nmov    %rbx,%rsi\nmov    %rbp,%rdx\ncall   1030 <strncpy@plt>\nmov    %rbx,%rdi\nadd    $0x3,%r15\nadd    $0x3,%r14d\nadd    $0xfffffffd,%r13d\ncmp    %r15,0x8(%rsp)\nje     12af <func0+0x18f>\nmov    0x10(%rsp),%rbx\ncmp    %ebx,%r14d\ncmovl  %r14d,%ebx\nlea    (%rbx,%r13,1),%eax\nadd    $0xfffffffd,%ebx\nmov    0x18(%rsp),%rcx\nlea    (%rcx,%r15,1),%r12\nmovslq %eax,%rbp\nmov    %r12,%rsi\nmov    %rbp,%rdx\ncall   1030 <strncpy@plt>\nmovb   $0x0,0x4(%rsp,%rbp,1)\ncmp    %r15d,%ebx\njne    11a0 <func0+0x80>\nmovzbl 0x6(%rsp),%eax\nmovzbl 0x4(%rsp),%ecx\nmovzbl 0x5(%rsp),%edx\nmov    %dl,0x6(%rsp)\nmov    %cl,0x5(%rsp)\nmov    %al,0x4(%rsp)\njmp    11a0 <func0+0x80>\nmov    %rax,0x20(%rsp)\nmov    $0x3,%ebp\nxor    %r14d,%r14d\nlea    0x4(%rsp),%r12\nxor    %r15d,%r15d\njmp    1260 <func0+0x140>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %r13,%rdi\nmov    %r12,%rsi\nmov    %rbx,%rdx\ncall   1030 <strncpy@plt>\nadd    $0x3,%r15\nadd    $0x3,%ebp\nadd    $0xfffffffd,%r14d\ncmp    %r15,0x20(%rsp)\nje     12af <func0+0x18f>\nmov    0x10(%rsp),%rax\ncmp    %eax,%ebp\ncmovl  %ebp,%eax\nlea    -0x3(%rax),%ecx\nmov    %ecx,0x8(%rsp)\nadd    %r14d,%eax\nmov    0x18(%rsp),%rcx\nlea    (%rcx,%r15,1),%r13\nmovslq %eax,%rbx\nmov    %r12,%rdi\nmov    %r13,%rsi\nmov    %rbx,%rdx\ncall   1030 <strncpy@plt>\nmovb   $0x0,0x4(%rsp,%rbx,1)\ncmp    %r15d,0x8(%rsp)\njne    1240 <func0+0x120>\nmovzbl 0x4(%rsp),%eax\nmovzwl 0x5(%rsp),%ecx\nmov    %cx,0x4(%rsp)\nmov    %al,0x6(%rsp)\njmp    1240 <func0+0x120>\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 39,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x8(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x2,-0x10(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    11bf <func0+0xbf>\nmov    -0xc(%rbp),%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmovl   $0x1,-0x1c(%rbp)\nmovl   $0x2,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nimul   -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njg     1190 <func0+0x90>\nmov    -0xc(%rbp),%eax\ncltd\nidivl  -0x20(%rbp)\ncmp    $0x0,%edx\njne    117d <func0+0x7d>\nmovl   $0x0,-0x1c(%rbp)\njmp    1190 <func0+0x90>\njmp    1182 <func0+0x82>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1151 <func0+0x51>\ncmpl   $0x0,-0x1c(%rbp)\nje     11a3 <func0+0xa3>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njne    11ba <func0+0xba>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\njmp    11c6 <func0+0xc6>\njmp    111c <func0+0x1c>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 39,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %r10d,%r10d\nmov    $0x2,%r11d\nmov    $0x1,%r9d\njmp    113b <func0+0x3b>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %r9d,%eax\nadd    %r11d,%eax\nmovzbl %cl,%ecx\nadd    %ecx,%r10d\ncmp    %edi,%r10d\ncmove  %r11d,%r8d\nmov    %r11d,%r9d\nmov    %eax,%r11d\nje     117c <func0+0x7c>\ncmp    %edi,%r10d\njge    1180 <func0+0x80>\ncmp    $0x4,%r11d\nsetl   %cl\njl     1120 <func0+0x20>\nmov    %r11d,%eax\nand    $0x1,%eax\nje     1120 <func0+0x20>\nmov    $0x3,%esi\ncs nopw 0x0(%rax,%rax,1)\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %r11d,%eax\nsetg   %cl\njg     1120 <func0+0x20>\nmov    %r11d,%eax\ncltd\nidiv   %esi\nadd    $0x1,%esi\ntest   %edx,%edx\njne    1160 <func0+0x60>\njmp    1120 <func0+0x20>\nmov    %r8d,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 39,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %r9d,%r9d\nmov    $0x2,%eax\nmov    $0x1,%r8d\njmp    1128 <func0+0x28>\ntest   %edx,%edx\nsetne  %dl\nmov    %r8d,%eax\nadd    %ecx,%eax\nmovzbl %dl,%edx\nadd    %edx,%r9d\nmov    %ecx,%r8d\ncmp    %edi,%r9d\nje     1157 <func0+0x57>\ncmp    %edi,%r9d\njge    115a <func0+0x5a>\nmov    %eax,%ecx\nmov    $0x1,%dl\ncmp    $0x4,%eax\njl     1115 <func0+0x15>\nmov    $0x2,%esi\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1110 <func0+0x10>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1140 <func0+0x40>\njmp    1110 <func0+0x10>\nmov    %ecx,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 39,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %r9d,%r9d\nmov    $0x2,%eax\nmov    $0x1,%r8d\njmp    1128 <func0+0x28>\ntest   %edx,%edx\nsetne  %dl\nmov    %r8d,%eax\nadd    %ecx,%eax\nmovzbl %dl,%edx\nadd    %edx,%r9d\nmov    %ecx,%r8d\ncmp    %edi,%r9d\nje     1157 <func0+0x57>\ncmp    %edi,%r9d\njge    115a <func0+0x5a>\nmov    %eax,%ecx\nmov    $0x1,%dl\ncmp    $0x4,%eax\njl     1115 <func0+0x15>\nmov    $0x2,%esi\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1110 <func0+0x10>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1140 <func0+0x40>\njmp    1110 <func0+0x10>\nmov    %ecx,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 40,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11b4 <func0+0xb4>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11a1 <func0+0xa1>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    118e <func0+0x8e>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x10(%rbp),%rcx\nmovslq -0x1c(%rbp),%rdx\nadd    (%rcx,%rdx,4),%eax\nmov    -0x10(%rbp),%rcx\nmovslq -0x20(%rbp),%rdx\nadd    (%rcx,%rdx,4),%eax\ncmp    $0x0,%eax\njne    117b <func0+0x7b>\nmovb   $0x1,-0x1(%rbp)\njmp    11b8 <func0+0xb8>\njmp    1180 <func0+0x80>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    113c <func0+0x3c>\njmp    1193 <func0+0x93>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1127 <func0+0x27>\njmp    11a6 <func0+0xa6>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1112 <func0+0x12>\nmovb   $0x0,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 40,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nxor    %r12d,%r12d\ntest   %esi,%esi\nmov    $0x0,%eax\ncmovg  %esi,%eax\nmov    %rax,-0x18(%rsp)\nmov    %esi,%r13d\nlea    0x4(%rdi),%rax\nmov    %rax,-0x8(%rsp)\nmov    $0x2,%eax\nmov    $0x1,%r11d\nmov    $0x3,%r14d\njmp    1162 <func0+0x62>\nnopl   0x0(%rax,%rax,1)\nmov    $0x5,%ebp\nmov    -0x1c(%rsp),%eax\nadd    $0x1,%eax\nadd    $0x1,%r11\nadd    $0x1,%r14d\nmov    -0x10(%rsp),%r12\ncmp    $0x5,%ebp\njne    11fd <func0+0xfd>\ncmp    -0x18(%rsp),%r12\nje     11f8 <func0+0xf8>\nlea    0x1(%r12),%rcx\nmov    %rcx,-0x10(%rsp)\nmov    %r14d,%r15d\nmov    %r11,%rdx\nmov    %eax,-0x1c(%rsp)\nmov    %eax,%ebx\njmp    11a0 <func0+0xa0>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    $0x1,%ebp\nadd    $0x1,%ebx\nadd    $0x1,%r15d\ntest   %cl,%cl\njne    1145 <func0+0x45>\ncmp    %r13,%rdx\nje     1140 <func0+0x40>\nmov    %rdx,%rax\nmov    %ebx,%ebx\nadd    $0x1,%rdx\nmov    $0x8,%ebp\ncmp    %esi,%edx\nsetl   %cl\njge    1195 <func0+0x95>\nmov    (%rdi,%rax,4),%r8d\nadd    (%rdi,%r12,4),%r8d\nmov    (%rdi,%rbx,4),%eax\nadd    %r8d,%eax\nje     1190 <func0+0x90>\nmov    -0x8(%rsp),%rax\nlea    (%rax,%rbx,4),%r9\nmov    %r15d,%eax\ncs nopw 0x0(%rax,%rax,1)\ncmp    %esi,%eax\nsetl   %cl\njge    1195 <func0+0x95>\nmov    (%r9),%r10d\nadd    $0x4,%r9\nadd    $0x1,%eax\nadd    %r8d,%r10d\njne    11e0 <func0+0xe0>\njmp    1190 <func0+0x90>\nmov    $0x2,%ebp\ncmp    $0x2,%ebp\nsetne  %al\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 40,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\ntest   %esi,%esi\njle    1186 <func0+0x86>\nmov    %esi,%r8d\nmov    $0x1,%al\nmov    $0x2,%r14d\nmov    $0x1,%r15d\nxor    %r9d,%r9d\nmov    %eax,%r10d\nmov    %r9,%r11\nadd    $0x1,%r9\nmov    %r15,%r12\nmov    %r14,%rcx\ncmp    %r8,%r9\nsetb   %al\njb     1159 <func0+0x59>\nadd    $0x1,%r14\nadd    $0x1,%r15\ncmp    %r8,%r9\njne    1120 <func0+0x20>\njmp    1188 <func0+0x88>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rcx\ncmp    %r8,%r12\nje     1138 <func0+0x38>\nmov    %r12,%rdx\nadd    $0x1,%r12\ncmp    %esi,%r12d\njge    1150 <func0+0x50>\nmov    (%rdi,%rdx,4),%ebp\nadd    (%rdi,%r11,4),%ebp\nmov    %rcx,%rdx\nnop\nmov    (%rdi,%rdx,4),%ebx\nadd    %ebp,%ebx\nje     1181 <func0+0x81>\nadd    $0x1,%rdx\ncmp    %esi,%edx\njl     1170 <func0+0x70>\njmp    1150 <func0+0x50>\nmov    %r10d,%eax\njmp    1188 <func0+0x88>\nxor    %eax,%eax\nand    $0x1,%al\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 40,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\ntest   %esi,%esi\njle    1186 <func0+0x86>\nmov    %esi,%r8d\nmov    $0x1,%al\nmov    $0x2,%r14d\nmov    $0x1,%r15d\nxor    %r9d,%r9d\nmov    %eax,%r10d\nmov    %r9,%r11\nadd    $0x1,%r9\nmov    %r15,%r12\nmov    %r14,%rcx\ncmp    %r8,%r9\nsetb   %al\njb     1159 <func0+0x59>\nadd    $0x1,%r14\nadd    $0x1,%r15\ncmp    %r8,%r9\njne    1120 <func0+0x20>\njmp    1188 <func0+0x88>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rcx\ncmp    %r8,%r12\nje     1138 <func0+0x38>\nmov    %r12,%rdx\nadd    $0x1,%r12\ncmp    %esi,%r12d\njge    1150 <func0+0x50>\nmov    (%rdi,%rdx,4),%ebp\nadd    (%rdi,%r11,4),%ebp\nmov    %rcx,%rdx\nnop\nmov    (%rdi,%rdx,4),%ebx\nadd    %ebp,%ebx\nje     1181 <func0+0x81>\nadd    $0x1,%rdx\ncmp    %esi,%edx\njl     1170 <func0+0x70>\njmp    1150 <func0+0x50>\nmov    %r10d,%eax\njmp    1188 <func0+0x88>\nxor    %eax,%eax\nand    $0x1,%al\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 41,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 41,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\nimul   %edi,%eax\nret\n"
    },
    {
        "task_id": 41,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\nimul   %edi,%eax\nret\n"
    },
    {
        "task_id": 41,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\nimul   %edi,%eax\nret\n"
    },
    {
        "task_id": 42,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    113d <func0+0x3d>\nmov    -0x8(%rbp),%rax\nmovslq -0x10(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nadd    $0x1,%edx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    1112 <func0+0x12>\npop    %rbp\nret\n"
    },
    {
        "task_id": 42,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    111d <func0+0x1d>\nmov    %esi,%eax\nxor    %ecx,%ecx\nnopl   0x0(%rax,%rax,1)\naddl   $0x1,(%rdi,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1110 <func0+0x10>\nret\n"
    },
    {
        "task_id": 42,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    11cd <func0+0xcd>\nmov    %esi,%eax\ncmp    $0x8,%esi\njae    1116 <func0+0x16>\nxor    %ecx,%ecx\njmp    11c0 <func0+0xc0>\nmov    %eax,%ecx\nand    $0xfffffff8,%ecx\nlea    -0x8(%rcx),%rdx\nmov    %rdx,%r8\nshr    $0x3,%r8\nadd    $0x1,%r8\ntest   %rdx,%rdx\nje     11ce <func0+0xce>\nmov    %r8,%rsi\nand    $0xfffffffffffffffe,%rsi\nxor    %edx,%edx\npcmpeqd %xmm0,%xmm0\nmovdqu (%rdi,%rdx,4),%xmm1\nmovdqu 0x10(%rdi,%rdx,4),%xmm2\nmovdqu 0x20(%rdi,%rdx,4),%xmm3\nmovdqu 0x30(%rdi,%rdx,4),%xmm4\npsubd  %xmm0,%xmm1\npsubd  %xmm0,%xmm2\nmovdqu %xmm1,(%rdi,%rdx,4)\nmovdqu %xmm2,0x10(%rdi,%rdx,4)\npsubd  %xmm0,%xmm3\npsubd  %xmm0,%xmm4\nmovdqu %xmm3,0x20(%rdi,%rdx,4)\nmovdqu %xmm4,0x30(%rdi,%rdx,4)\nadd    $0x10,%rdx\nadd    $0xfffffffffffffffe,%rsi\njne    1140 <func0+0x40>\ntest   $0x1,%r8b\nje     11b0 <func0+0xb0>\nmovdqu (%rdi,%rdx,4),%xmm0\nmovdqu 0x10(%rdi,%rdx,4),%xmm1\npcmpeqd %xmm2,%xmm2\npsubd  %xmm2,%xmm0\npsubd  %xmm2,%xmm1\nmovdqu %xmm0,(%rdi,%rdx,4)\nmovdqu %xmm1,0x10(%rdi,%rdx,4)\ncmp    %rax,%rcx\nje     11cd <func0+0xcd>\ncs nopw 0x0(%rax,%rax,1)\nnop\naddl   $0x1,(%rdi,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    11c0 <func0+0xc0>\nret\nxor    %edx,%edx\ntest   $0x1,%r8b\njne    118e <func0+0x8e>\njmp    11b0 <func0+0xb0>\n"
    },
    {
        "task_id": 42,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    11cd <func0+0xcd>\nmov    %esi,%eax\ncmp    $0x8,%esi\njae    1116 <func0+0x16>\nxor    %ecx,%ecx\njmp    11c0 <func0+0xc0>\nmov    %eax,%ecx\nand    $0xfffffff8,%ecx\nlea    -0x8(%rcx),%rdx\nmov    %rdx,%r8\nshr    $0x3,%r8\nadd    $0x1,%r8\ntest   %rdx,%rdx\nje     11ce <func0+0xce>\nmov    %r8,%rsi\nand    $0xfffffffffffffffe,%rsi\nxor    %edx,%edx\npcmpeqd %xmm0,%xmm0\nmovdqu (%rdi,%rdx,4),%xmm1\nmovdqu 0x10(%rdi,%rdx,4),%xmm2\nmovdqu 0x20(%rdi,%rdx,4),%xmm3\nmovdqu 0x30(%rdi,%rdx,4),%xmm4\npsubd  %xmm0,%xmm1\npsubd  %xmm0,%xmm2\nmovdqu %xmm1,(%rdi,%rdx,4)\nmovdqu %xmm2,0x10(%rdi,%rdx,4)\npsubd  %xmm0,%xmm3\npsubd  %xmm0,%xmm4\nmovdqu %xmm3,0x20(%rdi,%rdx,4)\nmovdqu %xmm4,0x30(%rdi,%rdx,4)\nadd    $0x10,%rdx\nadd    $0xfffffffffffffffe,%rsi\njne    1140 <func0+0x40>\ntest   $0x1,%r8b\nje     11b0 <func0+0xb0>\nmovdqu (%rdi,%rdx,4),%xmm0\nmovdqu 0x10(%rdi,%rdx,4),%xmm1\npcmpeqd %xmm2,%xmm2\npsubd  %xmm2,%xmm0\npsubd  %xmm2,%xmm1\nmovdqu %xmm0,(%rdi,%rdx,4)\nmovdqu %xmm1,0x10(%rdi,%rdx,4)\ncmp    %rax,%rcx\nje     11cd <func0+0xcd>\ncs nopw 0x0(%rax,%rax,1)\nnop\naddl   $0x1,(%rdi,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    11c0 <func0+0xc0>\nret\nxor    %edx,%edx\ntest   $0x1,%r8b\njne    118e <func0+0x8e>\njmp    11b0 <func0+0xb0>\n"
    },
    {
        "task_id": 43,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1181 <func0+0x81>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    116e <func0+0x6e>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x10(%rbp),%rcx\nmovslq -0x1c(%rbp),%rdx\nadd    (%rcx,%rdx,4),%eax\ncmp    $0x0,%eax\njne    115b <func0+0x5b>\nmovb   $0x1,-0x1(%rbp)\njmp    1185 <func0+0x85>\njmp    1160 <func0+0x60>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1127 <func0+0x27>\njmp    1173 <func0+0x73>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1112 <func0+0x12>\nmovb   $0x0,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 43,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %rbx\nxor    %r9d,%r9d\ntest   %esi,%esi\nmov    $0x0,%r8d\ncmovg  %esi,%r8d\nmov    %esi,%r11d\nmov    $0x1,%r15d\nmov    $0x2,%r14d\njmp    113c <func0+0x3c>\nmov    $0x5,%r10d\ncmp    %esi,%ecx\nsetl   %cl\nadd    $0x1,%r15\nadd    $0x1,%r14\ntest   %cl,%cl\njne    1191 <func0+0x91>\ncmp    %r8,%r9\nje     118b <func0+0x8b>\nmov    %r9,%rbx\nadd    $0x1,%r9\nmov    $0x5,%r10d\ncmp    %esi,%r9d\nsetl   %cl\njge    1130 <func0+0x30>\nmov    (%rdi,%rbx,4),%ebx\nmov    $0x1,%r10d\nmov    (%rdi,%r15,4),%edx\nadd    %ebx,%edx\nje     1130 <func0+0x30>\nmov    %r14,%rdx\nnopw   0x0(%rax,%rax,1)\nmov    %rdx,%rcx\ncmp    %ecx,%r11d\nje     1125 <func0+0x25>\nlea    0x1(%rcx),%rdx\nmov    (%rdi,%rcx,4),%eax\nadd    %ebx,%eax\njne    1170 <func0+0x70>\nmov    $0x1,%r10d\njmp    112b <func0+0x2b>\nmov    $0x2,%r10d\ncmp    $0x2,%r10d\nsetne  %al\npop    %rbx\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 43,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ntest   %esi,%esi\njle    1167 <func0+0x67>\nmov    %esi,%r8d\nmov    $0x1,%al\nxor    %r10d,%r10d\nmov    %r8,%r11\nmov    %rdi,%rsi\njmp    112d <func0+0x2d>\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x4,%rsi\nadd    $0xffffffffffffffff,%r11\ncmp    %r8,%r10\nje     1169 <func0+0x69>\nmov    %eax,%r9d\nmov    %r10,%rcx\nadd    $0x1,%r10\ncmp    %r8,%r10\nsetb   %al\njae    1120 <func0+0x20>\nmov    (%rdi,%rcx,4),%ecx\nmov    $0x1,%edx\nnopw   0x0(%rax,%rax,1)\nmov    (%rsi,%rdx,4),%ebx\nadd    %ecx,%ebx\nje     1162 <func0+0x62>\nadd    $0x1,%rdx\ncmp    %rdx,%r11\njne    1150 <func0+0x50>\njmp    1120 <func0+0x20>\nmov    %r9d,%eax\njmp    1169 <func0+0x69>\nxor    %eax,%eax\nand    $0x1,%al\npop    %rbx\nret\n"
    },
    {
        "task_id": 43,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ntest   %esi,%esi\njle    1169 <func0+0x69>\nmov    %esi,%r8d\nmov    $0x1,%al\nxor    %r10d,%r10d\nmov    %r8,%r11\nmov    %rdi,%rsi\njmp    112d <func0+0x2d>\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x4,%rsi\nadd    $0xffffffffffffffff,%r11\ncmp    %r8,%r10\nje     1165 <func0+0x65>\nmov    %eax,%r9d\nmov    %r10,%rcx\nadd    $0x1,%r10\ncmp    %r8,%r10\nsetb   %al\njae    1120 <func0+0x20>\nmov    (%rdi,%rcx,4),%ecx\nmov    $0x1,%edx\nnopw   0x0(%rax,%rax,1)\nmov    (%rsi,%rdx,4),%ebx\nadd    %ecx,%ebx\nje     1162 <func0+0x62>\nadd    $0x1,%rdx\ncmp    %rdx,%r11\njne    1150 <func0+0x50>\njmp    1120 <func0+0x20>\nmov    %r9d,%eax\nand    $0x1,%al\npop    %rbx\nret\nxor    %eax,%eax\nand    $0x1,%al\npop    %rbx\nret\n"
    },
    {
        "task_id": 44,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %rdx,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njle    114b <func0+0x4b>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nadd    $0x30,%edx\nmov    %dl,%cl\nmov    -0x14(%rbp),%eax\nmov    %eax,%edx\nadd    $0x1,%edx\nmov    %edx,-0x14(%rbp)\ncltq\nmov    %cl,-0x40(%rbp,%rax,1)\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %eax,-0x4(%rbp)\njmp    1115 <func0+0x15>\nmovl   $0x0,-0x44(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njle    1185 <func0+0x85>\nmov    -0x14(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x14(%rbp)\ncltq\nmov    -0x40(%rbp,%rax,1),%dl\nmov    -0x10(%rbp),%rax\nmov    -0x44(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x44(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\njmp    1152 <func0+0x52>\nmov    -0x10(%rbp),%rax\nmovslq -0x44(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\npop    %rbp\nret\n"
    },
    {
        "task_id": 44,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %rdx,%r8\ntest   %edi,%edi\njle    114b <func0+0x4b>\nmov    %edi,%eax\nxor    %edi,%edi\nnopl   0x0(%rax,%rax,1)\ncltd\nidiv   %esi\nadd    $0x30,%dl\nmov    %dl,-0x28(%rsp,%rdi,1)\nadd    $0x1,%rdi\ntest   %eax,%eax\njg     1110 <func0+0x10>\ntest   %edi,%edi\njle    1151 <func0+0x51>\nmov    %edi,%edx\nadd    $0xffffffffffffffff,%rdx\nxor    %eax,%eax\nxchg   %ax,%ax\nmov    %edx,%esi\nmovzbl -0x28(%rsp,%rsi,1),%ecx\nmov    %cl,(%r8,%rax,1)\nadd    $0x1,%rax\nadd    $0xffffffffffffffff,%rdx\njb     1130 <func0+0x30>\nmovb   $0x0,(%r8,%rax,1)\nret\nxor    %edi,%edi\ntest   %edi,%edi\njg     1126 <func0+0x26>\nxor    %eax,%eax\nmovb   $0x0,(%r8,%rax,1)\nret\n"
    },
    {
        "task_id": 44,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nmov    %rdx,%r10\ntest   %edi,%edi\njle    11d6 <func0+0xd6>\nmov    %edi,%eax\nxor    %edi,%edi\ncltd\nidiv   %esi\nadd    $0x30,%dl\nmov    %dl,-0x30(%rsp,%rdi,1)\nadd    $0x1,%rdi\ntest   %eax,%eax\njg     1110 <func0+0x10>\ntest   %edi,%edi\njle    11d6 <func0+0xd6>\nmov    %edi,%r8d\ncmp    $0x8,%r8\njae    11df <func0+0xdf>\nxor    %eax,%eax\nmov    %r8,%rbx\nmov    %edi,%ecx\nsub    %eax,%ecx\nmov    %rax,%rsi\nnot    %rsi\nadd    %rsi,%r8\ntest   $0x3,%cl\nje     1179 <func0+0x79>\nmov    %edi,%ecx\nsub    %al,%cl\nmovzbl %cl,%ecx\nand    $0x3,%ecx\nnopl   0x0(%rax,%rax,1)\nadd    $0xffffffffffffffff,%rbx\nmov    %ebx,%esi\nmovzbl -0x30(%rsp,%rsi,1),%edx\nmov    %dl,(%r10,%rax,1)\nadd    $0x1,%rax\nadd    $0xffffffffffffffff,%rcx\njne    1160 <func0+0x60>\ncmp    $0x3,%r8\njb     11d2 <func0+0xd2>\nmov    $0xfffffffe,%r8d\nmov    %edi,%esi\nnopw   0x0(%rax,%rax,1)\nlea    (%rbx,%r8,1),%rdx\nlea    0x1(%rdx),%ecx\nmovzbl -0x30(%rsp,%rcx,1),%ecx\nmov    %cl,(%r10,%rax,1)\nmov    %edx,%ecx\nmovzbl -0x30(%rsp,%rcx,1),%ecx\nmov    %cl,0x1(%r10,%rax,1)\nadd    $0xffffffff,%edx\nmovzbl -0x30(%rsp,%rdx,1),%ecx\nmov    %cl,0x2(%r10,%rax,1)\nadd    $0xfffffffffffffffc,%rbx\nmov    %ebx,%ecx\nmovzbl -0x30(%rsp,%rcx,1),%ecx\nmov    %cl,0x3(%r10,%rax,1)\nadd    $0x4,%rax\ncmp    %rax,%rsi\njne    1190 <func0+0x90>\nmov    %edi,%eax\njmp    11d8 <func0+0xd8>\nxor    %eax,%eax\nmovb   $0x0,(%r10,%rax,1)\npop    %rbx\nret\nlea    -0x1(%r8),%rcx\nlea    -0x1(%rdi),%edx\nxor    %eax,%eax\ncmp    %ecx,%edx\njb     1139 <func0+0x39>\nshr    $0x20,%rcx\nmov    %r8,%rbx\njne    113c <func0+0x3c>\ncmp    $0x20,%r8d\njae    120a <func0+0x10a>\nxor    %eax,%eax\njmp    12cb <func0+0x1cb>\nlea    -0x1(%rdi),%r11\nmov    %edi,%r9d\nmov    %edi,%ebx\nand    $0x1f,%ebx\nmov    %r8,%rax\nsub    %rbx,%rax\nsub    %rbx,%r9\nxor    %ecx,%ecx\npxor   %xmm0,%xmm0\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %r11d,%esi\nmovdqu -0x4f(%rsp,%rsi,1),%xmm1\nmovdqu -0x3f(%rsp,%rsi,1),%xmm2\nmovdqa %xmm2,%xmm3\npunpcklbw %xmm0,%xmm3\npshufd $0x4e,%xmm3,%xmm3\npshuflw $0x1b,%xmm3,%xmm3\npshufhw $0x1b,%xmm3,%xmm3\npunpckhbw %xmm0,%xmm2\npshufd $0x4e,%xmm2,%xmm2\npshuflw $0x1b,%xmm2,%xmm2\npshufhw $0x1b,%xmm2,%xmm2\npackuswb %xmm3,%xmm2\nmovdqa %xmm1,%xmm3\npunpcklbw %xmm0,%xmm3\npshufd $0x4e,%xmm3,%xmm3\npshuflw $0x1b,%xmm3,%xmm3\npshufhw $0x1b,%xmm3,%xmm3\npunpckhbw %xmm0,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm3,%xmm1\nmovdqu %xmm2,(%r10,%rcx,1)\nmovdqu %xmm1,0x10(%r10,%rcx,1)\nadd    $0x20,%rcx\nadd    $0xffffffffffffffe0,%r11\ncmp    %rcx,%r9\njne    1230 <func0+0x130>\ntest   %rbx,%rbx\nje     11d2 <func0+0xd2>\ncmp    $0x8,%ebx\njb     113c <func0+0x3c>\nmov    %rax,%r11\nmov    %edi,%r9d\nmov    %edi,%ebx\nand    $0x7,%ebx\nmov    %r8,%rax\nsub    %rbx,%rax\nmov    %r11,%rcx\nnot    %rcx\nadd    %rdi,%rcx\nsub    %rbx,%r9\npxor   %xmm0,%xmm0\nnopl   0x0(%rax)\nmov    %ecx,%esi\nmovq   -0x37(%rsp,%rsi,1),%xmm1\npunpcklbw %xmm0,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm1,%xmm1\nmovq   %xmm1,(%r10,%r11,1)\nadd    $0x8,%r11\nadd    $0xfffffffffffffff8,%rcx\ncmp    %r11,%r9\njne    12f0 <func0+0x1f0>\ntest   %rbx,%rbx\njne    113c <func0+0x3c>\njmp    11d2 <func0+0xd2>\n"
    },
    {
        "task_id": 44,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nmov    %rdx,%r10\ntest   %edi,%edi\njle    11db <func0+0xdb>\nmov    %edi,%eax\nxor    %edi,%edi\ncltd\nidiv   %esi\nadd    $0x30,%dl\nmov    %dl,-0x30(%rsp,%rdi,1)\nadd    $0x1,%rdi\ntest   %eax,%eax\njg     1110 <func0+0x10>\ntest   %edi,%edi\njle    11db <func0+0xdb>\nmov    %edi,%r8d\ncmp    $0x8,%r8\njae    11e4 <func0+0xe4>\nxor    %eax,%eax\nmov    %r8,%rbx\nmov    %edi,%ecx\nsub    %eax,%ecx\nmov    %rax,%rsi\nnot    %rsi\nadd    %rsi,%r8\ntest   $0x3,%cl\nje     1179 <func0+0x79>\nmov    %edi,%ecx\nsub    %al,%cl\nmovzbl %cl,%ecx\nand    $0x3,%ecx\nnopl   0x0(%rax,%rax,1)\nadd    $0xffffffffffffffff,%rbx\nmov    %ebx,%esi\nmovzbl -0x30(%rsp,%rsi,1),%edx\nmov    %dl,(%r10,%rax,1)\nadd    $0x1,%rax\nadd    $0xffffffffffffffff,%rcx\njne    1160 <func0+0x60>\ncmp    $0x3,%r8\njb     11d2 <func0+0xd2>\nmov    $0xfffffffe,%r8d\nmov    %edi,%esi\nnopw   0x0(%rax,%rax,1)\nlea    (%rbx,%r8,1),%rdx\nlea    0x1(%rdx),%ecx\nmovzbl -0x30(%rsp,%rcx,1),%ecx\nmov    %cl,(%r10,%rax,1)\nmov    %edx,%ecx\nmovzbl -0x30(%rsp,%rcx,1),%ecx\nmov    %cl,0x1(%r10,%rax,1)\nadd    $0xffffffff,%edx\nmovzbl -0x30(%rsp,%rdx,1),%ecx\nmov    %cl,0x2(%r10,%rax,1)\nadd    $0xfffffffffffffffc,%rbx\nmov    %ebx,%ecx\nmovzbl -0x30(%rsp,%rcx,1),%ecx\nmov    %cl,0x3(%r10,%rax,1)\nadd    $0x4,%rax\ncmp    %rax,%rsi\njne    1190 <func0+0x90>\nmov    %edi,%eax\nmovb   $0x0,(%r10,%rax,1)\npop    %rbx\nret\nxor    %eax,%eax\nmovb   $0x0,(%r10,%rax,1)\npop    %rbx\nret\nlea    -0x1(%r8),%rcx\nlea    -0x1(%rdi),%edx\nxor    %eax,%eax\ncmp    %ecx,%edx\njb     1139 <func0+0x39>\nshr    $0x20,%rcx\nmov    %r8,%rbx\njne    113c <func0+0x3c>\ncmp    $0x20,%r8d\njae    120f <func0+0x10f>\nxor    %eax,%eax\njmp    12cb <func0+0x1cb>\nlea    -0x1(%rdi),%r11\nmov    %edi,%r9d\nmov    %edi,%ebx\nand    $0x1f,%ebx\nmov    %r8,%rax\nsub    %rbx,%rax\nsub    %rbx,%r9\nxor    %ecx,%ecx\npxor   %xmm0,%xmm0\nnopw   0x0(%rax,%rax,1)\nmov    %r11d,%esi\nmovdqu -0x4f(%rsp,%rsi,1),%xmm1\nmovdqu -0x3f(%rsp,%rsi,1),%xmm2\nmovdqa %xmm2,%xmm3\npunpcklbw %xmm0,%xmm3\npshufd $0x4e,%xmm3,%xmm3\npshuflw $0x1b,%xmm3,%xmm3\npshufhw $0x1b,%xmm3,%xmm3\npunpckhbw %xmm0,%xmm2\npshufd $0x4e,%xmm2,%xmm2\npshuflw $0x1b,%xmm2,%xmm2\npshufhw $0x1b,%xmm2,%xmm2\npackuswb %xmm3,%xmm2\nmovdqa %xmm1,%xmm3\npunpcklbw %xmm0,%xmm3\npshufd $0x4e,%xmm3,%xmm3\npshuflw $0x1b,%xmm3,%xmm3\npshufhw $0x1b,%xmm3,%xmm3\npunpckhbw %xmm0,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm3,%xmm1\nmovdqu %xmm2,(%r10,%rcx,1)\nmovdqu %xmm1,0x10(%r10,%rcx,1)\nadd    $0x20,%rcx\nadd    $0xffffffffffffffe0,%r11\ncmp    %rcx,%r9\njne    1230 <func0+0x130>\ntest   %rbx,%rbx\nje     11d2 <func0+0xd2>\ncmp    $0x8,%ebx\njb     113c <func0+0x3c>\nmov    %rax,%r11\nmov    %edi,%r9d\nmov    %edi,%ebx\nand    $0x7,%ebx\nmov    %r8,%rax\nsub    %rbx,%rax\nmov    %r11,%rcx\nnot    %rcx\nadd    %rdi,%rcx\nsub    %rbx,%r9\npxor   %xmm0,%xmm0\nnopl   0x0(%rax)\nmov    %ecx,%esi\nmovq   -0x37(%rsp,%rsi,1),%xmm1\npunpcklbw %xmm0,%xmm1\npshufd $0x4e,%xmm1,%xmm1\npshuflw $0x1b,%xmm1,%xmm1\npshufhw $0x1b,%xmm1,%xmm1\npackuswb %xmm1,%xmm1\nmovq   %xmm1,(%r10,%r11,1)\nadd    $0x8,%r11\nadd    $0xfffffffffffffff8,%rcx\ncmp    %r11,%r9\njne    12f0 <func0+0x1f0>\ntest   %rbx,%rbx\njne    113c <func0+0x3c>\njmp    11d2 <func0+0xd2>\n"
    },
    {
        "task_id": 45,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmulss  -0x8(%rbp),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xedc(%rip),%xmm1\nmulsd  %xmm1,%xmm0\ncvtsd2ss %xmm0,%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 45,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmulss  %xmm1,%xmm0\nmulss  0xef4(%rip),%xmm0\nret\n"
    },
    {
        "task_id": 45,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmulss  %xmm1,%xmm0\nmulss  0xef4(%rip),%xmm0\nret\n"
    },
    {
        "task_id": 45,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmulss  %xmm1,%xmm0\nmulss  0xef4(%rip),%xmm0\nret\n"
    },
    {
        "task_id": 46,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x130,%rsp\nmov    %edi,-0x4(%rbp)\nmovl   $0x0,-0x1a0(%rbp)\nmovl   $0x0,-0x19c(%rbp)\nmovl   $0x2,-0x198(%rbp)\nmovl   $0x0,-0x194(%rbp)\nmovl   $0x4,-0x1a4(%rbp)\nmov    -0x1a4(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     11b9 <func0+0xb9>\nmov    -0x1a4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%ecx\nmov    -0x1a4(%rbp),%eax\nsub    $0x2,%eax\ncltq\nadd    -0x1a0(%rbp,%rax,4),%ecx\nmov    -0x1a4(%rbp),%eax\nsub    $0x3,%eax\ncltq\nadd    -0x1a0(%rbp,%rax,4),%ecx\nmov    -0x1a4(%rbp),%eax\nsub    $0x4,%eax\ncltq\nadd    -0x1a0(%rbp,%rax,4),%ecx\nmovslq -0x1a4(%rbp),%rax\nmov    %ecx,-0x1a0(%rbp,%rax,4)\nmov    -0x1a4(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1a4(%rbp)\njmp    1140 <func0+0x40>\nmovslq -0x4(%rbp),%rax\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    $0x130,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 46,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nsub    $0x118,%rsp\nmovaps 0xef2(%rip),%xmm0\nmovaps %xmm0,-0x80(%rsp)\ncmp    $0x4,%edi\njl     1152 <func0+0x52>\nlea    0x1(%rdi),%eax\nmov    $0x4,%ecx\nmov    -0x74(%rsp),%edx\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nadd    -0x88(%rsp,%rcx,4),%edx\nadd    -0x8c(%rsp,%rcx,4),%edx\nadd    -0x90(%rsp,%rcx,4),%edx\nmov    %edx,-0x80(%rsp,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1130 <func0+0x30>\nmovslq %edi,%rax\nmov    -0x80(%rsp,%rax,4),%eax\nadd    $0x118,%rsp\nret\n"
    },
    {
        "task_id": 46,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nsub    $0x118,%rsp\nmovaps 0xef2(%rip),%xmm0\nmovaps %xmm0,-0x80(%rsp)\ncmp    $0x4,%edi\njl     11c9 <func0+0xc9>\nlea    0x1(%rdi),%eax\nmovl   $0x2,-0x70(%rsp)\ncmp    $0x5,%eax\nje     11c9 <func0+0xc9>\nmov    %edi,%r8d\ncmp    $0x6,%eax\njne    1154 <func0+0x54>\nmov    $0x4,%edx\nmov    $0x2,%ecx\nmov    $0x5,%eax\nmov    $0x2,%esi\ntest   $0x1,%r8b\njne    11b5 <func0+0xb5>\njmp    11c9 <func0+0xc9>\nlea    -0x4(%r8),%r9\nand    $0xfffffffffffffffe,%r9\nneg    %r9\nmov    $0x2,%ecx\nmov    $0x4,%edx\nmov    $0x2,%esi\nxchg   %ax,%ax\nmov    -0x84(%rsp,%rdx,4),%eax\nadd    %eax,%ecx\nadd    %esi,%ecx\nmov    -0x80(%rsp,%rdx,4),%esi\nadd    -0x8c(%rsp,%rdx,4),%ecx\nmov    %ecx,-0x7c(%rsp,%rdx,4)\nadd    %esi,%ecx\nadd    %eax,%ecx\nadd    -0x88(%rsp,%rdx,4),%ecx\nmov    %ecx,-0x78(%rsp,%rdx,4)\nlea    (%r9,%rdx,1),%rax\nadd    $0x2,%rax\nadd    $0x2,%rdx\ncmp    $0x4,%rax\njne    1170 <func0+0x70>\nlea    0x1(%rdx),%rax\ntest   $0x1,%r8b\nje     11c9 <func0+0xc9>\nadd    -0x84(%rsp,%rdx,4),%ecx\nadd    %esi,%ecx\nadd    -0x8c(%rsp,%rdx,4),%ecx\nmov    %ecx,-0x80(%rsp,%rax,4)\nmovslq %edi,%rax\nmov    -0x80(%rsp,%rax,4),%eax\nadd    $0x118,%rsp\nret\n"
    },
    {
        "task_id": 46,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nsub    $0x118,%rsp\nmovaps 0xef2(%rip),%xmm0\nmovaps %xmm0,-0x80(%rsp)\ncmp    $0x4,%edi\njl     11c9 <func0+0xc9>\nlea    0x1(%rdi),%eax\nmovl   $0x2,-0x70(%rsp)\ncmp    $0x5,%eax\nje     11c9 <func0+0xc9>\nmov    %edi,%r8d\ncmp    $0x6,%eax\njne    1154 <func0+0x54>\nmov    $0x4,%edx\nmov    $0x2,%ecx\nmov    $0x5,%eax\nmov    $0x2,%esi\ntest   $0x1,%r8b\njne    11b5 <func0+0xb5>\njmp    11c9 <func0+0xc9>\nlea    -0x4(%r8),%r9\nand    $0xfffffffffffffffe,%r9\nneg    %r9\nmov    $0x2,%ecx\nmov    $0x4,%edx\nmov    $0x2,%esi\nxchg   %ax,%ax\nmov    -0x84(%rsp,%rdx,4),%eax\nadd    %eax,%ecx\nadd    %esi,%ecx\nmov    -0x80(%rsp,%rdx,4),%esi\nadd    -0x8c(%rsp,%rdx,4),%ecx\nmov    %ecx,-0x7c(%rsp,%rdx,4)\nadd    %esi,%ecx\nadd    %eax,%ecx\nadd    -0x88(%rsp,%rdx,4),%ecx\nmov    %ecx,-0x78(%rsp,%rdx,4)\nlea    (%r9,%rdx,1),%rax\nadd    $0x2,%rax\nadd    $0x2,%rdx\ncmp    $0x4,%rax\njne    1170 <func0+0x70>\nlea    0x1(%rdx),%rax\ntest   $0x1,%r8b\nje     11c9 <func0+0xc9>\nadd    -0x84(%rsp,%rdx,4),%ecx\nadd    %esi,%ecx\nadd    -0x8c(%rsp,%rdx,4),%ecx\nmov    %ecx,-0x80(%rsp,%rax,4)\nmovslq %edi,%rax\nmov    -0x80(%rsp,%rax,4),%eax\nadd    $0x118,%rsp\nret\n"
    },
    {
        "task_id": 47,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11b6 <func0+0xb6>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11a3 <func0+0xa3>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nucomiss (%rax,%rcx,4),%xmm0\njbe    1190 <func0+0x90>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovss  %xmm0,(%rax,%rcx,4)\nmovss  -0x20(%rbp),%xmm0\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  %xmm0,(%rax,%rcx,4)\njmp    1195 <func0+0x95>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1127 <func0+0x27>\njmp    11a8 <func0+0xa8>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1112 <func0+0x12>\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    11f5 <func0+0xf5>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x28(%rbp),%rax\nmovslq %ecx,%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmovss  %xmm0,-0x4(%rbp)\njmp    1253 <func0+0x153>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x38(%rbp),%rax\nmovslq %ecx,%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x30(%rbp),%rax\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\naddss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm1\nmovsd  0xdba(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ncvtsd2ss %xmm0,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 47,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1164 <func0+0x64>\nmovslq %esi,%r8\nmov    %esi,%r9d\nxor    %r10d,%r10d\nmov    %r9,%r11\nmov    %rdi,%rax\njmp    112d <func0+0x2d>\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x4,%rax\nadd    $0xffffffffffffffff,%r11\ncmp    %r9,%r10\nje     1164 <func0+0x64>\nmov    %r10,%rcx\nadd    $0x1,%r10\ncmp    %r8,%r10\njge    1120 <func0+0x20>\nmov    $0x1,%edx\njmp    1149 <func0+0x49>\nadd    $0x1,%rdx\ncmp    %rdx,%r11\nje     1120 <func0+0x20>\nmovss  (%rdi,%rcx,4),%xmm0\nmovss  (%rax,%rdx,4),%xmm1\nucomiss %xmm1,%xmm0\njbe    1140 <func0+0x40>\nmovss  %xmm1,(%rdi,%rcx,4)\nmovss  %xmm0,(%rax,%rdx,4)\njmp    1140 <func0+0x40>\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %esi,%eax\nmov    %eax,%ecx\nsar    %ecx\nand    $0xfffffffe,%eax\nsub    %eax,%esi\nmovslq %ecx,%rax\nmovss  (%rdi,%rax,4),%xmm0\ncmp    $0x1,%esi\nje     118f <func0+0x8f>\naddss  -0x4(%rdi,%rax,4),%xmm0\nmulss  0xe71(%rip),%xmm0\nret\n"
    },
    {
        "task_id": 47,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1164 <func0+0x64>\nmov    %esi,%r8d\nxor    %r9d,%r9d\nmov    %r8,%r10\nmov    %rdi,%rdx\njmp    112d <func0+0x2d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nadd    $0x4,%rdx\nadd    $0xffffffffffffffff,%r10\ncmp    %r8,%r9\nje     1164 <func0+0x64>\nmov    %r9,%rax\nadd    $0x1,%r9\ncmp    %r8,%r9\njae    1120 <func0+0x20>\nmov    $0x1,%ecx\njmp    1149 <func0+0x49>\nadd    $0x1,%rcx\ncmp    %rcx,%r10\nje     1120 <func0+0x20>\nmovss  (%rdi,%rax,4),%xmm0\nmovss  (%rdx,%rcx,4),%xmm1\nucomiss %xmm1,%xmm0\njbe    1140 <func0+0x40>\nmovss  %xmm1,(%rdi,%rax,4)\nmovss  %xmm0,(%rdx,%rcx,4)\njmp    1140 <func0+0x40>\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %esi,%eax\nmov    %eax,%ecx\nsar    %ecx\nand    $0xfffffffe,%eax\nsub    %eax,%esi\nmovslq %ecx,%rax\nmovss  (%rdi,%rax,4),%xmm0\ncmp    $0x1,%esi\nje     118f <func0+0x8f>\naddss  -0x4(%rdi,%rax,4),%xmm0\nmulss  0xe71(%rip),%xmm0\nret\n"
    },
    {
        "task_id": 47,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1164 <func0+0x64>\nmov    %esi,%r8d\nxor    %r9d,%r9d\nmov    %r8,%r10\nmov    %rdi,%rdx\njmp    112d <func0+0x2d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nadd    $0x4,%rdx\nadd    $0xffffffffffffffff,%r10\ncmp    %r8,%r9\nje     1164 <func0+0x64>\nmov    %r9,%rax\nadd    $0x1,%r9\ncmp    %r8,%r9\njae    1120 <func0+0x20>\nmov    $0x1,%ecx\njmp    1149 <func0+0x49>\nadd    $0x1,%rcx\ncmp    %rcx,%r10\nje     1120 <func0+0x20>\nmovss  (%rdi,%rax,4),%xmm0\nmovss  (%rdx,%rcx,4),%xmm1\nucomiss %xmm1,%xmm0\njbe    1140 <func0+0x40>\nmovss  %xmm1,(%rdi,%rax,4)\nmovss  %xmm0,(%rdx,%rcx,4)\njmp    1140 <func0+0x40>\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %esi,%eax\nmov    %eax,%ecx\nsar    %ecx\nand    $0xfffffffe,%eax\nsub    %eax,%esi\nmovslq %ecx,%rax\nmovss  (%rdi,%rax,4),%xmm0\ncmp    $0x1,%esi\nje     118f <func0+0x8f>\naddss  -0x4(%rdi,%rax,4),%xmm0\nmulss  0xe71(%rip),%xmm0\nret\n"
    },
    {
        "task_id": 48,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x1c(%rbp),%eax\ncmp    %ecx,%eax\njge    1191 <func0+0x81>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x14(%rbp),%edx\nsub    $0x1,%edx\nsub    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nmovsbl (%rcx,%rdx,1),%ecx\ncmp    %ecx,%eax\nje     117e <func0+0x6e>\nmovb   $0x0,-0x1(%rbp)\njmp    1195 <func0+0x85>\njmp    1183 <func0+0x73>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    112f <func0+0x1f>\nmovb   $0x1,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 48,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\ncmp    $0x2,%eax\nsetge  %cl\njl     1185 <func0+0x75>\nmov    (%rbx),%dl\nlea    -0x1(%rax),%esi\nmovslq %esi,%rsi\ncmp    (%rbx,%rsi,1),%dl\njne    1185 <func0+0x75>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\nmovabs $0xffffffff00000000,%r9\nff ff ff\nmovslq %ecx,%r8\nmov    %r8d,%r10d\nshl    $0x20,%rax\nmovabs $0xfffffffe00000000,%rdi\nff ff ff\nadd    %rax,%rdi\nmov    $0x1,%ecx\nnopl   (%rax)\nmov    %rcx,%rax\ncmp    %rcx,%r10\nje     117f <func0+0x6f>\nmovzbl (%rbx,%rax,1),%edx\nmov    %rdi,%rsi\nsar    $0x20,%rsi\nlea    0x1(%rax),%rcx\nadd    %r9,%rdi\ncmp    (%rbx,%rsi,1),%dl\nje     1160 <func0+0x50>\ncmp    %r8,%rax\nsetl   %cl\nxor    $0x1,%cl\nmov    %ecx,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 48,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nmov    $0x1,%cl\ncmp    $0x2,%eax\njl     1189 <func0+0x79>\nmov    (%rbx),%cl\nlea    -0x1(%rax),%edx\nmovslq %edx,%rdx\ncmp    (%rbx,%rdx,1),%cl\njne    1187 <func0+0x77>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\nmovabs $0xffffffff00000000,%r9\nff ff ff\nmovslq %ecx,%r8\nmov    %r8d,%r10d\nshl    $0x20,%rax\nmovabs $0xfffffffe00000000,%rdi\nff ff ff\nadd    %rax,%rdi\nmov    $0x1,%ecx\nnopl   0x0(%rax)\nmov    %rcx,%rax\ncmp    %rcx,%r10\nje     117f <func0+0x6f>\nmovzbl (%rbx,%rax,1),%edx\nmov    %rdi,%rsi\nsar    $0x20,%rsi\nlea    0x1(%rax),%rcx\nadd    %r9,%rdi\ncmp    (%rbx,%rsi,1),%dl\nje     1160 <func0+0x50>\ncmp    %r8,%rax\nsetge  %cl\njmp    1189 <func0+0x79>\nxor    %ecx,%ecx\nmov    %ecx,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 48,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nmov    $0x1,%cl\ncmp    $0x2,%eax\njl     1185 <func0+0x75>\nmov    (%rbx),%cl\nlea    -0x1(%rax),%edx\nmovslq %edx,%rdx\ncmp    (%rbx,%rdx,1),%cl\njne    1189 <func0+0x79>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\nmovabs $0xffffffff00000000,%r9\nff ff ff\nmovslq %ecx,%r8\nmov    %r8d,%r10d\nshl    $0x20,%rax\nmovabs $0xfffffffe00000000,%rdi\nff ff ff\nadd    %rax,%rdi\nmov    $0x1,%ecx\nnopl   0x0(%rax)\nmov    %rcx,%rax\ncmp    %rcx,%r10\nje     117f <func0+0x6f>\nmovzbl (%rbx,%rax,1),%edx\nmov    %rdi,%rsi\nsar    $0x20,%rsi\nlea    0x1(%rax),%rcx\nadd    %r9,%rdi\ncmp    (%rbx,%rsi,1),%dl\nje     1160 <func0+0x50>\ncmp    %r8,%rax\nsetge  %cl\nmov    %ecx,%eax\npop    %rbx\nret\nxor    %ecx,%ecx\nmov    %ecx,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 49,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    113f <func0+0x3f>\nmov    -0xc(%rbp),%eax\nshl    $0x1,%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    1118 <func0+0x18>\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 49,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%edx\ntest   %edi,%edi\njle    111c <func0+0x1c>\nnopl   0x0(%rax)\nadd    %edx,%edx\nmov    %edx,%eax\ncltd\nidiv   %esi\nadd    $0xffffffff,%edi\njne    1110 <func0+0x10>\nmov    %edx,%eax\nret\n"
    },
    {
        "task_id": 49,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1118 <func0+0x18>\nlea    -0x1(%rdi),%eax\nmov    %edi,%ecx\nand    $0x3,%ecx\ncmp    $0x3,%eax\njae    111e <func0+0x1e>\nmov    $0x1,%edx\njmp    114e <func0+0x4e>\nmov    $0x1,%eax\nret\nand    $0xfffffffc,%edi\nmov    $0x1,%edx\ncs nopw 0x0(%rax,%rax,1)\nadd    %edx,%edx\nmov    %edx,%eax\ncltd\nidiv   %esi\nlea    (%rdx,%rdx,1),%eax\ncltd\nidiv   %esi\nlea    (%rdx,%rdx,1),%eax\ncltd\nidiv   %esi\nlea    (%rdx,%rdx,1),%eax\ncltd\nidiv   %esi\nadd    $0xfffffffc,%edi\njne    1130 <func0+0x30>\ntest   %ecx,%ecx\nje     116c <func0+0x6c>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nadd    %edx,%edx\nmov    %edx,%eax\ncltd\nidiv   %esi\nadd    $0xffffffff,%ecx\njne    1160 <func0+0x60>\nmov    %edx,%eax\nret\n"
    },
    {
        "task_id": 49,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1118 <func0+0x18>\nlea    -0x1(%rdi),%eax\nmov    %edi,%ecx\nand    $0x3,%ecx\ncmp    $0x3,%eax\njae    111e <func0+0x1e>\nmov    $0x1,%edx\njmp    114e <func0+0x4e>\nmov    $0x1,%eax\nret\nand    $0xfffffffc,%edi\nmov    $0x1,%edx\ncs nopw 0x0(%rax,%rax,1)\nadd    %edx,%edx\nmov    %edx,%eax\ncltd\nidiv   %esi\nlea    (%rdx,%rdx,1),%eax\ncltd\nidiv   %esi\nlea    (%rdx,%rdx,1),%eax\ncltd\nidiv   %esi\nlea    (%rdx,%rdx,1),%eax\ncltd\nidiv   %esi\nadd    $0xfffffffc,%edi\njne    1130 <func0+0x30>\ntest   %ecx,%ecx\nje     116c <func0+0x6c>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nadd    %edx,%edx\nmov    %edx,%eax\ncltd\nidiv   %esi\nadd    $0xffffffff,%ecx\njne    1160 <func0+0x60>\nmov    %edx,%eax\nret\n"
    },
    {
        "task_id": 50,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0xc(%rbp),%edx\nmov    $0x15,%eax\nmov    $0x5,%ecx\ncmp    $0x0,%edx\ncmovne %ecx,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,-0x18(%rbp)\nmovq   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x18(%rbp),%rax\njae    1199 <func0+0x89>\nmov    -0x8(%rbp),%rax\nmov    -0x20(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nsub    $0x61,%eax\nadd    -0x10(%rbp),%eax\nmov    $0x1a,%ecx\ncltd\nidiv   %ecx\nadd    $0x61,%edx\nmov    %edx,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nmov    %al,%dl\nmov    -0x8(%rbp),%rax\nmov    -0x20(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x20(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x20(%rbp)\njmp    114a <func0+0x3a>\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 50,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %esi,%ebp\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1179 <func0+0x69>\nxor    %ecx,%ecx\ntest   %ebp,%ebp\nsete   %cl\nshl    $0x4,%ecx\nor     $0xffffffa4,%ecx\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovsbl (%rbx,%rdx,1),%esi\nadd    %ecx,%esi\nmovslq %esi,%rsi\nimul   $0x4ec4ec4f,%rsi,%rdi\nmov    %rdi,%rbp\nshr    $0x3f,%rbp\nsar    $0x23,%rdi\nadd    %ebp,%edi\nlea    (%rdi,%rdi,4),%ebp\nlea    0x0(%rbp,%rbp,4),%ebp\nadd    %edi,%ebp\nsub    %ebp,%esi\nadd    $0x61,%sil\nmov    %sil,(%rbx,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%rax\njne    1140 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 50,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %esi,%ebp\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1950 <func0+0x840>\nxor    %ecx,%ecx\ntest   %ebp,%ebp\nsete   %cl\nshl    $0x4,%ecx\nor     $0xffffffa4,%ecx\ncmp    $0x8,%rax\njae    1140 <func0+0x30>\nxor    %edx,%edx\njmp    1917 <func0+0x807>\nmovd   %ecx,%xmm8\ncmp    $0x10,%rax\njae    129f <func0+0x18f>\nxor    %edx,%edx\nmov    %rdx,%rsi\nmov    %rax,%rdx\nand    $0xfffffffffffffff8,%rdx\npshufd $0x0,%xmm8,%xmm0\nmovdqa 0xe97(%rip),%xmm1\nmovdqa 0xe9f(%rip),%xmm2\nmovdqa 0xea7(%rip),%xmm3\nmovdqa 0xebe(%rip),%xmm8\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovq   (%rbx,%rsi,1),%xmm5\npunpcklbw %xmm5,%xmm6\npunpcklwd %xmm6,%xmm5\npsrad  $0x18,%xmm5\npunpckhwd %xmm6,%xmm6\npsrad  $0x18,%xmm6\npaddd  %xmm0,%xmm6\npaddd  %xmm0,%xmm5\nmovdqa %xmm5,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npshufd $0xf5,%xmm5,%xmm4\npmuludq %xmm1,%xmm4\npshufd $0xed,%xmm4,%xmm4\npunpckldq %xmm4,%xmm7\npxor   %xmm4,%xmm4\npcmpgtd %xmm5,%xmm4\npand   %xmm1,%xmm4\npsubd  %xmm4,%xmm7\nmovdqa %xmm7,%xmm4\npsrld  $0x1f,%xmm4\npsrld  $0x3,%xmm7\npaddd  %xmm4,%xmm7\npshufd $0xf5,%xmm7,%xmm4\npmuludq %xmm2,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npmuludq %xmm2,%xmm4\npshufd $0xe8,%xmm4,%xmm4\npunpckldq %xmm4,%xmm7\npsubd  %xmm7,%xmm5\nmovdqa %xmm6,%xmm4\npmuludq %xmm1,%xmm4\npshufd $0xed,%xmm4,%xmm4\npshufd $0xf5,%xmm6,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm4\npxor   %xmm7,%xmm7\npcmpgtd %xmm6,%xmm7\npand   %xmm1,%xmm7\npsubd  %xmm7,%xmm4\nmovdqa %xmm4,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm4\npaddd  %xmm7,%xmm4\npshufd $0xf5,%xmm4,%xmm7\npmuludq %xmm2,%xmm4\npshufd $0xe8,%xmm4,%xmm4\npmuludq %xmm2,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm4\npsubd  %xmm4,%xmm6\npand   %xmm3,%xmm6\npand   %xmm3,%xmm5\npackuswb %xmm6,%xmm5\npackuswb %xmm5,%xmm5\npaddb  %xmm8,%xmm5\nmovq   %xmm5,(%rbx,%rsi,1)\nadd    $0x8,%rsi\ncmp    %rsi,%rdx\njne    1190 <func0+0x80>\njmp    194b <func0+0x83b>\nmov    %rax,%rdx\nand    $0xfffffffffffffff0,%rdx\npshufd $0x0,%xmm8,%xmm12\nlea    -0x10(%rdx),%rsi\nmov    %rsi,%rbp\nshr    $0x4,%rbp\nadd    $0x1,%rbp\ntest   %rsi,%rsi\nje     1909 <func0+0x7f9>\nmov    %rbp,%rdi\nand    $0xfffffffffffffffe,%rdi\nxor    %esi,%esi\nmovdqa 0xd2b(%rip),%xmm2\nmovdqa 0xd33(%rip),%xmm3\nmovdqa 0xd3a(%rip),%xmm10\nmovdqa 0xd41(%rip),%xmm9\nnop\nmovdqu (%rbx,%rsi,1),%xmm4\nmovdqu 0x10(%rbx,%rsi,1),%xmm11\npunpcklbw %xmm4,%xmm0\npunpcklwd %xmm0,%xmm6\npsrad  $0x18,%xmm6\npunpckhwd %xmm0,%xmm0\npsrad  $0x18,%xmm0\npunpckhbw %xmm4,%xmm4\npunpcklwd %xmm4,%xmm5\npsrad  $0x18,%xmm5\npunpckhwd %xmm4,%xmm4\npsrad  $0x18,%xmm4\npaddd  %xmm12,%xmm4\npaddd  %xmm12,%xmm5\npaddd  %xmm12,%xmm0\npaddd  %xmm12,%xmm6\nmovdqa %xmm6,%xmm7\npmuludq %xmm2,%xmm7\npshufd $0xed,%xmm7,%xmm7\npshufd $0xf5,%xmm6,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npunpckldq %xmm1,%xmm7\npxor   %xmm1,%xmm1\npcmpgtd %xmm6,%xmm1\npand   %xmm2,%xmm1\npsubd  %xmm1,%xmm7\nmovdqa %xmm7,%xmm1\npsrld  $0x1f,%xmm1\npsrld  $0x3,%xmm7\npaddd  %xmm1,%xmm7\npshufd $0xf5,%xmm7,%xmm1\npmuludq %xmm3,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm7\npsubd  %xmm7,%xmm6\nmovdqa %xmm0,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm0,%xmm7\npmuludq %xmm2,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npxor   %xmm7,%xmm7\npcmpgtd %xmm0,%xmm7\npand   %xmm2,%xmm7\npsubd  %xmm7,%xmm1\nmovdqa %xmm1,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm1\npaddd  %xmm7,%xmm1\npshufd $0xf5,%xmm1,%xmm7\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npsubd  %xmm1,%xmm0\nmovdqa %xmm5,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm5,%xmm7\npmuludq %xmm2,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npxor   %xmm7,%xmm7\npcmpgtd %xmm5,%xmm7\npand   %xmm2,%xmm7\npsubd  %xmm7,%xmm1\nmovdqa %xmm1,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm1\npaddd  %xmm7,%xmm1\npshufd $0xf5,%xmm1,%xmm7\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npsubd  %xmm1,%xmm5\nmovdqa %xmm4,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm4,%xmm7\npmuludq %xmm2,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npxor   %xmm7,%xmm7\npcmpgtd %xmm4,%xmm7\npand   %xmm2,%xmm7\npsubd  %xmm7,%xmm1\nmovdqa %xmm1,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm1\npaddd  %xmm7,%xmm1\npshufd $0xf5,%xmm1,%xmm7\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npsubd  %xmm1,%xmm4\npand   %xmm10,%xmm4\npand   %xmm10,%xmm5\npackuswb %xmm4,%xmm5\npand   %xmm10,%xmm0\npand   %xmm10,%xmm6\npackuswb %xmm0,%xmm6\npackuswb %xmm5,%xmm6\npaddb  %xmm9,%xmm6\nmovdqu %xmm6,(%rbx,%rsi,1)\npunpcklbw %xmm11,%xmm0\npunpcklwd %xmm0,%xmm7\npsrad  $0x18,%xmm7\npunpckhwd %xmm0,%xmm0\npsrad  $0x18,%xmm0\npunpckhbw %xmm11,%xmm1\npunpcklwd %xmm1,%xmm5\npsrad  $0x18,%xmm5\npunpckhwd %xmm1,%xmm4\npsrad  $0x18,%xmm4\npaddd  %xmm12,%xmm4\npaddd  %xmm12,%xmm5\npaddd  %xmm12,%xmm0\npaddd  %xmm12,%xmm7\nmovdqa %xmm7,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm7,%xmm6\npmuludq %xmm2,%xmm6\npshufd $0xed,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npxor   %xmm6,%xmm6\npcmpgtd %xmm7,%xmm6\npand   %xmm2,%xmm6\npsubd  %xmm6,%xmm1\nmovdqa %xmm1,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm1\npaddd  %xmm6,%xmm1\npshufd $0xf5,%xmm1,%xmm6\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npsubd  %xmm1,%xmm7\nmovdqa %xmm0,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm0,%xmm6\npmuludq %xmm2,%xmm6\npshufd $0xed,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npxor   %xmm6,%xmm6\npcmpgtd %xmm0,%xmm6\npand   %xmm2,%xmm6\npsubd  %xmm6,%xmm1\nmovdqa %xmm1,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm1\npaddd  %xmm6,%xmm1\npshufd $0xf5,%xmm1,%xmm6\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npsubd  %xmm1,%xmm0\nmovdqa %xmm5,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm5,%xmm6\npmuludq %xmm2,%xmm6\npshufd $0xed,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npxor   %xmm6,%xmm6\npcmpgtd %xmm5,%xmm6\npand   %xmm2,%xmm6\npsubd  %xmm6,%xmm1\nmovdqa %xmm1,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm1\npaddd  %xmm6,%xmm1\npshufd $0xf5,%xmm1,%xmm6\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npsubd  %xmm1,%xmm5\nmovdqa %xmm4,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm4,%xmm6\npmuludq %xmm2,%xmm6\npshufd $0xed,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npxor   %xmm6,%xmm6\npcmpgtd %xmm4,%xmm6\npand   %xmm2,%xmm6\npsubd  %xmm6,%xmm1\nmovdqa %xmm1,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm1\npaddd  %xmm6,%xmm1\npshufd $0xf5,%xmm1,%xmm6\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npsubd  %xmm1,%xmm4\npand   %xmm10,%xmm4\npand   %xmm10,%xmm5\npackuswb %xmm4,%xmm5\npand   %xmm10,%xmm0\npand   %xmm10,%xmm7\npackuswb %xmm0,%xmm7\npackuswb %xmm5,%xmm7\npaddb  %xmm9,%xmm7\nmovdqu %xmm7,0x10(%rbx,%rsi,1)\nadd    $0x20,%rsi\nadd    $0xfffffffffffffffe,%rdi\njne    12f0 <func0+0x1e0>\ntest   $0x1,%bpl\nje     18fa <func0+0x7ea>\nmovdqu (%rbx,%rsi,1),%xmm0\npunpcklbw %xmm0,%xmm1\npunpcklwd %xmm1,%xmm2\npsrad  $0x18,%xmm2\npunpckhwd %xmm1,%xmm3\npsrad  $0x18,%xmm3\npunpckhbw %xmm0,%xmm0\npunpcklwd %xmm0,%xmm4\npsrad  $0x18,%xmm4\npunpckhwd %xmm0,%xmm0\npsrad  $0x18,%xmm0\npaddd  %xmm12,%xmm0\npaddd  %xmm12,%xmm4\npaddd  %xmm12,%xmm3\npaddd  %xmm12,%xmm2\nmovdqa 0x8c8(%rip),%xmm1\nmovdqa %xmm2,%xmm5\npmuludq %xmm1,%xmm5\npshufd $0xed,%xmm5,%xmm7\npshufd $0xf5,%xmm2,%xmm5\npmuludq %xmm1,%xmm5\npshufd $0xed,%xmm5,%xmm5\npunpckldq %xmm5,%xmm7\npxor   %xmm5,%xmm5\npxor   %xmm6,%xmm6\npcmpgtd %xmm2,%xmm6\npand   %xmm1,%xmm6\npsubd  %xmm6,%xmm7\nmovdqa %xmm7,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm7\npaddd  %xmm6,%xmm7\nmovdqa 0x88a(%rip),%xmm9\npshufd $0xf5,%xmm7,%xmm6\npmuludq %xmm9,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npmuludq %xmm9,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm7\npsubd  %xmm7,%xmm2\nmovdqa %xmm3,%xmm6\npmuludq %xmm1,%xmm6\npshufd $0xed,%xmm6,%xmm6\npshufd $0xf5,%xmm3,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npxor   %xmm7,%xmm7\npcmpgtd %xmm3,%xmm7\npand   %xmm1,%xmm7\npsubd  %xmm7,%xmm6\nmovdqa %xmm6,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm6\npaddd  %xmm7,%xmm6\npshufd $0xf5,%xmm6,%xmm7\npmuludq %xmm9,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npmuludq %xmm9,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npsubd  %xmm6,%xmm3\nmovdqa %xmm4,%xmm6\npmuludq %xmm1,%xmm6\npshufd $0xed,%xmm6,%xmm6\npshufd $0xf5,%xmm4,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npxor   %xmm7,%xmm7\npcmpgtd %xmm4,%xmm7\npand   %xmm1,%xmm7\npsubd  %xmm7,%xmm6\nmovdqa %xmm6,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm6\npaddd  %xmm7,%xmm6\npshufd $0xf5,%xmm6,%xmm7\npmuludq %xmm9,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npmuludq %xmm9,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npsubd  %xmm6,%xmm4\nmovdqa %xmm0,%xmm6\npmuludq %xmm1,%xmm6\npshufd $0xed,%xmm6,%xmm6\npshufd $0xf5,%xmm0,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npcmpgtd %xmm0,%xmm5\npand   %xmm1,%xmm5\npsubd  %xmm5,%xmm6\nmovdqa %xmm6,%xmm1\npsrld  $0x1f,%xmm1\npsrld  $0x3,%xmm6\npaddd  %xmm1,%xmm6\npshufd $0xf5,%xmm6,%xmm1\npmuludq %xmm9,%xmm6\npshufd $0xe8,%xmm6,%xmm5\npmuludq %xmm9,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm5\npsubd  %xmm5,%xmm0\nmovdqa 0x74f(%rip),%xmm1\npand   %xmm1,%xmm0\npand   %xmm1,%xmm4\npackuswb %xmm0,%xmm4\npand   %xmm1,%xmm3\npand   %xmm1,%xmm2\npackuswb %xmm3,%xmm2\npackuswb %xmm4,%xmm2\npaddb  0x73b(%rip),%xmm2\nmovdqu %xmm2,(%rbx,%rsi,1)\ncmp    %rdx,%rax\nje     1950 <func0+0x840>\ntest   $0x8,%al\njne    1151 <func0+0x41>\njmp    1917 <func0+0x807>\nxor    %esi,%esi\ntest   $0x1,%bpl\njne    16eb <func0+0x5db>\njmp    18fa <func0+0x7ea>\nmovsbl (%rbx,%rdx,1),%esi\nadd    %ecx,%esi\nmovslq %esi,%rsi\nimul   $0x4ec4ec4f,%rsi,%rdi\nmov    %rdi,%rbp\nshr    $0x3f,%rbp\nsar    $0x23,%rdi\nadd    %ebp,%edi\nlea    (%rdi,%rdi,4),%ebp\nlea    0x0(%rbp,%rbp,4),%ebp\nadd    %edi,%ebp\nsub    %ebp,%esi\nadd    $0x61,%sil\nmov    %sil,(%rbx,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%rax\njne    1917 <func0+0x807>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 50,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %esi,%ebp\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1950 <func0+0x840>\nxor    %ecx,%ecx\ntest   %ebp,%ebp\nsete   %cl\nshl    $0x4,%ecx\nor     $0xffffffa4,%ecx\ncmp    $0x8,%rax\njae    1140 <func0+0x30>\nxor    %edx,%edx\njmp    1917 <func0+0x807>\nmovd   %ecx,%xmm8\ncmp    $0x10,%rax\njae    129f <func0+0x18f>\nxor    %edx,%edx\nmov    %rdx,%rsi\nmov    %rax,%rdx\nand    $0xfffffffffffffff8,%rdx\npshufd $0x0,%xmm8,%xmm0\nmovdqa 0xe97(%rip),%xmm1\nmovdqa 0xe9f(%rip),%xmm2\nmovdqa 0xea7(%rip),%xmm3\nmovdqa 0xebe(%rip),%xmm8\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovq   (%rbx,%rsi,1),%xmm5\npunpcklbw %xmm5,%xmm6\npunpcklwd %xmm6,%xmm5\npsrad  $0x18,%xmm5\npunpckhwd %xmm6,%xmm6\npsrad  $0x18,%xmm6\npaddd  %xmm0,%xmm6\npaddd  %xmm0,%xmm5\nmovdqa %xmm5,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npshufd $0xf5,%xmm5,%xmm4\npmuludq %xmm1,%xmm4\npshufd $0xed,%xmm4,%xmm4\npunpckldq %xmm4,%xmm7\npxor   %xmm4,%xmm4\npcmpgtd %xmm5,%xmm4\npand   %xmm1,%xmm4\npsubd  %xmm4,%xmm7\nmovdqa %xmm7,%xmm4\npsrld  $0x1f,%xmm4\npsrld  $0x3,%xmm7\npaddd  %xmm4,%xmm7\npshufd $0xf5,%xmm7,%xmm4\npmuludq %xmm2,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npmuludq %xmm2,%xmm4\npshufd $0xe8,%xmm4,%xmm4\npunpckldq %xmm4,%xmm7\npsubd  %xmm7,%xmm5\nmovdqa %xmm6,%xmm4\npmuludq %xmm1,%xmm4\npshufd $0xed,%xmm4,%xmm4\npshufd $0xf5,%xmm6,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm4\npxor   %xmm7,%xmm7\npcmpgtd %xmm6,%xmm7\npand   %xmm1,%xmm7\npsubd  %xmm7,%xmm4\nmovdqa %xmm4,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm4\npaddd  %xmm7,%xmm4\npshufd $0xf5,%xmm4,%xmm7\npmuludq %xmm2,%xmm4\npshufd $0xe8,%xmm4,%xmm4\npmuludq %xmm2,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm4\npsubd  %xmm4,%xmm6\npand   %xmm3,%xmm6\npand   %xmm3,%xmm5\npackuswb %xmm6,%xmm5\npackuswb %xmm5,%xmm5\npaddb  %xmm8,%xmm5\nmovq   %xmm5,(%rbx,%rsi,1)\nadd    $0x8,%rsi\ncmp    %rsi,%rdx\njne    1190 <func0+0x80>\njmp    194b <func0+0x83b>\nmov    %rax,%rdx\nand    $0xfffffffffffffff0,%rdx\npshufd $0x0,%xmm8,%xmm12\nlea    -0x10(%rdx),%rsi\nmov    %rsi,%rbp\nshr    $0x4,%rbp\nadd    $0x1,%rbp\ntest   %rsi,%rsi\nje     1909 <func0+0x7f9>\nmov    %rbp,%rdi\nand    $0xfffffffffffffffe,%rdi\nxor    %esi,%esi\nmovdqa 0xd2b(%rip),%xmm2\nmovdqa 0xd33(%rip),%xmm3\nmovdqa 0xd3a(%rip),%xmm10\nmovdqa 0xd41(%rip),%xmm9\nnop\nmovdqu (%rbx,%rsi,1),%xmm4\nmovdqu 0x10(%rbx,%rsi,1),%xmm11\npunpcklbw %xmm4,%xmm0\npunpcklwd %xmm0,%xmm6\npsrad  $0x18,%xmm6\npunpckhwd %xmm0,%xmm0\npsrad  $0x18,%xmm0\npunpckhbw %xmm4,%xmm4\npunpcklwd %xmm4,%xmm5\npsrad  $0x18,%xmm5\npunpckhwd %xmm4,%xmm4\npsrad  $0x18,%xmm4\npaddd  %xmm12,%xmm4\npaddd  %xmm12,%xmm5\npaddd  %xmm12,%xmm0\npaddd  %xmm12,%xmm6\nmovdqa %xmm6,%xmm7\npmuludq %xmm2,%xmm7\npshufd $0xed,%xmm7,%xmm7\npshufd $0xf5,%xmm6,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npunpckldq %xmm1,%xmm7\npxor   %xmm1,%xmm1\npcmpgtd %xmm6,%xmm1\npand   %xmm2,%xmm1\npsubd  %xmm1,%xmm7\nmovdqa %xmm7,%xmm1\npsrld  $0x1f,%xmm1\npsrld  $0x3,%xmm7\npaddd  %xmm1,%xmm7\npshufd $0xf5,%xmm7,%xmm1\npmuludq %xmm3,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm7\npsubd  %xmm7,%xmm6\nmovdqa %xmm0,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm0,%xmm7\npmuludq %xmm2,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npxor   %xmm7,%xmm7\npcmpgtd %xmm0,%xmm7\npand   %xmm2,%xmm7\npsubd  %xmm7,%xmm1\nmovdqa %xmm1,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm1\npaddd  %xmm7,%xmm1\npshufd $0xf5,%xmm1,%xmm7\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npsubd  %xmm1,%xmm0\nmovdqa %xmm5,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm5,%xmm7\npmuludq %xmm2,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npxor   %xmm7,%xmm7\npcmpgtd %xmm5,%xmm7\npand   %xmm2,%xmm7\npsubd  %xmm7,%xmm1\nmovdqa %xmm1,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm1\npaddd  %xmm7,%xmm1\npshufd $0xf5,%xmm1,%xmm7\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npsubd  %xmm1,%xmm5\nmovdqa %xmm4,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm4,%xmm7\npmuludq %xmm2,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npxor   %xmm7,%xmm7\npcmpgtd %xmm4,%xmm7\npand   %xmm2,%xmm7\npsubd  %xmm7,%xmm1\nmovdqa %xmm1,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm1\npaddd  %xmm7,%xmm1\npshufd $0xf5,%xmm1,%xmm7\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm1\npsubd  %xmm1,%xmm4\npand   %xmm10,%xmm4\npand   %xmm10,%xmm5\npackuswb %xmm4,%xmm5\npand   %xmm10,%xmm0\npand   %xmm10,%xmm6\npackuswb %xmm0,%xmm6\npackuswb %xmm5,%xmm6\npaddb  %xmm9,%xmm6\nmovdqu %xmm6,(%rbx,%rsi,1)\npunpcklbw %xmm11,%xmm0\npunpcklwd %xmm0,%xmm7\npsrad  $0x18,%xmm7\npunpckhwd %xmm0,%xmm0\npsrad  $0x18,%xmm0\npunpckhbw %xmm11,%xmm1\npunpcklwd %xmm1,%xmm5\npsrad  $0x18,%xmm5\npunpckhwd %xmm1,%xmm4\npsrad  $0x18,%xmm4\npaddd  %xmm12,%xmm4\npaddd  %xmm12,%xmm5\npaddd  %xmm12,%xmm0\npaddd  %xmm12,%xmm7\nmovdqa %xmm7,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm7,%xmm6\npmuludq %xmm2,%xmm6\npshufd $0xed,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npxor   %xmm6,%xmm6\npcmpgtd %xmm7,%xmm6\npand   %xmm2,%xmm6\npsubd  %xmm6,%xmm1\nmovdqa %xmm1,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm1\npaddd  %xmm6,%xmm1\npshufd $0xf5,%xmm1,%xmm6\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npsubd  %xmm1,%xmm7\nmovdqa %xmm0,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm0,%xmm6\npmuludq %xmm2,%xmm6\npshufd $0xed,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npxor   %xmm6,%xmm6\npcmpgtd %xmm0,%xmm6\npand   %xmm2,%xmm6\npsubd  %xmm6,%xmm1\nmovdqa %xmm1,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm1\npaddd  %xmm6,%xmm1\npshufd $0xf5,%xmm1,%xmm6\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npsubd  %xmm1,%xmm0\nmovdqa %xmm5,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm5,%xmm6\npmuludq %xmm2,%xmm6\npshufd $0xed,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npxor   %xmm6,%xmm6\npcmpgtd %xmm5,%xmm6\npand   %xmm2,%xmm6\npsubd  %xmm6,%xmm1\nmovdqa %xmm1,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm1\npaddd  %xmm6,%xmm1\npshufd $0xf5,%xmm1,%xmm6\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npsubd  %xmm1,%xmm5\nmovdqa %xmm4,%xmm1\npmuludq %xmm2,%xmm1\npshufd $0xed,%xmm1,%xmm1\npshufd $0xf5,%xmm4,%xmm6\npmuludq %xmm2,%xmm6\npshufd $0xed,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npxor   %xmm6,%xmm6\npcmpgtd %xmm4,%xmm6\npand   %xmm2,%xmm6\npsubd  %xmm6,%xmm1\nmovdqa %xmm1,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm1\npaddd  %xmm6,%xmm1\npshufd $0xf5,%xmm1,%xmm6\npmuludq %xmm3,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm3,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm1\npsubd  %xmm1,%xmm4\npand   %xmm10,%xmm4\npand   %xmm10,%xmm5\npackuswb %xmm4,%xmm5\npand   %xmm10,%xmm0\npand   %xmm10,%xmm7\npackuswb %xmm0,%xmm7\npackuswb %xmm5,%xmm7\npaddb  %xmm9,%xmm7\nmovdqu %xmm7,0x10(%rbx,%rsi,1)\nadd    $0x20,%rsi\nadd    $0xfffffffffffffffe,%rdi\njne    12f0 <func0+0x1e0>\ntest   $0x1,%bpl\nje     18fa <func0+0x7ea>\nmovdqu (%rbx,%rsi,1),%xmm0\npunpcklbw %xmm0,%xmm1\npunpcklwd %xmm1,%xmm2\npsrad  $0x18,%xmm2\npunpckhwd %xmm1,%xmm3\npsrad  $0x18,%xmm3\npunpckhbw %xmm0,%xmm0\npunpcklwd %xmm0,%xmm4\npsrad  $0x18,%xmm4\npunpckhwd %xmm0,%xmm0\npsrad  $0x18,%xmm0\npaddd  %xmm12,%xmm0\npaddd  %xmm12,%xmm4\npaddd  %xmm12,%xmm3\npaddd  %xmm12,%xmm2\nmovdqa 0x8c8(%rip),%xmm1\nmovdqa %xmm2,%xmm5\npmuludq %xmm1,%xmm5\npshufd $0xed,%xmm5,%xmm7\npshufd $0xf5,%xmm2,%xmm5\npmuludq %xmm1,%xmm5\npshufd $0xed,%xmm5,%xmm5\npunpckldq %xmm5,%xmm7\npxor   %xmm5,%xmm5\npxor   %xmm6,%xmm6\npcmpgtd %xmm2,%xmm6\npand   %xmm1,%xmm6\npsubd  %xmm6,%xmm7\nmovdqa %xmm7,%xmm6\npsrld  $0x1f,%xmm6\npsrld  $0x3,%xmm7\npaddd  %xmm6,%xmm7\nmovdqa 0x88a(%rip),%xmm9\npshufd $0xf5,%xmm7,%xmm6\npmuludq %xmm9,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npmuludq %xmm9,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npunpckldq %xmm6,%xmm7\npsubd  %xmm7,%xmm2\nmovdqa %xmm3,%xmm6\npmuludq %xmm1,%xmm6\npshufd $0xed,%xmm6,%xmm6\npshufd $0xf5,%xmm3,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npxor   %xmm7,%xmm7\npcmpgtd %xmm3,%xmm7\npand   %xmm1,%xmm7\npsubd  %xmm7,%xmm6\nmovdqa %xmm6,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm6\npaddd  %xmm7,%xmm6\npshufd $0xf5,%xmm6,%xmm7\npmuludq %xmm9,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npmuludq %xmm9,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npsubd  %xmm6,%xmm3\nmovdqa %xmm4,%xmm6\npmuludq %xmm1,%xmm6\npshufd $0xed,%xmm6,%xmm6\npshufd $0xf5,%xmm4,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npxor   %xmm7,%xmm7\npcmpgtd %xmm4,%xmm7\npand   %xmm1,%xmm7\npsubd  %xmm7,%xmm6\nmovdqa %xmm6,%xmm7\npsrld  $0x1f,%xmm7\npsrld  $0x3,%xmm6\npaddd  %xmm7,%xmm6\npshufd $0xf5,%xmm6,%xmm7\npmuludq %xmm9,%xmm6\npshufd $0xe8,%xmm6,%xmm6\npmuludq %xmm9,%xmm7\npshufd $0xe8,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npsubd  %xmm6,%xmm4\nmovdqa %xmm0,%xmm6\npmuludq %xmm1,%xmm6\npshufd $0xed,%xmm6,%xmm6\npshufd $0xf5,%xmm0,%xmm7\npmuludq %xmm1,%xmm7\npshufd $0xed,%xmm7,%xmm7\npunpckldq %xmm7,%xmm6\npcmpgtd %xmm0,%xmm5\npand   %xmm1,%xmm5\npsubd  %xmm5,%xmm6\nmovdqa %xmm6,%xmm1\npsrld  $0x1f,%xmm1\npsrld  $0x3,%xmm6\npaddd  %xmm1,%xmm6\npshufd $0xf5,%xmm6,%xmm1\npmuludq %xmm9,%xmm6\npshufd $0xe8,%xmm6,%xmm5\npmuludq %xmm9,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm5\npsubd  %xmm5,%xmm0\nmovdqa 0x74f(%rip),%xmm1\npand   %xmm1,%xmm0\npand   %xmm1,%xmm4\npackuswb %xmm0,%xmm4\npand   %xmm1,%xmm3\npand   %xmm1,%xmm2\npackuswb %xmm3,%xmm2\npackuswb %xmm4,%xmm2\npaddb  0x73b(%rip),%xmm2\nmovdqu %xmm2,(%rbx,%rsi,1)\ncmp    %rdx,%rax\nje     1950 <func0+0x840>\ntest   $0x8,%al\njne    1151 <func0+0x41>\njmp    1917 <func0+0x807>\nxor    %esi,%esi\ntest   $0x1,%bpl\njne    16eb <func0+0x5db>\njmp    18fa <func0+0x7ea>\nmovsbl (%rbx,%rdx,1),%esi\nadd    %ecx,%esi\nmovslq %esi,%rsi\nimul   $0x4ec4ec4f,%rsi,%rdi\nmov    %rdi,%rbp\nshr    $0x3f,%rbp\nsar    $0x23,%rdi\nadd    %ebp,%edi\nlea    (%rdi,%rdi,4),%ebp\nlea    0x0(%rbp,%rbp,4),%ebp\nadd    %edi,%ebp\nsub    %ebp,%esi\nadd    $0x61,%sil\nmov    %sil,(%rbx,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rdx,%rax\njne    1917 <func0+0x807>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 51,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    0xedd(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovsbl (%rax),%eax\ncmp    $0x0,%eax\nje     1181 <func0+0x71>\nmov    -0x10(%rbp),%rdi\nmov    -0x8(%rbp),%rax\nmovsbl (%rax),%esi\ncall   1030 <strchr@plt>\ncmp    $0x0,%rax\njne    1170 <func0+0x60>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%cl\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdx\nadd    $0x1,%rdx\nmov    %rdx,-0x18(%rbp)\nmov    %cl,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x8(%rbp)\njmp    112f <func0+0x1f>\nmov    -0x18(%rbp),%rax\nmovb   $0x0,(%rax)\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 51,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r15\nmov    (%rdi),%bpl\ntest   %bpl,%bpl\nje     115b <func0+0x4b>\nlea    0x1(%r15),%rbx\nlea    0xed3(%rip),%r14\njmp    113c <func0+0x2c>\nnop\nmovzbl (%rbx),%ebp\nadd    $0x1,%rbx\ntest   %bpl,%bpl\nje     115b <func0+0x4b>\nmovsbl %bpl,%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1030 <memchr@plt>\ntest   %rax,%rax\njne    1130 <func0+0x20>\nmov    %bpl,(%r15)\nadd    $0x1,%r15\njmp    1130 <func0+0x20>\nmovb   $0x0,(%r15)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 51,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r15\nmov    (%rdi),%bpl\ntest   %bpl,%bpl\nje     115b <func0+0x4b>\nlea    0x1(%r15),%rbx\nlea    0xed3(%rip),%r14\njmp    113c <func0+0x2c>\nnop\nmovzbl (%rbx),%ebp\nadd    $0x1,%rbx\ntest   %bpl,%bpl\nje     115b <func0+0x4b>\nmovsbl %bpl,%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1030 <memchr@plt>\ntest   %rax,%rax\njne    1130 <func0+0x20>\nmov    %bpl,(%r15)\nadd    $0x1,%r15\njmp    1130 <func0+0x20>\nmovb   $0x0,(%r15)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 51,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r15\nmov    (%rdi),%bpl\ntest   %bpl,%bpl\nje     115b <func0+0x4b>\nlea    0x1(%r15),%rbx\nlea    0xed3(%rip),%r14\njmp    113c <func0+0x2c>\nnop\nmovzbl (%rbx),%ebp\nadd    $0x1,%rbx\ntest   %bpl,%bpl\nje     115b <func0+0x4b>\nmovsbl %bpl,%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1030 <memchr@plt>\ntest   %rax,%rax\njne    1130 <func0+0x20>\nmov    %bpl,(%r15)\nadd    $0x1,%r15\njmp    1130 <func0+0x20>\nmovb   $0x0,(%r15)\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 52,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmov    %edx,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1151 <func0+0x51>\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x18(%rbp),%eax\njl     113e <func0+0x3e>\nmovb   $0x0,-0x1(%rbp)\njmp    1155 <func0+0x55>\njmp    1143 <func0+0x43>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1115 <func0+0x15>\nmovb   $0x1,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 52,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\nsetg   %al\njle    1137 <func0+0x37>\ncmp    %edx,(%rdi)\njge    1137 <func0+0x37>\nmovslq %esi,%r8\nmov    %esi,%ecx\nmov    $0x1,%eax\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %rax,%rsi\ncmp    %rax,%rcx\nje     1131 <func0+0x31>\nlea    0x1(%rsi),%rax\ncmp    %edx,(%rdi,%rsi,4)\njl     1120 <func0+0x20>\ncmp    %r8,%rsi\nsetl   %al\nxor    $0x1,%al\nret\n"
    },
    {
        "task_id": 52,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1128 <func0+0x28>\ncmp    %edx,(%rdi)\njge    112b <func0+0x2b>\nmov    %esi,%eax\nmov    $0x1,%esi\nnop\nmov    %rsi,%rcx\ncmp    %rsi,%rax\nje     1121 <func0+0x21>\nlea    0x1(%rcx),%rsi\ncmp    %edx,(%rdi,%rcx,4)\njl     1110 <func0+0x10>\ncmp    %rax,%rcx\nsetae  %al\nret\nmov    $0x1,%al\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 52,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1128 <func0+0x28>\ncmp    %edx,(%rdi)\njge    112b <func0+0x2b>\nmov    %esi,%eax\nmov    $0x1,%esi\nnop\nmov    %rsi,%rcx\ncmp    %rsi,%rax\nje     1121 <func0+0x21>\nlea    0x1(%rcx),%rsi\ncmp    %edx,(%rdi,%rcx,4)\njl     1110 <func0+0x10>\ncmp    %rax,%rcx\nsetae  %al\nret\nmov    $0x1,%al\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 53,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nadd    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 53,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nlea    (%rdi,%rsi,1),%eax\nret\n"
    },
    {
        "task_id": 53,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nlea    (%rdi,%rsi,1),%eax\nret\n"
    },
    {
        "task_id": 53,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nlea    (%rdi,%rsi,1),%eax\nret\n"
    },
    {
        "task_id": 54,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x1c(%rbp)\nmov    -0x18(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x20(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njge    11c4 <func0+0xb4>\nmovb   $0x0,-0x25(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    119e <func0+0x8e>\nmov    -0x10(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nmov    -0x18(%rbp),%rcx\nmovslq -0x2c(%rbp),%rdx\nmovsbl (%rcx,%rdx,1),%ecx\ncmp    %ecx,%eax\njne    118b <func0+0x7b>\nmovb   $0x1,-0x25(%rbp)\njmp    119e <func0+0x8e>\njmp    1190 <func0+0x80>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1156 <func0+0x46>\ntestb  $0x1,-0x25(%rbp)\njne    11b1 <func0+0xa1>\nmovb   $0x0,-0x1(%rbp)\njmp    1254 <func0+0x144>\njmp    11b6 <func0+0xa6>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    113f <func0+0x2f>\nmovl   $0x0,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    1250 <func0+0x140>\nmovb   $0x0,-0x31(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njge    122a <func0+0x11a>\nmov    -0x18(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nmov    -0x10(%rbp),%rcx\nmovslq -0x38(%rbp),%rdx\nmovsbl (%rcx,%rdx,1),%ecx\ncmp    %ecx,%eax\njne    1217 <func0+0x107>\nmovb   $0x1,-0x31(%rbp)\njmp    122a <func0+0x11a>\njmp    121c <func0+0x10c>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    11e2 <func0+0xd2>\ntestb  $0x1,-0x31(%rbp)\njne    123d <func0+0x12d>\nmovb   $0x0,-0x1(%rbp)\njmp    1254 <func0+0x144>\njmp    1242 <func0+0x132>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    11cb <func0+0xbb>\nmovb   $0x1,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 54,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %rbx\nmov    %rsi,%rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1030 <strlen@plt>\ntest   %r15d,%r15d\nsetg   %r10b\njle    117f <func0+0x6f>\nmovslq %r15d,%r9\nmov    %r9d,%r8d\nmov    %eax,%edi\nxor    %esi,%esi\nmov    %r10d,%r11d\ntest   %eax,%eax\njle    1175 <func0+0x65>\nmov    (%r14,%rsi,1),%dl\nxor    %ecx,%ecx\nnopl   0x0(%rax,%rax,1)\ncmp    (%rbx,%rcx,1),%dl\nje     1160 <func0+0x50>\nadd    $0x1,%rcx\ncmp    %rcx,%rdi\njne    1150 <func0+0x40>\njmp    1172 <func0+0x62>\nadd    $0x1,%rsi\ncmp    %r9,%rsi\nsetl   %r11b\ncmp    %r8,%rsi\njne    1141 <func0+0x31>\njmp    117f <func0+0x6f>\nmov    %r11d,%r10d\ntest   $0x1,%r10b\nje     117f <func0+0x6f>\nxor    %eax,%eax\njmp    11d6 <func0+0xc6>\ntest   %eax,%eax\nsetg   %r10b\njle    11d1 <func0+0xc1>\nmovslq %eax,%r9\nmov    %r9d,%r8d\nmov    %r15d,%edi\nxor    %esi,%esi\nmov    %r10d,%eax\ntest   %r15d,%r15d\njle    11d1 <func0+0xc1>\nmov    (%rbx,%rsi,1),%dl\nxor    %ecx,%ecx\nnop\ncmp    (%r14,%rcx,1),%dl\nje     11c0 <func0+0xb0>\nadd    $0x1,%rcx\ncmp    %rcx,%rdi\njne    11a0 <func0+0x90>\njmp    11d4 <func0+0xc4>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rsi\ncmp    %r9,%rsi\nsetl   %al\ncmp    %r8,%rsi\njne    1195 <func0+0x85>\njmp    11d4 <func0+0xc4>\nmov    %r10d,%eax\nxor    $0x1,%al\nand    $0x1,%al\npop    %rbx\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 54,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %rbx\nmov    %rsi,%rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1030 <strlen@plt>\ntest   %r15d,%r15d\njle    117c <func0+0x6c>\nmovslq %r15d,%r9\nmov    %r9d,%r8d\nmov    %eax,%esi\nmov    $0x1,%r10b\nxor    %edi,%edi\ntest   %eax,%eax\njle    1178 <func0+0x68>\nmov    (%r14,%rdi,1),%cl\nxor    %edx,%edx\nnopw   0x0(%rax,%rax,1)\ncmp    (%rbx,%rdx,1),%cl\nje     1160 <func0+0x50>\nadd    $0x1,%rdx\ncmp    %rdx,%rsi\njne    1150 <func0+0x40>\njmp    1172 <func0+0x62>\nadd    $0x1,%rdi\ncmp    %r9,%rdi\nsetl   %r10b\ncmp    %r8,%rdi\njne    113d <func0+0x2d>\njmp    117c <func0+0x6c>\ntest   $0x1,%r10b\nje     117c <func0+0x6c>\nxor    %eax,%eax\njmp    11d5 <func0+0xc5>\ntest   %eax,%eax\njle    11d1 <func0+0xc1>\nmovslq %eax,%r9\nmov    %r9d,%r8d\nmov    %r15d,%esi\nxor    %edi,%edi\nmov    $0x1,%al\ntest   %r15d,%r15d\njle    11dd <func0+0xcd>\nmov    (%rbx,%rdi,1),%dl\nxor    %ecx,%ecx\nnopw   0x0(%rax,%rax,1)\ncmp    (%r14,%rcx,1),%dl\nje     11c0 <func0+0xb0>\nadd    $0x1,%rcx\ncmp    %rcx,%rsi\njne    11a0 <func0+0x90>\njmp    11d3 <func0+0xc3>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rdi\ncmp    %r9,%rdi\nsetl   %al\ncmp    %r8,%rdi\njne    118d <func0+0x7d>\njmp    11d3 <func0+0xc3>\nxor    %eax,%eax\nxor    $0x1,%al\nand    $0x1,%al\npop    %rbx\npop    %r14\npop    %r15\nret\nmov    $0x1,%al\njmp    11d3 <func0+0xc3>\n"
    },
    {
        "task_id": 54,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %rbx\nmov    %rsi,%rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1030 <strlen@plt>\ntest   %eax,%eax\nsetg   %cl\ntest   %r15d,%r15d\njle    11c0 <func0+0xb0>\ntest   %eax,%eax\njle    1178 <func0+0x68>\nmovslq %r15d,%r9\nmov    %r9d,%r8d\nmov    %eax,%esi\nmov    $0x1,%r10b\nxor    %edi,%edi\nmov    (%r14,%rdi,1),%cl\nxor    %edx,%edx\ncmp    (%rbx,%rdx,1),%cl\nje     1160 <func0+0x50>\nadd    $0x1,%rdx\ncmp    %rdx,%rsi\njne    1150 <func0+0x40>\njmp    1172 <func0+0x62>\nadd    $0x1,%rdi\ncmp    %r9,%rdi\nsetl   %r10b\ncmp    %r8,%rdi\njne    114a <func0+0x3a>\njmp    117c <func0+0x6c>\ntest   $0x1,%r10b\nje     117c <func0+0x6c>\nxor    %ecx,%ecx\njmp    11c3 <func0+0xb3>\ntest   %eax,%eax\nsetg   %cl\njle    11c0 <func0+0xb0>\ntest   %r15d,%r15d\njle    11c0 <func0+0xb0>\nmovslq %eax,%r9\nmov    %r9d,%r8d\nmov    %r15d,%esi\nmov    $0x1,%cl\nxor    %edi,%edi\nmov    (%rbx,%rdi,1),%dl\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\ncmp    (%r14,%rax,1),%dl\nje     11b1 <func0+0xa1>\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    11a0 <func0+0x90>\njmp    11c0 <func0+0xb0>\nadd    $0x1,%rdi\ncmp    %r9,%rdi\nsetl   %cl\ncmp    %r8,%rdi\njne    1195 <func0+0x85>\nxor    $0x1,%cl\nand    $0x1,%cl\nmov    %ecx,%eax\npop    %rbx\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 55,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xfc0,%rsp\nmov    %edi,-0x4(%rbp)\nlea    -0xfb0(%rbp),%rdi\nxor    %esi,%esi\nmov    $0xfa0,%edx\ncall   1030 <memset@plt>\nmovl   $0x0,-0xfb0(%rbp)\nmovl   $0x1,-0xfac(%rbp)\nmovl   $0x2,-0xfb4(%rbp)\nmov    -0xfb4(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     11a4 <func0+0x94>\nmov    -0xfb4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0xfb0(%rbp,%rax,4),%ecx\nmov    -0xfb4(%rbp),%eax\nsub    $0x2,%eax\ncltq\nadd    -0xfb0(%rbp,%rax,4),%ecx\nmovslq -0xfb4(%rbp),%rax\nmov    %ecx,-0xfb0(%rbp,%rax,4)\nmov    -0xfb4(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xfb4(%rbp)\njmp    114f <func0+0x3f>\nmovslq -0x4(%rbp),%rax\nmov    -0xfb0(%rbp,%rax,4),%eax\nadd    $0xfc0,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 55,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nsub    $0xfa0,%rsp\nmov    %edi,%ebx\nmov    %rsp,%rdi\nmov    $0xfa0,%edx\nxor    %esi,%esi\ncall   1030 <memset@plt>\nmovl   $0x1,0x4(%rsp)\ncmp    $0x2,%ebx\njl     1160 <func0+0x50>\nlea    0x1(%rbx),%eax\nmov    $0x2,%ecx\nmov    0x4(%rsp),%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nadd    -0x8(%rsp,%rcx,4),%edx\nmov    %edx,(%rsp,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1150 <func0+0x40>\nmovslq %ebx,%rax\nmov    (%rsp,%rax,4),%eax\nadd    $0xfa0,%rsp\npop    %rbx\nret\n"
    },
    {
        "task_id": 55,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nsub    $0xfa0,%rsp\nmov    %edi,%ebx\nmov    %rsp,%rdi\nmov    $0xfa0,%edx\nxor    %esi,%esi\ncall   1030 <memset@plt>\nmovl   $0x1,0x4(%rsp)\ncmp    $0x2,%ebx\njl     11e4 <func0+0xd4>\nlea    0x1(%rbx),%ecx\nmovl   $0x1,0x8(%rsp)\ncmp    $0x3,%ecx\nje     11e4 <func0+0xd4>\nlea    -0x3(%rcx),%rsi\nadd    $0xfffffffffffffffc,%rcx\nmov    %esi,%eax\nand    $0x3,%eax\ncmp    $0x3,%rcx\njae    1177 <func0+0x67>\nmov    $0x2,%esi\nmov    $0x1,%ecx\nmov    $0x3,%edx\ntest   %rax,%rax\njne    11d0 <func0+0xc0>\njmp    11e4 <func0+0xd4>\nand    $0xfffffffffffffffc,%rsi\nneg    %rsi\nmov    $0x1,%ecx\nmov    $0x3,%edx\nnopl   0x0(%rax,%rax,1)\nadd    -0x8(%rsp,%rdx,4),%ecx\nmov    %ecx,(%rsp,%rdx,4)\nmov    -0x4(%rsp,%rdx,4),%edi\nadd    %ecx,%edi\nmov    %edi,0x4(%rsp,%rdx,4)\nadd    %edi,%ecx\nmov    %ecx,0x8(%rsp,%rdx,4)\nadd    %edi,%ecx\nmov    %ecx,0xc(%rsp,%rdx,4)\nlea    (%rsi,%rdx,1),%rdi\nadd    $0x4,%rdi\nadd    $0x4,%rdx\ncmp    $0x3,%rdi\njne    1190 <func0+0x80>\nlea    -0x1(%rdx),%rsi\ntest   %rax,%rax\nje     11e4 <func0+0xd4>\nnopl   0x0(%rax,%rax,1)\nadd    -0x4(%rsp,%rsi,4),%ecx\nmov    %ecx,(%rsp,%rdx,4)\nmov    %rdx,%rsi\nadd    $0x1,%rdx\nadd    $0xffffffffffffffff,%rax\njne    11d0 <func0+0xc0>\nmovslq %ebx,%rax\nmov    (%rsp,%rax,4),%eax\nadd    $0xfa0,%rsp\npop    %rbx\nret\n"
    },
    {
        "task_id": 55,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nsub    $0xfa0,%rsp\nmov    %edi,%ebx\nmov    %rsp,%rdi\nmov    $0xfa0,%edx\nxor    %esi,%esi\ncall   1030 <memset@plt>\nmovl   $0x1,0x4(%rsp)\ncmp    $0x2,%ebx\njl     11e4 <func0+0xd4>\nlea    0x1(%rbx),%ecx\nmovl   $0x1,0x8(%rsp)\ncmp    $0x3,%ecx\nje     11e4 <func0+0xd4>\nlea    -0x3(%rcx),%rsi\nadd    $0xfffffffffffffffc,%rcx\nmov    %esi,%eax\nand    $0x3,%eax\ncmp    $0x3,%rcx\njae    1177 <func0+0x67>\nmov    $0x2,%esi\nmov    $0x1,%ecx\nmov    $0x3,%edx\ntest   %rax,%rax\njne    11d0 <func0+0xc0>\njmp    11e4 <func0+0xd4>\nand    $0xfffffffffffffffc,%rsi\nneg    %rsi\nmov    $0x1,%ecx\nmov    $0x3,%edx\nnopl   0x0(%rax,%rax,1)\nadd    -0x8(%rsp,%rdx,4),%ecx\nmov    %ecx,(%rsp,%rdx,4)\nmov    -0x4(%rsp,%rdx,4),%edi\nadd    %ecx,%edi\nmov    %edi,0x4(%rsp,%rdx,4)\nadd    %edi,%ecx\nmov    %ecx,0x8(%rsp,%rdx,4)\nadd    %edi,%ecx\nmov    %ecx,0xc(%rsp,%rdx,4)\nlea    (%rsi,%rdx,1),%rdi\nadd    $0x4,%rdi\nadd    $0x4,%rdx\ncmp    $0x3,%rdi\njne    1190 <func0+0x80>\nlea    -0x1(%rdx),%rsi\ntest   %rax,%rax\nje     11e4 <func0+0xd4>\nnopl   0x0(%rax,%rax,1)\nadd    -0x4(%rsp,%rsi,4),%ecx\nmov    %ecx,(%rsp,%rdx,4)\nmov    %rdx,%rsi\nadd    $0x1,%rdx\nadd    $0xffffffffffffffff,%rax\njne    11d0 <func0+0xc0>\nmovslq %ebx,%rax\nmov    (%rsp,%rax,4),%eax\nadd    $0xfa0,%rsp\npop    %rbx\nret\n"
    },
    {
        "task_id": 56,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\ncmpb   $0x0,(%rax,%rcx,1)\nje     1185 <func0+0x85>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x3c,%eax\njne    1146 <func0+0x46>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x3e,%eax\njne    1164 <func0+0x64>\nmov    -0x14(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njge    1177 <func0+0x77>\nmovb   $0x0,-0x1(%rbp)\njmp    119c <func0+0x9c>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1116 <func0+0x16>\ncmpl   $0x0,-0x14(%rbp)\nje     1198 <func0+0x98>\nmovb   $0x0,-0x1(%rbp)\njmp    119c <func0+0x9c>\nmovb   $0x1,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 56,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\njmp    1123 <func0+0x23>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nadd    $0x1,%eax\nxor    %edx,%edx\ncmp    $0x3e,%cl\nsete   %dl\nadd    $0x1,%rdi\nsub    %edx,%eax\njs     1135 <func0+0x35>\nmovzbl (%rdi),%ecx\ncmp    $0x3c,%cl\nje     1110 <func0+0x10>\ntest   %cl,%cl\njne    1113 <func0+0x13>\ntest   %eax,%eax\nsete   %al\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 56,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\njmp    1123 <func0+0x23>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nadd    $0x1,%eax\nxor    %edx,%edx\ncmp    $0x3e,%cl\nsete   %dl\nadd    $0x1,%rdi\nsub    %edx,%eax\njs     1135 <func0+0x35>\nmovzbl (%rdi),%ecx\ncmp    $0x3c,%cl\nje     1110 <func0+0x10>\ntest   %cl,%cl\njne    1113 <func0+0x13>\ntest   %eax,%eax\nsete   %al\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 56,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\njmp    1123 <func0+0x23>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nadd    $0x1,%eax\nxor    %edx,%edx\ncmp    $0x3e,%cl\nsete   %dl\nadd    $0x1,%rdi\nsub    %edx,%eax\njs     1135 <func0+0x35>\nmovzbl (%rdi),%ecx\ncmp    $0x3c,%cl\nje     1110 <func0+0x10>\ntest   %cl,%cl\njne    1113 <func0+0x13>\ntest   %eax,%eax\nsete   %al\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 57,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1199 <func0+0x99>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nmov    -0x10(%rbp),%rax\nmov    -0x20(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nucomiss (%rax,%rcx,4),%xmm0\njbe    1157 <func0+0x57>\nmovl   $0x1,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm1\nmov    -0x10(%rbp),%rax\nmov    -0x20(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmovss  (%rax,%rcx,4),%xmm0\nucomiss %xmm1,%xmm0\njbe    1186 <func0+0x86>\nmovl   $0x1,-0x1c(%rbp)\njmp    118b <func0+0x8b>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1120 <func0+0x20>\nmov    -0x18(%rbp),%eax\nadd    -0x1c(%rbp),%eax\ncmp    $0x2,%eax\njne    11b1 <func0+0xb1>\nmovb   $0x0,-0x1(%rbp)\njmp    11b5 <func0+0xb5>\nmovb   $0x1,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 57,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%al\ncmp    $0x2,%esi\njl     1148 <func0+0x48>\nmov    %esi,%r8d\nxor    %eax,%eax\nmov    $0x1,%edx\nmov    $0x1,%esi\nxor    %ecx,%ecx\nnopl   0x0(%rax,%rax,1)\nmovss  -0x4(%rdi,%rdx,4),%xmm0\nmovss  (%rdi,%rdx,4),%xmm1\nucomiss %xmm0,%xmm1\ncmova  %esi,%ecx\nucomiss %xmm1,%xmm0\ncmova  %esi,%eax\nadd    $0x1,%rdx\ncmp    %rdx,%r8\njne    1120 <func0+0x20>\nadd    %ecx,%eax\ncmp    $0x2,%eax\nsetne  %al\nret\n"
    },
    {
        "task_id": 57,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%al\ncmp    $0x2,%esi\njl     1245 <func0+0x145>\nmov    %esi,%r9d\nmovss  (%rdi),%xmm1\nlea    -0x1(%r9),%r8\ncmp    $0x8,%r8\njae    112a <func0+0x2a>\nxor    %eax,%eax\nmov    $0x1,%ecx\nxor    %edx,%edx\njmp    121a <func0+0x11a>\nmov    %r8,%rsi\nand    $0xfffffffffffffff8,%rsi\nlea    0x1(%rsi),%rcx\nshufps $0x0,%xmm1,%xmm1\nxorps  %xmm8,%xmm8\nxor    %eax,%eax\nxorps  %xmm9,%xmm9\nxorps  %xmm4,%xmm4\nxorps  %xmm3,%xmm3\nnopl   0x0(%rax)\nmovaps %xmm1,%xmm0\nmovups 0x4(%rdi,%rax,4),%xmm5\nshufps $0x3,%xmm5,%xmm0\nshufps $0x98,%xmm5,%xmm0\nmovaps %xmm5,%xmm6\nmovaps %xmm0,%xmm2\ncmpltps %xmm5,%xmm2\ncmpltps %xmm0,%xmm5\nmovups 0x14(%rdi,%rax,4),%xmm1\nshufps $0x3,%xmm1,%xmm6\nshufps $0x98,%xmm1,%xmm6\nmovaps %xmm1,%xmm0\ncmpltps %xmm6,%xmm0\ncmpltps %xmm1,%xmm6\nmovaps %xmm2,%xmm7\nandnps %xmm4,%xmm7\nmovaps %xmm7,%xmm4\npsubd  %xmm2,%xmm4\nmovaps %xmm6,%xmm2\nandnps %xmm3,%xmm2\nmovaps %xmm2,%xmm3\npsubd  %xmm6,%xmm3\nmovaps %xmm5,%xmm2\nandnps %xmm8,%xmm2\nmovaps %xmm2,%xmm8\npsubd  %xmm5,%xmm8\nmovaps %xmm0,%xmm2\nandnps %xmm9,%xmm2\nmovaps %xmm2,%xmm9\npsubd  %xmm0,%xmm9\nadd    $0x8,%rax\ncmp    %rax,%rsi\njne    1150 <func0+0x50>\npxor   %xmm0,%xmm0\nmovaps %xmm4,%xmm2\npcmpeqd %xmm0,%xmm2\nandps  %xmm2,%xmm3\nandnps %xmm4,%xmm2\norps   %xmm3,%xmm2\npcmpeqd %xmm0,%xmm2\nmovmskps %xmm2,%eax\nxor    %edx,%edx\ncmp    $0xf,%eax\nsetne  %dl\nmovaps %xmm8,%xmm2\npcmpeqd %xmm0,%xmm2\nandps  %xmm2,%xmm9\nandnps %xmm8,%xmm2\norps   %xmm9,%xmm2\npcmpeqd %xmm0,%xmm2\nmovmskps %xmm2,%r10d\nxor    %eax,%eax\ncmp    $0xf,%r10d\nsetne  %al\ncmp    %rsi,%r8\nje     123d <func0+0x13d>\nshufps $0xff,%xmm1,%xmm1\nmov    $0x1,%esi\nnop\nmovss  (%rdi,%rcx,4),%xmm0\nucomiss %xmm1,%xmm0\ncmova  %esi,%edx\nucomiss %xmm0,%xmm1\ncmova  %esi,%eax\nadd    $0x1,%rcx\nmovaps %xmm0,%xmm1\ncmp    %rcx,%r9\njne    1220 <func0+0x120>\nadd    %eax,%edx\ncmp    $0x2,%edx\nsetne  %al\nret\n"
    },
    {
        "task_id": 57,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%al\ncmp    $0x2,%esi\njl     1245 <func0+0x145>\nmov    %esi,%r9d\nmovss  (%rdi),%xmm1\nlea    -0x1(%r9),%r8\ncmp    $0x8,%r8\njae    112a <func0+0x2a>\nxor    %eax,%eax\nmov    $0x1,%ecx\nxor    %edx,%edx\njmp    121a <func0+0x11a>\nmov    %r8,%rsi\nand    $0xfffffffffffffff8,%rsi\nlea    0x1(%rsi),%rcx\nshufps $0x0,%xmm1,%xmm1\nxorps  %xmm8,%xmm8\nxor    %eax,%eax\nxorps  %xmm9,%xmm9\nxorps  %xmm4,%xmm4\nxorps  %xmm3,%xmm3\nnopl   0x0(%rax)\nmovaps %xmm1,%xmm0\nmovups 0x4(%rdi,%rax,4),%xmm5\nshufps $0x3,%xmm5,%xmm0\nshufps $0x98,%xmm5,%xmm0\nmovaps %xmm5,%xmm6\nmovaps %xmm0,%xmm2\ncmpltps %xmm5,%xmm2\ncmpltps %xmm0,%xmm5\nmovups 0x14(%rdi,%rax,4),%xmm1\nshufps $0x3,%xmm1,%xmm6\nshufps $0x98,%xmm1,%xmm6\nmovaps %xmm1,%xmm0\ncmpltps %xmm6,%xmm0\ncmpltps %xmm1,%xmm6\nmovaps %xmm2,%xmm7\nandnps %xmm4,%xmm7\nmovaps %xmm7,%xmm4\npsubd  %xmm2,%xmm4\nmovaps %xmm6,%xmm2\nandnps %xmm3,%xmm2\nmovaps %xmm2,%xmm3\npsubd  %xmm6,%xmm3\nmovaps %xmm5,%xmm2\nandnps %xmm8,%xmm2\nmovaps %xmm2,%xmm8\npsubd  %xmm5,%xmm8\nmovaps %xmm0,%xmm2\nandnps %xmm9,%xmm2\nmovaps %xmm2,%xmm9\npsubd  %xmm0,%xmm9\nadd    $0x8,%rax\ncmp    %rax,%rsi\njne    1150 <func0+0x50>\npxor   %xmm0,%xmm0\nmovaps %xmm4,%xmm2\npcmpeqd %xmm0,%xmm2\nandps  %xmm2,%xmm3\nandnps %xmm4,%xmm2\norps   %xmm3,%xmm2\npcmpeqd %xmm0,%xmm2\nmovmskps %xmm2,%eax\nxor    %edx,%edx\ncmp    $0xf,%eax\nsetne  %dl\nmovaps %xmm8,%xmm2\npcmpeqd %xmm0,%xmm2\nandps  %xmm2,%xmm9\nandnps %xmm8,%xmm2\norps   %xmm9,%xmm2\npcmpeqd %xmm0,%xmm2\nmovmskps %xmm2,%r10d\nxor    %eax,%eax\ncmp    $0xf,%r10d\nsetne  %al\ncmp    %rsi,%r8\nje     123d <func0+0x13d>\nshufps $0xff,%xmm1,%xmm1\nmov    $0x1,%esi\nnop\nmovss  (%rdi,%rcx,4),%xmm0\nucomiss %xmm1,%xmm0\ncmova  %esi,%edx\nucomiss %xmm0,%xmm1\ncmova  %esi,%eax\nadd    $0x1,%rcx\nmovaps %xmm0,%xmm1\ncmp    %rcx,%r9\njne    1220 <func0+0x120>\nadd    %eax,%edx\ncmp    $0x2,%edx\nsetne  %al\nret\n"
    },
    {
        "task_id": 58,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %ecx,-0x1c(%rbp)\nmov    %r8,-0x28(%rbp)\nmovslq -0xc(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1233 <func0+0x123>\nmovl   $0x0,-0x44(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njge    11aa <func0+0x9a>\nmov    -0x30(%rbp),%rax\nmovslq -0x40(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmovslq -0x38(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njne    1197 <func0+0x87>\nmovl   $0x1,-0x44(%rbp)\njmp    11aa <func0+0x9a>\njmp    119c <func0+0x8c>\nmov    -0x40(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x40(%rbp)\njmp    1163 <func0+0x53>\ncmpl   $0x0,-0x44(%rbp)\njne    1220 <func0+0x110>\nmovl   $0x0,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njge    121b <func0+0x10b>\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x18(%rbp),%rcx\nmovslq -0x3c(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njne    1208 <func0+0xf8>\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x30(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x34(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    121b <func0+0x10b>\njmp    120d <func0+0xfd>\nmov    -0x3c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x3c(%rbp)\njmp    11bb <func0+0xab>\njmp    1220 <func0+0x110>\njmp    1225 <func0+0x115>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    1149 <func0+0x39>\nmovl   $0x0,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\nmov    -0x34(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    12e9 <func0+0x1d9>\nmovl   $0x0,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nmov    -0x34(%rbp),%ecx\nsub    -0x38(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    12d6 <func0+0x1c6>\nmov    -0x30(%rbp),%rax\nmovslq -0x3c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x30(%rbp),%rcx\nmov    -0x3c(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\njle    12c3 <func0+0x1b3>\nmov    -0x30(%rbp),%rax\nmovslq -0x3c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x48(%rbp)\nmov    -0x30(%rbp),%rax\nmov    -0x3c(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x30(%rbp),%rax\nmovslq -0x3c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x48(%rbp),%edx\nmov    -0x30(%rbp),%rax\nmov    -0x3c(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    12c8 <func0+0x1b8>\nmov    -0x3c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x3c(%rbp)\njmp    1252 <func0+0x142>\njmp    12db <func0+0x1cb>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    123a <func0+0x12a>\nmov    -0x34(%rbp),%ecx\nmov    -0x28(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x30(%rbp),%rax\nadd    $0x50,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 58,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %r8,%r14\nmov    %ecx,%r15d\nmov    %rdx,%rbx\nmov    %esi,%r12d\nmov    %rdi,%r13\nmovslq %esi,%rbp\nlea    0x0(,%rbp,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebp,%ebp\njle    11b0 <func0+0xa0>\nmov    %r12d,%r8d\nmov    %r15d,%esi\nxor    %edi,%edi\nxor    %r9d,%r9d\njmp    1163 <func0+0x53>\nnopl   0x0(%rax,%rax,1)\nmovslq %r9d,%rcx\nadd    $0x1,%r9d\nmov    %ebp,(%rax,%rcx,4)\nadd    $0x1,%rdi\ncmp    %r8,%rdi\nje     11b3 <func0+0xa3>\ntest   %r9d,%r9d\njle    118e <func0+0x7e>\nmov    0x0(%r13,%rdi,4),%ebp\nmov    %r9d,%edx\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ncmp    %ebp,(%rax,%rcx,4)\nje     115a <func0+0x4a>\nadd    $0x1,%rcx\ncmp    %rcx,%rdx\njne    1180 <func0+0x70>\ntest   %r15d,%r15d\njle    115a <func0+0x4a>\nmov    0x0(%r13,%rdi,4),%ebp\nxor    %ecx,%ecx\nnopw   0x0(%rax,%rax,1)\ncmp    (%rbx,%rcx,4),%ebp\nje     1150 <func0+0x40>\nadd    $0x1,%rcx\ncmp    %rcx,%rsi\njne    11a0 <func0+0x90>\njmp    115a <func0+0x4a>\nxor    %r9d,%r9d\ncmp    $0x2,%r9d\njl     1210 <func0+0x100>\nlea    -0x1(%r9),%r8d\nxor    %esi,%esi\nmov    %r8d,%edi\njmp    11db <func0+0xcb>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nadd    $0x1,%esi\nadd    $0xffffffff,%edi\ncmp    %r8d,%esi\nje     1210 <func0+0x100>\nmov    %edi,%edi\nmov    %esi,%ecx\nnot    %ecx\nadd    %r9d,%ecx\ntest   %ecx,%ecx\njle    11d0 <func0+0xc0>\nxor    %ebp,%ebp\njmp    11f8 <func0+0xe8>\nnopl   0x0(%rax)\nmov    %rcx,%rbp\ncmp    %rcx,%rdi\nje     11d0 <func0+0xc0>\nmov    (%rax,%rbp,4),%ebx\nmov    0x4(%rax,%rbp,4),%edx\nlea    0x1(%rbp),%rcx\ncmp    %edx,%ebx\njle    11f0 <func0+0xe0>\nmov    %edx,(%rax,%rbp,4)\nmov    %ebx,0x4(%rax,%rbp,4)\njmp    11f0 <func0+0xe0>\nmov    %r9d,(%r14)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 58,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %r8,%r14\nmov    %ecx,%r15d\nmov    %rdx,%rbx\nmov    %esi,%r12d\nmov    %rdi,%r13\nmovslq %esi,%rbp\nlea    0x0(,%rbp,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebp,%ebp\njle    1272 <func0+0x162>\nmov    %r12d,%r8d\nmov    %r15d,%esi\nxor    %edi,%edi\nxor    %r9d,%r9d\njmp    1163 <func0+0x53>\nnop\nmovslq %r9d,%rdx\nadd    $0x1,%r9d\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdi\ncmp    %r8,%rdi\nje     11b0 <func0+0xa0>\ntest   %r9d,%r9d\njle    118e <func0+0x7e>\nmov    0x0(%r13,%rdi,4),%ecx\nmov    %r9d,%ebp\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ncmp    %ecx,(%rax,%rdx,4)\nje     115a <func0+0x4a>\nadd    $0x1,%rdx\ncmp    %rdx,%rbp\njne    1180 <func0+0x70>\ntest   %r15d,%r15d\njle    115a <func0+0x4a>\nmov    0x0(%r13,%rdi,4),%ecx\nxor    %edx,%edx\nnopw   0x0(%rax,%rax,1)\ncmp    (%rbx,%rdx,4),%ecx\nje     1150 <func0+0x40>\nadd    $0x1,%rdx\ncmp    %rdx,%rsi\njne    11a0 <func0+0x90>\njmp    115a <func0+0x4a>\ncmp    $0x2,%r9d\njl     1275 <func0+0x165>\nlea    -0x1(%r9),%r8d\nxor    %esi,%esi\nmov    %r8d,%r11d\njmp    11e0 <func0+0xd0>\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x1,%esi\nadd    $0xffffffff,%r11d\ncmp    %r8d,%esi\nje     1275 <func0+0x165>\nmov    %esi,%ecx\nnot    %ecx\nadd    %r9d,%ecx\ntest   %ecx,%ecx\njle    11d0 <func0+0xc0>\nmov    %r8d,%r10d\nsub    %esi,%r10d\nmov    (%rax),%edx\ncmp    $0x1,%r10d\njne    1220 <func0+0x110>\nxor    %ebx,%ebx\ntest   $0x1,%r10b\nje     11d0 <func0+0xc0>\nmov    0x4(%rax,%rbx,4),%ecx\ncmp    %ecx,%edx\njle    11d0 <func0+0xc0>\nmov    %ecx,(%rax,%rbx,4)\nmov    %edx,0x4(%rax,%rbx,4)\njmp    11d0 <func0+0xc0>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %r11d,%edi\nand    $0xfffffffe,%edi\nxor    %ecx,%ecx\njmp    1240 <func0+0x130>\nnopw   0x0(%rax,%rax,1)\nmov    %ebp,0x4(%rax,%rcx,4)\nmov    %edx,0x8(%rax,%rcx,4)\nmov    %rbx,%rcx\ncmp    %rbx,%rdi\nje     11fb <func0+0xeb>\nmov    0x4(%rax,%rcx,4),%ebp\ncmp    %ebp,%edx\njle    1260 <func0+0x150>\nmov    %ebp,(%rax,%rcx,4)\nmov    %edx,0x4(%rax,%rcx,4)\njmp    1262 <func0+0x152>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %ebp,%edx\nlea    0x2(%rcx),%rbx\nmov    0x8(%rax,%rcx,4),%ebp\ncmp    %ebp,%edx\njg     1230 <func0+0x120>\nmov    %ebp,%edx\njmp    1238 <func0+0x128>\nxor    %r9d,%r9d\nmov    %r9d,(%r14)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 58,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %r8,%r14\nmov    %ecx,%r12d\nmov    %rdx,%rbx\nmov    %esi,%r13d\nmov    %rdi,%r15\nmovslq %esi,%rbp\nlea    0x0(,%rbp,4),%rdi\ncall   1030 <malloc@plt>\nxor    %r9d,%r9d\ntest   %ebp,%ebp\njle    127a <func0+0x16a>\ntest   %r12d,%r12d\njle    127a <func0+0x16a>\nmov    %r13d,%r8d\nmov    %r12d,%esi\nxor    %edi,%edi\nxor    %r9d,%r9d\njmp    1173 <func0+0x63>\nnopl   0x0(%rax,%rax,1)\nmovslq %r9d,%rcx\nadd    $0x1,%r9d\nmov    %ebp,(%rax,%rcx,4)\nadd    $0x1,%rdi\ncmp    %r8,%rdi\nje     11b0 <func0+0xa0>\nmov    (%r15,%rdi,4),%ebp\ntest   %r9d,%r9d\njle    119e <func0+0x8e>\nmov    %r9d,%ecx\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\ncmp    %ebp,(%rax,%rdx,4)\nje     116a <func0+0x5a>\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    1190 <func0+0x80>\nxor    %ecx,%ecx\ncmp    (%rbx,%rcx,4),%ebp\nje     1160 <func0+0x50>\nadd    $0x1,%rcx\ncmp    %rcx,%rsi\njne    11a0 <func0+0x90>\njmp    116a <func0+0x5a>\ncmp    $0x2,%r9d\njl     127a <func0+0x16a>\nlea    -0x1(%r9),%r8d\nxor    %esi,%esi\nmov    %r8d,%r11d\njmp    11e0 <func0+0xd0>\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x1,%esi\nadd    $0xffffffff,%r11d\ncmp    %r8d,%esi\nje     127a <func0+0x16a>\nmov    %esi,%ecx\nnot    %ecx\nadd    %r9d,%ecx\ntest   %ecx,%ecx\njle    11d0 <func0+0xc0>\nmov    %r8d,%r10d\nsub    %esi,%r10d\nmov    (%rax),%edx\ncmp    $0x1,%r10d\njne    1200 <func0+0xf0>\nxor    %ebx,%ebx\njmp    1258 <func0+0x148>\nnopl   (%rax)\nmov    %r11d,%edi\nand    $0xfffffffe,%edi\nxor    %ecx,%ecx\njmp    1220 <func0+0x110>\nnopw   0x0(%rax,%rax,1)\nmov    %ebp,0x4(%rax,%rcx,4)\nmov    %edx,0x8(%rax,%rcx,4)\nmov    %rbx,%rcx\ncmp    %rbx,%rdi\nje     1258 <func0+0x148>\nmov    0x4(%rax,%rcx,4),%ebp\ncmp    %ebp,%edx\njle    1240 <func0+0x130>\nmov    %ebp,(%rax,%rcx,4)\nmov    %edx,0x4(%rax,%rcx,4)\nlea    0x2(%rcx),%rbx\nmov    0x8(%rax,%rcx,4),%ebp\ncmp    %ebp,%edx\njg     1210 <func0+0x100>\njmp    124e <func0+0x13e>\nnopl   (%rax)\nmov    %ebp,%edx\nlea    0x2(%rcx),%rbx\nmov    0x8(%rax,%rcx,4),%ebp\ncmp    %ebp,%edx\njg     1210 <func0+0x100>\nmov    %ebp,%edx\nmov    %rbx,%rcx\ncmp    %rbx,%rdi\njne    1220 <func0+0x110>\ntest   $0x1,%r10b\nje     11d0 <func0+0xc0>\nmov    0x4(%rax,%rbx,4),%ecx\ncmp    %ecx,%edx\njle    11d0 <func0+0xc0>\nmov    %ecx,(%rax,%rbx,4)\nmov    %edx,0x4(%rax,%rbx,4)\njmp    11d0 <func0+0xc0>\nmov    %r9d,(%r14)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 59,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmovl   $0x2,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     1176 <func0+0x76>\njmp    1123 <func0+0x23>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nxor    %eax,%eax\ncmp    $0x0,%edx\nmov    %al,-0x9(%rbp)\njne    1144 <func0+0x44>\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\nsetg   %al\nmov    %al,-0x9(%rbp)\nmov    -0x9(%rbp),%al\ntest   $0x1,%al\njne    1154 <func0+0x54>\njmp    1163 <func0+0x63>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %eax,-0x4(%rbp)\njmp    1123 <func0+0x23>\njmp    1168 <func0+0x68>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmp    110e <func0+0xe>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 59,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    $0x4,%edi\njge    1108 <func0+0x8>\nmov    %edi,%eax\nret\nmov    $0x2,%ecx\njmp    111c <func0+0x1c>\nnop\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     1105 <func0+0x5>\nmov    %edi,%eax\nxchg   %ax,%ax\ncltd\nidiv   %ecx\ncmp    %ecx,%edi\njle    1110 <func0+0x10>\ntest   %edx,%edx\njne    1110 <func0+0x10>\nmov    %edi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%edi\njmp    1120 <func0+0x20>\n"
    },
    {
        "task_id": 59,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    $0x4,%edi\njge    1108 <func0+0x8>\nmov    %edi,%eax\nret\nmov    $0x2,%ecx\njmp    111c <func0+0x1c>\nnop\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     1105 <func0+0x5>\nmov    %edi,%eax\nxchg   %ax,%ax\ncltd\nidiv   %ecx\ncmp    %ecx,%edi\njle    1110 <func0+0x10>\ntest   %edx,%edx\njne    1110 <func0+0x10>\nmov    %edi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%edi\njmp    1120 <func0+0x20>\n"
    },
    {
        "task_id": 59,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    $0x4,%edi\njge    1108 <func0+0x8>\nmov    %edi,%eax\nret\nmov    $0x2,%ecx\njmp    111c <func0+0x1c>\nnop\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     1105 <func0+0x5>\nmov    %edi,%eax\ncltd\nidiv   %ecx\ncmp    %ecx,%edi\njle    1110 <func0+0x10>\ncs nopw 0x0(%rax,%rax,1)\nnop\ntest   %edx,%edx\njne    1110 <func0+0x10>\nmov    %edi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%edi\ncltd\nidiv   %ecx\ncmp    %ecx,%edi\njg     1130 <func0+0x30>\njmp    1110 <func0+0x10>\n"
    },
    {
        "task_id": 60,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    -0x4(%rbp),%ecx\nadd    $0x1,%ecx\nimul   %ecx,%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\npop    %rbp\nret\n"
    },
    {
        "task_id": 60,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nlea    0x1(%rdi),%ecx\nimul   %edi,%ecx\nmov    %ecx,%eax\nshr    $0x1f,%eax\nadd    %ecx,%eax\nsar    %eax\nret\n"
    },
    {
        "task_id": 60,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nlea    0x1(%rdi),%ecx\nimul   %edi,%ecx\nmov    %ecx,%eax\nshr    $0x1f,%eax\nadd    %ecx,%eax\nsar    %eax\nret\n"
    },
    {
        "task_id": 60,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nlea    0x1(%rdi),%ecx\nimul   %edi,%ecx\nmov    %ecx,%eax\nshr    $0x1f,%eax\nadd    %ecx,%eax\nsar    %eax\nret\n"
    },
    {
        "task_id": 61,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovslq -0x18(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\nmov    -0x20(%rbp),%rax\ncmp    %rcx,%rax\njae    11ad <func0+0x9d>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x28,%eax\njne    1169 <func0+0x59>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x29,%eax\njne    1187 <func0+0x77>\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njge    119a <func0+0x8a>\nmovb   $0x0,-0x1(%rbp)\njmp    11b9 <func0+0xa9>\njmp    119f <func0+0x8f>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    112a <func0+0x1a>\ncmpl   $0x0,-0x14(%rbp)\nsete   %al\nand    $0x1,%al\nmov    %al,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 61,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nsetne  %cl\nje     1186 <func0+0x76>\nmov    (%r14),%sil\nxor    %edx,%edx\ncmp    $0x28,%sil\nsete   %dl\nxor    %edi,%edi\ncmp    $0x29,%sil\nsete   %dil\nsub    %edi,%edx\njs     118a <func0+0x7a>\nmov    $0x1,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %rsi,%rcx\ncmp    %rsi,%rax\nje     117e <func0+0x6e>\nmovzbl (%r14,%rcx,1),%ebx\nxor    %esi,%esi\ncmp    $0x28,%bl\nsete   %sil\nadd    %esi,%edx\nxor    %edi,%edi\ncmp    $0x29,%bl\nsete   %dil\nlea    0x1(%rcx),%rsi\nsub    %edi,%edx\njns    1150 <func0+0x40>\nmov    $0x1,%edx\ncmp    %rcx,%rax\nseta   %cl\njmp    118f <func0+0x7f>\nxor    %edx,%edx\njmp    118f <func0+0x7f>\nmov    $0x1,%edx\ntest   %edx,%edx\nsete   %al\nnot    %cl\nand    %al,%cl\nmov    %ecx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 61,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1176 <func0+0x66>\nmov    (%r14),%dl\nxor    %ecx,%ecx\ncmp    $0x28,%dl\nsete   %cl\nxor    %esi,%esi\ncmp    $0x29,%dl\nsete   %sil\nsub    %esi,%ecx\njs     117c <func0+0x6c>\nmov    $0x1,%esi\nxchg   %ax,%ax\nmov    %rsi,%rdx\ncmp    %rsi,%rax\nje     116e <func0+0x5e>\nmovzbl (%r14,%rdx,1),%ebx\nxor    %esi,%esi\ncmp    $0x28,%bl\nsete   %sil\nadd    %esi,%ecx\nxor    %edi,%edi\ncmp    $0x29,%bl\nsete   %dil\nlea    0x1(%rdx),%rsi\nsub    %edi,%ecx\njns    1140 <func0+0x30>\nmov    $0x1,%ecx\ncmp    %rdx,%rax\nsetbe  %dl\njmp    1183 <func0+0x73>\nxor    %ecx,%ecx\nmov    $0x1,%dl\njmp    1183 <func0+0x73>\nxor    %edx,%edx\nmov    $0x1,%ecx\ntest   %ecx,%ecx\nsete   %al\nand    %dl,%al\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 61,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1176 <func0+0x66>\nmov    (%r14),%dl\nxor    %ecx,%ecx\ncmp    $0x28,%dl\nsete   %cl\nxor    %esi,%esi\ncmp    $0x29,%dl\nsete   %sil\nsub    %esi,%ecx\njs     117c <func0+0x6c>\nmov    $0x1,%esi\nxchg   %ax,%ax\nmov    %rsi,%rdx\ncmp    %rsi,%rax\nje     116e <func0+0x5e>\nmovzbl (%r14,%rdx,1),%ebx\nxor    %esi,%esi\ncmp    $0x28,%bl\nsete   %sil\nadd    %esi,%ecx\nxor    %edi,%edi\ncmp    $0x29,%bl\nsete   %dil\nlea    0x1(%rdx),%rsi\nsub    %edi,%ecx\njns    1140 <func0+0x30>\nmov    $0x1,%ecx\ncmp    %rdx,%rax\nsetbe  %dl\njmp    1183 <func0+0x73>\nxor    %ecx,%ecx\nmov    $0x1,%dl\njmp    1183 <func0+0x73>\nxor    %edx,%edx\nmov    $0x1,%ecx\ntest   %ecx,%ecx\nsete   %al\nand    %dl,%al\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 62,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1154 <func0+0x54>\ncvtsi2ssl -0x1c(%rbp),%xmm0\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmulss  (%rax,%rcx,4),%xmm0\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmovss  %xmm0,(%rax,%rcx,4)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1116 <func0+0x16>\npop    %rbp\nret\n"
    },
    {
        "task_id": 62,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    $0x2,%esi\njl     112b <func0+0x2b>\nmov    %esi,%eax\nmov    $0x1,%ecx\nnopl   0x0(%rax)\nxorps  %xmm0,%xmm0\ncvtsi2ss %ecx,%xmm0\nmulss  (%rdi,%rcx,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1110 <func0+0x10>\nret\n"
    },
    {
        "task_id": 62,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    $0x2,%esi\njl     1290 <func0+0x190>\nmov    %esi,%r10d\nlea    -0x1(%r10),%r8\nmov    $0x1,%ecx\ncmp    $0x8,%r8\njb     1236 <func0+0x136>\nlea    (%rdi,%r10,4),%rax\ncmp    %rdx,%rax\njbe    113d <func0+0x3d>\nlea    (%rdx,%r10,4),%rax\nadd    $0xfffffffffffffffc,%rax\nlea    0x4(%rdi),%rsi\ncmp    %rax,%rsi\njb     1236 <func0+0x136>\nmov    %r8,%rcx\nand    $0xfffffffffffffff8,%rcx\nlea    -0x8(%rcx),%rax\nmov    %rax,%r9\nshr    $0x3,%r9\nadd    $0x1,%r9\ntest   %rax,%rax\nje     1291 <func0+0x191>\nmov    %r9,%rax\nand    $0xfffffffffffffffe,%rax\nmovdqa 0xe95(%rip),%xmm0\nxor    %esi,%esi\nmovdqa 0xe9b(%rip),%xmm1\nmovdqa 0xea3(%rip),%xmm2\nmovdqa 0xeab(%rip),%xmm3\nmovdqa 0xeb3(%rip),%xmm4\nnopl   (%rax)\nmovdqa %xmm0,%xmm5\npaddd  %xmm1,%xmm5\ncvtdq2ps %xmm0,%xmm6\ncvtdq2ps %xmm5,%xmm5\nmovups 0x4(%rdi,%rsi,4),%xmm7\nmulps  %xmm6,%xmm7\nmovups 0x14(%rdi,%rsi,4),%xmm6\nmulps  %xmm5,%xmm6\nmovups %xmm7,(%rdx,%rsi,4)\nmovups %xmm6,0x10(%rdx,%rsi,4)\nmovdqa %xmm0,%xmm5\npaddd  %xmm2,%xmm5\nmovdqa %xmm0,%xmm6\npaddd  %xmm3,%xmm6\ncvtdq2ps %xmm5,%xmm5\ncvtdq2ps %xmm6,%xmm6\nmovups 0x24(%rdi,%rsi,4),%xmm7\nmulps  %xmm5,%xmm7\nmovups 0x34(%rdi,%rsi,4),%xmm5\nmulps  %xmm6,%xmm5\nmovups %xmm7,0x20(%rdx,%rsi,4)\nmovups %xmm5,0x30(%rdx,%rsi,4)\nadd    $0x10,%rsi\npaddd  %xmm4,%xmm0\nadd    $0xfffffffffffffffe,%rax\njne    1190 <func0+0x90>\ntest   $0x1,%r9b\nje     122d <func0+0x12d>\ncvtdq2ps %xmm0,%xmm1\npaddd  0xe0a(%rip),%xmm0\ncvtdq2ps %xmm0,%xmm0\nlea    0x0(,%rsi,4),%rax\nor     $0x4,%rax\nmovups (%rdi,%rax,1),%xmm2\nmulps  %xmm1,%xmm2\nmovups 0x10(%rdi,%rax,1),%xmm1\nmulps  %xmm0,%xmm1\nmovups %xmm2,(%rdx,%rsi,4)\nmovups %xmm1,0x10(%rdx,%rsi,4)\ncmp    %rcx,%r8\nje     1290 <func0+0x190>\nor     $0x1,%rcx\nmov    %rcx,%rax\nnot    %rax\ntest   $0x1,%r10b\njne    1258 <func0+0x158>\nxorps  %xmm0,%xmm0\ncvtsi2ss %ecx,%xmm0\nmulss  (%rdi,%rcx,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rcx,4)\nadd    $0x1,%rcx\nadd    %r10,%rax\nje     1290 <func0+0x190>\nnopl   (%rax)\nxorps  %xmm0,%xmm0\ncvtsi2ss %ecx,%xmm0\nmulss  (%rdi,%rcx,4),%xmm0\nlea    0x1(%rcx),%eax\nxorps  %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nmovss  %xmm0,-0x4(%rdx,%rcx,4)\nmulss  0x4(%rdi,%rcx,4),%xmm1\nmovss  %xmm1,(%rdx,%rcx,4)\nadd    $0x2,%rcx\ncmp    %r10,%rcx\njne    1260 <func0+0x160>\nret\nmovdqa 0xd67(%rip),%xmm0\nxor    %esi,%esi\ntest   $0x1,%r9b\njne    11fb <func0+0xfb>\njmp    122d <func0+0x12d>\n"
    },
    {
        "task_id": 62,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    $0x2,%esi\njl     1292 <func0+0x192>\nmov    %esi,%r10d\nlea    -0x1(%r10),%r8\nmov    $0x1,%ecx\ncmp    $0x8,%r8\njb     1135 <func0+0x35>\nlea    (%rdi,%r10,4),%rax\ncmp    %rdx,%rax\njbe    1195 <func0+0x95>\nlea    (%rdx,%r10,4),%rax\nadd    $0xfffffffffffffffc,%rax\nlea    0x4(%rdi),%rsi\ncmp    %rax,%rsi\njae    1195 <func0+0x95>\nmov    %rcx,%rax\nnot    %rax\ntest   $0x1,%r10b\njne    1157 <func0+0x57>\nxorps  %xmm0,%xmm0\ncvtsi2ss %ecx,%xmm0\nmulss  (%rdi,%rcx,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rcx,4)\nadd    $0x1,%rcx\nadd    %r10,%rax\nje     1292 <func0+0x192>\nxorps  %xmm0,%xmm0\ncvtsi2ss %ecx,%xmm0\nmulss  (%rdi,%rcx,4),%xmm0\nlea    0x1(%rcx),%eax\nxorps  %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nmovss  %xmm0,-0x4(%rdx,%rcx,4)\nmulss  0x4(%rdi,%rcx,4),%xmm1\nmovss  %xmm1,(%rdx,%rcx,4)\nadd    $0x2,%rcx\ncmp    %r10,%rcx\njne    1160 <func0+0x60>\njmp    1292 <func0+0x192>\nmov    %r8,%rcx\nand    $0xfffffffffffffff8,%rcx\nlea    -0x8(%rcx),%rax\nmov    %rax,%r9\nshr    $0x3,%r9\nadd    $0x1,%r9\ntest   %rax,%rax\nje     12ac <func0+0x1ac>\nmov    %r9,%rax\nand    $0xfffffffffffffffe,%rax\nmovdqa 0xe3d(%rip),%xmm0\nxor    %esi,%esi\nmovdqa 0xe43(%rip),%xmm1\nmovdqa 0xe4b(%rip),%xmm2\nmovdqa 0xe53(%rip),%xmm3\nmovdqa 0xe5b(%rip),%xmm4\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovdqa %xmm0,%xmm5\npaddd  %xmm1,%xmm5\ncvtdq2ps %xmm0,%xmm6\ncvtdq2ps %xmm5,%xmm5\nmovups 0x4(%rdi,%rsi,4),%xmm7\nmulps  %xmm6,%xmm7\nmovups 0x14(%rdi,%rsi,4),%xmm6\nmulps  %xmm5,%xmm6\nmovups %xmm7,(%rdx,%rsi,4)\nmovups %xmm6,0x10(%rdx,%rsi,4)\nmovdqa %xmm0,%xmm5\npaddd  %xmm2,%xmm5\nmovdqa %xmm0,%xmm6\npaddd  %xmm3,%xmm6\ncvtdq2ps %xmm5,%xmm5\ncvtdq2ps %xmm6,%xmm6\nmovups 0x24(%rdi,%rsi,4),%xmm7\nmulps  %xmm5,%xmm7\nmovups 0x34(%rdi,%rsi,4),%xmm5\nmulps  %xmm6,%xmm5\nmovups %xmm7,0x20(%rdx,%rsi,4)\nmovups %xmm5,0x30(%rdx,%rsi,4)\nadd    $0x10,%rsi\npaddd  %xmm4,%xmm0\nadd    $0xfffffffffffffffe,%rax\njne    11f0 <func0+0xf0>\ntest   $0x1,%r9b\nje     128d <func0+0x18d>\ncvtdq2ps %xmm0,%xmm1\npaddd  0xdaa(%rip),%xmm0\ncvtdq2ps %xmm0,%xmm0\nlea    0x0(,%rsi,4),%rax\nor     $0x4,%rax\nmovups (%rdi,%rax,1),%xmm2\nmulps  %xmm1,%xmm2\nmovups 0x10(%rdi,%rax,1),%xmm1\nmulps  %xmm0,%xmm1\nmovups %xmm2,(%rdx,%rsi,4)\nmovups %xmm1,0x10(%rdx,%rsi,4)\ncmp    %rcx,%r8\njne    1293 <func0+0x193>\nret\nor     $0x1,%rcx\nmov    %rcx,%rax\nnot    %rax\ntest   $0x1,%r10b\nje     1141 <func0+0x41>\njmp    1157 <func0+0x57>\nmovdqa 0xd4c(%rip),%xmm0\nxor    %esi,%esi\ntest   $0x1,%r9b\njne    125b <func0+0x15b>\njmp    128d <func0+0x18d>\n"
    },
    {
        "task_id": 63,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x1b0,%rsp\nmov    %edi,-0x4(%rbp)\nlea    -0x1a0(%rbp),%rdi\nxor    %esi,%esi\nmov    $0x190,%edx\ncall   1030 <memset@plt>\nmovl   $0x0,-0x19c(%rbp)\nmovl   $0x1,-0x198(%rbp)\nmovl   $0x3,-0x1a4(%rbp)\nmov    -0x1a4(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     11b6 <func0+0xa6>\nmov    -0x1a4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%ecx\nmov    -0x1a4(%rbp),%eax\nsub    $0x2,%eax\ncltq\nadd    -0x1a0(%rbp,%rax,4),%ecx\nmov    -0x1a4(%rbp),%eax\nsub    $0x3,%eax\ncltq\nadd    -0x1a0(%rbp,%rax,4),%ecx\nmovslq -0x1a4(%rbp),%rax\nmov    %ecx,-0x1a0(%rbp,%rax,4)\nmov    -0x1a4(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1a4(%rbp)\njmp    114f <func0+0x3f>\nmovslq -0x4(%rbp),%rax\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    $0x1b0,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 63,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nsub    $0x190,%rsp\nmov    %edi,%ebx\nmov    %rsp,%rdi\nmov    $0x190,%edx\nxor    %esi,%esi\ncall   1030 <memset@plt>\nmovl   $0x1,0x8(%rsp)\ncmp    $0x3,%ebx\njl     1164 <func0+0x54>\nlea    0x1(%rbx),%eax\nmov    $0x3,%ecx\nmov    0x8(%rsp),%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nadd    -0x8(%rsp,%rcx,4),%edx\nadd    -0xc(%rsp,%rcx,4),%edx\nmov    %edx,(%rsp,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1150 <func0+0x40>\nmovslq %ebx,%rax\nmov    (%rsp,%rax,4),%eax\nadd    $0x190,%rsp\npop    %rbx\nret\n"
    },
    {
        "task_id": 63,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nsub    $0x190,%rsp\nmov    %edi,%ebx\nmov    %rsp,%rdi\nmov    $0x190,%edx\nxor    %esi,%esi\ncall   1030 <memset@plt>\nmovl   $0x1,0x8(%rsp)\ncmp    $0x3,%ebx\njl     11ac <func0+0x9c>\nlea    0x1(%rbx),%ecx\nmov    (%rsp),%eax\nadd    $0x1,%eax\nmov    %eax,0xc(%rsp)\ncmp    $0x4,%ecx\nje     11ac <func0+0x9c>\ncmp    $0x5,%ecx\njne    115e <func0+0x4e>\nmov    $0x2,%edx\nmov    $0x4,%esi\ntest   $0x1,%cl\njne    11a2 <func0+0x92>\njmp    11ac <func0+0x9c>\nlea    -0x4(%rcx),%rsi\nand    $0xfffffffffffffffe,%rsi\nneg    %rsi\nmov    $0x2,%edx\nxchg   %ax,%ax\nmov    (%rsp,%rdx,4),%edi\nadd    %edi,%eax\nadd    -0x4(%rsp,%rdx,4),%eax\nmov    %eax,0x8(%rsp,%rdx,4)\nadd    0x4(%rsp,%rdx,4),%eax\nadd    %edi,%eax\nmov    %eax,0xc(%rsp,%rdx,4)\nlea    (%rsi,%rdx,1),%rdi\nadd    $0x2,%rdi\nadd    $0x2,%rdx\ncmp    $0x2,%rdi\njne    1170 <func0+0x60>\nlea    0x2(%rdx),%rsi\ntest   $0x1,%cl\nje     11ac <func0+0x9c>\nadd    (%rsp,%rdx,4),%eax\nadd    -0xc(%rsp,%rsi,4),%eax\nmov    %eax,(%rsp,%rsi,4)\nmovslq %ebx,%rax\nmov    (%rsp,%rax,4),%eax\nadd    $0x190,%rsp\npop    %rbx\nret\n"
    },
    {
        "task_id": 63,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nsub    $0x190,%rsp\nmov    %edi,%ebx\nmov    %rsp,%rdi\nmov    $0x190,%edx\nxor    %esi,%esi\ncall   1030 <memset@plt>\nmovl   $0x1,0x8(%rsp)\ncmp    $0x3,%ebx\njl     11ac <func0+0x9c>\nlea    0x1(%rbx),%ecx\nmov    (%rsp),%eax\nadd    $0x1,%eax\nmov    %eax,0xc(%rsp)\ncmp    $0x4,%ecx\nje     11ac <func0+0x9c>\ncmp    $0x5,%ecx\njne    115e <func0+0x4e>\nmov    $0x2,%edx\nmov    $0x4,%esi\ntest   $0x1,%cl\njne    11a2 <func0+0x92>\njmp    11ac <func0+0x9c>\nlea    -0x4(%rcx),%rsi\nand    $0xfffffffffffffffe,%rsi\nneg    %rsi\nmov    $0x2,%edx\nxchg   %ax,%ax\nmov    (%rsp,%rdx,4),%edi\nadd    %edi,%eax\nadd    -0x4(%rsp,%rdx,4),%eax\nmov    %eax,0x8(%rsp,%rdx,4)\nadd    0x4(%rsp,%rdx,4),%eax\nadd    %edi,%eax\nmov    %eax,0xc(%rsp,%rdx,4)\nlea    (%rsi,%rdx,1),%rdi\nadd    $0x2,%rdi\nadd    $0x2,%rdx\ncmp    $0x2,%rdi\njne    1170 <func0+0x60>\nlea    0x2(%rdx),%rsi\ntest   $0x1,%cl\nje     11ac <func0+0x9c>\nadd    (%rsp,%rdx,4),%eax\nadd    -0xc(%rsp,%rsi,4),%eax\nmov    %eax,(%rsp,%rsi,4)\nmovslq %ebx,%rax\nmov    (%rsp,%rax,4),%eax\nadd    $0x190,%rsp\npop    %rbx\nret\n"
    },
    {
        "task_id": 64,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    0xecd(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njge    1198 <func0+0x78>\nmov    -0x10(%rbp),%rdi\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%esi\ncall   1040 <strchr@plt>\ncmp    $0x0,%rax\nje     1185 <func0+0x65>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    118a <func0+0x6a>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1151 <func0+0x31>\ncmpl   $0x0,-0x18(%rbp)\njle    11df <func0+0xbf>\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x79,%eax\nje     11d6 <func0+0xb6>\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x59,%eax\njne    11df <func0+0xbf>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 64,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdi,%r12\ncall   1030 <strlen@plt>\nmov    %rax,%r14\ntest   %r14d,%r14d\njle    1179 <func0+0x59>\nmov    %r14d,%r13d\nxor    %ebx,%ebx\nlea    0xeb9(%rip),%r15\nxor    %ebp,%ebp\nnopl   0x0(%rax)\nmovsbl (%r12,%rbx,1),%esi\nmov    $0xb,%edx\nmov    %r15,%rdi\ncall   1040 <memchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x1,%rbx\ncmp    %rbx,%r13\njne    1150 <func0+0x30>\ntest   %r14d,%r14d\njg     1180 <func0+0x60>\njmp    1191 <func0+0x71>\nxor    %ebp,%ebp\ntest   %r14d,%r14d\njle    1191 <func0+0x71>\nlea    -0x1(%r14),%eax\nmov    (%r12,%rax,1),%al\nor     $0x20,%al\ncmp    $0x79,%al\njne    1191 <func0+0x71>\nadd    $0x1,%ebp\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 64,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%r15\ntest   %r15d,%r15d\njle    118a <func0+0x6a>\nmov    %r15d,%r13d\nxor    %ebp,%ebp\nlea    0xeb9(%rip),%r12\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmovsbl (%r14,%rbp,1),%esi\nmov    $0xb,%edx\nmov    %r12,%rdi\ncall   1040 <memchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebx\nadd    $0x1,%rbp\ncmp    %rbp,%r13\njne    1150 <func0+0x30>\ntest   %r15d,%r15d\njle    118c <func0+0x6c>\nadd    $0xffffffff,%r15d\nmov    (%r14,%r15,1),%al\nor     $0x20,%al\ncmp    $0x79,%al\njne    118c <func0+0x6c>\nadd    $0x1,%ebx\njmp    118c <func0+0x6c>\nxor    %ebx,%ebx\nmov    %ebx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 64,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%r15\ntest   %r15d,%r15d\njle    118a <func0+0x6a>\nmov    %r15d,%r13d\nxor    %ebp,%ebp\nlea    0xeb9(%rip),%r12\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmovsbl (%r14,%rbp,1),%esi\nmov    $0xb,%edx\nmov    %r12,%rdi\ncall   1040 <memchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebx\nadd    $0x1,%rbp\ncmp    %rbp,%r13\njne    1150 <func0+0x30>\ntest   %r15d,%r15d\njle    118c <func0+0x6c>\nadd    $0xffffffff,%r15d\nmov    (%r14,%r15,1),%al\nor     $0x20,%al\ncmp    $0x79,%al\njne    118c <func0+0x6c>\nadd    $0x1,%ebx\njmp    118c <func0+0x6c>\nxor    %ebx,%ebx\nmov    %ebx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 65,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%edx\nlea    0x2ef8(%rip),%rdi\nlea    0xea1(%rip),%rsi\nmov    $0x0,%al\ncall   1060 <sprintf@plt>\nlea    0x2ee3(%rip),%rdi\ncall   1040 <strlen@plt>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    1207 <func0+0xc7>\nmovl   $0x0,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmov    %eax,-0x54(%rbp)\nmov    -0xc(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x54(%rbp),%eax\ncmp    %ecx,%eax\njge    1202 <func0+0xc2>\nmovslq -0x10(%rbp),%rcx\nlea    0x2e9f(%rip),%rax\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x11(%rbp)\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x10(%rbp),%eax\nmovslq %eax,%rcx\nlea    0x2e86(%rip),%rax\nmov    (%rax,%rcx,1),%dl\nmovslq -0x10(%rbp),%rcx\nlea    0x2e78(%rip),%rax\nmov    %dl,(%rax,%rcx,1)\nmov    -0x11(%rbp),%dl\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x10(%rbp),%eax\nmovslq %eax,%rcx\nlea    0x2e5f(%rip),%rax\nmov    %dl,(%rax,%rcx,1)\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    1188 <func0+0x48>\njmp    125c <func0+0x11c>\nlea    -0x50(%rbp),%rdi\nmovslq -0xc(%rbp),%rax\nlea    0x2e3a(%rip),%rsi\nadd    %rax,%rsi\nmovslq -0x8(%rbp),%rcx\nxor    %eax,%eax\nsub    %rcx,%rax\nadd    %rax,%rsi\ncall   1030 <strcpy@plt>\nmovslq -0x8(%rbp),%rax\nmovb   $0x0,-0x50(%rbp,%rax,1)\nlea    -0x50(%rbp),%rdi\nmov    -0xc(%rbp),%eax\nsub    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nlea    0x2e09(%rip),%rsi\ncall   1050 <strncat@plt>\nlea    -0x50(%rbp),%rsi\nlea    0x2df9(%rip),%rdi\ncall   1030 <strcpy@plt>\nlea    0x2ded(%rip),%rax\nadd    $0x60,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 65,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\nsub    $0x38,%rsp\nmov    %esi,%r14d\nmov    %edi,%edx\nlea    0x2efa(%rip),%r15\nlea    0xea3(%rip),%rsi\nmov    %r15,%rdi\nxor    %eax,%eax\ncall   1060 <sprintf@plt>\nmov    %r15,%rdi\ncall   1040 <strlen@plt>\nmov    %eax,%ebp\nsub    %r14d,%ebp\njge    11c9 <func0+0x89>\ncmp    $0x2,%eax\njl     11fd <func0+0xbd>\nmovabs $0xffffffff00000000,%rdi\nff ff ff\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %eax,%edx\nsar    %edx\nshl    $0x20,%rax\nadd    %rdi,%rax\nxor    %esi,%esi\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rsi,%r15,1),%ecx\nmov    %rax,%rbp\nsar    $0x20,%rbp\nmovzbl 0x0(%rbp,%r15,1),%ebx\nmov    %bl,(%rsi,%r15,1)\nmov    %cl,0x0(%rbp,%r15,1)\nadd    $0x1,%rsi\nadd    %rdi,%rax\ncmp    %rsi,%rdx\njne    11a0 <func0+0x60>\njmp    11fd <func0+0xbd>\nmovslq %eax,%rsi\nadd    %r15,%rsi\nmovslq %r14d,%rbx\nsub    %rbx,%rsi\nmov    %rsp,%r14\nmov    %r14,%rdi\ncall   1030 <strcpy@plt>\nmovb   $0x0,(%rsp,%rbx,1)\nmovslq %ebp,%rdx\nmov    %r14,%rdi\nmov    %r15,%rsi\ncall   1050 <strncat@plt>\nmov    %r15,%rdi\nmov    %r14,%rsi\ncall   1030 <strcpy@plt>\nlea    0x2e4c(%rip),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 65,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\nsub    $0x38,%rsp\nmov    %esi,%r14d\nmov    %edi,%edx\nlea    0x2efa(%rip),%r15\nlea    0xea3(%rip),%rsi\nmov    %r15,%rdi\nxor    %eax,%eax\ncall   1060 <sprintf@plt>\nmov    %r15,%rdi\ncall   1040 <strlen@plt>\nmov    %eax,%ebp\nsub    %r14d,%ebp\njge    11a0 <func0+0x60>\ncmp    $0x2,%eax\njl     1263 <func0+0x123>\nmov    %rax,%r8\nshr    %r8\nmov    %r8d,%r11d\nand    $0x7fffffff,%r11d\nand    $0x1,%r8d\ncmp    $0x1,%r11\njne    11d9 <func0+0x99>\nxor    %edx,%edx\njmp    1245 <func0+0x105>\nmovslq %eax,%rsi\nadd    %r15,%rsi\nmovslq %r14d,%rbx\nsub    %rbx,%rsi\nmov    %rsp,%r14\nmov    %r14,%rdi\ncall   1030 <strcpy@plt>\nmovb   $0x0,(%rsp,%rbx,1)\nmovslq %ebp,%rdx\nmov    %r14,%rdi\nmov    %r15,%rsi\ncall   1050 <strncat@plt>\nmov    %r15,%rdi\nmov    %r14,%rsi\ncall   1030 <strcpy@plt>\njmp    1263 <func0+0x123>\nmovabs $0xfffffffe00000000,%r9\nff ff ff\nsub    %r8,%r11\nmov    %rax,%rdx\nshl    $0x20,%rdx\nlea    (%rdx,%r9,1),%rsi\nmovabs $0xffffffff00000000,%rdi\nff ff ff\nadd    %rdx,%rdi\nxor    %edx,%edx\nmovzbl (%rdx,%r15,1),%r10d\nmov    %rdi,%rcx\nsar    $0x20,%rcx\nmovzbl (%rcx,%r15,1),%ebx\nmov    %bl,(%rdx,%r15,1)\nmov    %r10b,(%rcx,%r15,1)\nmovzbl 0x1(%rdx,%r15,1),%ecx\nmov    %rsi,%rbp\nsar    $0x20,%rbp\nmovzbl 0x0(%rbp,%r15,1),%ebx\nmov    %bl,0x1(%rdx,%r15,1)\nmov    %cl,0x0(%rbp,%r15,1)\nadd    $0x2,%rdx\nadd    %r9,%rsi\nadd    %r9,%rdi\ncmp    %rdx,%r11\njne    1200 <func0+0xc0>\ntest   %r8,%r8\nje     1263 <func0+0x123>\nmov    (%rdx,%r15,1),%cl\nmov    %edx,%esi\nnot    %esi\nadd    %eax,%esi\nmovslq %esi,%rax\nmov    (%rax,%r15,1),%bl\nmov    %bl,(%rdx,%r15,1)\nmov    %cl,(%rax,%r15,1)\nlea    0x2de6(%rip),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 65,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\nsub    $0x38,%rsp\nmov    %esi,%r14d\nmov    %edi,%edx\nlea    0x2efa(%rip),%r15\nlea    0xea3(%rip),%rsi\nmov    %r15,%rdi\nxor    %eax,%eax\ncall   1060 <sprintf@plt>\nmov    %r15,%rdi\ncall   1040 <strlen@plt>\nmov    %eax,%ebp\nsub    %r14d,%ebp\njge    11a0 <func0+0x60>\ncmp    $0x2,%eax\njl     1263 <func0+0x123>\nmov    %rax,%r8\nshr    %r8\nmov    %r8d,%r11d\nand    $0x7fffffff,%r11d\nand    $0x1,%r8d\ncmp    $0x1,%r11\njne    11d9 <func0+0x99>\nxor    %edx,%edx\njmp    1245 <func0+0x105>\nmovslq %eax,%rsi\nadd    %r15,%rsi\nmovslq %r14d,%rbx\nsub    %rbx,%rsi\nmov    %rsp,%r14\nmov    %r14,%rdi\ncall   1030 <strcpy@plt>\nmovb   $0x0,(%rsp,%rbx,1)\nmovslq %ebp,%rdx\nmov    %r14,%rdi\nmov    %r15,%rsi\ncall   1050 <strncat@plt>\nmov    %r15,%rdi\nmov    %r14,%rsi\ncall   1030 <strcpy@plt>\njmp    1263 <func0+0x123>\nmovabs $0xfffffffe00000000,%r9\nff ff ff\nsub    %r8,%r11\nmov    %rax,%rdx\nshl    $0x20,%rdx\nlea    (%rdx,%r9,1),%rsi\nmovabs $0xffffffff00000000,%rdi\nff ff ff\nadd    %rdx,%rdi\nxor    %edx,%edx\nmovzbl (%rdx,%r15,1),%r10d\nmov    %rdi,%rcx\nsar    $0x20,%rcx\nmovzbl (%rcx,%r15,1),%ebx\nmov    %bl,(%rdx,%r15,1)\nmov    %r10b,(%rcx,%r15,1)\nmovzbl 0x1(%rdx,%r15,1),%ecx\nmov    %rsi,%rbp\nsar    $0x20,%rbp\nmovzbl 0x0(%rbp,%r15,1),%ebx\nmov    %bl,0x1(%rdx,%r15,1)\nmov    %cl,0x0(%rbp,%r15,1)\nadd    $0x2,%rdx\nadd    %r9,%rsi\nadd    %r9,%rdi\ncmp    %rdx,%r11\njne    1200 <func0+0xc0>\ntest   %r8,%r8\nje     1263 <func0+0x123>\nmov    (%rdx,%r15,1),%cl\nmov    %edx,%esi\nnot    %esi\nadd    %eax,%esi\nmovslq %esi,%rax\nmov    (%rax,%r15,1),%bl\nmov    %bl,(%rdx,%r15,1)\nmov    %cl,(%rax,%r15,1)\nlea    0x2de6(%rip),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 66,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x10(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     117a <func0+0x7a>\nmov    -0x8(%rbp),%rax\nmovslq -0x10(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x41,%eax\njl     1167 <func0+0x67>\nmov    -0x8(%rbp),%rax\nmovslq -0x10(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x5a,%eax\njg     1167 <func0+0x67>\nmov    -0x8(%rbp),%rax\nmovslq -0x10(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nadd    -0xc(%rbp),%eax\nmov    %eax,-0xc(%rbp)\njmp    116c <func0+0x6c>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    1116 <func0+0x16>\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 66,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    (%rdi),%dl\ntest   %dl,%dl\nje     112e <func0+0x2e>\nadd    $0x1,%rdi\nxor    %ecx,%ecx\nxor    %eax,%eax\nxchg   %ax,%ax\nlea    -0x41(%rdx),%esi\ncmp    $0x1a,%sil\nmovzbl %dl,%edx\ncmovae %ecx,%edx\nmovsbl %dl,%edx\nadd    %edx,%eax\nmovzbl (%rdi),%edx\nadd    $0x1,%rdi\ntest   %dl,%dl\njne    1110 <func0+0x10>\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 66,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    (%rdi),%dl\ntest   %dl,%dl\nje     112e <func0+0x2e>\nadd    $0x1,%rdi\nxor    %ecx,%ecx\nxor    %eax,%eax\nxchg   %ax,%ax\nlea    -0x41(%rdx),%esi\ncmp    $0x1a,%sil\nmovzbl %dl,%edx\ncmovae %ecx,%edx\nmovzbl %dl,%edx\nadd    %edx,%eax\nmovzbl (%rdi),%edx\nadd    $0x1,%rdi\ntest   %dl,%dl\njne    1110 <func0+0x10>\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 66,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    (%rdi),%dl\ntest   %dl,%dl\nje     112e <func0+0x2e>\nadd    $0x1,%rdi\nxor    %ecx,%ecx\nxor    %eax,%eax\nxchg   %ax,%ax\nlea    -0x41(%rdx),%esi\ncmp    $0x1a,%sil\nmovzbl %dl,%edx\ncmovae %ecx,%edx\nmovzbl %dl,%edx\nadd    %edx,%eax\nmovzbl (%rdi),%edx\nadd    $0x1,%rdi\ntest   %dl,%dl\njne    1110 <func0+0x10>\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 67,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nlea    -0x16(%rbp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <memset@plt>\nlea    -0x20(%rbp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <memset@plt>\nmovl   $0x0,-0x24(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1238 <func0+0x108>\ncall   1050 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x2c(%rbp),%rdx\nmovsbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x800,%eax\ncmp    $0x0,%eax\nje     11fe <func0+0xce>\ncmpl   $0x0,-0x24(%rbp)\njne    11dd <func0+0xad>\nmov    -0x8(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmov    -0x28(%rbp),%eax\nmov    %eax,%edx\nadd    $0x1,%edx\nmov    %edx,-0x28(%rbp)\ncltq\nmov    %cl,-0x16(%rbp,%rax,1)\njmp    11f9 <func0+0xc9>\nmov    -0x8(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmov    -0x28(%rbp),%eax\nmov    %eax,%edx\nadd    $0x1,%edx\nmov    %edx,-0x28(%rbp)\ncltq\nmov    %cl,-0x20(%rbp,%rax,1)\njmp    1225 <func0+0xf5>\ncmpl   $0x0,-0x24(%rbp)\njne    1220 <func0+0xf0>\ncmpl   $0x0,-0x28(%rbp)\njle    1220 <func0+0xf0>\nmovl   $0x1,-0x24(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    1225 <func0+0xf5>\njmp    122a <func0+0xfa>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1174 <func0+0x44>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x34(%rbp)\nlea    -0x16(%rbp),%rdi\ncall   1040 <atoi@plt>\nmov    %eax,%ecx\nmov    -0x34(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,-0x30(%rbp)\nlea    -0x20(%rbp),%rdi\ncall   1040 <atoi@plt>\nmov    %eax,%ecx\nmov    -0x30(%rbp),%eax\nsub    %ecx,%eax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 67,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nsub    $0x20,%rsp\nmov    %esi,%r14d\nmovw   $0x0,0x18(%rsp)\nmovq   $0x0,0x10(%rsp)\nmovw   $0x0,0x8(%rsp)\nmovq   $0x0,(%rsp)\nmov    (%rdi),%bl\ntest   %bl,%bl\nje     11ba <func0+0x9a>\nmov    %rdi,%rbp\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nadd    $0x1,%rbp\nxor    %r8d,%r8d\nmov    $0x1,%edx\nxor    %edi,%edi\nxor    %esi,%esi\njmp    1193 <func0+0x73>\nnopl   (%rax)\ntest   %esi,%esi\nsete   %cl\ntest   %edi,%edi\nsetg   %bl\ntest   %bl,%cl\ncmovne %edx,%esi\ncmovne %r8d,%edi\nmov    %edi,%ecx\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\nmov    %ecx,%edi\ntest   %bl,%bl\nje     11ba <func0+0x9a>\nmovsbq %bl,%rcx\ntestb  $0x8,0x1(%rax,%rcx,2)\nje     1170 <func0+0x50>\nlea    0x1(%rdi),%ecx\nmovslq %edi,%rdi\ntest   %esi,%esi\nje     11b2 <func0+0x92>\nmov    %bl,(%rsp,%rdi,1)\nmov    $0x1,%esi\njmp    1185 <func0+0x65>\nmov    %bl,0x10(%rsp,%rdi,1)\nxor    %esi,%esi\njmp    1185 <func0+0x65>\nlea    0x10(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%rbx\nmov    %rsp,%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nadd    %ebx,%eax\nsub    %eax,%r14d\nmov    %r14d,%eax\nadd    $0x20,%rsp\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 67,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nsub    $0x20,%rsp\nmov    %esi,%r14d\nmovw   $0x0,0x18(%rsp)\nmovq   $0x0,0x10(%rsp)\nmovw   $0x0,0x8(%rsp)\nmovq   $0x0,(%rsp)\nmov    (%rdi),%bl\ntest   %bl,%bl\nje     11ba <func0+0x9a>\nmov    %rdi,%rbp\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nadd    $0x1,%rbp\nxor    %r8d,%r8d\nmov    $0x1,%edx\nxor    %edi,%edi\nxor    %esi,%esi\njmp    1193 <func0+0x73>\nnopl   (%rax)\ntest   %esi,%esi\nsete   %cl\ntest   %edi,%edi\nsetg   %bl\ntest   %bl,%cl\ncmovne %edx,%esi\ncmovne %r8d,%edi\nmov    %edi,%ecx\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\nmov    %ecx,%edi\ntest   %bl,%bl\nje     11ba <func0+0x9a>\nmovsbq %bl,%rcx\ntestb  $0x8,0x1(%rax,%rcx,2)\nje     1170 <func0+0x50>\nlea    0x1(%rdi),%ecx\nmovslq %edi,%rdi\ntest   %esi,%esi\nje     11b2 <func0+0x92>\nmov    %bl,(%rsp,%rdi,1)\nmov    $0x1,%esi\njmp    1185 <func0+0x65>\nmov    %bl,0x10(%rsp,%rdi,1)\nxor    %esi,%esi\njmp    1185 <func0+0x65>\nlea    0x10(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%rbx\nmov    %rsp,%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nadd    %ebx,%eax\nsub    %eax,%r14d\nmov    %r14d,%eax\nadd    $0x20,%rsp\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 67,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nsub    $0x20,%rsp\nmov    %esi,%r14d\nmovw   $0x0,0x18(%rsp)\nmovq   $0x0,0x10(%rsp)\nmovw   $0x0,0x8(%rsp)\nmovq   $0x0,(%rsp)\nmov    (%rdi),%bl\ntest   %bl,%bl\nje     11ba <func0+0x9a>\nmov    %rdi,%rbp\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nadd    $0x1,%rbp\nxor    %r8d,%r8d\nmov    $0x1,%edx\nxor    %edi,%edi\nxor    %esi,%esi\njmp    1193 <func0+0x73>\nnopl   (%rax)\ntest   %esi,%esi\nsete   %cl\ntest   %edi,%edi\nsetg   %bl\ntest   %bl,%cl\ncmovne %edx,%esi\ncmovne %r8d,%edi\nmov    %edi,%ecx\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\nmov    %ecx,%edi\ntest   %bl,%bl\nje     11ba <func0+0x9a>\nmovsbq %bl,%rcx\ntestb  $0x8,0x1(%rax,%rcx,2)\nje     1170 <func0+0x50>\nlea    0x1(%rdi),%ecx\nmovslq %edi,%rdi\ntest   %esi,%esi\nje     11b2 <func0+0x92>\nmov    %bl,(%rsp,%rdi,1)\nmov    $0x1,%esi\njmp    1185 <func0+0x65>\nmov    %bl,0x10(%rsp,%rdi,1)\nxor    %esi,%esi\njmp    1185 <func0+0x65>\nlea    0x10(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%rbx\nmov    %rsp,%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nadd    %ebx,%eax\nsub    %eax,%r14d\nmov    %r14d,%eax\nadd    $0x20,%rsp\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 68,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmov    %rdx,-0x20(%rbp)\nmovl   $0x7fffffff,-0x24(%rbp)\nmovl   $0xffffffff,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1191 <func0+0x91>\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    117e <func0+0x7e>\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x24(%rbp),%eax\njl     116a <func0+0x6a>\ncmpl   $0xffffffff,-0x28(%rbp)\njne    117e <func0+0x7e>\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,-0x28(%rbp)\njmp    1183 <func0+0x83>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1124 <func0+0x24>\ncmpl   $0xffffffff,-0x28(%rbp)\njne    11a8 <func0+0xa8>\nmovq   $0x0,-0x8(%rbp)\njmp    11c3 <func0+0xc3>\nmov    -0x24(%rbp),%ecx\nmov    -0x20(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x28(%rbp),%ecx\nmov    -0x20(%rbp),%rax\nmov    %ecx,0x4(%rax)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 68,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %rdx,%rax\ntest   %esi,%esi\njle    114c <func0+0x4c>\nmov    %esi,%r8d\nmov    $0x7fffffff,%r9d\nmov    $0xffffffff,%r10d\nxor    %esi,%esi\njmp    1129 <func0+0x29>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rsi\ncmp    %rsi,%r8\nje     1158 <func0+0x58>\nmov    (%rdi,%rsi,4),%edx\ntest   $0x1,%dl\njne    1120 <func0+0x20>\ncmp    %r9d,%edx\nsetl   %r11b\ncmp    $0xffffffff,%r10d\nsete   %cl\nor     %r11b,%cl\ncmovne %edx,%r9d\ncmovne %esi,%r10d\njmp    1120 <func0+0x20>\nmov    $0xffffffff,%r10d\nmov    $0x7fffffff,%r9d\ncmp    $0xffffffff,%r10d\nje     1166 <func0+0x66>\nmov    %r9d,(%rax)\nmov    %r10d,0x4(%rax)\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 68,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ntest   %esi,%esi\njle    1158 <func0+0x58>\nmov    %rdx,%rax\nmov    %esi,%r8d\ncmp    $0x1,%esi\njne    115c <func0+0x5c>\nmov    $0x7fffffff,%r10d\nmov    $0xffffffff,%r11d\nxor    %esi,%esi\ntest   $0x1,%r8b\nje     1149 <func0+0x49>\nmov    (%rdi,%rsi,4),%edi\ntest   $0x1,%dil\njne    1149 <func0+0x49>\ncmp    %r10d,%edi\nsetl   %r8b\ncmp    $0xffffffff,%r11d\nsete   %cl\nor     %r8b,%cl\ncmovne %edi,%r10d\ncmove  %r11d,%esi\nmov    %esi,%r11d\ncmp    $0xffffffff,%r11d\nje     1158 <func0+0x58>\nmov    %r10d,(%rax)\nmov    %r11d,0x4(%rax)\npop    %rbx\nret\nxor    %eax,%eax\npop    %rbx\nret\nmov    %r8d,%r9d\nand    $0xfffffffe,%r9d\nmov    $0x7fffffff,%r10d\nmov    $0xffffffff,%r11d\nxor    %esi,%esi\njmp    1189 <func0+0x89>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x2,%rsi\ncmp    %rsi,%r9\nje     111e <func0+0x1e>\nmov    (%rdi,%rsi,4),%ecx\ntest   $0x1,%cl\njne    11a8 <func0+0xa8>\ncmp    %r10d,%ecx\nsetl   %dl\ncmp    $0xffffffff,%r11d\nsete   %bl\nor     %dl,%bl\ncmovne %ecx,%r10d\ncmovne %esi,%r11d\nmov    0x4(%rdi,%rsi,4),%ecx\ntest   $0x1,%cl\njne    1180 <func0+0x80>\ncmp    %r10d,%ecx\nsetl   %dl\ncmp    $0xffffffff,%r11d\nsete   %bl\nor     %dl,%bl\nlea    0x1(%rsi),%edx\ntest   %bl,%bl\ncmovne %ecx,%r10d\ncmovne %edx,%r11d\njmp    1180 <func0+0x80>\n"
    },
    {
        "task_id": 68,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ntest   %esi,%esi\njle    1158 <func0+0x58>\nmov    %rdx,%rax\nmov    %esi,%r8d\ncmp    $0x1,%esi\njne    115c <func0+0x5c>\nmov    $0x7fffffff,%r10d\nmov    $0xffffffff,%r11d\nxor    %esi,%esi\ntest   $0x1,%r8b\nje     1149 <func0+0x49>\nmov    (%rdi,%rsi,4),%edi\ntest   $0x1,%dil\njne    1149 <func0+0x49>\ncmp    %r10d,%edi\nsetl   %r8b\ncmp    $0xffffffff,%r11d\nsete   %cl\nor     %r8b,%cl\ncmovne %edi,%r10d\ncmove  %r11d,%esi\nmov    %esi,%r11d\ncmp    $0xffffffff,%r11d\nje     1158 <func0+0x58>\nmov    %r10d,(%rax)\nmov    %r11d,0x4(%rax)\npop    %rbx\nret\nxor    %eax,%eax\npop    %rbx\nret\nmov    %r8d,%r9d\nand    $0xfffffffe,%r9d\nmov    $0x7fffffff,%r10d\nmov    $0xffffffff,%r11d\nxor    %esi,%esi\njmp    1189 <func0+0x89>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x2,%rsi\ncmp    %rsi,%r9\nje     111e <func0+0x1e>\nmov    (%rdi,%rsi,4),%ecx\ntest   $0x1,%cl\njne    11c0 <func0+0xc0>\ncmp    %r10d,%ecx\nsetl   %dl\ncmp    $0xffffffff,%r11d\nsete   %bl\nor     %dl,%bl\ncmovne %ecx,%r10d\ncmovne %esi,%r11d\nmov    0x4(%rdi,%rsi,4),%ecx\ntest   $0x1,%cl\njne    1180 <func0+0x80>\njmp    11c9 <func0+0xc9>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    0x4(%rdi,%rsi,4),%ecx\ntest   $0x1,%cl\njne    1180 <func0+0x80>\ncmp    %r10d,%ecx\nsetl   %dl\ncmp    $0xffffffff,%r11d\nsete   %bl\nor     %dl,%bl\nlea    0x1(%rsi),%edx\ntest   %bl,%bl\ncmovne %ecx,%r10d\ncmovne %edx,%r11d\njmp    1180 <func0+0x80>\n"
    },
    {
        "task_id": 69,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0xffffffff,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11d2 <func0+0xb2>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x20(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nadd    $0x1,%edx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x20(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmovslq -0x20(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njl     11bf <func0+0x9f>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x1c(%rbp),%eax\njle    11bf <func0+0x9f>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x1c(%rbp)\njmp    11c4 <func0+0xa4>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1154 <func0+0x34>\nmov    -0x18(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x1c(%rbp),%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 69,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %esi,%ebp\nmov    %rdi,%r14\nlea    0x1(%rbp),%eax\nmovslq %eax,%rdi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\ntest   %ebp,%ebp\njle    1174 <func0+0x54>\nmov    %ebp,%ecx\nmov    $0xffffffff,%esi\nxor    %edx,%edx\nmov    %esi,%ebp\nnopl   0x0(%rax,%rax,1)\nmovslq (%r14,%rdx,4),%rdi\nmov    (%rax,%rdi,4),%ebx\nadd    $0x1,%ebx\nmov    %ebx,(%rax,%rdi,4)\ncmp    %esi,%edi\ncmovg  %edi,%ebp\ncmp    %edi,%ebx\ncmovl  %esi,%ebp\nadd    $0x1,%rdx\nmov    %ebp,%esi\ncmp    %rdx,%rcx\njne    1150 <func0+0x30>\njmp    1179 <func0+0x59>\nmov    $0xffffffff,%ebp\nmov    %rax,%rdi\ncall   1030 <free@plt>\nmov    %ebp,%eax\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 69,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %esi,%ebp\nmov    %rdi,%rbx\nlea    0x1(%rbp),%eax\nmovslq %eax,%rdi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\ntest   %ebp,%ebp\njle    116c <func0+0x4c>\nmov    %ebp,%r8d\ncmp    $0x1,%ebp\njne    1182 <func0+0x62>\nmov    $0xffffffff,%ebp\nxor    %edx,%edx\ntest   $0x1,%r8b\nje     1171 <func0+0x51>\nmovslq (%rbx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nadd    $0x1,%edx\ncmp    %ebp,%ecx\nmov    %ebp,%esi\ncmovg  %ecx,%esi\nmov    %edx,(%rax,%rcx,4)\ncmp    %ecx,%edx\ncmovge %esi,%ebp\njmp    1171 <func0+0x51>\nmov    $0xffffffff,%ebp\nmov    %rax,%rdi\ncall   1030 <free@plt>\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nmov    %r8d,%r9d\nand    $0xfffffffe,%r9d\nmov    $0xffffffff,%ebp\nxor    %edx,%edx\njmp    11ae <func0+0x8e>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ncmp    %edi,%ecx\ncmovge %esi,%ebp\nadd    $0x2,%rdx\ncmp    %rdx,%r9\nje     114b <func0+0x2b>\nmovslq (%rbx,%rdx,4),%rdi\nmov    (%rax,%rdi,4),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax,%rdi,4)\nmov    %edi,%esi\ncmp    %ebp,%edi\njg     11c3 <func0+0xa3>\nmov    %ebp,%esi\ncmp    %edi,%ecx\ncmovge %esi,%ebp\nmovslq 0x4(%rbx,%rdx,4),%rdi\nmov    (%rax,%rdi,4),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax,%rdi,4)\nmov    %edi,%esi\ncmp    %ebp,%edi\njg     11a0 <func0+0x80>\nmov    %ebp,%esi\njmp    11a0 <func0+0x80>\n"
    },
    {
        "task_id": 69,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %esi,%ebp\nmov    %rdi,%rbx\nlea    0x1(%rbp),%eax\nmovslq %eax,%rdi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\ntest   %ebp,%ebp\njle    116c <func0+0x4c>\nmov    %ebp,%r8d\ncmp    $0x1,%ebp\njne    1182 <func0+0x62>\nmov    $0xffffffff,%ebp\nxor    %edx,%edx\ntest   $0x1,%r8b\nje     1171 <func0+0x51>\nmovslq (%rbx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nadd    $0x1,%edx\ncmp    %ebp,%ecx\nmov    %ebp,%esi\ncmovg  %ecx,%esi\nmov    %edx,(%rax,%rcx,4)\ncmp    %ecx,%edx\ncmovge %esi,%ebp\njmp    1171 <func0+0x51>\nmov    $0xffffffff,%ebp\nmov    %rax,%rdi\ncall   1030 <free@plt>\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nmov    %r8d,%r9d\nand    $0xfffffffe,%r9d\nmov    $0xffffffff,%ebp\nxor    %edx,%edx\njmp    11ae <func0+0x8e>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ncmp    %edi,%ecx\ncmovge %esi,%ebp\nadd    $0x2,%rdx\ncmp    %rdx,%r9\nje     114b <func0+0x2b>\nmovslq (%rbx,%rdx,4),%rdi\nmov    (%rax,%rdi,4),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax,%rdi,4)\nmov    %edi,%esi\ncmp    %ebp,%edi\njg     11c3 <func0+0xa3>\nmov    %ebp,%esi\ncmp    %edi,%ecx\ncmovge %esi,%ebp\nmovslq 0x4(%rbx,%rdx,4),%rdi\nmov    (%rax,%rdi,4),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax,%rdi,4)\nmov    %edi,%esi\ncmp    %ebp,%edi\njg     11a0 <func0+0x80>\nmov    %ebp,%esi\njmp    11a0 <func0+0x80>\n"
    },
    {
        "task_id": 70,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    -0xc(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    11b0 <func0+0xb0>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    119d <func0+0x9d>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmovslq -0x20(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njle    118a <func0+0x8a>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x24(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    118f <func0+0x8f>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1130 <func0+0x30>\njmp    11a2 <func0+0xa2>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1116 <func0+0x16>\nmovl   $0x0,-0x28(%rbp)\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njg     1267 <func0+0x167>\nmov    -0x28(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njne    120e <func0+0x10e>\nmov    -0x8(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x28(%rbp)\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmov    -0x30(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x30(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1262 <func0+0x162>\nmov    -0x8(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x28(%rbp)\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmov    -0x30(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x30(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x8(%rbp),%rax\nmov    -0x2c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0xffffffff,%edx\nmov    %edx,-0x2c(%rbp)\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmov    -0x30(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x30(%rbp)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    11c7 <func0+0xc7>\npop    %rbp\nret\n"
    },
    {
        "task_id": 70,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\nlea    -0x1(%rsi),%r10d\ncmp    $0x2,%esi\njl     115d <func0+0x5d>\nmovslq %esi,%r8\nmov    %r10d,%r9d\nmov    %esi,%r14d\nxor    %r11d,%r11d\nmov    %rdi,%r15\njmp    112d <func0+0x2d>\nadd    $0x4,%r15\nadd    $0xffffffffffffffff,%r14\ncmp    %r9,%r11\nje     115d <func0+0x5d>\nmov    %r11,%rbx\nadd    $0x1,%r11\ncmp    %r8,%r11\njge    1120 <func0+0x20>\nmov    $0x1,%ecx\njmp    1149 <func0+0x49>\nadd    $0x1,%rcx\ncmp    %rcx,%r14\nje     1120 <func0+0x20>\nmov    (%rdi,%rbx,4),%ebp\nmov    (%r15,%rcx,4),%eax\ncmp    %eax,%ebp\njle    1140 <func0+0x40>\nmov    %eax,(%rdi,%rbx,4)\nmov    %ebp,(%r15,%rcx,4)\njmp    1140 <func0+0x40>\ntest   %esi,%esi\njle    11af <func0+0xaf>\nxor    %ecx,%ecx\nxor    %eax,%eax\njmp    1182 <func0+0x82>\nnopw   0x0(%rax,%rax,1)\nlea    0x1(%rcx),%rsi\nmovslq %r10d,%rbp\nmov    %r8d,%eax\ncmp    %rbp,%rcx\nmov    %rsi,%rcx\njge    11af <func0+0xaf>\nmov    %r10d,%ebp\nlea    0x1(%rax),%r8d\nmov    (%rdi,%rcx,4),%ebx\nmovslq %eax,%rsi\nmov    %ebx,(%rdx,%rsi,4)\ncmp    %rbp,%rcx\nje     1170 <func0+0x70>\nmovslq %r10d,%rsi\nadd    $0xffffffff,%r10d\nmov    (%rdi,%rsi,4),%esi\nadd    $0x2,%eax\nmovslq %r8d,%rbp\nmov    %esi,(%rdx,%rbp,4)\nmov    %eax,%r8d\njmp    1170 <func0+0x70>\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 70,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\nlea    -0x1(%rsi),%r10d\ncmp    $0x2,%esi\njl     115d <func0+0x5d>\nmov    %esi,%r9d\nmov    %r10d,%r8d\nxor    %r11d,%r11d\nmov    %r9,%r14\nmov    %rdi,%r15\njmp    112d <func0+0x2d>\nadd    $0x4,%r15\nadd    $0xffffffffffffffff,%r14\ncmp    %r8,%r11\nje     115d <func0+0x5d>\nmov    %r11,%rbx\nadd    $0x1,%r11\ncmp    %r9,%r11\njae    1120 <func0+0x20>\nmov    $0x1,%ecx\njmp    1149 <func0+0x49>\nadd    $0x1,%rcx\ncmp    %rcx,%r14\nje     1120 <func0+0x20>\nmov    (%rdi,%rbx,4),%ebp\nmov    (%r15,%rcx,4),%eax\ncmp    %eax,%ebp\njle    1140 <func0+0x40>\nmov    %eax,(%rdi,%rbx,4)\nmov    %ebp,(%r15,%rcx,4)\njmp    1140 <func0+0x40>\ntest   %esi,%esi\njle    11af <func0+0xaf>\nxor    %ecx,%ecx\nxor    %eax,%eax\njmp    1182 <func0+0x82>\nnopw   0x0(%rax,%rax,1)\nlea    0x1(%rcx),%rsi\nmovslq %r10d,%rbp\nmov    %r8d,%eax\ncmp    %rbp,%rcx\nmov    %rsi,%rcx\njge    11af <func0+0xaf>\nmov    %r10d,%ebp\nlea    0x1(%rax),%r8d\nmov    (%rdi,%rcx,4),%ebx\nmovslq %eax,%rsi\nmov    %ebx,(%rdx,%rsi,4)\ncmp    %rbp,%rcx\nje     1170 <func0+0x70>\nmovslq %r10d,%rsi\nadd    $0xffffffff,%r10d\nmov    (%rdi,%rsi,4),%esi\nadd    $0x2,%eax\nmovslq %r8d,%rbp\nmov    %esi,(%rdx,%rbp,4)\nmov    %eax,%r8d\njmp    1170 <func0+0x70>\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 70,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\nlea    -0x1(%rsi),%r10d\ncmp    $0x2,%esi\njl     115d <func0+0x5d>\nmov    %esi,%r9d\nmov    %r10d,%r8d\nxor    %r11d,%r11d\nmov    %r9,%r14\nmov    %rdi,%r15\njmp    112d <func0+0x2d>\nadd    $0x4,%r15\nadd    $0xffffffffffffffff,%r14\ncmp    %r8,%r11\nje     115d <func0+0x5d>\nmov    %r11,%rbx\nadd    $0x1,%r11\ncmp    %r9,%r11\njae    1120 <func0+0x20>\nmov    $0x1,%ecx\njmp    1149 <func0+0x49>\nadd    $0x1,%rcx\ncmp    %rcx,%r14\nje     1120 <func0+0x20>\nmov    (%rdi,%rbx,4),%ebp\nmov    (%r15,%rcx,4),%eax\ncmp    %eax,%ebp\njle    1140 <func0+0x40>\nmov    %eax,(%rdi,%rbx,4)\nmov    %ebp,(%r15,%rcx,4)\njmp    1140 <func0+0x40>\ntest   %esi,%esi\njle    11af <func0+0xaf>\nxor    %ecx,%ecx\nxor    %eax,%eax\njmp    1182 <func0+0x82>\nnopw   0x0(%rax,%rax,1)\nlea    0x1(%rcx),%rsi\nmovslq %r10d,%rbp\nmov    %r8d,%eax\ncmp    %rbp,%rcx\nmov    %rsi,%rcx\njge    11af <func0+0xaf>\nmov    %r10d,%ebp\nlea    0x1(%rax),%r8d\nmov    (%rdi,%rcx,4),%ebx\nmovslq %eax,%rsi\nmov    %ebx,(%rdx,%rsi,4)\ncmp    %rbp,%rcx\nje     1170 <func0+0x70>\nmovslq %r10d,%rsi\nadd    $0xffffffff,%r10d\nmov    (%rdi,%rsi,4),%esi\nadd    $0x2,%eax\nmovslq %r8d,%rbp\nmov    %esi,(%rdx,%rbp,4)\nmov    %eax,%r8d\njmp    1170 <func0+0x70>\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 71,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovss  %xmm0,-0x8(%rbp)\nmovss  %xmm1,-0xc(%rbp)\nmovss  %xmm2,-0x10(%rbp)\nmovss  -0x8(%rbp),%xmm1\naddss  -0xc(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\nucomiss %xmm1,%xmm0\njae    117f <func0+0x5f>\nmovss  -0x8(%rbp),%xmm1\naddss  -0x10(%rbp),%xmm1\nmovss  -0xc(%rbp),%xmm0\nucomiss %xmm1,%xmm0\njae    117f <func0+0x5f>\nmovss  -0xc(%rbp),%xmm1\naddss  -0x10(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nucomiss %xmm1,%xmm0\njb     1191 <func0+0x71>\nmovss  0xe81(%rip),%xmm0\nmovss  %xmm0,-0x4(%rbp)\njmp    120d <func0+0xed>\nmovss  -0x8(%rbp),%xmm0\naddss  -0xc(%rbp),%xmm0\naddss  -0x10(%rbp),%xmm0\nmovss  0xe5c(%rip),%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovss  -0x14(%rbp),%xmm1\nsubss  -0x8(%rbp),%xmm1\nmulss  %xmm1,%xmm0\nmovss  -0x14(%rbp),%xmm1\nsubss  -0xc(%rbp),%xmm1\nmulss  %xmm1,%xmm0\nmovss  -0x14(%rbp),%xmm1\nsubss  -0x10(%rbp),%xmm1\nmulss  %xmm1,%xmm0\ncall   1030 <sqrtf@plt>\nmovss  %xmm0,-0x18(%rbp)\nmovss  0xe0e(%rip),%xmm0\nmulss  -0x18(%rbp),%xmm0\ncall   1040 <roundf@plt>\nmovss  0xdfc(%rip),%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 71,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rax\nmovaps %xmm0,%xmm4\nmovaps %xmm1,%xmm0\naddss  %xmm2,%xmm0\nucomiss %xmm0,%xmm4\nmovss  0xeca(%rip),%xmm3\njae    11a5 <func0+0x85>\nmovaps %xmm4,%xmm0\naddss  %xmm1,%xmm0\nucomiss %xmm0,%xmm2\njae    11a5 <func0+0x85>\nmovaps %xmm4,%xmm5\naddss  %xmm2,%xmm5\nucomiss %xmm5,%xmm1\njae    11a5 <func0+0x85>\naddss  %xmm2,%xmm0\nmulss  0xea8(%rip),%xmm0\nmovaps %xmm0,%xmm3\nsubss  %xmm4,%xmm3\nmulss  %xmm0,%xmm3\nmovaps %xmm0,%xmm4\nsubss  %xmm1,%xmm4\nmulss  %xmm3,%xmm4\nsubss  %xmm2,%xmm0\nmulss  %xmm4,%xmm0\nxorps  %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njb     1188 <func0+0x68>\nsqrtss %xmm0,%xmm0\njmp    118d <func0+0x6d>\ncall   1030 <sqrtf@plt>\nmulss  0xe73(%rip),%xmm0\ncall   1040 <roundf@plt>\nmovaps %xmm0,%xmm3\ndivss  0xe63(%rip),%xmm3\nmovaps %xmm3,%xmm0\npop    %rax\nret\n"
    },
    {
        "task_id": 71,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rax\nmovaps %xmm0,%xmm4\nmovaps %xmm1,%xmm0\naddss  %xmm2,%xmm0\nucomiss %xmm0,%xmm4\nmovss  0xeca(%rip),%xmm3\njae    11a5 <func0+0x85>\nmovaps %xmm4,%xmm0\naddss  %xmm1,%xmm0\nucomiss %xmm0,%xmm2\njae    11a5 <func0+0x85>\nmovaps %xmm4,%xmm5\naddss  %xmm2,%xmm5\nucomiss %xmm5,%xmm1\njae    11a5 <func0+0x85>\naddss  %xmm2,%xmm0\nmulss  0xea8(%rip),%xmm0\nmovaps %xmm0,%xmm3\nsubss  %xmm4,%xmm3\nmulss  %xmm0,%xmm3\nmovaps %xmm0,%xmm4\nsubss  %xmm1,%xmm4\nmulss  %xmm3,%xmm4\nsubss  %xmm2,%xmm0\nmulss  %xmm4,%xmm0\nxorps  %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njb     1188 <func0+0x68>\nsqrtss %xmm0,%xmm0\njmp    118d <func0+0x6d>\ncall   1030 <sqrtf@plt>\nmulss  0xe73(%rip),%xmm0\ncall   1040 <roundf@plt>\nmovaps %xmm0,%xmm3\ndivss  0xe63(%rip),%xmm3\nmovaps %xmm3,%xmm0\npop    %rax\nret\n"
    },
    {
        "task_id": 71,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rax\nmovaps %xmm0,%xmm4\nmovaps %xmm1,%xmm0\naddss  %xmm2,%xmm0\nucomiss %xmm0,%xmm4\nmovss  0xeca(%rip),%xmm3\njae    11a5 <func0+0x85>\nmovaps %xmm4,%xmm0\naddss  %xmm1,%xmm0\nucomiss %xmm0,%xmm2\njae    11a5 <func0+0x85>\nmovaps %xmm4,%xmm5\naddss  %xmm2,%xmm5\nucomiss %xmm5,%xmm1\njae    11a5 <func0+0x85>\naddss  %xmm2,%xmm0\nmulss  0xea8(%rip),%xmm0\nmovaps %xmm0,%xmm3\nsubss  %xmm4,%xmm3\nmulss  %xmm0,%xmm3\nmovaps %xmm0,%xmm4\nsubss  %xmm1,%xmm4\nmulss  %xmm3,%xmm4\nsubss  %xmm2,%xmm0\nmulss  %xmm4,%xmm0\nxorps  %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njb     1188 <func0+0x68>\nsqrtss %xmm0,%xmm0\njmp    118d <func0+0x6d>\ncall   1030 <sqrtf@plt>\nmulss  0xe73(%rip),%xmm0\ncall   1040 <roundf@plt>\nmovaps %xmm0,%xmm3\ndivss  0xe63(%rip),%xmm3\nmovaps %xmm3,%xmm0\npop    %rax\nret\n"
    },
    {
        "task_id": 72,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmov    %edx,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x24(%rbp),%eax\ncmp    %ecx,%eax\njge    1199 <func0+0x99>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x14(%rbp),%edx\nsub    $0x1,%edx\nsub    -0x20(%rbp),%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\nje     1167 <func0+0x67>\nmovb   $0x0,-0x1(%rbp)\njmp    11e0 <func0+0xe0>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x14(%rbp),%edx\nsub    $0x1,%edx\nsub    -0x20(%rbp),%edx\nmovslq %edx,%rdx\nadd    (%rcx,%rdx,4),%eax\nadd    -0x1c(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    111c <func0+0x1c>\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    11d2 <func0+0xd2>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x30(%rbp),%rax\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nadd    -0x1c(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\nsetle  %al\nand    $0x1,%al\nmov    %al,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 72,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\nmov    %esi,%r9d\nshr    $0x1f,%r9d\nadd    %esi,%r9d\nmov    %r9d,%r8d\nsar    %r8d\nxor    %eax,%eax\ncmp    $0x2,%esi\njl     114e <func0+0x4e>\nmov    %r8d,%r10d\nlea    -0x1(%rsi),%r11d\nxor    %ecx,%ecx\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    (%rdi,%rcx,4),%ebx\nmovslq %r11d,%rbp\nmov    (%rdi,%rbp,4),%ebp\ncmp    %ebp,%ebx\njne    1167 <func0+0x67>\nadd    %ebx,%eax\nadd    %ebp,%eax\nadd    $0x1,%rcx\nadd    $0xffffffff,%r11d\ncmp    %rcx,%r10\njne    1130 <func0+0x30>\nand    $0xfffffffe,%r9d\nsub    %r9d,%esi\ncmp    $0x1,%esi\njne    1160 <func0+0x60>\nmovslq %r8d,%rcx\nadd    (%rdi,%rcx,4),%eax\ncmp    %edx,%eax\nsetle  %al\njmp    1169 <func0+0x69>\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 72,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\nmov    %esi,%r9d\nshr    $0x1f,%r9d\nadd    %esi,%r9d\nmov    %r9d,%r8d\nsar    %r8d\nxor    %r11d,%r11d\ncmp    $0x2,%esi\njl     114b <func0+0x4b>\nmov    %r8d,%r10d\nlea    -0x1(%rsi),%ebp\nxor    %eax,%eax\nxor    %r11d,%r11d\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    (%rdi,%rax,4),%ebx\nmovslq %ebp,%rcx\ncmp    (%rdi,%rcx,4),%ebx\njne    1166 <func0+0x66>\nlea    (%r11,%rbx,2),%r11d\nadd    $0x1,%rax\nadd    $0xffffffff,%ebp\ncmp    %rax,%r10\njne    1130 <func0+0x30>\nand    $0xfffffffe,%r9d\nsub    %r9d,%esi\ncmp    $0x1,%esi\njne    115e <func0+0x5e>\nmovslq %r8d,%rax\nadd    (%rdi,%rax,4),%r11d\ncmp    %edx,%r11d\nsetle  %al\njmp    1168 <func0+0x68>\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 72,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\nmov    %esi,%r9d\nshr    $0x1f,%r9d\nadd    %esi,%r9d\nmov    %r9d,%r8d\nsar    %r8d\nxor    %r11d,%r11d\ncmp    $0x2,%esi\njl     114b <func0+0x4b>\nmov    %r8d,%r10d\nlea    -0x1(%rsi),%ebp\nxor    %eax,%eax\nxor    %r11d,%r11d\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    (%rdi,%rax,4),%ebx\nmovslq %ebp,%rcx\ncmp    (%rdi,%rcx,4),%ebx\njne    1167 <func0+0x67>\nlea    (%r11,%rbx,2),%r11d\nadd    $0x1,%rax\nadd    $0xffffffff,%ebp\ncmp    %rax,%r10\njne    1130 <func0+0x30>\nand    $0xfffffffe,%r9d\nsub    %r9d,%esi\ncmp    $0x1,%esi\njne    115e <func0+0x5e>\nmovslq %r8d,%rax\nadd    (%rdi,%rax,4),%r11d\ncmp    %edx,%r11d\nsetle  %al\npop    %rbx\npop    %rbp\nret\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 73,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x18(%rbp),%eax\ncmp    %ecx,%eax\njge    1177 <func0+0x77>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmov    -0xc(%rbp),%edx\nsub    $0x1,%edx\nsub    -0x14(%rbp),%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\nje     1164 <func0+0x64>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    1169 <func0+0x69>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1119 <func0+0x19>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 73,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\ncmp    $0x2,%esi\njl     113e <func0+0x3e>\nmov    %esi,%r8d\nshr    $0x1f,%r8d\nadd    %esi,%r8d\nsar    %r8d\nadd    $0xffffffff,%esi\nxor    %edx,%edx\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi,%rdx,4),%r9d\nmovslq %esi,%rsi\nxor    %ecx,%ecx\ncmp    (%rdi,%rsi,4),%r9d\nsetne  %cl\nadd    %ecx,%eax\nadd    $0x1,%rdx\nadd    $0xffffffff,%esi\ncmp    %rdx,%r8\njne    1120 <func0+0x20>\nret\n"
    },
    {
        "task_id": 73,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\nxor    %eax,%eax\ncmp    $0x2,%esi\njl     124b <func0+0x14b>\nmov    %esi,%r8d\nshr    %r8d\ncmp    $0x10,%esi\njae    1197 <func0+0x97>\nxor    %r14d,%r14d\nxor    %eax,%eax\nmov    %r14,%r10\nnot    %r10\ntest   $0x1,%r8b\nje     1147 <func0+0x47>\nmov    (%rdi,%r14,4),%r9d\nmov    %r14d,%ecx\nnot    %ecx\nadd    %esi,%ecx\nmovslq %ecx,%r11\nxor    %ecx,%ecx\ncmp    (%rdi,%r11,4),%r9d\nsetne  %cl\nadd    %ecx,%eax\nor     $0x1,%r14\nadd    %r8,%r10\nje     124b <func0+0x14b>\nmov    %r14d,%ecx\nnot    %ecx\nadd    %esi,%ecx\nnopw   0x0(%rax,%rax,1)\nmovslq %ecx,%rcx\nmov    (%rdi,%r14,4),%esi\nmov    0x4(%rdi,%r14,4),%edx\nxor    %ebx,%ebx\ncmp    (%rdi,%rcx,4),%esi\nsetne  %bl\nadd    %eax,%ebx\nlea    -0x1(%rcx),%eax\nmovslq %eax,%rsi\nxor    %eax,%eax\ncmp    (%rdi,%rsi,4),%edx\nsetne  %al\nadd    %ebx,%eax\nadd    $0x2,%r14\nadd    $0xfffffffe,%ecx\ncmp    %r14,%r8\njne    1160 <func0+0x60>\njmp    124b <func0+0x14b>\nlea    -0x1(%r8),%r9\nlea    -0x1(%rsi),%ecx\nmov    %ecx,%eax\nsub    %r9d,%eax\nxor    %r14d,%r14d\ncmp    %ecx,%eax\njg     111c <func0+0x1c>\nshr    $0x20,%r9\nmov    $0x0,%eax\njne    111e <func0+0x1e>\nmov    %r8d,%r14d\nand    $0xfffffff8,%r14d\nmov    %esi,%r9d\nand    $0xfffffff0,%r9d\nadd    %r9,%r9\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npcmpeqd %xmm2,%xmm2\npxor   %xmm1,%xmm1\nnopl   0x0(%rax)\nmovdqu (%rdi,%rax,1),%xmm3\nmovdqu 0x10(%rdi,%rax,1),%xmm4\nmovslq %ecx,%rcx\nmovdqu -0x1c(%rdi,%rcx,4),%xmm5\nmovdqu -0xc(%rdi,%rcx,4),%xmm6\npshufd $0x1b,%xmm6,%xmm6\npcmpeqd %xmm3,%xmm6\npaddd  %xmm6,%xmm0\npshufd $0x1b,%xmm5,%xmm3\npcmpeqd %xmm4,%xmm3\npaddd  %xmm3,%xmm1\npsubd  %xmm2,%xmm0\npsubd  %xmm2,%xmm1\nadd    $0x20,%rax\nadd    $0xfffffff8,%ecx\ncmp    %rax,%r9\njne    11e0 <func0+0xe0>\npaddd  %xmm0,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ncmp    %r8,%r14\njne    111e <func0+0x1e>\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 73,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\nxor    %eax,%eax\ncmp    $0x2,%esi\njl     1252 <func0+0x152>\nmov    %esi,%r8d\nshr    %r8d\ncmp    $0x10,%esi\njae    1133 <func0+0x33>\nxor    %r14d,%r14d\nxor    %eax,%eax\nmov    %r14,%r10\nnot    %r10\ntest   $0x1,%r8b\njne    11f3 <func0+0xf3>\njmp    1210 <func0+0x110>\nlea    -0x1(%r8),%r9\nlea    -0x1(%rsi),%ecx\nmov    %ecx,%eax\nsub    %r9d,%eax\nxor    %r14d,%r14d\ncmp    %ecx,%eax\njg     111c <func0+0x1c>\nshr    $0x20,%r9\nmov    $0x0,%eax\njne    11e7 <func0+0xe7>\nmov    %r8d,%r14d\nand    $0xfffffff8,%r14d\nmov    %esi,%r9d\nand    $0xfffffff0,%r9d\nadd    %r9,%r9\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npcmpeqd %xmm2,%xmm2\npxor   %xmm1,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovdqu (%rdi,%rax,1),%xmm3\nmovdqu 0x10(%rdi,%rax,1),%xmm4\nmovslq %ecx,%rcx\nmovdqu -0x1c(%rdi,%rcx,4),%xmm5\nmovdqu -0xc(%rdi,%rcx,4),%xmm6\npshufd $0x1b,%xmm6,%xmm6\npcmpeqd %xmm3,%xmm6\npaddd  %xmm6,%xmm0\npshufd $0x1b,%xmm5,%xmm3\npcmpeqd %xmm4,%xmm3\npaddd  %xmm3,%xmm1\npsubd  %xmm2,%xmm0\npsubd  %xmm2,%xmm1\nadd    $0x20,%rax\nadd    $0xfffffff8,%ecx\ncmp    %rax,%r9\njne    1180 <func0+0x80>\npaddd  %xmm0,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ncmp    %r8,%r14\nje     1252 <func0+0x152>\nmov    %r14,%r10\nnot    %r10\ntest   $0x1,%r8b\nje     1210 <func0+0x110>\nmov    (%rdi,%r14,4),%r9d\nmov    %r14d,%ecx\nnot    %ecx\nadd    %esi,%ecx\nmovslq %ecx,%r11\nxor    %ecx,%ecx\ncmp    (%rdi,%r11,4),%r9d\nsetne  %cl\nadd    %ecx,%eax\nor     $0x1,%r14\nadd    %r8,%r10\nje     1252 <func0+0x152>\nmov    %r14d,%ecx\nnot    %ecx\nadd    %esi,%ecx\nnopl   0x0(%rax)\nmovslq %ecx,%rcx\nmov    (%rdi,%r14,4),%esi\nmov    0x4(%rdi,%r14,4),%edx\nxor    %ebx,%ebx\ncmp    (%rdi,%rcx,4),%esi\nsetne  %bl\nadd    %eax,%ebx\nlea    -0x1(%rcx),%eax\nmovslq %eax,%rsi\nxor    %eax,%eax\ncmp    (%rdi,%rsi,4),%edx\nsetne  %al\nadd    %ebx,%eax\nadd    $0x2,%r14\nadd    $0xfffffffe,%ecx\ncmp    %r14,%r8\njne    1220 <func0+0x120>\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 74,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmov    %rdx,-0x20(%rbp)\nmov    %ecx,-0x24(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1173 <func0+0x63>\nmov    -0x10(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\nmovslq -0x2c(%rbp),%rax\nadd    %rcx,%rax\nmov    %eax,-0x2c(%rbp)\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    113b <func0+0x2b>\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njge    11b2 <func0+0xa2>\nmov    -0x20(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\nmovslq -0x30(%rbp),%rax\nadd    %rcx,%rax\nmov    %eax,-0x30(%rbp)\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    117a <func0+0x6a>\nmov    -0x2c(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njge    11cb <func0+0xbb>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    11ec <func0+0xdc>\nmov    -0x2c(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njle    11e4 <func0+0xd4>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    11ec <func0+0xdc>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 74,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %ecx,0x4(%rsp)\nmov    %rdx,%r12\nmov    %rdi,%rbp\nxor    %r14d,%r14d\nmov    $0x0,%ebx\ntest   %esi,%esi\njle    1155 <func0+0x45>\nmov    %esi,%r13d\nxor    %r15d,%r15d\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmov    0x0(%rbp,%r15,8),%rdi\ncall   1030 <strlen@plt>\nadd    %eax,%ebx\nadd    $0x1,%r15\ncmp    %r15,%r13\njne    1140 <func0+0x30>\nmov    %rbp,%r13\nmov    0x4(%rsp),%eax\ntest   %eax,%eax\njle    1185 <func0+0x75>\nmov    %eax,%r15d\nxor    %ebp,%ebp\nxor    %r14d,%r14d\nnopl   0x0(%rax,%rax,1)\nmov    (%r12,%rbp,8),%rdi\ncall   1030 <strlen@plt>\nadd    %eax,%r14d\nadd    $0x1,%rbp\ncmp    %rbp,%r15\njne    1170 <func0+0x60>\ncmp    %r14d,%ebx\ncmovle %r13,%r12\ncmovl  %r13,%r12\nmov    %r12,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 74,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %ecx,0x4(%rsp)\nmov    %rdx,%r12\nmov    %rdi,%rbp\nxor    %r14d,%r14d\nmov    $0x0,%ebx\ntest   %esi,%esi\njle    1155 <func0+0x45>\nmov    %esi,%r13d\nxor    %r15d,%r15d\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmov    0x0(%rbp,%r15,8),%rdi\ncall   1030 <strlen@plt>\nadd    %eax,%ebx\nadd    $0x1,%r15\ncmp    %r15,%r13\njne    1140 <func0+0x30>\nmov    %rbp,%r13\nmov    0x4(%rsp),%eax\ntest   %eax,%eax\njle    1185 <func0+0x75>\nmov    %eax,%r15d\nxor    %ebp,%ebp\nxor    %r14d,%r14d\nnopl   0x0(%rax,%rax,1)\nmov    (%r12,%rbp,8),%rdi\ncall   1030 <strlen@plt>\nadd    %eax,%r14d\nadd    $0x1,%rbp\ncmp    %rbp,%r15\njne    1170 <func0+0x60>\ncmp    %r14d,%ebx\ncmovle %r13,%r12\ncmovl  %r13,%r12\nmov    %r12,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 74,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %ecx,0x4(%rsp)\nmov    %rdx,%r12\nmov    %rdi,%rbp\nxor    %r14d,%r14d\nmov    $0x0,%ebx\ntest   %esi,%esi\njle    1155 <func0+0x45>\nmov    %esi,%r13d\nxor    %r15d,%r15d\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmov    0x0(%rbp,%r15,8),%rdi\ncall   1030 <strlen@plt>\nadd    %eax,%ebx\nadd    $0x1,%r15\ncmp    %r15,%r13\njne    1140 <func0+0x30>\nmov    %rbp,%r13\nmov    0x4(%rsp),%eax\ntest   %eax,%eax\njle    1185 <func0+0x75>\nmov    %eax,%r15d\nxor    %ebp,%ebp\nxor    %r14d,%r14d\nnopl   0x0(%rax,%rax,1)\nmov    (%r12,%rbp,8),%rdi\ncall   1030 <strlen@plt>\nadd    %eax,%r14d\nadd    $0x1,%rbp\ncmp    %rbp,%r15\njne    1170 <func0+0x60>\ncmp    %r14d,%ebx\ncmovle %r13,%r12\ncmovl  %r13,%r12\nmov    %r12,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 75,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x8(%rbp)\ncmpl   $0x2,-0x8(%rbp)\njge    111d <func0+0x1d>\nmovl   $0x0,-0x4(%rbp)\njmp    119d <func0+0x9d>\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x2,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nimul   -0x10(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njg     117b <func0+0x7b>\njmp    1140 <func0+0x40>\nmov    -0x8(%rbp),%eax\ncltd\nidivl  -0x10(%rbp)\ncmp    $0x0,%edx\njne    1168 <func0+0x68>\nmov    -0x8(%rbp),%eax\ncltd\nidivl  -0x10(%rbp)\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    1140 <func0+0x40>\njmp    116d <func0+0x6d>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    112b <func0+0x2b>\ncmpl   $0x1,-0x8(%rbp)\njle    118e <func0+0x8e>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x3,-0xc(%rbp)\nsete   %al\nand    $0x1,%al\nmovzbl %al,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 75,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\ncmp    $0x2,%edi\njl     1120 <func0+0x20>\nxor    %ecx,%ecx\ncmp    $0x4,%edi\njge    1121 <func0+0x21>\nxor    %edx,%edx\ncmp    $0x2,%edi\nsetge  %dl\nadd    %ecx,%edx\nxor    %eax,%eax\ncmp    $0x3,%edx\nsete   %al\nret\nxor    %ecx,%ecx\nmov    $0x2,%esi\njmp    113c <func0+0x3c>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njg     110e <func0+0xe>\nmov    %edi,%eax\nxchg   %ax,%ax\ncltd\nidiv   %esi\ntest   %edx,%edx\njne    1130 <func0+0x30>\nmov    %edi,%eax\ncltd\nidiv   %esi\nadd    $0x1,%ecx\nmov    %eax,%edi\njmp    1140 <func0+0x40>\n"
    },
    {
        "task_id": 75,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\ncmp    $0x2,%edi\njl     1120 <func0+0x20>\nxor    %ecx,%ecx\ncmp    $0x4,%edi\njae    1121 <func0+0x21>\nxor    %edx,%edx\ncmp    $0x2,%edi\nsetge  %dl\nadd    %ecx,%edx\nxor    %eax,%eax\ncmp    $0x3,%edx\nsete   %al\nret\nxor    %ecx,%ecx\nmov    $0x2,%esi\njmp    113c <func0+0x3c>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njg     110e <func0+0xe>\nmov    %edi,%eax\nxchg   %ax,%ax\ncltd\nidiv   %esi\ntest   %edx,%edx\njne    1130 <func0+0x30>\nmov    %edi,%eax\ncltd\nidiv   %esi\nadd    $0x1,%ecx\nmov    %eax,%edi\njmp    1140 <func0+0x40>\n"
    },
    {
        "task_id": 75,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\ncmp    $0x2,%edi\njl     1120 <func0+0x20>\nxor    %ecx,%ecx\ncmp    $0x4,%edi\njae    1121 <func0+0x21>\nxor    %edx,%edx\ncmp    $0x2,%edi\nsetge  %dl\nadd    %ecx,%edx\nxor    %eax,%eax\ncmp    $0x3,%edx\nsete   %al\nret\nxor    %ecx,%ecx\nmov    $0x2,%esi\njmp    113c <func0+0x3c>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njg     110e <func0+0xe>\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\njne    1130 <func0+0x30>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %edi,%eax\ncltd\nidiv   %esi\nadd    $0x1,%ecx\nmov    %eax,%edi\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1150 <func0+0x50>\njmp    1130 <func0+0x30>\n"
    },
    {
        "task_id": 76,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x10(%rbp),%ecx\nxor    %eax,%eax\ncmp    -0x8(%rbp),%ecx\nmov    %al,-0x15(%rbp)\njg     1133 <func0+0x33>\ncmpl   $0x64,-0x14(%rbp)\nsetl   %al\nmov    %al,-0x15(%rbp)\nmov    -0x15(%rbp),%al\ntest   $0x1,%al\njne    1143 <func0+0x43>\njmp    1173 <func0+0x73>\nmov    -0x10(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njne    115b <func0+0x5b>\nmovl   $0x1,-0x4(%rbp)\njmp    117a <func0+0x7a>\nmov    -0x10(%rbp),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1118 <func0+0x18>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 76,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1128 <func0+0x28>\nxor    %ecx,%ecx\nmov    $0x1,%edx\nxor    %eax,%eax\nnopl   (%rax)\ncmp    %edi,%edx\nje     112b <func0+0x2b>\nimul   %esi,%edx\ncmp    %edi,%edx\njg     1127 <func0+0x27>\nlea    0x1(%rcx),%r8d\ncmp    $0x63,%ecx\nmov    %r8d,%ecx\njb     1110 <func0+0x10>\nret\nxor    %eax,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 76,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1128 <func0+0x28>\nxor    %ecx,%ecx\nmov    $0x1,%edx\nxor    %eax,%eax\nnopl   (%rax)\ncmp    %edi,%edx\nje     112b <func0+0x2b>\nimul   %esi,%edx\ncmp    %edi,%edx\njg     1127 <func0+0x27>\nlea    0x1(%rcx),%r8d\ncmp    $0x63,%ecx\nmov    %r8d,%ecx\njb     1110 <func0+0x10>\nret\nxor    %eax,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 76,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1128 <func0+0x28>\nxor    %ecx,%ecx\nmov    $0x1,%edx\nxor    %eax,%eax\nnopl   (%rax)\ncmp    %edi,%edx\nje     112b <func0+0x2b>\nimul   %esi,%edx\ncmp    %edi,%edx\njg     1127 <func0+0x27>\nlea    0x1(%rcx),%r8d\ncmp    $0x63,%ecx\nmov    %r8d,%ecx\njb     1110 <func0+0x10>\nret\nxor    %eax,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 77,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nimul   -0xc(%rbp),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x8(%rbp),%edi\ncall   1030 <abs@plt>\nmov    %eax,%ecx\nmov    -0x10(%rbp),%eax\ncmp    %ecx,%eax\njg     1187 <func0+0x77>\nmov    -0xc(%rbp),%eax\nimul   -0xc(%rbp),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x8(%rbp),%edi\ncall   1030 <abs@plt>\nmov    %eax,%ecx\nmov    -0x14(%rbp),%eax\ncmp    %ecx,%eax\njne    1174 <func0+0x64>\nmovl   $0x1,-0x4(%rbp)\njmp    118e <func0+0x7e>\njmp    1179 <func0+0x69>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    1122 <func0+0x12>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 77,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\nneg    %eax\ncmovs  %edi,%eax\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nmov    %ecx,%edx\nimul   %ecx,%edx\nimul   %ecx,%edx\nadd    $0x1,%ecx\ncmp    %eax,%edx\njb     1110 <func0+0x10>\nsetbe  %al\nmovzbl %al,%eax\nret\n"
    },
    {
        "task_id": 77,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\nneg    %eax\ncmovs  %edi,%eax\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nmov    %ecx,%edx\nimul   %ecx,%edx\nimul   %ecx,%edx\nadd    $0x1,%ecx\ncmp    %eax,%edx\njb     1110 <func0+0x10>\nsetbe  %al\nmovzbl %al,%eax\nret\n"
    },
    {
        "task_id": 77,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\nneg    %eax\ncmovs  %edi,%eax\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nmov    %ecx,%edx\nimul   %ecx,%edx\nimul   %ecx,%edx\nadd    $0x1,%ecx\ncmp    %eax,%edx\njb     1110 <func0+0x10>\nsetbe  %al\nmovzbl %al,%eax\nret\n"
    },
    {
        "task_id": 78,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    0xecd(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovslq -0x18(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\nmov    -0x20(%rbp),%rax\ncmp    %rcx,%rax\njae    11a1 <func0+0x81>\nmov    -0x10(%rbp),%rdi\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%esi\ncall   1040 <strchr@plt>\ncmp    $0x0,%rax\nje     118e <func0+0x6e>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1193 <func0+0x73>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1145 <func0+0x25>\nmov    -0x14(%rbp),%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 78,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1174 <func0+0x54>\nmov    %rax,%r12\nxor    %ebx,%ebx\nlea    0xebf(%rip),%r15\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovsbl (%r14,%rbx,1),%esi\nmov    $0x7,%edx\nmov    %r15,%rdi\ncall   1040 <memchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x1,%rbx\ncmp    %rbx,%r12\njne    1150 <func0+0x30>\njmp    1176 <func0+0x56>\nxor    %ebp,%ebp\nmov    %ebp,%eax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 78,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1174 <func0+0x54>\nmov    %rax,%r12\nxor    %ebx,%ebx\nlea    0xebf(%rip),%r15\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovsbl (%r14,%rbx,1),%esi\nmov    $0x7,%edx\nmov    %r15,%rdi\ncall   1040 <memchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x1,%rbx\ncmp    %rbx,%r12\njne    1150 <func0+0x30>\njmp    1176 <func0+0x56>\nxor    %ebp,%ebp\nmov    %ebp,%eax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 78,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1174 <func0+0x54>\nmov    %rax,%r12\nxor    %ebx,%ebx\nlea    0xebf(%rip),%r15\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovsbl (%r14,%rbx,1),%esi\nmov    $0x7,%edx\nmov    %r15,%rdi\ncall   1040 <memchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x1,%rbx\ncmp    %rbx,%r12\njne    1150 <func0+0x30>\njmp    1176 <func0+0x56>\nxor    %ebp,%ebp\nmov    %ebp,%eax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 79,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0xc(%rbp)\nmov    $0x40,%edi\ncall   1050 <malloc@plt>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1171 <func0+0x31>\nmovq   $0x0,-0x8(%rbp)\njmp    1297 <func0+0x157>\nmovl   $0x3e,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmovb   $0x0,0x3f(%rax)\ncmpl   $0x0,-0xc(%rbp)\njne    11a5 <func0+0x65>\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0xffffffff,%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x30,(%rax,%rcx,1)\njmp    11ef <func0+0xaf>\njmp    11aa <func0+0x6a>\ncmpl   $0x0,-0xc(%rbp)\njle    11ea <func0+0xaa>\nmov    -0xc(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nadd    $0x30,%edx\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0xffffffff,%esi\nmov    %esi,-0x1c(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0xc(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0xc(%rbp)\njmp    11aa <func0+0x6a>\njmp    11ef <func0+0xaf>\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0xffffffff,%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x62,(%rax,%rcx,1)\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0xffffffff,%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x64,(%rax,%rcx,1)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\nmov    $0x3e,%eax\nsub    -0x20(%rbp),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x3,%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x30(%rbp)\ncmpq   $0x0,-0x30(%rbp)\njne    1262 <func0+0x122>\nmov    -0x18(%rbp),%rdi\ncall   1030 <free@plt>\nmovq   $0x0,-0x8(%rbp)\njmp    1297 <func0+0x157>\nmov    -0x30(%rbp),%rdi\nmov    -0x18(%rbp),%rsi\nmovslq -0x20(%rbp),%rax\nadd    %rax,%rsi\ncall   1040 <strcpy@plt>\nmov    -0x30(%rbp),%rdi\nlea    0xd7f(%rip),%rsi\ncall   1060 <strcat@plt>\nmov    -0x18(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 79,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %edi,%ebp\nmov    $0x40,%edi\ncall   1060 <malloc@plt>\ntest   %rax,%rax\nje     1198 <func0+0x58>\nmov    %rax,%rbx\nmovb   $0x0,0x3f(%rax)\ntest   %ebp,%ebp\nje     119c <func0+0x5c>\njle    11a7 <func0+0x67>\nmov    $0x3e,%eax\nmov    %ebp,%ecx\nnopl   0x0(%rax)\nshr    $0x1f,%ecx\nadd    %ebp,%ecx\nmov    %ecx,%edx\nand    $0xfe,%edx\nmov    %ebp,%esi\nsub    %edx,%esi\nadd    $0x30,%sil\nmov    %sil,(%rbx,%rax,1)\nadd    $0xffffffffffffffff,%rax\nsar    %ecx\ncmp    $0x1,%ebp\nmov    %ecx,%ebp\njg     1170 <func0+0x30>\njmp    11ac <func0+0x6c>\nxor    %ebp,%ebp\njmp    11ff <func0+0xbf>\nmovb   $0x30,0x3e(%rbx)\nmov    $0x3d,%eax\njmp    11ac <func0+0x6c>\nmov    $0x3e,%eax\nmovslq %eax,%r14\nmovw   $0x6264,-0x1(%r14,%rbx,1)\n62\nmov    $0x42,%eax\nsub    %r14d,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\ntest   %rax,%rax\nje     11f5 <func0+0xb5>\nmov    %rax,%rbp\nlea    (%r14,%rbx,1),%rsi\nadd    $0xffffffffffffffff,%rsi\nmov    %rax,%rdi\ncall   1040 <strcpy@plt>\nmov    %rbp,%rdi\ncall   1050 <strlen@plt>\nmovw   $0x6264,0x0(%rbp,%rax,1)\nmovb   $0x0,0x2(%rbp,%rax,1)\njmp    11f7 <func0+0xb7>\nxor    %ebp,%ebp\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %rbp,%rax\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 79,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %edi,%ebp\nmov    $0x40,%edi\ncall   1060 <malloc@plt>\ntest   %rax,%rax\nje     118a <func0+0x4a>\nmov    %rax,%rbx\nmovb   $0x0,0x3f(%rax)\ntest   %ebp,%ebp\nje     118e <func0+0x4e>\njle    1199 <func0+0x59>\nmov    $0x3e,%eax\nmov    %ebp,%ecx\nnopl   0x0(%rax)\nmov    %ebp,%edx\nand    $0x1,%dl\nor     $0x30,%dl\nmov    %dl,(%rbx,%rax,1)\nadd    $0xffffffffffffffff,%rax\nshr    %ecx\ncmp    $0x1,%ebp\nmov    %ecx,%ebp\nja     1170 <func0+0x30>\njmp    119e <func0+0x5e>\nxor    %ebp,%ebp\njmp    11f1 <func0+0xb1>\nmovb   $0x30,0x3e(%rbx)\nmov    $0x3d,%eax\njmp    119e <func0+0x5e>\nmov    $0x3e,%eax\nmovslq %eax,%r14\nmovw   $0x6264,-0x1(%r14,%rbx,1)\n62\nmov    $0x42,%eax\nsub    %r14d,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\ntest   %rax,%rax\nje     11e7 <func0+0xa7>\nmov    %rax,%rbp\nlea    (%r14,%rbx,1),%rsi\nadd    $0xffffffffffffffff,%rsi\nmov    %rax,%rdi\ncall   1040 <strcpy@plt>\nmov    %rbp,%rdi\ncall   1050 <strlen@plt>\nmovw   $0x6264,0x0(%rbp,%rax,1)\nmovb   $0x0,0x2(%rbp,%rax,1)\njmp    11e9 <func0+0xa9>\nxor    %ebp,%ebp\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %rbp,%rax\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 79,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %edi,%ebp\nmov    $0x40,%edi\ncall   1060 <malloc@plt>\ntest   %rax,%rax\nje     118a <func0+0x4a>\nmov    %rax,%rbx\nmovb   $0x0,0x3f(%rax)\ntest   %ebp,%ebp\nje     118e <func0+0x4e>\njle    1199 <func0+0x59>\nmov    $0x3e,%eax\nmov    %ebp,%ecx\nnopl   0x0(%rax)\nmov    %ebp,%edx\nand    $0x1,%dl\nor     $0x30,%dl\nmov    %dl,(%rbx,%rax,1)\nadd    $0xffffffffffffffff,%rax\nshr    %ecx\ncmp    $0x1,%ebp\nmov    %ecx,%ebp\nja     1170 <func0+0x30>\njmp    119e <func0+0x5e>\nxor    %ebp,%ebp\njmp    11f1 <func0+0xb1>\nmovb   $0x30,0x3e(%rbx)\nmov    $0x3d,%eax\njmp    119e <func0+0x5e>\nmov    $0x3e,%eax\nmovslq %eax,%r14\nmovw   $0x6264,-0x1(%r14,%rbx,1)\n62\nmov    $0x42,%eax\nsub    %r14d,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\ntest   %rax,%rax\nje     11e7 <func0+0xa7>\nmov    %rax,%rbp\nlea    (%r14,%rbx,1),%rsi\nadd    $0xffffffffffffffff,%rsi\nmov    %rax,%rdi\ncall   1040 <strcpy@plt>\nmov    %rbp,%rdi\ncall   1050 <strlen@plt>\nmovw   $0x6264,0x0(%rbp,%rax,1)\nmovb   $0x0,0x2(%rbp,%rax,1)\njmp    11e9 <func0+0xa9>\nxor    %ebp,%ebp\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %rbp,%rax\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 80,
        "type": "O0",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\ncmp    $0x3,%rax\njae    1138 <func0+0x28>\nmovb   $0x0,-0x1(%rbp)\njmp    11ca <func0+0xba>\nmovl   $0x2,-0x14(%rbp)\nmovslq -0x14(%rbp),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\nmov    -0x20(%rbp),%rax\ncmp    %rcx,%rax\njae    11c6 <func0+0xb6>\nmov    -0x10(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x14(%rbp),%edx\nsub    $0x1,%edx\nmovslq %edx,%rdx\nmovsbl (%rcx,%rdx,1),%ecx\ncmp    %ecx,%eax\nje     11aa <func0+0x9a>\nmov    -0x10(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x14(%rbp),%edx\nsub    $0x2,%edx\nmovslq %edx,%rdx\nmovsbl (%rcx,%rdx,1),%ecx\ncmp    %ecx,%eax\njne    11b3 <func0+0xa3>\nmovb   $0x0,-0x1(%rbp)\njmp    11ca <func0+0xba>\njmp    11b8 <func0+0xa8>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    113f <func0+0x2f>\nmovb   $0x1,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 80,
        "type": "O1",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\ncmp    $0x3,%rax\njae    1123 <func0+0x13>\nxor    %eax,%eax\npop    %rbx\nret\nmov    $0x2,%ecx\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rbx,%rcx,1),%edx\ncmp    -0x1(%rbx,%rcx,1),%dl\nje     111f <func0+0xf>\ncmp    -0x2(%rbx,%rcx,1),%dl\nje     111f <func0+0xf>\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1130 <func0+0x20>\nmov    $0x1,%al\npop    %rbx\nret\n"
    },
    {
        "task_id": 80,
        "type": "O2",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ncmp    $0x3,%rax\njae    112c <func0+0x1c>\nxor    %eax,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\nmov    0x1(%r14),%dl\nmov    $0x2,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %edx,%ebx\nmovzbl (%r14,%rcx,1),%edx\ncmp    %bl,%dl\nje     1122 <func0+0x12>\ncmp    -0x2(%r14,%rcx,1),%dl\nje     1122 <func0+0x12>\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1140 <func0+0x30>\nmov    $0x1,%al\njmp    1124 <func0+0x14>\n"
    },
    {
        "task_id": 80,
        "type": "O3",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ncmp    $0x3,%rax\njae    112c <func0+0x1c>\nxor    %eax,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\nmov    0x1(%r14),%dl\nmov    $0x2,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %edx,%ebx\nmovzbl (%r14,%rcx,1),%edx\ncmp    %bl,%dl\nje     1122 <func0+0x12>\ncmp    -0x2(%r14,%rcx,1),%dl\nje     1122 <func0+0x12>\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1140 <func0+0x30>\nmov    $0x1,%al\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 81,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovslq -0xc(%rbp),%rdi\nshl    $0x3,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1464 <func0+0x354>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xea4(%rip),%xmm1\nucomisd %xmm1,%xmm0\njb     117e <func0+0x6e>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xeeb(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    1451 <func0+0x341>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xe71(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    11b9 <func0+0xa9>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xeb3(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    144c <func0+0x33c>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xe3e(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    11f4 <func0+0xe4>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xe7a(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    1447 <func0+0x337>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xe0b(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    122f <func0+0x11f>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xe42(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    1442 <func0+0x332>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xdd8(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    126a <func0+0x15a>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xe0a(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    143d <func0+0x32d>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xda5(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    12a5 <func0+0x195>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xdd1(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    1438 <func0+0x328>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xd72(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    12e0 <func0+0x1d0>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xd99(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    1433 <func0+0x323>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xd3f(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    131b <func0+0x20b>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xd61(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    142e <func0+0x31e>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xd0c(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    1356 <func0+0x246>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xd28(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    1429 <func0+0x319>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xcd9(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    1391 <func0+0x281>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xcf0(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    1424 <func0+0x314>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xca6(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    13cc <func0+0x2bc>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xcb8(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    141f <func0+0x30f>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0xc73(%rip),%xmm1\nucomisd %xmm1,%xmm0\njbe    1407 <func0+0x2f7>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xc7f(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    141a <func0+0x30a>\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nlea    0xc6a(%rip),%rdx\nmov    %rdx,(%rax,%rcx,8)\njmp    141f <func0+0x30f>\njmp    1424 <func0+0x314>\njmp    1429 <func0+0x319>\njmp    142e <func0+0x31e>\njmp    1433 <func0+0x323>\njmp    1438 <func0+0x328>\njmp    143d <func0+0x32d>\njmp    1442 <func0+0x332>\njmp    1447 <func0+0x337>\njmp    144c <func0+0x33c>\njmp    1451 <func0+0x341>\njmp    1456 <func0+0x346>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1137 <func0+0x27>\nmov    -0x18(%rbp),%rax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 81,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %esi,%r14d\nmov    %rdi,%rbx\nmovslq %esi,%rbp\nlea    0x0(,%rbp,8),%rdi\ncall   1030 <malloc@plt>\ntest   %ebp,%ebp\njle    12de <func0+0x1ce>\nmov    %r14d,%ecx\nxor    %edx,%edx\nmovsd  0xeba(%rip),%xmm0\nmovsd  0xeba(%rip),%xmm1\nlea    0xf0e(%rip),%rsi\nmovsd  0xeb3(%rip),%xmm2\nlea    0xf01(%rip),%rdi\nmovsd  0xeac(%rip),%xmm3\nlea    0xef5(%rip),%rbp\nmovsd  0xea5(%rip),%xmm4\nlea    0xee9(%rip),%r8\nmovsd  0xe9e(%rip),%xmm5\nlea    0xedc(%rip),%r9\nmovsd  0xe97(%rip),%xmm6\nlea    0xed0(%rip),%r10\nmovsd  0xe8f(%rip),%xmm12\nlea    0xec3(%rip),%r11\nmovsd  0xe87(%rip),%xmm8\nlea    0xeb5(%rip),%r14\nmovsd  0xe7f(%rip),%xmm9\nmovsd  0xe7e(%rip),%xmm10\nlea    0xea2(%rip),%r13\nmovsd  0xe76(%rip),%xmm11\nlea    0xe97(%rip),%r15\nlea    0xe70(%rip),%r12\njmp    1211 <func0+0x101>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %r12,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\nje     12de <func0+0x1ce>\nmovss  (%rbx,%rdx,4),%xmm7\ncvtss2sd %xmm7,%xmm7\nucomisd %xmm0,%xmm7\njae    1200 <func0+0xf0>\nucomisd %xmm1,%xmm7\njbe    1230 <func0+0x120>\nmov    %rsi,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nnopl   0x0(%rax)\nucomisd %xmm2,%xmm7\njbe    123c <func0+0x12c>\nmov    %rdi,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm3,%xmm7\njbe    1248 <func0+0x138>\nmov    %rbp,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm4,%xmm7\njbe    1254 <func0+0x144>\nmov    %r8,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm5,%xmm7\njbe    1260 <func0+0x150>\nmov    %r9,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm6,%xmm7\njbe    126c <func0+0x15c>\nmov    %r10,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm12,%xmm7\njbe    1279 <func0+0x169>\nmov    %r11,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm8,%xmm7\njbe    1289 <func0+0x179>\nmov    %r14,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm9,%xmm7\njbe    12a7 <func0+0x197>\nlea    0xde1(%rip),%r13\nmov    %r13,(%rax,%rdx,8)\nlea    0xdd9(%rip),%r13\njmp    1204 <func0+0xf4>\nucomisd %xmm10,%xmm7\njbe    12b7 <func0+0x1a7>\nmov    %r13,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm11,%xmm7\njbe    12d5 <func0+0x1c5>\nlea    0xdb8(%rip),%r14\nmov    %r14,(%rax,%rdx,8)\nlea    0xda5(%rip),%r14\njmp    1204 <func0+0xf4>\nmov    %r15,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 81,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %esi,%r14d\nmov    %rdi,%rbx\nmovslq %esi,%rbp\nlea    0x0(,%rbp,8),%rdi\ncall   1030 <malloc@plt>\ntest   %ebp,%ebp\njle    12de <func0+0x1ce>\nmov    %r14d,%ecx\nxor    %edx,%edx\nmovsd  0xeba(%rip),%xmm0\nmovsd  0xeba(%rip),%xmm1\nlea    0xf0e(%rip),%rsi\nmovsd  0xeb3(%rip),%xmm2\nlea    0xf01(%rip),%rdi\nmovsd  0xeac(%rip),%xmm3\nlea    0xef5(%rip),%rbp\nmovsd  0xea5(%rip),%xmm4\nlea    0xee9(%rip),%r8\nmovsd  0xe9e(%rip),%xmm5\nlea    0xedc(%rip),%r9\nmovsd  0xe97(%rip),%xmm6\nlea    0xed0(%rip),%r10\nmovsd  0xe8f(%rip),%xmm12\nlea    0xec3(%rip),%r11\nmovsd  0xe87(%rip),%xmm8\nlea    0xeb5(%rip),%r14\nmovsd  0xe7f(%rip),%xmm9\nmovsd  0xe7e(%rip),%xmm10\nlea    0xea2(%rip),%r13\nmovsd  0xe76(%rip),%xmm11\nlea    0xe97(%rip),%r15\nlea    0xe70(%rip),%r12\njmp    1211 <func0+0x101>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %r12,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\nje     12de <func0+0x1ce>\nmovss  (%rbx,%rdx,4),%xmm7\ncvtss2sd %xmm7,%xmm7\nucomisd %xmm0,%xmm7\njae    1200 <func0+0xf0>\nucomisd %xmm1,%xmm7\njbe    1230 <func0+0x120>\nmov    %rsi,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nnopl   0x0(%rax)\nucomisd %xmm2,%xmm7\njbe    123c <func0+0x12c>\nmov    %rdi,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm3,%xmm7\njbe    1248 <func0+0x138>\nmov    %rbp,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm4,%xmm7\njbe    1254 <func0+0x144>\nmov    %r8,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm5,%xmm7\njbe    1260 <func0+0x150>\nmov    %r9,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm6,%xmm7\njbe    126c <func0+0x15c>\nmov    %r10,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm12,%xmm7\njbe    1279 <func0+0x169>\nmov    %r11,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm8,%xmm7\njbe    1289 <func0+0x179>\nmov    %r14,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm9,%xmm7\njbe    12a7 <func0+0x197>\nlea    0xde1(%rip),%r13\nmov    %r13,(%rax,%rdx,8)\nlea    0xdd9(%rip),%r13\njmp    1204 <func0+0xf4>\nucomisd %xmm10,%xmm7\njbe    12b7 <func0+0x1a7>\nmov    %r13,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm11,%xmm7\njbe    12d5 <func0+0x1c5>\nlea    0xdb8(%rip),%r14\nmov    %r14,(%rax,%rdx,8)\nlea    0xda5(%rip),%r14\njmp    1204 <func0+0xf4>\nmov    %r15,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 81,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %esi,%r14d\nmov    %rdi,%rbx\nmovslq %esi,%rbp\nlea    0x0(,%rbp,8),%rdi\ncall   1030 <malloc@plt>\ntest   %ebp,%ebp\njle    12de <func0+0x1ce>\nmov    %r14d,%ecx\nxor    %edx,%edx\nmovsd  0xeba(%rip),%xmm0\nmovsd  0xeba(%rip),%xmm1\nlea    0xf0e(%rip),%rsi\nmovsd  0xeb3(%rip),%xmm2\nlea    0xf01(%rip),%rdi\nmovsd  0xeac(%rip),%xmm3\nlea    0xef5(%rip),%rbp\nmovsd  0xea5(%rip),%xmm4\nlea    0xee9(%rip),%r8\nmovsd  0xe9e(%rip),%xmm5\nlea    0xedc(%rip),%r9\nmovsd  0xe97(%rip),%xmm6\nlea    0xed0(%rip),%r10\nmovsd  0xe8f(%rip),%xmm12\nlea    0xec3(%rip),%r11\nmovsd  0xe87(%rip),%xmm8\nlea    0xeb5(%rip),%r14\nmovsd  0xe7f(%rip),%xmm9\nmovsd  0xe7e(%rip),%xmm10\nlea    0xea2(%rip),%r13\nmovsd  0xe76(%rip),%xmm11\nlea    0xe97(%rip),%r15\nlea    0xe70(%rip),%r12\njmp    1211 <func0+0x101>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %r12,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\nje     12de <func0+0x1ce>\nmovss  (%rbx,%rdx,4),%xmm7\ncvtss2sd %xmm7,%xmm7\nucomisd %xmm0,%xmm7\njae    1200 <func0+0xf0>\nucomisd %xmm1,%xmm7\njbe    1230 <func0+0x120>\nmov    %rsi,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nnopl   0x0(%rax)\nucomisd %xmm2,%xmm7\njbe    123c <func0+0x12c>\nmov    %rdi,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm3,%xmm7\njbe    1248 <func0+0x138>\nmov    %rbp,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm4,%xmm7\njbe    1254 <func0+0x144>\nmov    %r8,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm5,%xmm7\njbe    1260 <func0+0x150>\nmov    %r9,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm6,%xmm7\njbe    126c <func0+0x15c>\nmov    %r10,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm12,%xmm7\njbe    1279 <func0+0x169>\nmov    %r11,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm8,%xmm7\njbe    1289 <func0+0x179>\nmov    %r14,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm9,%xmm7\njbe    12a7 <func0+0x197>\nlea    0xde1(%rip),%r13\nmov    %r13,(%rax,%rdx,8)\nlea    0xdd9(%rip),%r13\njmp    1204 <func0+0xf4>\nucomisd %xmm10,%xmm7\njbe    12b7 <func0+0x1a7>\nmov    %r13,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nucomisd %xmm11,%xmm7\njbe    12d5 <func0+0x1c5>\nlea    0xdb8(%rip),%r14\nmov    %r14,(%rax,%rdx,8)\nlea    0xda5(%rip),%r14\njmp    1204 <func0+0xf4>\nmov    %r15,(%rax,%rdx,8)\njmp    1204 <func0+0xf4>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 82,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x14(%rbp)\ncmpl   $0x2,-0x14(%rbp)\njge    113b <func0+0x2b>\nmovb   $0x0,-0x1(%rbp)\njmp    1182 <func0+0x72>\nmovl   $0x2,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nimul   -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njg     117e <func0+0x6e>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x18(%rbp)\ncmp    $0x0,%edx\njne    116b <func0+0x5b>\nmovb   $0x0,-0x1(%rbp)\njmp    1182 <func0+0x72>\njmp    1170 <func0+0x60>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1142 <func0+0x32>\nmovb   $0x1,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 82,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rax\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\ncmp    $0x2,%ecx\njge    1122 <func0+0x12>\nxor    %esi,%esi\njmp    1159 <func0+0x49>\ncmp    $0x4,%ecx\nsetl   %sil\njl     1159 <func0+0x49>\nmov    %ecx,%eax\nand    $0x1,%eax\nje     1159 <func0+0x49>\nmov    $0x3,%edi\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%eax\nimul   %edi,%eax\ncmp    %ecx,%eax\nsetg   %sil\njg     1159 <func0+0x49>\nmov    %ecx,%eax\ncltd\nidiv   %edi\nadd    $0x1,%edi\ntest   %edx,%edx\njne    1140 <func0+0x30>\nmov    %esi,%eax\npop    %rcx\nret\n"
    },
    {
        "task_id": 82,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rax\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\ncmp    $0x2,%ecx\njge    1122 <func0+0x12>\nxor    %eax,%eax\npop    %rcx\nret\nmov    $0x1,%al\ncmp    $0x4,%ecx\njb     1120 <func0+0x10>\nmov    $0x2,%esi\nxchg   %ax,%ax\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1145 <func0+0x35>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1130 <func0+0x20>\ntest   %edx,%edx\nsetne  %al\npop    %rcx\nret\n"
    },
    {
        "task_id": 82,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rax\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\ncmp    $0x2,%ecx\njge    1122 <func0+0x12>\nxor    %eax,%eax\npop    %rcx\nret\nmov    $0x1,%al\ncmp    $0x4,%ecx\njb     114a <func0+0x3a>\nmov    $0x2,%esi\nxchg   %ax,%ax\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1145 <func0+0x35>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1130 <func0+0x20>\ntest   %edx,%edx\nsetne  %al\npop    %rcx\nret\n"
    },
    {
        "task_id": 83,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x8(%rbp)\ncmpl   $0x1,-0x8(%rbp)\njge    111d <func0+0x1d>\nmovl   $0x0,-0x4(%rbp)\njmp    1168 <func0+0x68>\ncmpl   $0x1,-0x8(%rbp)\njne    1133 <func0+0x33>\nmovl   $0x1,-0x4(%rbp)\njmp    1168 <func0+0x68>\nmovl   $0x12,-0xc(%rbp)\nmovl   $0x2,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    1162 <func0+0x62>\nimul   $0xa,-0xc(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    1141 <func0+0x41>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 83,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    112b <func0+0x2b>\nmov    $0x1,%eax\ncmp    $0x1,%edi\nje     112a <func0+0x2a>\nmov    $0x12,%eax\ncmp    $0x3,%edi\njl     112a <func0+0x2a>\nadd    $0xfffffffe,%edi\nmov    $0x12,%eax\nadd    %eax,%eax\nlea    (%rax,%rax,4),%eax\nadd    $0xffffffff,%edi\njne    1120 <func0+0x20>\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 83,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1139 <func0+0x39>\nmov    $0x1,%eax\ncmp    $0x1,%edi\nje     126a <func0+0x16a>\nmov    $0x12,%eax\ncmp    $0x3,%edi\njb     126a <func0+0x16a>\nlea    -0x2(%rdi),%r8d\ncmp    $0x8,%r8d\njae    113c <func0+0x3c>\nmov    $0x12,%eax\nmov    $0x2,%ecx\njmp    124f <func0+0x14f>\nxor    %eax,%eax\nret\nmov    %r8d,%ecx\nand    $0xfffffff8,%ecx\nlea    -0x8(%rcx),%edx\nmov    %edx,%esi\nshr    $0x3,%esi\nadd    $0x1,%esi\nmov    %esi,%eax\nand    $0x7,%eax\ncmp    $0x38,%edx\njae    1169 <func0+0x69>\nmovdqa 0xea1(%rip),%xmm0\nmovdqa 0xea9(%rip),%xmm1\njmp    11cb <func0+0xcb>\nand    $0xfffffff8,%esi\nmovdqa 0xe8c(%rip),%xmm0\nmovdqa 0xe94(%rip),%xmm1\nmovdqa 0xe9c(%rip),%xmm2\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\npshufd $0xf5,%xmm1,%xmm3\npmuludq %xmm2,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm2,%xmm3\npshufd $0xe8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm1\npshufd $0xf5,%xmm0,%xmm3\npmuludq %xmm2,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npmuludq %xmm2,%xmm3\npshufd $0xe8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm0\nadd    $0xfffffff8,%esi\njne    1190 <func0+0x90>\ntest   %eax,%eax\nje     121b <func0+0x11b>\nmovdqa 0xe59(%rip),%xmm2\nnopw   0x0(%rax,%rax,1)\npshufd $0xf5,%xmm1,%xmm3\npmuludq %xmm2,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm2,%xmm3\npshufd $0xe8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm1\npshufd $0xf5,%xmm0,%xmm3\npmuludq %xmm2,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npmuludq %xmm2,%xmm3\npshufd $0xe8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm0\nadd    $0xffffffff,%eax\njne    11e0 <func0+0xe0>\npshufd $0xf5,%xmm1,%xmm2\npshufd $0xf5,%xmm0,%xmm3\npmuludq %xmm2,%xmm3\npmuludq %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npmuludq %xmm0,%xmm1\npshufd $0xaa,%xmm3,%xmm0\npmuludq %xmm3,%xmm0\npmuludq %xmm1,%xmm0\nmovd   %xmm0,%eax\ncmp    %ecx,%r8d\nje     126a <func0+0x16a>\nor     $0x2,%ecx\nsub    %ecx,%edi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    %eax,%eax\nlea    (%rax,%rax,4),%eax\nadd    $0xffffffff,%edi\njne    1260 <func0+0x160>\nret\n"
    },
    {
        "task_id": 83,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1139 <func0+0x39>\nmov    $0x1,%eax\ncmp    $0x1,%edi\nje     126a <func0+0x16a>\nmov    $0x12,%eax\ncmp    $0x3,%edi\njb     126a <func0+0x16a>\nlea    -0x2(%rdi),%r8d\ncmp    $0x8,%r8d\njae    113c <func0+0x3c>\nmov    $0x12,%eax\nmov    $0x2,%ecx\njmp    124f <func0+0x14f>\nxor    %eax,%eax\nret\nmov    %r8d,%ecx\nand    $0xfffffff8,%ecx\nlea    -0x8(%rcx),%edx\nmov    %edx,%esi\nshr    $0x3,%esi\nadd    $0x1,%esi\nmov    %esi,%eax\nand    $0x7,%eax\ncmp    $0x38,%edx\njae    1169 <func0+0x69>\nmovdqa 0xea1(%rip),%xmm0\nmovdqa 0xea9(%rip),%xmm1\njmp    11cb <func0+0xcb>\nand    $0xfffffff8,%esi\nmovdqa 0xe8c(%rip),%xmm0\nmovdqa 0xe94(%rip),%xmm1\nmovdqa 0xe9c(%rip),%xmm2\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\npshufd $0xf5,%xmm1,%xmm3\npmuludq %xmm2,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm2,%xmm3\npshufd $0xe8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm1\npshufd $0xf5,%xmm0,%xmm3\npmuludq %xmm2,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npmuludq %xmm2,%xmm3\npshufd $0xe8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm0\nadd    $0xfffffff8,%esi\njne    1190 <func0+0x90>\ntest   %eax,%eax\nje     121b <func0+0x11b>\nmovdqa 0xe59(%rip),%xmm2\nnopw   0x0(%rax,%rax,1)\npshufd $0xf5,%xmm1,%xmm3\npmuludq %xmm2,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm2,%xmm3\npshufd $0xe8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm1\npshufd $0xf5,%xmm0,%xmm3\npmuludq %xmm2,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npmuludq %xmm2,%xmm3\npshufd $0xe8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm0\nadd    $0xffffffff,%eax\njne    11e0 <func0+0xe0>\npshufd $0xf5,%xmm1,%xmm2\npshufd $0xf5,%xmm0,%xmm3\npmuludq %xmm2,%xmm3\npmuludq %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npmuludq %xmm0,%xmm1\npshufd $0xaa,%xmm3,%xmm0\npmuludq %xmm3,%xmm0\npmuludq %xmm1,%xmm0\nmovd   %xmm0,%eax\ncmp    %ecx,%r8d\nje     126a <func0+0x16a>\nor     $0x2,%ecx\nsub    %ecx,%edi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    %eax,%eax\nlea    (%rax,%rax,4),%eax\nadd    $0xffffffff,%edi\njne    1260 <func0+0x160>\nret\n"
    },
    {
        "task_id": 84,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x4(%rbp)\nlea    -0xa(%rbp),%rdi\nmov    -0x4(%rbp),%edx\nlea    0xec7(%rip),%rsi\nmov    $0x0,%al\ncall   1040 <sprintf@plt>\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovslq -0x14(%rbp),%rax\nmovsbl -0xa(%rbp,%rax,1),%eax\ncmp    $0x0,%eax\nje     1180 <func0+0x60>\nmovslq -0x14(%rbp),%rax\nmovsbl -0xa(%rbp,%rax,1),%eax\nsub    $0x30,%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    114e <func0+0x2e>\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x24(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njne    11ba <func0+0x9a>\nmov    -0x20(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x24(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x30,(%rax,%rcx,1)\njmp    1204 <func0+0xe4>\njmp    11bf <func0+0x9f>\ncmpl   $0x0,-0x10(%rbp)\njle    11ff <func0+0xdf>\nmov    -0x10(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nadd    $0x30,%edx\nmov    -0x20(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x24(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x10(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x10(%rbp)\njmp    11bf <func0+0x9f>\njmp    1204 <func0+0xe4>\nmov    -0x20(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nmov    %eax,-0x30(%rbp)\nmov    -0x24(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x30(%rbp),%eax\ncmp    %ecx,%eax\njge    1285 <func0+0x165>\nmov    -0x20(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x29(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nsub    -0x28(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,1),%dl\nmov    -0x20(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x29(%rbp),%dl\nmov    -0x20(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nsub    -0x28(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    1217 <func0+0xf7>\nmov    -0x20(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 84,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nsub    $0x10,%rsp\nmov    %edi,%edx\nlea    0xed2(%rip),%rsi\nxor    %ebx,%ebx\nlea    0xa(%rsp),%rdi\nxor    %eax,%eax\ncall   1040 <sprintf@plt>\nmov    0xa(%rsp),%al\ntest   %al,%al\nje     1163 <func0+0x43>\nlea    0xb(%rsp),%rcx\nxor    %ebx,%ebx\nnopl   0x0(%rax,%rax,1)\nmovsbl %al,%eax\nadd    %eax,%ebx\nadd    $0xffffffd0,%ebx\nmovzbl (%rcx),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    1150 <func0+0x30>\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\nje     11aa <func0+0x8a>\njle    11b4 <func0+0x94>\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %ebx,%edx\nshr    $0x1f,%edx\nadd    %ebx,%edx\nmov    %edx,%esi\nand    $0xfe,%esi\nmov    %ebx,%edi\nsub    %esi,%edi\nadd    $0x30,%dil\nmov    %dil,(%rax,%rcx,1)\nadd    $0x1,%rcx\nsar    %edx\ncmp    $0x1,%ebx\nmov    %edx,%ebx\njg     1180 <func0+0x60>\njmp    11b6 <func0+0x96>\nmovb   $0x30,(%rax)\nmov    $0x1,%ecx\njmp    11b6 <func0+0x96>\nxor    %ecx,%ecx\nmov    %ecx,%edx\nmovb   $0x0,(%rax,%rdx,1)\ncmp    $0x2,%ecx\njb     1209 <func0+0xe9>\nmovslq %ecx,%rsi\nshr    %ecx\ncmp    $0x2,%ecx\nmov    $0x1,%r8d\ncmovae %ecx,%r8d\nlea    (%rsi,%rax,1),%rcx\nadd    $0xffffffffffffffff,%rcx\nneg    %r8\nxor    %esi,%esi\nmov    %rax,%rdi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovzbl (%rdi),%ebx\nmovzbl (%rcx,%rsi,1),%edx\nmov    %dl,(%rdi)\nmov    %bl,(%rcx,%rsi,1)\nadd    $0x1,%rdi\nadd    $0xffffffffffffffff,%rsi\ncmp    %rsi,%r8\njne    11f0 <func0+0xd0>\nadd    $0x10,%rsp\npop    %rbx\nret\n"
    },
    {
        "task_id": 84,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nsub    $0x10,%rsp\nmov    %edi,%edx\nlea    0xed2(%rip),%rsi\nxor    %ebx,%ebx\nlea    0xa(%rsp),%rdi\nxor    %eax,%eax\ncall   1040 <sprintf@plt>\nmov    0xa(%rsp),%al\ntest   %al,%al\nje     11b4 <func0+0x94>\nlea    0xb(%rsp),%rcx\nnopl   0x0(%rax)\nmovsbl %al,%eax\nadd    %eax,%ebx\nadd    $0xffffffd0,%ebx\nmovzbl (%rcx),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    1150 <func0+0x30>\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\nje     11be <func0+0x9e>\njle    11d0 <func0+0xb0>\nxor    %esi,%esi\nmov    %ebx,%edx\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%ecx\nand    $0x1,%cl\nor     $0x30,%cl\nmov    %cl,(%rax,%rsi,1)\nadd    $0x1,%rsi\nshr    %edx\ncmp    $0x2,%ebx\nmov    %edx,%ebx\njae    1180 <func0+0x60>\nmovb   $0x0,(%rax,%rsi,1)\ntest   $0xfffffffe,%esi\nje     11ca <func0+0xaa>\nmov    %rsi,%r8\nshr    %r8\ncmp    $0x1,%r8\njne    11d4 <func0+0xb4>\nxor    %edx,%edx\njmp    120d <func0+0xed>\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\nmovb   $0x30,(%rax)\nmov    $0x1,%ecx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x10,%rsp\npop    %rbx\nret\nxor    %ecx,%ecx\njmp    11c6 <func0+0xa6>\nlea    -0x1(%rsi),%rdi\nand    $0xfffffffffffffffe,%r8\nxor    %edx,%edx\nxchg   %ax,%ax\nmovzbl (%rax,%rdx,1),%ebx\nmovzbl (%rax,%rdi,1),%ecx\nmov    %cl,(%rax,%rdx,1)\nmov    %bl,(%rax,%rdi,1)\nmovzbl 0x1(%rax,%rdx,1),%ecx\nmovzbl -0x1(%rax,%rdi,1),%ebx\nmov    %bl,0x1(%rax,%rdx,1)\nmov    %cl,-0x1(%rax,%rdi,1)\nadd    $0x2,%rdx\nadd    $0xfffffffffffffffe,%rdi\ncmp    %rdx,%r8\njne    11e0 <func0+0xc0>\ntest   $0x2,%sil\nje     11ca <func0+0xaa>\nmov    (%rax,%rdx,1),%cl\nmov    %rdx,%rdi\nnot    %rdi\nadd    %rax,%rdi\nmov    (%rsi,%rdi,1),%bl\nmov    %bl,(%rax,%rdx,1)\nmov    %cl,(%rsi,%rdi,1)\njmp    11ca <func0+0xaa>\n"
    },
    {
        "task_id": 84,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nsub    $0x10,%rsp\nmov    %edi,%edx\nlea    0xed2(%rip),%rsi\nxor    %ebx,%ebx\nlea    0xa(%rsp),%rdi\nxor    %eax,%eax\ncall   1040 <sprintf@plt>\nmov    0xa(%rsp),%al\ntest   %al,%al\nje     11b4 <func0+0x94>\nlea    0xb(%rsp),%rcx\nnopl   0x0(%rax)\nmovsbl %al,%eax\nadd    %eax,%ebx\nadd    $0xffffffd0,%ebx\nmovzbl (%rcx),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    1150 <func0+0x30>\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\nje     11be <func0+0x9e>\njle    11d0 <func0+0xb0>\nxor    %esi,%esi\nmov    %ebx,%edx\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%ecx\nand    $0x1,%cl\nor     $0x30,%cl\nmov    %cl,(%rax,%rsi,1)\nadd    $0x1,%rsi\nshr    %edx\ncmp    $0x2,%ebx\nmov    %edx,%ebx\njae    1180 <func0+0x60>\nmovb   $0x0,(%rax,%rsi,1)\ntest   $0xfffffffe,%esi\nje     11ca <func0+0xaa>\nmov    %rsi,%r8\nshr    %r8\ncmp    $0x1,%r8\njne    11dc <func0+0xbc>\nxor    %edx,%edx\njmp    121d <func0+0xfd>\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\nmovb   $0x30,(%rax)\nmov    $0x1,%ecx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x10,%rsp\npop    %rbx\nret\nxor    %ecx,%ecx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x10,%rsp\npop    %rbx\nret\nlea    -0x1(%rsi),%rdi\nand    $0xfffffffffffffffe,%r8\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%rax,%rdx,1),%ebx\nmovzbl (%rax,%rdi,1),%ecx\nmov    %cl,(%rax,%rdx,1)\nmov    %bl,(%rax,%rdi,1)\nmovzbl 0x1(%rax,%rdx,1),%ecx\nmovzbl -0x1(%rax,%rdi,1),%ebx\nmov    %bl,0x1(%rax,%rdx,1)\nmov    %cl,-0x1(%rax,%rdi,1)\nadd    $0x2,%rdx\nadd    $0xfffffffffffffffe,%rdi\ncmp    %rdx,%r8\njne    11f0 <func0+0xd0>\ntest   $0x2,%sil\nje     11ca <func0+0xaa>\nmov    (%rax,%rdx,1),%cl\nmov    %rdx,%rdi\nnot    %rdi\nadd    %rax,%rdi\nmov    (%rsi,%rdi,1),%bl\nmov    %bl,(%rax,%rdx,1)\nmov    %cl,(%rsi,%rdi,1)\nadd    $0x10,%rsp\npop    %rbx\nret\n"
    },
    {
        "task_id": 85,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nshl    $0x1,%eax\nadd    $0x1,%eax\ncmp    -0xc(%rbp),%eax\njge    117b <func0+0x7b>\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nshl    $0x1,%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    1168 <func0+0x68>\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nshl    $0x1,%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    116d <func0+0x6d>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1119 <func0+0x19>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 85,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\ncmp    $0x2,%esi\njl     1136 <func0+0x36>\nadd    $0xfffffffe,%esi\nshr    %esi\nadd    $0x1,%esi\nxor    %r8d,%r8d\nxor    %edx,%edx\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nmov    0x4(%rdi,%rdx,8),%ecx\ntest   $0x1,%cl\ncmovne %r8d,%ecx\nadd    %ecx,%eax\nadd    $0x1,%rdx\ncmp    %rdx,%rsi\njne    1120 <func0+0x20>\nret\n"
    },
    {
        "task_id": 85,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\ncmp    $0x2,%esi\njl     11f5 <func0+0xf5>\nadd    $0xfffffffe,%esi\nmov    %esi,%ecx\nshr    %ecx\nadd    $0x1,%ecx\nxor    %r9d,%r9d\ncmp    $0x10,%esi\njae    112c <func0+0x2c>\nmov    $0x1,%r8d\nxor    %esi,%esi\nxor    %eax,%eax\njmp    11d3 <func0+0xd3>\nmov    %ecx,%eax\nand    $0x7,%eax\ntest   %rax,%rax\nmov    $0x8,%r8d\ncmovne %rax,%r8\nmov    %rcx,%rsi\nsub    %r8,%rsi\nlea    (%rsi,%rsi,1),%r8\nadd    $0x1,%r8\npxor   %xmm0,%xmm0\nxor    %eax,%eax\nmovaps 0xea7(%rip),%xmm3\npxor   %xmm2,%xmm2\npxor   %xmm1,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovups 0x4(%rdi,%rax,8),%xmm4\nmovups 0x14(%rdi,%rax,8),%xmm5\nshufps $0x88,%xmm5,%xmm4\nmovups 0x24(%rdi,%rax,8),%xmm5\nmovups 0x34(%rdi,%rax,8),%xmm6\nshufps $0x88,%xmm6,%xmm5\nmovaps %xmm4,%xmm6\nandps  %xmm3,%xmm6\nmovaps %xmm5,%xmm7\nandps  %xmm3,%xmm7\npcmpeqd %xmm0,%xmm6\npand   %xmm4,%xmm6\npaddd  %xmm6,%xmm2\npcmpeqd %xmm0,%xmm7\npand   %xmm5,%xmm7\npaddd  %xmm7,%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rsi\njne    1170 <func0+0x70>\npaddd  %xmm2,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\nsub    %rsi,%rcx\nlea    (%rdi,%r8,4),%rsi\nxor    %edi,%edi\nnopl   0x0(%rax)\nmov    (%rsi,%rdi,8),%edx\ntest   $0x1,%dl\ncmovne %r9d,%edx\nadd    %edx,%eax\nadd    $0x1,%rdi\ncmp    %rdi,%rcx\njne    11e0 <func0+0xe0>\nret\n"
    },
    {
        "task_id": 85,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %eax,%eax\ncmp    $0x2,%esi\njl     11f5 <func0+0xf5>\nadd    $0xfffffffe,%esi\nmov    %esi,%ecx\nshr    %ecx\nadd    $0x1,%ecx\nxor    %r9d,%r9d\ncmp    $0x10,%esi\njae    112c <func0+0x2c>\nmov    $0x1,%r8d\nxor    %esi,%esi\nxor    %eax,%eax\njmp    11d3 <func0+0xd3>\nmov    %ecx,%eax\nand    $0x7,%eax\ntest   %rax,%rax\nmov    $0x8,%r8d\ncmovne %rax,%r8\nmov    %rcx,%rsi\nsub    %r8,%rsi\nlea    (%rsi,%rsi,1),%r8\nadd    $0x1,%r8\npxor   %xmm0,%xmm0\nxor    %eax,%eax\nmovaps 0xea7(%rip),%xmm3\npxor   %xmm2,%xmm2\npxor   %xmm1,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovups 0x4(%rdi,%rax,8),%xmm4\nmovups 0x14(%rdi,%rax,8),%xmm5\nshufps $0x88,%xmm5,%xmm4\nmovups 0x24(%rdi,%rax,8),%xmm5\nmovups 0x34(%rdi,%rax,8),%xmm6\nshufps $0x88,%xmm6,%xmm5\nmovaps %xmm4,%xmm6\nandps  %xmm3,%xmm6\nmovaps %xmm5,%xmm7\nandps  %xmm3,%xmm7\npcmpeqd %xmm0,%xmm6\npand   %xmm4,%xmm6\npaddd  %xmm6,%xmm2\npcmpeqd %xmm0,%xmm7\npand   %xmm5,%xmm7\npaddd  %xmm7,%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rsi\njne    1170 <func0+0x70>\npaddd  %xmm2,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\nsub    %rsi,%rcx\nlea    (%rdi,%r8,4),%rsi\nxor    %edi,%edi\nnopl   0x0(%rax)\nmov    (%rsi,%rdi,8),%edx\ntest   $0x1,%dl\ncmovne %r9d,%edx\nadd    %edx,%eax\nadd    $0x1,%rdi\ncmp    %rdi,%rcx\njne    11e0 <func0+0xe0>\nret\n"
    },
    {
        "task_id": 86,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    $0x2,%eax\nmovslq %eax,%rdi\ncall   1040 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x54(%rbp)\nmovl   $0x0,-0x58(%rbp)\nmovl   $0x0,-0x5c(%rbp)\nmov    -0x5c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njg     12c1 <func0+0x1a1>\nmov    -0x8(%rbp),%rax\nmovslq -0x5c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x20,%eax\nje     1195 <func0+0x75>\nmov    -0x8(%rbp),%rax\nmovslq -0x5c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\njne    1292 <func0+0x172>\nmovl   $0x0,-0x60(%rbp)\nmov    -0x60(%rbp),%eax\nmov    -0x58(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    1228 <func0+0x108>\nmov    -0x60(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x58(%rbp),%eax\njge    1215 <func0+0xf5>\nmovslq -0x60(%rbp),%rax\nmovsbl -0x50(%rbp,%rax,1),%eax\nmovslq -0x64(%rbp),%rcx\nmovsbl -0x50(%rbp,%rcx,1),%ecx\ncmp    %ecx,%eax\njle    1202 <func0+0xe2>\nmovslq -0x60(%rbp),%rax\nmov    -0x50(%rbp,%rax,1),%al\nmov    %al,-0x65(%rbp)\nmovslq -0x64(%rbp),%rax\nmov    -0x50(%rbp,%rax,1),%cl\nmovslq -0x60(%rbp),%rax\nmov    %cl,-0x50(%rbp,%rax,1)\nmov    -0x65(%rbp),%cl\nmovslq -0x64(%rbp),%rax\nmov    %cl,-0x50(%rbp,%rax,1)\njmp    1207 <func0+0xe7>\nmov    -0x64(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x64(%rbp)\njmp    11b6 <func0+0x96>\njmp    121a <func0+0xfa>\nmov    -0x60(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x60(%rbp)\njmp    119c <func0+0x7c>\ncmpl   $0x0,-0x54(%rbp)\njle    1248 <func0+0x128>\nmov    -0x18(%rbp),%rax\nmov    -0x54(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x54(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x20,(%rax,%rcx,1)\nmovl   $0x0,-0x6c(%rbp)\nmov    -0x6c(%rbp),%eax\ncmp    -0x58(%rbp),%eax\njge    1286 <func0+0x166>\nmovslq -0x6c(%rbp),%rax\nmov    -0x50(%rbp,%rax,1),%dl\nmov    -0x18(%rbp),%rax\nmov    -0x54(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x54(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x6c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\njmp    124f <func0+0x12f>\nmovl   $0x0,-0x58(%rbp)\njmp    12ae <func0+0x18e>\nmov    -0x8(%rbp),%rax\nmovslq -0x5c(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmov    -0x58(%rbp),%eax\nmov    %eax,%edx\nadd    $0x1,%edx\nmov    %edx,-0x58(%rbp)\ncltq\nmov    %cl,-0x50(%rbp,%rax,1)\njmp    12b3 <func0+0x193>\nmov    -0x5c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x5c(%rbp)\njmp    115f <func0+0x3f>\nmov    -0x18(%rbp),%rax\nmovslq -0x54(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x18(%rbp),%rax\nadd    $0x70,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 86,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nmov    %rax,%rbp\nadd    $0x2,%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rbp,%r11\nmov    %rax,0x8(%rsp)\nxor    %r14d,%r14d\ntest   $0x80000000,%r11d\njne    125e <func0+0x12e>\nmov    %rbx,%r10\nadd    $0x1,%r11d\nxor    %r13d,%r13d\nxor    %r14d,%r14d\nxor    %r12d,%r12d\njmp    119e <func0+0x6e>\nxchg   %ax,%ax\nmovslq %r12d,%rcx\nadd    $0x1,%r12d\nmov    %al,0x10(%rsp,%rcx,1)\nmov    %r12d,%r15d\nadd    $0x1,%r13\nmov    %r15d,%r12d\ncmp    %r11,%r13\nje     125e <func0+0x12e>\nmov    (%r10,%r13,1),%al\ntest   $0xdf,%al\njne    1180 <func0+0x50>\ncmp    $0x2,%r12d\njl     1210 <func0+0xe0>\nlea    -0x1(%r12),%r8d\nmovslq %r12d,%r9\nmov    %r12d,%edx\nadd    $0xffffffffffffffff,%rdx\nlea    0x11(%rsp),%rsi\nxor    %ebx,%ebx\njmp    11dd <func0+0xad>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nadd    $0x1,%rsi\nadd    $0xffffffffffffffff,%rdx\ncmp    %r8,%rbx\nje     1210 <func0+0xe0>\nmov    %rbx,%rdi\nadd    $0x1,%rbx\ncmp    %r9,%rbx\njge    11d0 <func0+0xa0>\nxor    %ebp,%ebp\njmp    11f9 <func0+0xc9>\nnopl   (%rax)\nadd    $0x1,%rbp\ncmp    %rbp,%rdx\nje     11d0 <func0+0xa0>\nmovzbl 0x10(%rsp,%rdi,1),%eax\nmovzbl (%rsi,%rbp,1),%ecx\ncmp    %cl,%al\njle    11f0 <func0+0xc0>\nmov    %cl,0x10(%rsp,%rdi,1)\nmov    %al,(%rsi,%rbp,1)\njmp    11f0 <func0+0xc0>\nnop\ntest   %r14d,%r14d\njle    1225 <func0+0xf5>\nmovslq %r14d,%rax\nadd    $0x1,%r14d\nmov    0x8(%rsp),%rcx\nmovb   $0x20,(%rcx,%rax,1)\nxor    %r15d,%r15d\ntest   %r12d,%r12d\njle    118e <func0+0x5e>\nmovslq %r14d,%r14\nmov    0x8(%rsp),%rax\nlea    (%rax,%r14,1),%rdi\nmov    %r12d,%edx\nlea    0x10(%rsp),%rsi\nmov    %r10,%rbx\nmov    %r11,%rbp\ncall   1040 <memcpy@plt>\nmov    %rbp,%r11\nmov    %rbx,%r10\nadd    %r12d,%r14d\njmp    118e <func0+0x5e>\nmovslq %r14d,%rcx\nmov    0x8(%rsp),%rax\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x48,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 86,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nmov    %rax,%rbp\nadd    $0x2,%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rbp,%r11\nmov    %rax,0x8(%rsp)\nxor    %r14d,%r14d\ntest   $0x80000000,%r11d\njne    125e <func0+0x12e>\nmov    %rbx,%r10\nadd    $0x1,%r11d\nxor    %r13d,%r13d\nxor    %r14d,%r14d\nxor    %r12d,%r12d\njmp    119e <func0+0x6e>\nxchg   %ax,%ax\nmovslq %r12d,%rcx\nadd    $0x1,%r12d\nmov    %al,0x10(%rsp,%rcx,1)\nmov    %r12d,%r15d\nadd    $0x1,%r13\nmov    %r15d,%r12d\ncmp    %r11,%r13\nje     125e <func0+0x12e>\nmov    (%r10,%r13,1),%al\ntest   $0xdf,%al\njne    1180 <func0+0x50>\ncmp    $0x2,%r12d\njl     1210 <func0+0xe0>\nlea    -0x1(%r12),%r8d\nmov    %r12d,%r9d\nlea    -0x1(%r9),%rdx\nlea    0x11(%rsp),%rsi\nxor    %ebx,%ebx\njmp    11dd <func0+0xad>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rsi\nadd    $0xffffffffffffffff,%rdx\ncmp    %r8,%rbx\nje     1210 <func0+0xe0>\nmov    %rbx,%rdi\nadd    $0x1,%rbx\ncmp    %r9,%rbx\njae    11d0 <func0+0xa0>\nxor    %ebp,%ebp\njmp    11f9 <func0+0xc9>\nnopl   (%rax)\nadd    $0x1,%rbp\ncmp    %rbp,%rdx\nje     11d0 <func0+0xa0>\nmovzbl 0x10(%rsp,%rdi,1),%eax\nmovzbl (%rsi,%rbp,1),%ecx\ncmp    %cl,%al\njle    11f0 <func0+0xc0>\nmov    %cl,0x10(%rsp,%rdi,1)\nmov    %al,(%rsi,%rbp,1)\njmp    11f0 <func0+0xc0>\nnop\ntest   %r14d,%r14d\njle    1225 <func0+0xf5>\nmov    %r14d,%eax\nadd    $0x1,%r14d\nmov    0x8(%rsp),%rcx\nmovb   $0x20,(%rcx,%rax,1)\nxor    %r15d,%r15d\ntest   %r12d,%r12d\njle    118e <func0+0x5e>\nmovslq %r14d,%r14\nmov    0x8(%rsp),%rax\nlea    (%rax,%r14,1),%rdi\nmov    %r12d,%edx\nlea    0x10(%rsp),%rsi\nmov    %r10,%rbx\nmov    %r11,%rbp\ncall   1040 <memcpy@plt>\nmov    %rbp,%r11\nmov    %rbx,%r10\nadd    %r12d,%r14d\njmp    118e <func0+0x5e>\nmovslq %r14d,%rcx\nmov    0x8(%rsp),%rax\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x48,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 86,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nmov    %rax,%rbp\nadd    $0x2,%eax\nmovslq %eax,%rdi\ncall   1050 <malloc@plt>\nmov    %rbp,%r11\nmov    %rax,0x8(%rsp)\nxor    %r14d,%r14d\ntest   $0x80000000,%r11d\njne    125e <func0+0x12e>\nmov    %rbx,%r10\nadd    $0x1,%r11d\nxor    %r13d,%r13d\nxor    %r14d,%r14d\nxor    %r12d,%r12d\njmp    119e <func0+0x6e>\nxchg   %ax,%ax\nmovslq %r12d,%rcx\nadd    $0x1,%r12d\nmov    %al,0x10(%rsp,%rcx,1)\nmov    %r12d,%r15d\nadd    $0x1,%r13\nmov    %r15d,%r12d\ncmp    %r11,%r13\nje     125e <func0+0x12e>\nmov    (%r10,%r13,1),%al\ntest   $0xdf,%al\njne    1180 <func0+0x50>\ncmp    $0x2,%r12d\njl     1210 <func0+0xe0>\nlea    -0x1(%r12),%r8d\nmov    %r12d,%r9d\nlea    -0x1(%r9),%rdx\nlea    0x11(%rsp),%rsi\nxor    %ebx,%ebx\njmp    11dd <func0+0xad>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rsi\nadd    $0xffffffffffffffff,%rdx\ncmp    %r8,%rbx\nje     1210 <func0+0xe0>\nmov    %rbx,%rdi\nadd    $0x1,%rbx\ncmp    %r9,%rbx\njae    11d0 <func0+0xa0>\nxor    %ebp,%ebp\njmp    11f9 <func0+0xc9>\nnopl   (%rax)\nadd    $0x1,%rbp\ncmp    %rbp,%rdx\nje     11d0 <func0+0xa0>\nmovzbl 0x10(%rsp,%rdi,1),%eax\nmovzbl (%rsi,%rbp,1),%ecx\ncmp    %cl,%al\njle    11f0 <func0+0xc0>\nmov    %cl,0x10(%rsp,%rdi,1)\nmov    %al,(%rsi,%rbp,1)\njmp    11f0 <func0+0xc0>\nnop\ntest   %r14d,%r14d\njle    1225 <func0+0xf5>\nmov    %r14d,%eax\nadd    $0x1,%r14d\nmov    0x8(%rsp),%rcx\nmovb   $0x20,(%rcx,%rax,1)\nxor    %r15d,%r15d\ntest   %r12d,%r12d\njle    118e <func0+0x5e>\nmovslq %r14d,%r14\nmov    0x8(%rsp),%rax\nlea    (%rax,%r14,1),%rdi\nmov    %r12d,%edx\nlea    0x10(%rsp),%rsi\nmov    %r10,%rbx\nmov    %r11,%rbp\ncall   1040 <memcpy@plt>\nmov    %rbp,%r11\nmov    %rbx,%r10\nadd    %r12d,%r14d\njmp    118e <func0+0x5e>\nmovslq %r14d,%rcx\nmov    0x8(%rsp),%rax\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x48,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 87,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %ecx,-0x1c(%rbp)\nmov    %r8,-0x28(%rbp)\nmov    $0x320,%edi\ncall   1030 <malloc@plt>\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11f4 <func0+0xe4>\nmov    -0x18(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nsub    $0x1,%eax\nmov    %eax,-0x3c(%rbp)\ncmpl   $0x0,-0x3c(%rbp)\njl     11e1 <func0+0xd1>\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x3c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x1c(%rbp),%eax\njne    11ce <func0+0xbe>\nmov    $0x8,%edi\ncall   1030 <malloc@plt>\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x38(%rbp),%ecx\nmov    -0x30(%rbp),%rax\nmovslq -0x34(%rbp),%rdx\nmov    (%rax,%rdx,8),%rax\nmov    %ecx,(%rax)\nmov    -0x3c(%rbp),%ecx\nmov    -0x30(%rbp),%rax\nmovslq -0x34(%rbp),%rdx\nmov    (%rax,%rdx,8),%rax\nmov    %ecx,0x4(%rax)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    11d3 <func0+0xc3>\nmov    -0x3c(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x3c(%rbp)\njmp    1163 <func0+0x53>\njmp    11e6 <func0+0xd6>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    1146 <func0+0x36>\nmov    -0x34(%rbp),%ecx\nmov    -0x28(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x30(%rbp),%rax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 87,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %r8,0x8(%rsp)\nmov    %ecx,%ebp\nmov    %rdx,0x20(%rsp)\nmov    %esi,%r13d\nmov    %rdi,0x10(%rsp)\nmov    $0x320,%edi\ncall   1030 <malloc@plt>\nmov    %rax,(%rsp)\ntest   %r13d,%r13d\njle    11c5 <func0+0xb5>\nmov    %r13d,%eax\nmov    %rax,0x18(%rsp)\nxor    %r12d,%r12d\nxor    %r14d,%r14d\njmp    116b <func0+0x5b>\nnopl   0x0(%rax)\nadd    $0x1,%r12\ncmp    0x18(%rsp),%r12\nje     11c8 <func0+0xb8>\nmov    0x20(%rsp),%rax\nmovslq (%rax,%r12,4),%rax\ntest   %rax,%rax\njle    1160 <func0+0x50>\nmov    0x10(%rsp),%rcx\nmov    (%rcx,%r12,8),%r15\nmov    %rax,%r13\nadd    $0x1,%r13\nlea    -0x1(%rax),%ebx\njmp    119d <func0+0x8d>\nxchg   %ax,%ax\nadd    $0xffffffffffffffff,%r13\nadd    $0xffffffff,%ebx\ncmp    $0x1,%r13\njle    1160 <func0+0x50>\ncmp    %ebp,-0x8(%r15,%r13,4)\njne    1190 <func0+0x80>\nmov    $0x8,%edi\ncall   1030 <malloc@plt>\nmovslq %r14d,%r14\nmov    (%rsp),%rcx\nmov    %rax,(%rcx,%r14,8)\nmov    %r12d,(%rax)\nmov    %ebx,0x4(%rax)\nadd    $0x1,%r14d\njmp    1190 <func0+0x80>\nxor    %r14d,%r14d\nmov    0x8(%rsp),%rax\nmov    %r14d,(%rax)\nmov    (%rsp),%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 87,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %r8,0x8(%rsp)\nmov    %ecx,%ebp\nmov    %rdx,0x20(%rsp)\nmov    %esi,%r13d\nmov    %rdi,0x10(%rsp)\nmov    $0x320,%edi\ncall   1030 <malloc@plt>\nmov    %rax,(%rsp)\ntest   %r13d,%r13d\njle    11cf <func0+0xbf>\nmov    %r13d,%eax\nmov    %rax,0x18(%rsp)\nxor    %r12d,%r12d\nxor    %r14d,%r14d\njmp    116b <func0+0x5b>\nnopl   0x0(%rax)\nadd    $0x1,%r12\ncmp    0x18(%rsp),%r12\nje     11d2 <func0+0xc2>\nmov    0x20(%rsp),%rax\nmov    (%rax,%r12,4),%r13d\ntest   %r13d,%r13d\njle    1160 <func0+0x50>\nmov    0x10(%rsp),%rax\nmov    (%rax,%r12,8),%r15\njmp    119d <func0+0x8d>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nlea    0x1(%rbx),%rax\nmov    %rbx,%r13\ncmp    $0x1,%rax\njbe    1160 <func0+0x50>\nlea    -0x1(%r13),%rbx\nmov    %ebx,%eax\ncmp    %ebp,(%r15,%rax,4)\njne    1190 <func0+0x80>\nadd    $0xffffffff,%r13d\nmov    $0x8,%edi\ncall   1030 <malloc@plt>\nmovslq %r14d,%r14\nmov    (%rsp),%rcx\nmov    %rax,(%rcx,%r14,8)\nmov    %r12d,(%rax)\nmov    %r13d,0x4(%rax)\nadd    $0x1,%r14d\njmp    1190 <func0+0x80>\nxor    %r14d,%r14d\nmov    0x8(%rsp),%rax\nmov    %r14d,(%rax)\nmov    (%rsp),%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 87,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %r8,0x8(%rsp)\nmov    %ecx,%ebp\nmov    %rdx,0x20(%rsp)\nmov    %esi,%r13d\nmov    %rdi,0x10(%rsp)\nmov    $0x320,%edi\ncall   1030 <malloc@plt>\nmov    %rax,(%rsp)\ntest   %r13d,%r13d\njle    11cf <func0+0xbf>\nmov    %r13d,%eax\nmov    %rax,0x18(%rsp)\nxor    %r12d,%r12d\nxor    %r14d,%r14d\njmp    116b <func0+0x5b>\nnopl   0x0(%rax)\nadd    $0x1,%r12\ncmp    0x18(%rsp),%r12\nje     11d2 <func0+0xc2>\nmov    0x20(%rsp),%rax\nmov    (%rax,%r12,4),%r13d\ntest   %r13d,%r13d\njle    1160 <func0+0x50>\nmov    0x10(%rsp),%rax\nmov    (%rax,%r12,8),%r15\njmp    119d <func0+0x8d>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nlea    0x1(%rbx),%rax\nmov    %rbx,%r13\ncmp    $0x1,%rax\njbe    1160 <func0+0x50>\nlea    -0x1(%r13),%rbx\nmov    %ebx,%eax\ncmp    %ebp,(%r15,%rax,4)\njne    1190 <func0+0x80>\nadd    $0xffffffff,%r13d\nmov    $0x8,%edi\ncall   1030 <malloc@plt>\nmovslq %r14d,%r14\nmov    (%rsp),%rcx\nmov    %rax,(%rcx,%r14,8)\nmov    %r12d,(%rax)\nmov    %r13d,0x4(%rax)\nadd    $0x1,%r14d\njmp    1190 <func0+0x80>\nxor    %r14d,%r14d\nmov    0x8(%rsp),%rax\nmov    %r14d,(%rax)\nmov    (%rsp),%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 88,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    -0xc(%rbp),%ecx\nmov    -0x20(%rbp),%rax\nmov    %ecx,(%rax)\ncmpl   $0x0,-0xc(%rbp)\njne    115a <func0+0x3a>\nmov    -0x18(%rbp),%rax\nmovq   $0x0,(%rax)\njmp    1316 <func0+0x1f6>\nmovslq -0xc(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,(%rax)\nmov    -0x18(%rbp),%rax\ncmpq   $0x0,(%rax)\njne    1189 <func0+0x69>\nmov    $0x1,%edi\ncall   1040 <exit@plt>\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11c3 <func0+0xa3>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x24(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1190 <func0+0x70>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%rcx\nmov    -0xc(%rbp),%edx\nsub    $0x1,%edx\nmovslq %edx,%rdx\nadd    (%rcx,%rdx,4),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\nsete   %al\nand    $0x1,%al\nmovzbl %al,%eax\nmov    %eax,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    -0xc(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    1316 <func0+0x1f6>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1303 <func0+0x1e3>\ncmpl   $0x0,-0x28(%rbp)\nje     128b <func0+0x16b>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x18(%rbp),%rcx\nmov    (%rcx),%rcx\nmovslq -0x30(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njle    1286 <func0+0x166>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x34(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x30(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    12f0 <func0+0x1d0>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x18(%rbp),%rcx\nmov    (%rcx),%rcx\nmovslq -0x30(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njge    12eb <func0+0x1cb>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x38(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x30(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    12f0 <func0+0x1d0>\njmp    12f5 <func0+0x1d5>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    1210 <func0+0xf0>\njmp    1308 <func0+0x1e8>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    11f6 <func0+0xd6>\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 88,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdx,%r14\nmov    %esi,(%rcx)\ntest   %esi,%esi\nje     1216 <func0+0xf6>\nmov    %esi,%r15d\nmov    %rdi,%rbx\nmovslq %esi,%r12\nlea    0x0(,%r12,4),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,(%r14)\ntest   %rax,%rax\nje     1226 <func0+0x106>\nmov    %r15d,%eax\ntest   %r15d,%r15d\njle    117f <func0+0x5f>\nmov    (%r14),%rcx\nxor    %edx,%edx\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    (%rbx,%rdx,4),%esi\nmov    %esi,(%rcx,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rax\njne    1170 <func0+0x50>\ncmp    $0x2,%r15d\njl     121d <func0+0xfd>\nadd    $0xffffffff,%r15d\nmov    -0x4(%rbx,%r12,4),%r10d\nadd    (%rbx),%r10d\nmov    %r10d,%ecx\nshr    $0x1f,%ecx\nadd    %r10d,%ecx\nand    $0xfffffffe,%ecx\nsub    %ecx,%r10d\nmov    %r15d,%r8d\nxor    %r9d,%r9d\njmp    11b9 <func0+0x99>\nnopl   0x0(%rax)\nadd    $0xffffffffffffffff,%rax\ncmp    %r8,%r9\nje     121d <func0+0xfd>\nmov    %r9,%rdi\nadd    $0x1,%r9\ncmp    %r12,%r9\njge    11b0 <func0+0x90>\nmov    (%r14),%rbx\nlea    (%rbx,%rdi,4),%rbp\nmov    $0x1,%edx\njmp    11f0 <func0+0xd0>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %ecx,(%rbx,%rdi,4)\nmov    %esi,0x0(%rbp,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rax\nje     11b0 <func0+0x90>\nmov    (%rbx,%rdi,4),%esi\nmov    0x0(%rbp,%rdx,4),%ecx\ncmp    $0x1,%r10d\njne    1210 <func0+0xf0>\ncmp    %ecx,%esi\njg     11e0 <func0+0xc0>\njmp    11e7 <func0+0xc7>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\ncmp    %ecx,%esi\njl     11e0 <func0+0xc0>\njmp    11e7 <func0+0xc7>\nmovq   $0x0,(%r14)\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\nmov    $0x1,%edi\ncall   1040 <exit@plt>\n"
    },
    {
        "task_id": 88,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdx,%r15\nmov    %esi,(%rcx)\ntest   %esi,%esi\nje     116c <func0+0x4c>\nmov    %esi,%r14d\nmov    %rdi,%rbx\nmovslq %esi,%r12\nlea    0x0(,%r12,4),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,(%r15)\ntest   %rax,%rax\nje     12f5 <func0+0x1d5>\nmov    %r14d,%r10d\ntest   %r14d,%r14d\njle    126f <func0+0x14f>\ncmp    $0x8,%r14d\njae    1178 <func0+0x58>\nxor    %edx,%edx\njmp    1260 <func0+0x140>\nmovq   $0x0,(%r15)\njmp    12ec <func0+0x1cc>\nmov    %r10d,%edx\nand    $0xfffffff8,%edx\nlea    -0x8(%rdx),%rcx\nmov    %rcx,%rdi\nshr    $0x3,%rdi\nadd    $0x1,%rdi\nmov    %edi,%r8d\nand    $0x3,%r8d\ncmp    $0x18,%rcx\njae    119e <func0+0x7e>\nxor    %ebp,%ebp\njmp    1208 <func0+0xe8>\nand    $0xfffffffffffffffc,%rdi\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovups (%rbx,%rbp,4),%xmm0\nmovups 0x10(%rbx,%rbp,4),%xmm1\nmovups %xmm0,(%rax,%rbp,4)\nmovups %xmm1,0x10(%rax,%rbp,4)\nmovups 0x20(%rbx,%rbp,4),%xmm0\nmovups 0x30(%rbx,%rbp,4),%xmm1\nmovups %xmm0,0x20(%rax,%rbp,4)\nmovups %xmm1,0x30(%rax,%rbp,4)\nmovups 0x40(%rbx,%rbp,4),%xmm0\nmovups 0x50(%rbx,%rbp,4),%xmm1\nmovups %xmm0,0x40(%rax,%rbp,4)\nmovups %xmm1,0x50(%rax,%rbp,4)\nmovups 0x60(%rbx,%rbp,4),%xmm0\nmovups 0x70(%rbx,%rbp,4),%xmm1\nmovups %xmm0,0x60(%rax,%rbp,4)\nmovups %xmm1,0x70(%rax,%rbp,4)\nadd    $0x20,%rbp\nadd    $0xfffffffffffffffc,%rdi\njne    11b0 <func0+0x90>\ntest   %r8,%r8\nje     124c <func0+0x12c>\nlea    (%rax,%rbp,4),%rdi\nadd    $0x10,%rdi\nlea    (%rbx,%rbp,4),%rbp\nadd    $0x10,%rbp\nshl    $0x5,%r8\nxor    %esi,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovups -0x10(%rbp,%rsi,1),%xmm0\nmovups 0x0(%rbp,%rsi,1),%xmm1\nmovups %xmm0,-0x10(%rdi,%rsi,1)\nmovups %xmm1,(%rdi,%rsi,1)\nadd    $0x20,%rsi\ncmp    %rsi,%r8\njne    1230 <func0+0x110>\ncmp    %r10,%rdx\nje     126f <func0+0x14f>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx,%rdx,4),%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%r10\njne    1260 <func0+0x140>\ncmp    $0x2,%r14d\njl     12ec <func0+0x1cc>\nadd    $0xffffffff,%r14d\nmov    -0x4(%rbx,%r12,4),%edx\nadd    (%rbx),%edx\nmov    %edx,%ecx\nshr    $0x1f,%ecx\nadd    %edx,%ecx\nand    $0xfffffffe,%ecx\nsub    %ecx,%edx\nmov    %r14d,%r8d\nxor    %r9d,%r9d\nmov    %rax,%rdi\njmp    12ad <func0+0x18d>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rdi\nadd    $0xffffffffffffffff,%r10\ncmp    %r8,%r9\nje     12ec <func0+0x1cc>\nmov    %r9,%rbx\nadd    $0x1,%r9\ncmp    %r12,%r9\njge    12a0 <func0+0x180>\nmov    $0x1,%esi\njmp    12cf <func0+0x1af>\nmov    %ecx,(%rax,%rbx,4)\nmov    %ebp,(%rdi,%rsi,4)\nadd    $0x1,%rsi\ncmp    %rsi,%r10\nje     12a0 <func0+0x180>\ncmp    $0x1,%edx\njne    12e0 <func0+0x1c0>\nmov    (%rax,%rbx,4),%ebp\nmov    (%rdi,%rsi,4),%ecx\ncmp    %ecx,%ebp\njg     12c0 <func0+0x1a0>\njmp    12c6 <func0+0x1a6>\nmov    (%rax,%rbx,4),%ebp\nmov    (%rdi,%rsi,4),%ecx\ncmp    %ecx,%ebp\njl     12c0 <func0+0x1a0>\njmp    12c6 <func0+0x1a6>\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\nmov    $0x1,%edi\ncall   1040 <exit@plt>\n"
    },
    {
        "task_id": 88,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdx,%rbp\nmov    %esi,(%rcx)\ntest   %esi,%esi\nje     116c <func0+0x4c>\nmov    %esi,%r14d\nmov    %rdi,%rbx\nmovslq %esi,%r15\nlea    0x0(,%r15,4),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,0x0(%rbp)\ntest   %rax,%rax\nje     1336 <func0+0x216>\ntest   %r14d,%r14d\njle    132b <func0+0x20b>\nmov    %r14d,%ecx\ncmp    $0x8,%r14d\njae    1179 <func0+0x59>\nxor    %edx,%edx\njmp    1260 <func0+0x140>\nmovq   $0x0,0x0(%rbp)\njmp    132b <func0+0x20b>\nmov    %ecx,%edx\nand    $0xfffffff8,%edx\nlea    -0x8(%rdx),%rsi\nmov    %rsi,%rdi\nshr    $0x3,%rdi\nadd    $0x1,%rdi\nmov    %edi,%r8d\nand    $0x3,%r8d\ncmp    $0x18,%rsi\njae    119e <func0+0x7e>\nxor    %ebp,%ebp\njmp    1208 <func0+0xe8>\nand    $0xfffffffffffffffc,%rdi\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovups (%rbx,%rbp,4),%xmm0\nmovups 0x10(%rbx,%rbp,4),%xmm1\nmovups %xmm0,(%rax,%rbp,4)\nmovups %xmm1,0x10(%rax,%rbp,4)\nmovups 0x20(%rbx,%rbp,4),%xmm0\nmovups 0x30(%rbx,%rbp,4),%xmm1\nmovups %xmm0,0x20(%rax,%rbp,4)\nmovups %xmm1,0x30(%rax,%rbp,4)\nmovups 0x40(%rbx,%rbp,4),%xmm0\nmovups 0x50(%rbx,%rbp,4),%xmm1\nmovups %xmm0,0x40(%rax,%rbp,4)\nmovups %xmm1,0x50(%rax,%rbp,4)\nmovups 0x60(%rbx,%rbp,4),%xmm0\nmovups 0x70(%rbx,%rbp,4),%xmm1\nmovups %xmm0,0x60(%rax,%rbp,4)\nmovups %xmm1,0x70(%rax,%rbp,4)\nadd    $0x20,%rbp\nadd    $0xfffffffffffffffc,%rdi\njne    11b0 <func0+0x90>\ntest   %r8,%r8\nje     124c <func0+0x12c>\nlea    (%rax,%rbp,4),%rdi\nadd    $0x10,%rdi\nlea    (%rbx,%rbp,4),%rbp\nadd    $0x10,%rbp\nshl    $0x5,%r8\nxor    %esi,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovups -0x10(%rbp,%rsi,1),%xmm0\nmovups 0x0(%rbp,%rsi,1),%xmm1\nmovups %xmm0,-0x10(%rdi,%rsi,1)\nmovups %xmm1,(%rdi,%rsi,1)\nadd    $0x20,%rsi\ncmp    %rsi,%r8\njne    1230 <func0+0x110>\ncmp    %rcx,%rdx\nje     126f <func0+0x14f>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx,%rdx,4),%esi\nmov    %esi,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    1260 <func0+0x140>\ncmp    $0x2,%r14d\njl     132b <func0+0x20b>\nadd    $0xffffffff,%r14d\nmov    %r14d,%r8d\nmov    (%rbx,%r8,4),%edx\nadd    (%rbx),%edx\nmov    %edx,%esi\nshr    $0x1f,%esi\nadd    %edx,%esi\nand    $0xfffffffe,%esi\nsub    %esi,%edx\ncmp    $0x1,%edx\njne    12db <func0+0x1bb>\nxor    %edi,%edi\nmov    %rax,%rsi\njmp    12b0 <func0+0x190>\nxchg   %ax,%ax\nadd    $0x4,%rsi\nadd    $0xffffffffffffffff,%rcx\nmov    %r9,%rdi\ncmp    %r8,%r9\nje     132b <func0+0x20b>\nlea    0x1(%rdi),%r9\ncmp    %r15,%r9\njge    12a0 <func0+0x180>\nmov    $0x1,%ebx\njmp    12c9 <func0+0x1a9>\nadd    $0x1,%rbx\ncmp    %rbx,%rcx\nje     12a0 <func0+0x180>\nmov    (%rax,%rdi,4),%edx\nmov    (%rsi,%rbx,4),%ebp\ncmp    %ebp,%edx\njle    12c0 <func0+0x1a0>\nmov    %ebp,(%rax,%rdi,4)\nmov    %edx,(%rsi,%rbx,4)\njmp    12c0 <func0+0x1a0>\nxor    %r9d,%r9d\nmov    %rax,%rsi\njmp    12fd <func0+0x1dd>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x4,%rsi\nadd    $0xffffffffffffffff,%rcx\ncmp    %r8,%r9\nje     132b <func0+0x20b>\nmov    %r9,%rdi\nadd    $0x1,%r9\ncmp    %r15,%r9\njge    12f0 <func0+0x1d0>\nmov    $0x1,%ebx\njmp    1319 <func0+0x1f9>\nadd    $0x1,%rbx\ncmp    %rbx,%rcx\nje     12f0 <func0+0x1d0>\nmov    (%rax,%rdi,4),%edx\nmov    (%rsi,%rbx,4),%ebp\ncmp    %ebp,%edx\njge    1310 <func0+0x1f0>\nmov    %ebp,(%rax,%rdi,4)\nmov    %edx,(%rsi,%rbx,4)\njmp    1310 <func0+0x1f0>\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\nmov    $0x1,%edi\ncall   1040 <exit@plt>\n"
    },
    {
        "task_id": 89,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1166 <func0+0x66>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nsub    $0x61,%eax\nadd    $0x4,%eax\nmov    $0x1a,%ecx\ncltd\nidiv   %ecx\nadd    $0x61,%edx\nmov    %edx,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %al,%dl\nmov    -0x10(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1113 <func0+0x13>\nmov    -0x10(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\npop    %rbp\nret\n"
    },
    {
        "task_id": 89,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    (%rdi),%cl\ntest   %cl,%cl\nje     1154 <func0+0x54>\nxor    %r8d,%r8d\nnopl   0x0(%rax)\nmovsbl %cl,%ecx\nadd    $0xffffffa3,%ecx\nmovslq %ecx,%rcx\nimul   $0x4ec4ec4f,%rcx,%rdx\nmov    %rdx,%rax\nshr    $0x3f,%rax\nsar    $0x23,%rdx\nadd    %eax,%edx\nlea    (%rdx,%rdx,4),%eax\nlea    (%rax,%rax,4),%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nadd    $0x61,%cl\nmov    %cl,(%rsi,%r8,1)\nmovzbl 0x1(%rdi,%r8,1),%ecx\nadd    $0x1,%r8\ntest   %cl,%cl\njne    1110 <func0+0x10>\nmov    %r8d,%eax\nmovb   $0x0,(%rsi,%rax,1)\nret\nxor    %eax,%eax\nmovb   $0x0,(%rsi,%rax,1)\nret\n"
    },
    {
        "task_id": 89,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    (%rdi),%cl\ntest   %cl,%cl\nje     114d <func0+0x4d>\nxor    %r8d,%r8d\nnopl   0x0(%rax)\nmovsbl %cl,%ecx\nadd    $0xffffffa3,%ecx\nimul   $0x4ec5,%ecx,%edx\nmov    %edx,%eax\nshr    $0x1f,%eax\nshr    $0x13,%edx\nadd    %eax,%edx\nlea    (%rdx,%rdx,4),%eax\nlea    (%rax,%rax,4),%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nadd    $0x61,%cl\nmov    %cl,(%rsi,%r8,1)\nmovzbl 0x1(%rdi,%r8,1),%ecx\nadd    $0x1,%r8\ntest   %cl,%cl\njne    1110 <func0+0x10>\nmov    %r8d,%eax\nmovb   $0x0,(%rsi,%rax,1)\nret\nxor    %eax,%eax\nmovb   $0x0,(%rsi,%rax,1)\nret\n"
    },
    {
        "task_id": 89,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    (%rdi),%cl\ntest   %cl,%cl\nje     114d <func0+0x4d>\nxor    %r8d,%r8d\nnopl   0x0(%rax)\nmovsbl %cl,%ecx\nadd    $0xffffffa3,%ecx\nimul   $0x4ec5,%ecx,%edx\nmov    %edx,%eax\nshr    $0x1f,%eax\nshr    $0x13,%edx\nadd    %eax,%edx\nlea    (%rdx,%rdx,4),%eax\nlea    (%rax,%rax,4),%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nadd    $0x61,%cl\nmov    %cl,(%rsi,%r8,1)\nmovzbl 0x1(%rdi,%r8,1),%ecx\nadd    $0x1,%r8\ntest   %cl,%cl\njne    1110 <func0+0x10>\nmov    %r8d,%eax\nmovb   $0x0,(%rsi,%rax,1)\nret\nxor    %eax,%eax\nmovb   $0x0,(%rsi,%rax,1)\nret\n"
    },
    {
        "task_id": 90,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\ncmpl   $0x2,-0x14(%rbp)\njge    1121 <func0+0x21>\nmovl   $0xffffffff,-0x4(%rbp)\njmp    11dc <func0+0xdc>\nmovl   $0x7fffffff,-0x18(%rbp)\nmovl   $0x7fffffff,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11bd <func0+0xbd>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x18(%rbp),%eax\njge    116f <func0+0x6f>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x18(%rbp)\njmp    11aa <func0+0xaa>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x1c(%rbp),%eax\njge    11a5 <func0+0xa5>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x18(%rbp),%eax\nje     11a5 <func0+0xa5>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x1c(%rbp)\njmp    11aa <func0+0xaa>\njmp    11af <func0+0xaf>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1136 <func0+0x36>\ncmpl   $0x7fffffff,-0x1c(%rbp)\njne    11d6 <func0+0xd6>\nmovl   $0xffffffff,-0x4(%rbp)\njmp    11dc <func0+0xdc>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 90,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncmp    $0x2,%esi\njl     1153 <func0+0x53>\nmov    %esi,%r8d\nmov    $0x7fffffff,%ecx\nxor    %edx,%edx\nmov    $0x7fffffff,%eax\nnopl   0x0(%rax)\nmov    (%rdi,%rdx,4),%esi\ncmp    %eax,%esi\nmov    %esi,%r9d\ncmove  %ecx,%r9d\ncmp    %ecx,%esi\ncmovl  %r9d,%ecx\ncmp    %eax,%esi\ncmovge %eax,%esi\ncmovl  %eax,%ecx\nadd    $0x1,%rdx\nmov    %esi,%eax\ncmp    %rdx,%r8\njne    1120 <func0+0x20>\ncmp    $0x7fffffff,%ecx\nmov    $0xffffffff,%eax\ncmovne %ecx,%eax\nret\n"
    },
    {
        "task_id": 90,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncmp    $0x2,%esi\njl     1195 <func0+0x95>\nmov    %esi,%r8d\nlea    0x0(,%r8,4),%r9\nand    $0xfffffffffffffff8,%r9\nmov    $0x7fffffff,%ecx\nxor    %r10d,%r10d\nmov    $0x7fffffff,%eax\nnopw   0x0(%rax,%rax,1)\nmov    (%rdi,%r10,1),%edx\ncmp    %eax,%edx\nmov    %edx,%esi\ncmove  %ecx,%esi\ncmp    %ecx,%edx\ncmovge %ecx,%esi\ncmp    %eax,%edx\ncmovge %eax,%edx\ncmovl  %eax,%esi\nmov    0x4(%rdi,%r10,1),%eax\ncmp    %edx,%eax\nmov    %eax,%ecx\ncmove  %esi,%ecx\ncmp    %esi,%eax\ncmovge %esi,%ecx\ncmp    %edx,%eax\ncmovge %edx,%eax\ncmovl  %edx,%ecx\nadd    $0x8,%r10\ncmp    %r10,%r9\njne    1130 <func0+0x30>\ntest   $0x1,%r8b\nje     1187 <func0+0x87>\nmov    (%rdi,%r10,1),%edx\ncmp    %eax,%edx\nmov    %edx,%esi\ncmove  %ecx,%esi\ncmp    %ecx,%edx\ncmovge %ecx,%esi\ncmp    %eax,%edx\ncmovl  %eax,%esi\nmov    %esi,%ecx\ncmp    $0x7fffffff,%ecx\nmov    $0xffffffff,%eax\ncmovne %ecx,%eax\nret\n"
    },
    {
        "task_id": 90,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncmp    $0x2,%esi\njl     1195 <func0+0x95>\nmov    %esi,%r8d\nlea    0x0(,%r8,4),%r9\nand    $0xfffffffffffffff8,%r9\nmov    $0x7fffffff,%ecx\nxor    %r10d,%r10d\nmov    $0x7fffffff,%eax\nnopw   0x0(%rax,%rax,1)\nmov    (%rdi,%r10,1),%edx\ncmp    %eax,%edx\nmov    %edx,%esi\ncmove  %ecx,%esi\ncmp    %ecx,%edx\ncmovge %ecx,%esi\ncmp    %eax,%edx\ncmovge %eax,%edx\ncmovl  %eax,%esi\nmov    0x4(%rdi,%r10,1),%eax\ncmp    %edx,%eax\nmov    %eax,%ecx\ncmove  %esi,%ecx\ncmp    %esi,%eax\ncmovge %esi,%ecx\ncmp    %edx,%eax\ncmovge %edx,%eax\ncmovl  %edx,%ecx\nadd    $0x8,%r10\ncmp    %r10,%r9\njne    1130 <func0+0x30>\ntest   $0x1,%r8b\nje     1187 <func0+0x87>\nmov    (%rdi,%r10,1),%edx\ncmp    %eax,%edx\nmov    %edx,%esi\ncmove  %ecx,%esi\ncmp    %ecx,%edx\ncmovge %ecx,%esi\ncmp    %eax,%edx\ncmovl  %eax,%esi\nmov    %esi,%ecx\ncmp    $0x7fffffff,%ecx\nmov    $0xffffffff,%eax\ncmovne %ecx,%eax\nret\n"
    },
    {
        "task_id": 91,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1279 <func0+0x169>\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x18(%rbp),%rdx\nmovsbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x2000,%eax\ncmp    $0x0,%eax\nje     1190 <func0+0x80>\ncmpl   $0x0,-0x10(%rbp)\nje     1190 <func0+0x80>\nmovl   $0x0,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x49,%eax\njne    11bb <func0+0xab>\ncmpl   $0x0,-0xc(%rbp)\nje     11bb <func0+0xab>\nmovl   $0x1,-0x10(%rbp)\njmp    11f0 <func0+0xe0>\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x18(%rbp),%rdx\nmovsbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x2000,%eax\ncmp    $0x0,%eax\njne    11eb <func0+0xdb>\nmovl   $0x0,-0x10(%rbp)\njmp    11f0 <func0+0xe0>\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x18(%rbp),%rdx\nmovsbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x2000,%eax\ncmp    $0x0,%eax\njne    1220 <func0+0x110>\nmovl   $0x0,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x2e,%eax\nje     125f <func0+0x14f>\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x3f,%eax\nje     125f <func0+0x14f>\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x21,%eax\njne    1266 <func0+0x156>\nmovl   $0x1,-0xc(%rbp)\njmp    126b <func0+0x15b>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1138 <func0+0x28>\nmov    -0x14(%rbp),%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 91,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    (%rdi),%bl\ntest   %bl,%bl\nje     11b3 <func0+0xa3>\nmov    %rdi,%r14\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%r11\nadd    $0x1,%r14\nmov    $0x1,%r9d\nxor    %r10d,%r10d\nmovabs $0x8000400200000000,%r8\nxor    %eax,%eax\nxor    %edi,%edi\nmov    $0x1,%ebp\njmp    1161 <func0+0x51>\nxchg   %ax,%ax\nmovzbl %cl,%ecx\nadd    %ecx,%eax\nmovzbl (%r14),%ebx\nadd    $0x1,%r14\ntest   %bl,%bl\nje     11b5 <func0+0xa5>\nmov    %ebp,%r15d\nmovsbq %bl,%rsi\nmovzwl (%r11,%rsi,2),%edx\nmov    %edx,%ebp\nand    $0x2000,%ebp\nshr    $0xd,%edx\ntest   %edi,%edi\nsetne  %cl\ncmovne %r10d,%edi\nand    %dl,%cl\ntest   %ebp,%ebp\nmov    %edi,%edx\ncmove  %ebp,%edx\ncmovne %r15d,%ebp\ntest   %r15d,%r15d\nmov    %edx,%edi\ncmovne %r9d,%edi\ncmp    $0x49,%sil\ncmovne %edx,%edi\ncmp    $0x3f,%bl\nja     1150 <func0+0x40>\nmovzbl %bl,%edx\nbt     %rdx,%r8\njae    1150 <func0+0x40>\nmov    $0x1,%ebp\njmp    1150 <func0+0x40>\nxor    %eax,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 91,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    (%rdi),%bl\ntest   %bl,%bl\nje     11af <func0+0x9f>\nmov    %rdi,%r14\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%r9\nadd    $0x1,%r14\nmov    $0x1,%edx\nxor    %eax,%eax\nmovabs $0x8000400200000000,%r8\nxor    %r10d,%r10d\njmp    116a <func0+0x5a>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    $0x1,%r10d\nmovzbl %r11b,%edx\nadd    %edx,%eax\nmovzbl (%r14),%ebx\nadd    $0x1,%r14\nmov    %ecx,%edx\ntest   %bl,%bl\nje     11b1 <func0+0xa1>\nmovsbq %bl,%rdi\nmovzwl (%r9,%rdi,2),%esi\nmov    %esi,%ecx\nand    $0x2000,%ecx\nshr    $0xd,%esi\ntest   %r10d,%r10d\nsetne  %r11b\nand    %sil,%r11b\ntest   %ecx,%ecx\ncmovne %edx,%ecx\ncmp    $0x49,%dil\njne    1197 <func0+0x87>\ntest   %edx,%edx\njne    1150 <func0+0x40>\nxor    %r10d,%r10d\ncmp    $0x3f,%bl\nja     1156 <func0+0x46>\nmovzbl %bl,%edx\nbt     %rdx,%r8\njae    1156 <func0+0x46>\nmov    $0x1,%ecx\njmp    1156 <func0+0x46>\nxor    %eax,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 91,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    (%rdi),%bl\ntest   %bl,%bl\nje     11af <func0+0x9f>\nmov    %rdi,%r14\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%r9\nadd    $0x1,%r14\nmov    $0x1,%edx\nxor    %eax,%eax\nmovabs $0x8000400200000000,%r8\nxor    %r10d,%r10d\njmp    116a <func0+0x5a>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    $0x1,%r10d\nmovzbl %r11b,%edx\nadd    %edx,%eax\nmovzbl (%r14),%ebx\nadd    $0x1,%r14\nmov    %ecx,%edx\ntest   %bl,%bl\nje     11b1 <func0+0xa1>\nmovsbq %bl,%rdi\nmovzwl (%r9,%rdi,2),%esi\nmov    %esi,%ecx\nand    $0x2000,%ecx\nshr    $0xd,%esi\ntest   %r10d,%r10d\nsetne  %r11b\nand    %sil,%r11b\ntest   %ecx,%ecx\ncmovne %edx,%ecx\ncmp    $0x49,%dil\njne    1197 <func0+0x87>\ntest   %edx,%edx\njne    1150 <func0+0x40>\nxor    %r10d,%r10d\ncmp    $0x3f,%bl\nja     1156 <func0+0x46>\nmovzbl %bl,%edx\nbt     %rdx,%r8\njae    1156 <func0+0x46>\nmov    $0x1,%ecx\njmp    1156 <func0+0x46>\nxor    %eax,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 92,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovss  %xmm0,-0x8(%rbp)\nmovss  %xmm1,-0xc(%rbp)\nmovss  %xmm2,-0x10(%rbp)\nmovss  -0x8(%rbp),%xmm0\ncall   1030 <roundf@plt>\nucomiss -0x8(%rbp),%xmm0\njne    1146 <func0+0x36>\njp     1146 <func0+0x36>\njmp    1152 <func0+0x42>\nmovl   $0x0,-0x4(%rbp)\njmp    1213 <func0+0x103>\nmovss  -0xc(%rbp),%xmm0\ncall   1030 <roundf@plt>\nucomiss -0xc(%rbp),%xmm0\njne    1171 <func0+0x61>\njp     1171 <func0+0x61>\njmp    117d <func0+0x6d>\nmovl   $0x0,-0x4(%rbp)\njmp    1213 <func0+0x103>\nmovss  -0x10(%rbp),%xmm0\ncall   1030 <roundf@plt>\nucomiss -0x10(%rbp),%xmm0\njne    119c <func0+0x8c>\njp     119c <func0+0x8c>\njmp    11a8 <func0+0x98>\nmovl   $0x0,-0x4(%rbp)\njmp    1213 <func0+0x103>\nmovss  -0x8(%rbp),%xmm0\naddss  -0xc(%rbp),%xmm0\nucomiss -0x10(%rbp),%xmm0\njne    11c7 <func0+0xb7>\njp     11c7 <func0+0xb7>\njmp    1200 <func0+0xf0>\nmovss  -0x8(%rbp),%xmm0\naddss  -0x10(%rbp),%xmm0\nucomiss -0xc(%rbp),%xmm0\njne    11e6 <func0+0xd6>\njp     11e6 <func0+0xd6>\njmp    1200 <func0+0xf0>\nmovss  -0xc(%rbp),%xmm0\naddss  -0x10(%rbp),%xmm0\nucomiss -0x8(%rbp),%xmm0\njne    120c <func0+0xfc>\njp     120c <func0+0xfc>\nmovl   $0x1,-0x4(%rbp)\njmp    1213 <func0+0x103>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x10,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 92,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nsub    $0x18,%rsp\nmovss  %xmm2,0x4(%rsp)\nmovss  %xmm1,0x8(%rsp)\nmovss  %xmm0,0x10(%rsp)\ncall   1030 <roundf@plt>\nmovss  %xmm0,0x14(%rsp)\nmovss  0x8(%rsp),%xmm0\ncall   1030 <roundf@plt>\nmovss  %xmm0,0xc(%rsp)\nmovss  0x4(%rsp),%xmm0\ncall   1030 <roundf@plt>\nmovss  0x10(%rsp),%xmm3\nxor    %eax,%eax\nmovss  0x14(%rsp),%xmm1\nucomiss %xmm3,%xmm1\njne    11bc <func0+0xac>\njp     11bc <func0+0xac>\nmovss  0x8(%rsp),%xmm1\nmovss  0xc(%rsp),%xmm2\nucomiss %xmm1,%xmm2\njne    11bc <func0+0xac>\njp     11bc <func0+0xac>\nmovss  0x4(%rsp),%xmm2\nucomiss %xmm2,%xmm0\njne    11bc <func0+0xac>\njp     11bc <func0+0xac>\nmovaps %xmm3,%xmm0\naddss  %xmm1,%xmm0\nucomiss %xmm2,%xmm0\nsetnp  %al\nsete   %cl\nand    %al,%cl\nmovaps %xmm3,%xmm0\naddss  %xmm2,%xmm0\nucomiss %xmm1,%xmm0\nsetnp  %al\nsete   %dl\nand    %al,%dl\nor     %cl,%dl\naddss  %xmm2,%xmm1\nucomiss %xmm3,%xmm1\nsetnp  %al\nsete   %cl\nand    %al,%cl\nor     %dl,%cl\nmovzbl %cl,%eax\nadd    $0x18,%rsp\nret\n"
    },
    {
        "task_id": 92,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nsub    $0x18,%rsp\nmovss  %xmm2,0x4(%rsp)\nmovss  %xmm1,0x8(%rsp)\nmovss  %xmm0,0x10(%rsp)\ncall   1030 <roundf@plt>\nmovss  %xmm0,0x14(%rsp)\nmovss  0x8(%rsp),%xmm0\ncall   1030 <roundf@plt>\nmovss  %xmm0,0xc(%rsp)\nmovss  0x4(%rsp),%xmm0\ncall   1030 <roundf@plt>\nmovss  0x10(%rsp),%xmm3\nxor    %eax,%eax\nmovss  0x14(%rsp),%xmm1\nucomiss %xmm3,%xmm1\njne    11bc <func0+0xac>\njp     11bc <func0+0xac>\nmovss  0x8(%rsp),%xmm1\nmovss  0xc(%rsp),%xmm2\nucomiss %xmm1,%xmm2\njne    11bc <func0+0xac>\njp     11bc <func0+0xac>\nmovss  0x4(%rsp),%xmm2\nucomiss %xmm2,%xmm0\njne    11bc <func0+0xac>\njp     11bc <func0+0xac>\nmovaps %xmm3,%xmm0\naddss  %xmm1,%xmm0\nucomiss %xmm2,%xmm0\nsetnp  %al\nsete   %cl\nand    %al,%cl\nmovaps %xmm3,%xmm0\naddss  %xmm2,%xmm0\nucomiss %xmm1,%xmm0\nsetnp  %al\nsete   %dl\nand    %al,%dl\nor     %cl,%dl\naddss  %xmm2,%xmm1\nucomiss %xmm3,%xmm1\nsetnp  %al\nsete   %cl\nand    %al,%cl\nor     %dl,%cl\nmovzbl %cl,%eax\nadd    $0x18,%rsp\nret\n"
    },
    {
        "task_id": 92,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nsub    $0x18,%rsp\nmovss  %xmm2,0x4(%rsp)\nmovss  %xmm1,0x8(%rsp)\nmovss  %xmm0,0x10(%rsp)\ncall   1030 <roundf@plt>\nmovss  %xmm0,0x14(%rsp)\nmovss  0x8(%rsp),%xmm0\ncall   1030 <roundf@plt>\nmovss  %xmm0,0xc(%rsp)\nmovss  0x4(%rsp),%xmm0\ncall   1030 <roundf@plt>\nmovss  0x10(%rsp),%xmm3\nxor    %eax,%eax\nmovss  0x14(%rsp),%xmm1\nucomiss %xmm3,%xmm1\njne    11bc <func0+0xac>\njp     11bc <func0+0xac>\nmovss  0x8(%rsp),%xmm1\nmovss  0xc(%rsp),%xmm2\nucomiss %xmm1,%xmm2\njne    11bc <func0+0xac>\njp     11bc <func0+0xac>\nmovss  0x4(%rsp),%xmm2\nucomiss %xmm2,%xmm0\njne    11bc <func0+0xac>\njp     11bc <func0+0xac>\nmovaps %xmm3,%xmm0\naddss  %xmm1,%xmm0\nucomiss %xmm2,%xmm0\nsetnp  %al\nsete   %cl\nand    %al,%cl\nmovaps %xmm3,%xmm0\naddss  %xmm2,%xmm0\nucomiss %xmm1,%xmm0\nsetnp  %al\nsete   %dl\nand    %al,%dl\nor     %cl,%dl\naddss  %xmm2,%xmm1\nucomiss %xmm3,%xmm1\nsetnp  %al\nsete   %cl\nand    %al,%cl\nor     %dl,%cl\nmovzbl %cl,%eax\nadd    $0x18,%rsp\nret\n"
    },
    {
        "task_id": 93,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    0xeb9(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1255 <func0+0x125>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x21(%rbp)\ncall   1050 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmovsbl -0x21(%rbp),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x200,%eax\ncmp    $0x0,%eax\nje     11a7 <func0+0x77>\nmovsbl -0x21(%rbp),%edi\ncall   1030 <toupper@plt>\nmov    %al,-0x21(%rbp)\njmp    11d9 <func0+0xa9>\ncall   1050 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmovsbl -0x21(%rbp),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x100,%eax\ncmp    $0x0,%eax\nje     11d4 <func0+0xa4>\nmovsbl -0x21(%rbp),%edi\ncall   1040 <tolower@plt>\nmov    %al,-0x21(%rbp)\njmp    11d9 <func0+0xa9>\nmovl   $0x0,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1239 <func0+0x109>\nmovsbl -0x21(%rbp),%eax\nmov    -0x18(%rbp),%rcx\nmovslq -0x20(%rbp),%rdx\nmovsbl (%rcx,%rdx,1),%ecx\ncmp    %ecx,%eax\njne    1226 <func0+0xf6>\ncmpl   $0xa,-0x20(%rbp)\njge    1221 <func0+0xf1>\nmovsbl -0x21(%rbp),%eax\nadd    $0x2,%eax\nmov    %al,-0x21(%rbp)\njmp    1239 <func0+0x109>\njmp    122b <func0+0xfb>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    11e0 <func0+0xb0>\nmov    -0x21(%rbp),%dl\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1152 <func0+0x22>\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 93,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,(%rsp)\nmov    (%rdi),%bpl\ntest   %bpl,%bpl\nje     11e7 <func0+0xb7>\nmov    %rdi,%r15\nxor    %r13d,%r13d\ncall   1050 <__ctype_b_loc@plt>\nmov    %rax,%r12\nlea    0xea0(%rip),%rbx\njmp    1196 <func0+0x66>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nlea    0x2(%rbp),%ecx\ncmp    $0xa,%eax\nmovzbl %bpl,%eax\nmovzbl %cl,%ebp\ncmovae %eax,%ebp\nmov    (%rsp),%rax\nmov    %bpl,(%rax,%r13,1)\nmov    0x1(%r15,%r13,1),%bpl\nadd    $0x1,%r13\ntest   %bpl,%bpl\nje     11e2 <func0+0xb2>\nmov    (%r12),%rax\nmovsbq %bpl,%r14\nmovzwl (%rax,%r14,2),%eax\ntest   $0x200,%eax\njne    11c0 <func0+0x90>\ntest   $0x100,%eax\nje     11cc <func0+0x9c>\ncall   1040 <__ctype_tolower_loc@plt>\njmp    11c5 <func0+0x95>\nnopl   0x0(%rax,%rax,1)\ncall   1030 <__ctype_toupper_loc@plt>\nmov    (%rax),%rax\nmov    (%rax,%r14,4),%bpl\nxor    %eax,%eax\nxchg   %ax,%ax\ncmp    (%rax,%rbx,1),%bpl\nje     1170 <func0+0x40>\nadd    $0x1,%rax\ncmp    $0xa,%rax\njne    11d0 <func0+0xa0>\njmp    1180 <func0+0x50>\nmov    %r13d,%eax\njmp    11e9 <func0+0xb9>\nxor    %eax,%eax\nmov    (%rsp),%rcx\nmovb   $0x0,(%rcx,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 93,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    (%rdi),%bpl\ntest   %bpl,%bpl\nje     11d2 <func0+0xa2>\nmov    %rdi,%r15\nxor    %ebx,%ebx\ncall   1050 <__ctype_b_loc@plt>\nmov    %rax,%r12\nnopw   0x0(%rax,%rax,1)\nmov    (%r12),%rax\nmovsbq %bpl,%r13\nmovzwl (%rax,%r13,2),%eax\ntest   $0x200,%eax\njne    1190 <func0+0x60>\ntest   $0x100,%eax\nje     119d <func0+0x6d>\ncall   1040 <__ctype_tolower_loc@plt>\njmp    1195 <func0+0x65>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ncall   1030 <__ctype_toupper_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r13,4),%ebp\nlea    -0x41(%rbp),%eax\ncmp    $0x34,%al\nja     11bb <func0+0x8b>\nmovzbl %al,%eax\nmovabs $0x10411100104111,%rcx\nbt     %rax,%rcx\njae    11bb <func0+0x8b>\nadd    $0x2,%bpl\nmov    %bpl,(%r14,%rbx,1)\nmovzbl 0x1(%r15,%rbx,1),%ebp\nadd    $0x1,%rbx\ntest   %bpl,%bpl\njne    1160 <func0+0x30>\nmov    %ebx,%eax\njmp    11d4 <func0+0xa4>\nxor    %eax,%eax\nmovb   $0x0,(%r14,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 93,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    (%rdi),%bpl\ntest   %bpl,%bpl\nje     11d2 <func0+0xa2>\nmov    %rdi,%r15\nxor    %ebx,%ebx\ncall   1050 <__ctype_b_loc@plt>\nmov    %rax,%r12\nnopw   0x0(%rax,%rax,1)\nmov    (%r12),%rax\nmovsbq %bpl,%r13\nmovzwl (%rax,%r13,2),%eax\ntest   $0x200,%eax\njne    1190 <func0+0x60>\ntest   $0x100,%eax\nje     119d <func0+0x6d>\ncall   1040 <__ctype_tolower_loc@plt>\njmp    1195 <func0+0x65>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ncall   1030 <__ctype_toupper_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r13,4),%ebp\nlea    -0x41(%rbp),%eax\ncmp    $0x34,%al\nja     11bb <func0+0x8b>\nmovzbl %al,%eax\nmovabs $0x10411100104111,%rcx\nbt     %rax,%rcx\njae    11bb <func0+0x8b>\nadd    $0x2,%bpl\nmov    %bpl,(%r14,%rbx,1)\nmovzbl 0x1(%r15,%rbx,1),%ebp\nadd    $0x1,%rbx\ntest   %bpl,%bpl\njne    1160 <func0+0x30>\nmov    %ebx,%eax\njmp    11d4 <func0+0xa4>\nxor    %eax,%eax\nmovb   $0x0,(%r14,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 94,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11d6 <func0+0xd6>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x18(%rbp)\ncmpl   $0x1,-0x18(%rbp)\njle    11c3 <func0+0xc3>\nmovl   $0x1,-0x24(%rbp)\nmovl   $0x2,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nimul   -0x28(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njg     1191 <func0+0x91>\nmov    -0x18(%rbp),%eax\ncltd\nidivl  -0x28(%rbp)\ncmp    $0x0,%edx\njne    117e <func0+0x7e>\nmovl   $0x0,-0x24(%rbp)\njmp    1191 <func0+0x91>\njmp    1183 <func0+0x83>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    1152 <func0+0x52>\ncmpl   $0x0,-0x24(%rbp)\nje     11be <func0+0xbe>\nmov    -0x18(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njle    11b2 <func0+0xb2>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x2c(%rbp)\njmp    11b8 <func0+0xb8>\nmov    -0x10(%rbp),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    11c3 <func0+0xc3>\njmp    11c8 <func0+0xc8>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1120 <func0+0x20>\njmp    11db <func0+0xdb>\ncmpl   $0x0,-0x10(%rbp)\njle    1209 <func0+0x109>\nmov    -0x10(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nadd    -0x14(%rbp),%edx\nmov    %edx,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x10(%rbp)\njmp    11db <func0+0xdb>\nmov    -0x14(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 94,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxor    %r8d,%r8d\nmov    $0x0,%r11d\ntest   %esi,%esi\njle    1167 <func0+0x67>\nmov    %esi,%r9d\nxor    %r10d,%r10d\nxor    %r11d,%r11d\njmp    1130 <func0+0x30>\nnopl   0x0(%rax,%rax,1)\ncmp    %r11d,%esi\ncmovg  %esi,%r11d\nadd    $0x1,%r10\ncmp    %r9,%r10\nje     1167 <func0+0x67>\nmov    (%rdi,%r10,4),%esi\ncmp    $0x2,%esi\njl     1127 <func0+0x27>\ncmp    $0x4,%esi\njl     1120 <func0+0x20>\nmov    $0x2,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1127 <func0+0x27>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njle    1150 <func0+0x50>\njmp    1120 <func0+0x20>\ntest   %r11d,%r11d\njle    119b <func0+0x9b>\nxor    %r8d,%r8d\nnop\nmovslq %r11d,%rax\nimul   $0x66666667,%rax,%r11\nmov    %r11,%rcx\nshr    $0x3f,%rcx\nsar    $0x22,%r11\nadd    %ecx,%r11d\nlea    (%r11,%r11,1),%ecx\nlea    (%rcx,%rcx,4),%ecx\nmov    %eax,%edx\nsub    %ecx,%edx\nadd    %edx,%r8d\ncmp    $0x9,%eax\njg     1170 <func0+0x70>\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 94,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    11a2 <func0+0xa2>\nmov    %esi,%r8d\nxor    %r10d,%r10d\nxor    %r9d,%r9d\njmp    1130 <func0+0x30>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\ncmp    %r9d,%ecx\ncmovg  %ecx,%r9d\nadd    $0x1,%r10\ncmp    %r8,%r10\nje     1167 <func0+0x67>\nmov    (%rdi,%r10,4),%ecx\ncmp    $0x2,%ecx\njl     1127 <func0+0x27>\ncmp    $0x4,%ecx\njb     1120 <func0+0x20>\nmov    $0x2,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1127 <func0+0x27>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1150 <func0+0x50>\njmp    1120 <func0+0x20>\nxor    %eax,%eax\ntest   %r9d,%r9d\njle    11a1 <func0+0xa1>\nmov    $0xcccccccd,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %r9d,%edx\nimul   %rcx,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,1),%esi\nlea    (%rsi,%rsi,4),%esi\nmov    %r9d,%edi\nsub    %esi,%edi\nadd    %edi,%eax\ncmp    $0x9,%r9d\nmov    %edx,%r9d\nja     1180 <func0+0x80>\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 94,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    11a2 <func0+0xa2>\nmov    %esi,%r8d\nxor    %r10d,%r10d\nxor    %r9d,%r9d\njmp    1130 <func0+0x30>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\ncmp    %r9d,%ecx\ncmovg  %ecx,%r9d\nadd    $0x1,%r10\ncmp    %r8,%r10\nje     1167 <func0+0x67>\nmov    (%rdi,%r10,4),%ecx\ncmp    $0x2,%ecx\njl     1127 <func0+0x27>\ncmp    $0x4,%ecx\njb     1120 <func0+0x20>\nmov    $0x2,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     1127 <func0+0x27>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1150 <func0+0x50>\njmp    1120 <func0+0x20>\nxor    %eax,%eax\ntest   %r9d,%r9d\njle    11a1 <func0+0xa1>\nmov    $0xcccccccd,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %r9d,%edx\nimul   %rcx,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,1),%esi\nlea    (%rsi,%rsi,4),%esi\nmov    %r9d,%edi\nsub    %esi,%edi\nadd    %edi,%eax\ncmp    $0x9,%r9d\nmov    %edx,%r9d\nja     1180 <func0+0x80>\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 95,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1135 <func0+0x25>\nmovl   $0x0,-0x4(%rbp)\njmp    1262 <func0+0x152>\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    125b <func0+0x14b>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nshl    $0x4,%rcx\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\ncmpb   $0x0,(%rax,%rcx,1)\nje     1248 <func0+0x138>\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x2c(%rbp),%rdx\nmovzbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x400,%eax\ncmp    $0x0,%eax\njne    11ba <func0+0xaa>\nmovl   $0x0,-0x4(%rbp)\njmp    1262 <func0+0x152>\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x2c(%rbp),%rdx\nmovzbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x100,%eax\ncmp    $0x0,%eax\nje     11ea <func0+0xda>\nmovl   $0x1,-0x1c(%rbp)\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x2c(%rbp),%rdx\nmovzbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x200,%eax\ncmp    $0x0,%eax\nje     121a <func0+0x10a>\nmovl   $0x1,-0x18(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    -0x18(%rbp),%eax\ncmp    $0x2,%eax\njne    1235 <func0+0x125>\nmovl   $0x0,-0x4(%rbp)\njmp    1262 <func0+0x152>\njmp    123a <func0+0x12a>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1173 <func0+0x63>\njmp    124d <func0+0x13d>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    114a <func0+0x3a>\nmovl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 95,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,0x10(%rsp)\ntest   %esi,%esi\nje     11ee <func0+0xde>\nmov    $0x1,%eax\njle    11f0 <func0+0xe0>\nmov    %esi,%eax\nmov    %rax,0x8(%rsp)\nxor    %r13d,%r13d\nxor    %ebx,%ebx\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %r13,%rax\nshl    $0x4,%rax\nmov    0x10(%rsp),%rcx\nmov    (%rcx,%rax,1),%r15\nmov    (%r15),%r12b\nmov    $0x1,%r14b\ntest   %r12b,%r12b\nje     11d3 <func0+0xc3>\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nadd    $0x1,%r15\nnopw   0x0(%rax,%rax,1)\nmovzbl %r12b,%ecx\nmovzwl (%rax,%rcx,2),%ecx\ntest   $0x400,%ecx\nje     11d0 <func0+0xc0>\ntest   $0x100,%ecx\nje     119d <func0+0x8d>\nmov    $0x1,%ebx\ntest   $0x200,%ecx\nje     11aa <func0+0x9a>\nmov    $0x1,%ebp\nlea    (%rbx,%rbp,1),%ecx\ncmp    $0x2,%ecx\nje     11d0 <func0+0xc0>\nmovzbl (%r15),%r12d\nadd    $0x1,%r15\ntest   %r12b,%r12b\njne    1180 <func0+0x70>\njmp    11d3 <func0+0xc3>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nxor    %r14d,%r14d\ntest   %r14b,%r14b\nje     11ee <func0+0xde>\nadd    $0x1,%r13\ncmp    0x8(%rsp),%r13\njne    1150 <func0+0x40>\nmov    $0x1,%eax\njmp    11f0 <func0+0xe0>\nxor    %eax,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 95,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ntest   %esi,%esi\nje     11b6 <func0+0xa6>\njle    11ba <func0+0xaa>\nmov    %rdi,%r15\nmov    %esi,%eax\nmov    %rax,(%rsp)\nxor    %r12d,%r12d\nxor    %r13d,%r13d\nxor    %ebx,%ebx\njmp    114a <func0+0x3a>\nnopl   0x0(%rax)\nadd    $0x1,%r12\ncmp    (%rsp),%r12\nje     11ba <func0+0xaa>\nmov    %r12,%rax\nshl    $0x4,%rax\nmov    (%r15,%rax,1),%rbp\nmov    0x0(%rbp),%r14b\ntest   %r14b,%r14b\nje     1140 <func0+0x30>\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%rcx\nadd    $0x1,%rbp\nnopw   0x0(%rax,%rax,1)\nmovzbl %r14b,%eax\nmovzwl (%rcx,%rax,2),%edx\nxor    %eax,%eax\ntest   $0x400,%edx\nje     11bf <func0+0xaf>\ntest   $0x100,%edx\nje     1190 <func0+0x80>\nmov    $0x1,%r13d\ntest   $0x200,%edx\nje     119d <func0+0x8d>\nmov    $0x1,%ebx\nlea    (%rbx,%r13,1),%edx\ncmp    $0x2,%edx\nje     11bf <func0+0xaf>\nmovzbl 0x0(%rbp),%r14d\nadd    $0x1,%rbp\ntest   %r14b,%r14b\njne    1170 <func0+0x60>\njmp    1140 <func0+0x30>\nxor    %eax,%eax\njmp    11bf <func0+0xaf>\nmov    $0x1,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 95,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ntest   %esi,%esi\nje     11cf <func0+0xbf>\njle    11d3 <func0+0xc3>\nmov    %rdi,%r15\nmov    %esi,%eax\nmov    %rax,(%rsp)\nxor    %r12d,%r12d\nxor    %r13d,%r13d\nxor    %ebx,%ebx\njmp    114e <func0+0x3e>\nnopl   0x0(%rax)\nadd    $0x1,%r12\ncmp    (%rsp),%r12\nje     11d3 <func0+0xc3>\nmov    %r12,%rax\nshl    $0x4,%rax\nmov    (%r15,%rax,1),%rbp\nmov    0x0(%rbp),%r14b\ntest   %r14b,%r14b\nje     1140 <func0+0x30>\ncall   1030 <__ctype_b_loc@plt>\nmov    (%rax),%rcx\nadd    $0x1,%rbp\nxchg   %ax,%ax\nmovzbl %r14b,%eax\nmovzwl (%rcx,%rax,2),%edx\nxor    %eax,%eax\ntest   $0x400,%edx\nje     11d8 <func0+0xc8>\ntest   $0x100,%edx\njne    11a0 <func0+0x90>\ntest   $0x200,%edx\njne    11ae <func0+0x9e>\nlea    (%rbx,%r13,1),%edx\ncmp    $0x2,%edx\njne    11bc <func0+0xac>\njmp    11d8 <func0+0xc8>\nnopl   (%rax)\nmov    $0x1,%r13d\ntest   $0x200,%edx\nje     1192 <func0+0x82>\nmov    $0x1,%ebx\nlea    (%rbx,%r13,1),%edx\ncmp    $0x2,%edx\nje     11d8 <func0+0xc8>\nmovzbl 0x0(%rbp),%r14d\nadd    $0x1,%rbp\ntest   %r14b,%r14b\njne    1170 <func0+0x60>\njmp    1140 <func0+0x30>\nxor    %eax,%eax\njmp    11d8 <func0+0xc8>\nmov    $0x1,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 96,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovslq -0x4(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x2,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    11f5 <func0+0xe5>\nmovl   $0x1,-0x24(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    -0x10(%rbp),%rcx\ncmp    (%rcx),%eax\njge    11bc <func0+0xac>\nmov    -0x18(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nimul   -0x28(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njle    118d <func0+0x7d>\njmp    11bc <func0+0xac>\nmov    -0x1c(%rbp),%eax\ncltd\nidivl  -0x28(%rbp)\ncmp    $0x0,%edx\njne    11a9 <func0+0x99>\nmovl   $0x0,-0x24(%rbp)\njmp    11bc <func0+0xac>\njmp    11ae <func0+0x9e>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    115b <func0+0x4b>\ncmpl   $0x0,-0x24(%rbp)\nje     11e2 <func0+0xd2>\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    -0x10(%rbp),%rcx\nmovslq (%rcx),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax)\njmp    11e7 <func0+0xd7>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1141 <func0+0x31>\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 96,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %edi,%r15d\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,%rcx\nmovl   $0x0,(%r14)\ncmp    $0x3,%ebx\njl     1190 <func0+0x80>\nmov    (%r14),%r8d\nmov    $0x2,%esi\njmp    1165 <func0+0x55>\ncs nopw 0x0(%rax,%rax,1)\nmovslq %r8d,%rax\nmov    %esi,(%rcx,%rax,4)\nadd    $0x1,%r8d\nmov    %r8d,(%r14)\nadd    $0x1,%esi\ncmp    %r15d,%esi\nje     1190 <func0+0x80>\ntest   %r8d,%r8d\njle    1150 <func0+0x40>\nmov    %r8d,%ebx\nxor    %ebp,%ebp\nnop\nmov    (%rcx,%rbp,4),%edi\nmov    %edi,%eax\nimul   %edi,%eax\ncmp    %esi,%eax\nja     1150 <func0+0x40>\nmov    %esi,%eax\ncltd\nidiv   %edi\ntest   %edx,%edx\nje     115d <func0+0x4d>\nadd    $0x1,%rbp\ncmp    %rbp,%rbx\njne    1170 <func0+0x60>\njmp    1150 <func0+0x40>\nmov    %rcx,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 96,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %edi,%r15d\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,%rcx\nmovl   $0x0,(%r14)\ncmp    $0x3,%ebx\njl     1190 <func0+0x80>\nmov    $0x2,%esi\nxor    %r8d,%r8d\njmp    1165 <func0+0x55>\ncs nopw 0x0(%rax,%rax,1)\nmovslq %r8d,%rax\nmov    %esi,(%rcx,%rax,4)\nadd    $0x1,%r8d\nmov    %r8d,(%r14)\nadd    $0x1,%esi\ncmp    %r15d,%esi\nje     1190 <func0+0x80>\ntest   %r8d,%r8d\njle    1150 <func0+0x40>\nmov    %r8d,%ebx\nxor    %ebp,%ebp\nnop\nmov    (%rcx,%rbp,4),%edi\nmov    %edi,%eax\nimul   %edi,%eax\ncmp    %esi,%eax\nja     1150 <func0+0x40>\nmov    %esi,%eax\ncltd\nidiv   %edi\ntest   %edx,%edx\nje     115d <func0+0x4d>\nadd    $0x1,%rbp\ncmp    %rbp,%rbx\njne    1170 <func0+0x60>\njmp    1150 <func0+0x40>\nmov    %rcx,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 96,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %edi,%r15d\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,%rcx\nmovl   $0x0,(%r14)\ncmp    $0x3,%ebx\njl     1190 <func0+0x80>\nmov    $0x2,%esi\nxor    %r8d,%r8d\njmp    1165 <func0+0x55>\ncs nopw 0x0(%rax,%rax,1)\nmovslq %r8d,%rax\nmov    %esi,(%rcx,%rax,4)\nadd    $0x1,%r8d\nmov    %r8d,(%r14)\nadd    $0x1,%esi\ncmp    %r15d,%esi\nje     1190 <func0+0x80>\ntest   %r8d,%r8d\njle    1150 <func0+0x40>\nmov    %r8d,%ebx\nxor    %ebp,%ebp\nnop\nmov    (%rcx,%rbp,4),%edi\nmov    %edi,%eax\nimul   %edi,%eax\ncmp    %esi,%eax\nja     1150 <func0+0x40>\nmov    %esi,%eax\ncltd\nidiv   %edi\ntest   %edx,%edx\nje     115d <func0+0x4d>\nadd    $0x1,%rbp\ncmp    %rbp,%rbx\njne    1170 <func0+0x60>\njmp    1150 <func0+0x40>\nmov    %rcx,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 97,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%edi\ncall   1030 <abs@plt>\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %edx,-0xc(%rbp)\nmov    -0x8(%rbp),%edi\ncall   1030 <abs@plt>\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    -0xc(%rbp),%eax\nimul   %edx,%eax\nadd    $0x10,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 97,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%ecx\nneg    %ecx\ncmovs  %edi,%ecx\nmov    $0xcccccccd,%edx\nmov    %rcx,%rax\nimul   %rdx,%rax\nshr    $0x23,%rax\nadd    %eax,%eax\nlea    (%rax,%rax,4),%eax\nsub    %eax,%ecx\nmov    %esi,%eax\nneg    %eax\ncmovs  %esi,%eax\nimul   %rax,%rdx\nshr    $0x23,%rdx\nadd    %edx,%edx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\nimul   %ecx,%eax\nret\n"
    },
    {
        "task_id": 97,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%ecx\nneg    %ecx\ncmovs  %edi,%ecx\nmov    $0xcccccccd,%edx\nmov    %rcx,%rax\nimul   %rdx,%rax\nshr    $0x23,%rax\nadd    %eax,%eax\nlea    (%rax,%rax,4),%eax\nsub    %eax,%ecx\nmov    %esi,%eax\nneg    %eax\ncmovs  %esi,%eax\nimul   %rax,%rdx\nshr    $0x23,%rdx\nadd    %edx,%edx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\nimul   %ecx,%eax\nret\n"
    },
    {
        "task_id": 97,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%ecx\nneg    %ecx\ncmovs  %edi,%ecx\nmov    $0xcccccccd,%edx\nmov    %rcx,%rax\nimul   %rdx,%rax\nshr    $0x23,%rax\nadd    %eax,%eax\nlea    (%rax,%rax,4),%eax\nsub    %eax,%ecx\nmov    %esi,%eax\nneg    %eax\ncmovs  %esi,%eax\nimul   %rax,%rdx\nshr    $0x23,%rdx\nadd    %edx,%edx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\nimul   %ecx,%eax\nret\n"
    },
    {
        "task_id": 98,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    0xecd(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%ecx\nxor    %eax,%eax\ncmp    $0x0,%ecx\nmov    %al,-0x19(%rbp)\nje     1184 <func0+0x64>\nmov    -0x18(%rbp),%eax\nshl    $0x1,%eax\ncltq\nmov    %rax,-0x28(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\ncmp    %rcx,%rax\nsetb   %al\nmov    %al,-0x19(%rbp)\nmov    -0x19(%rbp),%al\ntest   $0x1,%al\njne    1194 <func0+0x74>\njmp    11d4 <func0+0xb4>\nmov    -0x10(%rbp),%rdi\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nshl    $0x1,%ecx\nmovslq %ecx,%rcx\nmovsbl (%rax,%rcx,1),%esi\ncall   1040 <strchr@plt>\ncmp    $0x0,%rax\nje     11c1 <func0+0xa1>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    11c6 <func0+0xa6>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1145 <func0+0x25>\nmov    -0x14(%rbp),%eax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 98,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ncmpb   $0x0,(%rdi)\nje     117f <func0+0x5f>\nmov    %rdi,%r12\ncall   1030 <strlen@plt>\nmov    %rax,%r14\nxor    %ebx,%ebx\nmov    $0x1,%r13d\nlea    0xeb6(%rip),%r15\nxor    %ebp,%ebp\nnopl   0x0(%rax)\ncmp    %rbx,%r14\njbe    1181 <func0+0x61>\nmovsbl (%r12,%rbx,1),%esi\nmov    $0x6,%edx\nmov    %r15,%rdi\ncall   1040 <memchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x2,%rbx\ncmpb   $0x0,(%r12,%r13,1)\nlea    0x1(%r13),%r13\njne    1150 <func0+0x30>\njmp    1181 <func0+0x61>\nxor    %ebp,%ebp\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 98,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ncmpb   $0x0,(%rdi)\nje     117f <func0+0x5f>\nmov    %rdi,%r12\ncall   1030 <strlen@plt>\nmov    %rax,%r14\nxor    %ebx,%ebx\nmov    $0x1,%r13d\nlea    0xeb6(%rip),%r15\nxor    %ebp,%ebp\nnopl   0x0(%rax)\ncmp    %rbx,%r14\njbe    1181 <func0+0x61>\nmovsbl (%r12,%rbx,1),%esi\nmov    $0x6,%edx\nmov    %r15,%rdi\ncall   1040 <memchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x2,%rbx\ncmpb   $0x0,(%r12,%r13,1)\nlea    0x1(%r13),%r13\njne    1150 <func0+0x30>\njmp    1181 <func0+0x61>\nxor    %ebp,%ebp\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 98,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\ncmpb   $0x0,(%rdi)\nje     117f <func0+0x5f>\nmov    %rdi,%r12\ncall   1030 <strlen@plt>\nmov    %rax,%r14\nxor    %ebx,%ebx\nmov    $0x1,%r13d\nlea    0xeb6(%rip),%r15\nxor    %ebp,%ebp\nnopl   0x0(%rax)\ncmp    %rbx,%r14\njbe    1181 <func0+0x61>\nmovsbl (%r12,%rbx,1),%esi\nmov    $0x6,%edx\nmov    %r15,%rdi\ncall   1040 <memchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x2,%rbx\ncmpb   $0x0,(%r12,%r13,1)\nlea    0x1(%r13),%r13\njne    1150 <func0+0x30>\njmp    1181 <func0+0x61>\nxor    %ebp,%ebp\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 99,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1030 <atof@plt>\nmovsd  %xmm0,-0x10(%rbp)\nxorps  %xmm0,%xmm0\nucomisd -0x10(%rbp),%xmm0\njbe    1178 <func0+0x48>\nmovsd  -0x10(%rbp),%xmm0\nmovsd  0xe9b(%rip),%xmm1\nsubsd  %xmm1,%xmm0\ncall   1040 <ceil@plt>\nmovsd  %xmm0,-0x18(%rbp)\njmp    118f <func0+0x5f>\nmovsd  0xe80(%rip),%xmm0\naddsd  -0x10(%rbp),%xmm0\ncall   1050 <floor@plt>\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  -0x18(%rbp),%xmm0\ncvttsd2si %xmm0,%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 99,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rax\nxor    %esi,%esi\ncall   1030 <strtod@plt>\nxorpd  %xmm1,%xmm1\nucomisd %xmm0,%xmm1\njbe    1151 <func0+0x21>\naddsd  0xebe(%rip),%xmm0\ncall   1040 <ceil@plt>\njmp    115e <func0+0x2e>\naddsd  0xea7(%rip),%xmm0\ncall   1050 <floor@plt>\ncvttsd2si %xmm0,%eax\npop    %rcx\nret\n"
    },
    {
        "task_id": 99,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rax\nxor    %esi,%esi\ncall   1030 <strtod@plt>\nxorpd  %xmm1,%xmm1\nucomisd %xmm0,%xmm1\njbe    1151 <func0+0x21>\naddsd  0xebe(%rip),%xmm0\ncall   1040 <ceil@plt>\njmp    115e <func0+0x2e>\naddsd  0xea7(%rip),%xmm0\ncall   1050 <floor@plt>\ncvttsd2si %xmm0,%eax\npop    %rcx\nret\n"
    },
    {
        "task_id": 99,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rax\nxor    %esi,%esi\ncall   1030 <strtod@plt>\nxorpd  %xmm1,%xmm1\nucomisd %xmm0,%xmm1\njbe    1155 <func0+0x25>\naddsd  0xebe(%rip),%xmm0\ncall   1040 <ceil@plt>\ncvttsd2si %xmm0,%eax\npop    %rcx\nret\naddsd  0xea3(%rip),%xmm0\ncall   1050 <floor@plt>\ncvttsd2si %xmm0,%eax\npop    %rcx\nret\n"
    },
    {
        "task_id": 100,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x4(%rbp)\nmovslq -0x4(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x10(%rbp)\nmov    -0x4(%rbp),%ecx\nmov    -0x10(%rbp),%rax\nmov    %ecx,(%rax)\nmovl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    1170 <func0+0x60>\nmov    -0x10(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    -0x4(%rax,%rcx,4),%edx\nadd    $0x2,%edx\nmov    -0x10(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    113c <func0+0x2c>\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 100,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %edi,%ebp\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\nmov    %ebx,(%rax)\ncmp    $0x2,%ebx\njl     114f <func0+0x3f>\nmov    %ebp,%ecx\nmov    (%rax),%edx\nadd    %rcx,%rcx\nmov    $0x2,%esi\nnopl   0x0(%rax,%rax,1)\nlea    (%rdx,%rsi,1),%edi\nmov    %edi,(%rax,%rsi,2)\nadd    $0x2,%rsi\ncmp    %rsi,%rcx\njne    1140 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 100,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %edi,%ebp\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\nmov    %ebx,(%rax)\ncmp    $0x2,%ebx\njl     11cf <func0+0xbf>\nmov    %ebp,%ecx\nmov    (%rax),%ebx\nlea    -0x1(%rcx),%rdi\nadd    $0xfffffffffffffffe,%rcx\nmov    %edi,%edx\nand    $0x3,%edx\nmov    $0x1,%esi\ncmp    $0x3,%rcx\njb     11a1 <func0+0x91>\nand    $0xfffffffffffffffc,%rdi\nmov    $0xffffffffffffffff,%rsi\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nlea    (%rbx,%rcx,1),%ebp\nadd    $0x2,%ebp\nmov    %ebp,0x4(%rax,%rcx,2)\nlea    0x4(%rbx,%rcx,1),%ebp\nmov    %ebp,0x8(%rax,%rcx,2)\nlea    0x6(%rbx,%rcx,1),%ebp\nmov    %ebp,0xc(%rax,%rcx,2)\nlea    (%rbx,%rcx,1),%ebp\nadd    $0x8,%ebp\nmov    %ebp,0x10(%rax,%rcx,2)\nadd    $0x8,%rcx\nlea    (%rdi,%rsi,1),%rbp\nadd    $0xfffffffffffffffc,%rbp\nadd    $0xfffffffffffffffc,%rsi\ncmp    $0xffffffffffffffff,%rbp\njne    1160 <func0+0x50>\nadd    %ebx,%ecx\nneg    %rsi\nmov    %ecx,%ebx\ntest   %rdx,%rdx\nje     11cf <func0+0xbf>\nadd    $0x2,%ebx\nlea    (%rax,%rsi,4),%rcx\nadd    %rdx,%rdx\nxor    %esi,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nlea    (%rbx,%rsi,1),%edi\nmov    %edi,(%rcx,%rsi,2)\nadd    $0x2,%rsi\ncmp    %rsi,%rdx\njne    11c0 <func0+0xb0>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 100,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %edi,%ebp\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\nmov    %ebx,(%rax)\ncmp    $0x2,%ebx\njl     11cf <func0+0xbf>\nmov    %ebp,%ecx\nmov    (%rax),%ebx\nlea    -0x1(%rcx),%rdi\nadd    $0xfffffffffffffffe,%rcx\nmov    %edi,%edx\nand    $0x3,%edx\nmov    $0x1,%esi\ncmp    $0x3,%rcx\njb     11a1 <func0+0x91>\nand    $0xfffffffffffffffc,%rdi\nmov    $0xffffffffffffffff,%rsi\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nlea    (%rbx,%rcx,1),%ebp\nadd    $0x2,%ebp\nmov    %ebp,0x4(%rax,%rcx,2)\nlea    0x4(%rbx,%rcx,1),%ebp\nmov    %ebp,0x8(%rax,%rcx,2)\nlea    0x6(%rbx,%rcx,1),%ebp\nmov    %ebp,0xc(%rax,%rcx,2)\nlea    (%rbx,%rcx,1),%ebp\nadd    $0x8,%ebp\nmov    %ebp,0x10(%rax,%rcx,2)\nadd    $0x8,%rcx\nlea    (%rdi,%rsi,1),%rbp\nadd    $0xfffffffffffffffc,%rbp\nadd    $0xfffffffffffffffc,%rsi\ncmp    $0xffffffffffffffff,%rbp\njne    1160 <func0+0x50>\nadd    %ebx,%ecx\nneg    %rsi\nmov    %ecx,%ebx\ntest   %rdx,%rdx\nje     11cf <func0+0xbf>\nadd    $0x2,%ebx\nlea    (%rax,%rsi,4),%rcx\nadd    %rdx,%rdx\nxor    %esi,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nlea    (%rbx,%rsi,1),%edi\nmov    %edi,(%rcx,%rsi,2)\nadd    $0x2,%rsi\ncmp    %rsi,%rdx\njne    11c0 <func0+0xb0>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 101,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovl   $0xa,-0x14(%rbp)\nmovslq -0x14(%rbp),%rdi\nshl    $0x3,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1040 <strlen@plt>\nmov    %rax,%rdi\nadd    $0x1,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\ncmpb   $0x0,(%rax,%rcx,1)\nje     1288 <func0+0x138>\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x20,%eax\nje     11e2 <func0+0x92>\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x2c,%eax\njne    1255 <func0+0x105>\ncmpl   $0x0,-0x30(%rbp)\njle    1250 <func0+0x100>\nmov    -0x28(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x28(%rbp),%rdi\ncall   1070 <strdup@plt>\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nmov    -0x2c(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x2c(%rbp)\nmovslq %ecx,%rcx\nmov    %rdx,(%rax,%rcx,8)\nmovl   $0x0,-0x30(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     124b <func0+0xfb>\nmov    -0x14(%rbp),%eax\nshl    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x20(%rbp),%rdi\nmovslq -0x14(%rbp),%rsi\nshl    $0x3,%rsi\ncall   1060 <realloc@plt>\nmov    %rax,-0x20(%rbp)\njmp    1250 <func0+0x100>\njmp    1275 <func0+0x125>\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,1),%dl\nmov    -0x28(%rbp),%rax\nmov    -0x30(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x30(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\njmp    127a <func0+0x12a>\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    11a6 <func0+0x56>\ncmpl   $0x0,-0x30(%rbp)\njle    12c0 <func0+0x170>\nmov    -0x28(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x28(%rbp),%rdi\ncall   1070 <strdup@plt>\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nmov    -0x2c(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x2c(%rbp)\nmovslq %ecx,%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x28(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x2c(%rbp),%ecx\nmov    -0x10(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 101,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,(%rsp)\nmov    %rdi,%rbx\nmov    $0x50,%edi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1040 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r12\nxor    %ebp,%ebp\nmov    $0xa,%r13d\nxor    %r14d,%r14d\njmp    1194 <func0+0x44>\nadd    $0x1,%rbx\nmovzbl (%rbx),%eax\ncmp    $0x20,%al\nje     11b0 <func0+0x60>\ncmp    $0x2c,%al\nje     11b0 <func0+0x60>\ntest   %al,%al\nje     11f2 <func0+0xa2>\nmovslq %r14d,%rcx\nadd    $0x1,%r14d\nmov    %al,(%r12,%rcx,1)\njmp    1190 <func0+0x40>\ntest   %r14d,%r14d\njle    1190 <func0+0x40>\nmovslq %r14d,%rax\nmovb   $0x0,(%r12,%rax,1)\nmov    %r12,%rdi\ncall   1070 <strdup@plt>\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nmov    %rax,(%r15,%rcx,8)\nxor    %r14d,%r14d\ncmp    %r13d,%ebp\njl     1190 <func0+0x40>\nadd    %r13d,%r13d\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\nmov    %r15,%rdi\ncall   1060 <realloc@plt>\nmov    %rax,%r15\nadd    $0x1,%rbx\njmp    1194 <func0+0x44>\ntest   %r14d,%r14d\njle    1211 <func0+0xc1>\nmovslq %r14d,%rax\nmovb   $0x0,(%r12,%rax,1)\nmov    %r12,%rdi\ncall   1070 <strdup@plt>\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nmov    %rax,(%r15,%rcx,8)\nmov    %r12,%rdi\ncall   1030 <free@plt>\nmov    (%rsp),%rax\nmov    %ebp,(%rax)\nmov    %r15,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 101,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,(%rsp)\nmov    %rdi,%rbx\nmov    $0x50,%edi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1040 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r12\nxor    %ebp,%ebp\nmov    $0xa,%r13d\nxor    %r14d,%r14d\njmp    1194 <func0+0x44>\nadd    $0x1,%rbx\nmovzbl (%rbx),%eax\ncmp    $0x20,%al\nje     11b0 <func0+0x60>\ncmp    $0x2c,%al\nje     11b0 <func0+0x60>\ntest   %al,%al\nje     11f2 <func0+0xa2>\nmovslq %r14d,%rcx\nadd    $0x1,%r14d\nmov    %al,(%r12,%rcx,1)\njmp    1190 <func0+0x40>\ntest   %r14d,%r14d\njle    1190 <func0+0x40>\nmov    %r14d,%eax\nmovb   $0x0,(%r12,%rax,1)\nmov    %r12,%rdi\ncall   1070 <strdup@plt>\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nmov    %rax,(%r15,%rcx,8)\nxor    %r14d,%r14d\ncmp    %r13d,%ebp\njl     1190 <func0+0x40>\nadd    %r13d,%r13d\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\nmov    %r15,%rdi\ncall   1060 <realloc@plt>\nmov    %rax,%r15\nadd    $0x1,%rbx\njmp    1194 <func0+0x44>\ntest   %r14d,%r14d\njle    1211 <func0+0xc1>\nmov    %r14d,%eax\nmovb   $0x0,(%r12,%rax,1)\nmov    %r12,%rdi\ncall   1070 <strdup@plt>\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nmov    %rax,(%r15,%rcx,8)\nmov    %r12,%rdi\ncall   1030 <free@plt>\nmov    (%rsp),%rax\nmov    %ebp,(%rax)\nmov    %r15,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 101,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,(%rsp)\nmov    %rdi,%rbx\nmov    $0x50,%edi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1040 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r12\nxor    %ebp,%ebp\nmov    $0xa,%r13d\nxor    %r14d,%r14d\nmov    (%rbx),%al\ncmp    $0x20,%al\njne    11aa <func0+0x5a>\njmp    11c0 <func0+0x70>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%rbx\nmov    (%rbx),%al\ncmp    $0x20,%al\nje     11c0 <func0+0x70>\ncmp    $0x2c,%al\nje     11c0 <func0+0x70>\ntest   %al,%al\nje     1209 <func0+0xb9>\nmovslq %r14d,%rcx\nadd    $0x1,%r14d\nmov    %al,(%r12,%rcx,1)\njmp    11a0 <func0+0x50>\nnop\ntest   %r14d,%r14d\njle    11a0 <func0+0x50>\nmov    %r14d,%eax\nmovb   $0x0,(%r12,%rax,1)\nmov    %r12,%rdi\ncall   1070 <strdup@plt>\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nmov    %rax,(%r15,%rcx,8)\nxor    %r14d,%r14d\ncmp    %r13d,%ebp\njl     11a0 <func0+0x50>\nadd    %r13d,%r13d\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\nmov    %r15,%rdi\ncall   1060 <realloc@plt>\nmov    %rax,%r15\nadd    $0x1,%rbx\nmovzbl (%rbx),%eax\ncmp    $0x20,%al\njne    11aa <func0+0x5a>\njmp    11c0 <func0+0x70>\ntest   %r14d,%r14d\njle    1228 <func0+0xd8>\nmov    %r14d,%eax\nmovb   $0x0,(%r12,%rax,1)\nmov    %r12,%rdi\ncall   1070 <strdup@plt>\nmovslq %ebp,%rcx\nadd    $0x1,%ebp\nmov    %rax,(%r15,%rcx,8)\nmov    %r12,%rdi\ncall   1030 <free@plt>\nmov    (%rsp),%rax\nmov    %ebp,(%rax)\nmov    %r15,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 102,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    1122 <func0+0x22>\nmovl   $0xffffffff,-0x4(%rbp)\njmp    1176 <func0+0x76>\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njne    114e <func0+0x4e>\nmov    -0xc(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    114e <func0+0x4e>\nmovl   $0xffffffff,-0x4(%rbp)\njmp    1176 <func0+0x76>\nmov    -0xc(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    1170 <func0+0x70>\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    1176 <func0+0x76>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 102,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncmp    %edi,%esi\njl     1120 <func0+0x20>\nmov    %esi,%edx\nshr    $0x1f,%edx\nadd    %esi,%edx\nand    $0xfffffffe,%edx\nmov    %esi,%ecx\nsub    %edx,%ecx\ncmp    %edi,%esi\njne    1121 <func0+0x21>\ncmp    $0x1,%ecx\njne    1121 <func0+0x21>\nret\nxor    %eax,%eax\ncmp    $0x1,%ecx\nsete   %al\nsub    %eax,%esi\nmov    %esi,%eax\nret\n"
    },
    {
        "task_id": 102,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncmp    %edi,%esi\njl     1120 <func0+0x20>\nmov    %esi,%edx\nshr    $0x1f,%edx\nadd    %esi,%edx\nand    $0xfffffffe,%edx\nmov    %esi,%ecx\nsub    %edx,%ecx\ncmp    %edi,%esi\njne    1121 <func0+0x21>\ncmp    $0x1,%ecx\njne    1121 <func0+0x21>\nret\nxor    %eax,%eax\ncmp    $0x1,%ecx\nsete   %al\nsub    %eax,%esi\nmov    %esi,%eax\nret\n"
    },
    {
        "task_id": 102,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncmp    %edi,%esi\njl     1120 <func0+0x20>\nmov    %esi,%edx\nshr    $0x1f,%edx\nadd    %esi,%edx\nand    $0xfffffffe,%edx\nmov    %esi,%ecx\nsub    %edx,%ecx\ncmp    %edi,%esi\njne    1121 <func0+0x21>\ncmp    $0x1,%ecx\njne    1121 <func0+0x21>\nret\nxor    %eax,%eax\ncmp    $0x1,%ecx\nsete   %al\nsub    %eax,%esi\nmov    %esi,%eax\nret\n"
    },
    {
        "task_id": 103,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0xc(%rbp)\nmov    %esi,-0x10(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njle    113a <func0+0x2a>\nlea    0xecf(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    11cc <func0+0xbc>\nmov    -0x10(%rbp),%eax\nadd    -0xc(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x14(%rbp)\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x20,-0x24(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0xffffffff,%edx\nmov    %edx,-0x24(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nadd    $0x30,%edx\nmov    -0x20(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0xffffffff,%esi\nmov    %esi,-0x24(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x14(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     117d <func0+0x6d>\nmov    -0x20(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nadd    %rcx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 103,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ncmp    %esi,%edi\njle    111e <func0+0xe>\nlea    0xee4(%rip),%rax\npop    %rbx\nret\nmov    %esi,%ebx\nadd    %edi,%ebx\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\nmovb   $0x0,(%rax)\nmovb   $0x0,0x20(%rax)\nadd    $0x20,%rax\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%ecx\nshr    $0x1f,%ecx\nadd    %ebx,%ecx\nmov    %ecx,%edx\nsar    %edx\nshr    $0x1f,%ecx\nadd    %edx,%ecx\nand    $0xfe,%ecx\nmov    %edx,%esi\nsub    %ecx,%esi\nadd    $0x30,%sil\nmov    %sil,-0x1(%rax)\nadd    $0xffffffffffffffff,%rax\ncmp    $0x3,%ebx\nmov    %edx,%ebx\njg     1140 <func0+0x30>\npop    %rbx\nret\n"
    },
    {
        "task_id": 103,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ncmp    %esi,%edi\njle    111e <func0+0xe>\nlea    0xee4(%rip),%rax\npop    %rbx\nret\nmov    %esi,%ebx\nadd    %edi,%ebx\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\nmovb   $0x0,(%rax)\nmovb   $0x0,0x20(%rax)\nadd    $0x20,%rax\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%ecx\nshr    $0x1f,%ecx\nadd    %ebx,%ecx\nmov    %ecx,%edx\nsar    %edx\nshr    $0x1f,%ecx\nadd    %edx,%ecx\nand    $0xfe,%ecx\nmov    %edx,%esi\nsub    %ecx,%esi\nadd    $0x30,%sil\nmov    %sil,-0x1(%rax)\nadd    $0xffffffffffffffff,%rax\ncmp    $0x3,%ebx\nmov    %edx,%ebx\njg     1140 <func0+0x30>\npop    %rbx\nret\n"
    },
    {
        "task_id": 103,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ncmp    %esi,%edi\njle    111e <func0+0xe>\nlea    0xee4(%rip),%rax\npop    %rbx\nret\nmov    %esi,%ebx\nadd    %edi,%ebx\nmov    $0x21,%edi\ncall   1030 <malloc@plt>\nmovb   $0x0,(%rax)\nmovb   $0x0,0x20(%rax)\nadd    $0x20,%rax\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%ecx\nshr    $0x1f,%ecx\nadd    %ebx,%ecx\nmov    %ecx,%edx\nsar    %edx\nshr    $0x1f,%ecx\nadd    %edx,%ecx\nand    $0xfe,%ecx\nmov    %edx,%esi\nsub    %ecx,%esi\nadd    $0x30,%sil\nmov    %sil,-0x1(%rax)\nadd    $0xffffffffffffffff,%rax\ncmp    $0x3,%ebx\nmov    %edx,%ebx\njg     1140 <func0+0x30>\npop    %rbx\nret\n"
    },
    {
        "task_id": 104,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nmovslq -0xc(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,(%rax)\nmov    -0x20(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1216 <func0+0x106>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x28(%rbp)\nmovb   $0x0,-0x29(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njne    117b <func0+0x6b>\nmovb   $0x1,-0x29(%rbp)\njmp    1180 <func0+0x70>\nxor    %eax,%eax\ncmpl   $0x0,-0x28(%rbp)\nmov    %al,-0x39(%rbp)\njle    1197 <func0+0x87>\nmov    -0x29(%rbp),%al\nxor    $0xff,%al\nmov    %al,-0x39(%rbp)\nmov    -0x39(%rbp),%al\ntest   $0x1,%al\njne    11a7 <func0+0x97>\njmp    11d2 <func0+0xc2>\nmov    -0x28(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    11bf <func0+0xaf>\nmovb   $0x1,-0x29(%rbp)\nmov    -0x28(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x28(%rbp)\njmp    1180 <func0+0x70>\ntestb  $0x1,-0x29(%rbp)\njne    1203 <func0+0xf3>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x20(%rbp),%rcx\nmovslq (%rcx),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax)\njmp    1208 <func0+0xf8>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    114f <func0+0x3f>\nmovl   $0x0,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\nmov    -0x20(%rbp),%rcx\nmov    (%rcx),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    12e4 <func0+0x1d4>\nmovl   $0x0,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\nmov    -0x20(%rbp),%rcx\nmov    (%rcx),%ecx\nsub    -0x30(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    12d1 <func0+0x1c1>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x18(%rbp),%rcx\nmov    (%rcx),%rcx\nmov    -0x34(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\njle    12be <func0+0x1ae>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x34(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovslq -0x34(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x38(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x34(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    12c3 <func0+0x1b3>\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    1238 <func0+0x128>\njmp    12d6 <func0+0x1c6>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    121d <func0+0x10d>\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 104,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rcx,%rbx\nmov    %rdx,%r14\nmov    %esi,%r12d\nmov    %rdi,%r15\nmovslq %esi,%rbp\nlea    0x0(,%rbp,4),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,(%r14)\nmovl   $0x0,(%rbx)\ntest   %ebp,%ebp\njle    11b6 <func0+0xa6>\nmov    %r12d,%r8d\nxor    %r10d,%r10d\nmov    $0x1,%edx\njmp    1159 <func0+0x49>\nxchg   %ax,%ax\nadd    $0x1,%r10\ncmp    %r8,%r10\nje     11b6 <func0+0xa6>\nmov    (%r15,%r10,4),%r9d\ntest   %r9d,%r9d\nsetne  %al\njle    11a3 <func0+0x93>\nsete   %dil\nmov    %r9d,%ebp\nnopl   0x0(%rax)\ntest   $0x1,%bpl\nmovzbl %dil,%edi\ncmove  %edx,%edi\nmov    %edi,%ecx\nand    $0x1,%cl\nsete   %al\ncmp    $0xa,%ebp\njl     11a3 <func0+0x93>\nmovslq %ebp,%rbp\nimul   $0x66666667,%rbp,%rbp\nmov    %rbp,%rsi\nshr    $0x3f,%rsi\nsar    $0x22,%rbp\nadd    %esi,%ebp\ntest   %cl,%cl\nje     1170 <func0+0x60>\ntest   %al,%al\nje     1150 <func0+0x40>\nmov    (%r14),%rax\nmovslq (%rbx),%rcx\nmov    %r9d,(%rax,%rcx,4)\naddl   $0x1,(%rbx)\njmp    1150 <func0+0x40>\ncmpl   $0x2,(%rbx)\njl     1216 <func0+0x106>\nxor    %r8d,%r8d\njmp    11ce <func0+0xbe>\nadd    $0x1,%r8d\nmov    (%rbx),%eax\nadd    $0xffffffff,%eax\ncmp    %eax,%r8d\njge    1216 <func0+0x106>\nmov    %r8d,%ecx\nnot    %ecx\nmov    (%rbx),%eax\nadd    %ecx,%eax\ntest   %eax,%eax\njle    11c0 <func0+0xb0>\nmov    (%r14),%rdx\nxor    %esi,%esi\njmp    11fe <func0+0xee>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    (%rbx),%eax\nadd    %ecx,%eax\ncltq\nmov    %rdi,%rsi\ncmp    %rax,%rdi\njge    11c0 <func0+0xb0>\nmov    (%rdx,%rsi,4),%ebp\nmov    0x4(%rdx,%rsi,4),%eax\nlea    0x1(%rsi),%rdi\ncmp    %eax,%ebp\njle    11f0 <func0+0xe0>\nmov    %eax,(%rdx,%rsi,4)\nmov    %ebp,0x4(%rdx,%rsi,4)\njmp    11f0 <func0+0xe0>\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 104,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rcx,%r14\nmov    %rdx,%r15\nmov    %esi,%ebp\nmov    %rdi,%r12\nmovslq %esi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,(%r15)\nmovl   $0x0,(%r14)\ntest   %ebx,%ebx\njle    1272 <func0+0x162>\nmov    %ebp,%r8d\nxor    %r9d,%r9d\nmov    $0x1,%esi\nmov    $0xcccccccd,%edi\nxor    %ebp,%ebp\njmp    1169 <func0+0x59>\nnopl   0x0(%rax)\nadd    $0x1,%rbp\ncmp    %r8,%rbp\nje     11ba <func0+0xaa>\nmov    (%r12,%rbp,4),%r10d\ntest   %r10d,%r10d\nsetne  %r11b\njle    11a5 <func0+0x95>\nsete   %cl\nmov    %r10d,%edx\nnopl   0x0(%rax)\ntest   $0x1,%dl\nmovzbl %cl,%ecx\ncmove  %esi,%ecx\nmov    %ecx,%ebx\nand    $0x1,%bl\nsete   %r11b\ncmp    $0xa,%edx\njb     11a5 <func0+0x95>\nmov    %edx,%edx\nimul   %rdi,%rdx\nshr    $0x23,%rdx\ntest   %bl,%bl\nje     1180 <func0+0x70>\ntest   %r11b,%r11b\nje     1160 <func0+0x50>\nmovslq %r9d,%r9\nmov    %r10d,(%rax,%r9,4)\nadd    $0x1,%r9d\nmov    %r9d,(%r14)\njmp    1160 <func0+0x50>\ncmp    $0x2,%r9d\njl     1272 <func0+0x162>\nlea    -0x1(%r9),%r8d\nxor    %esi,%esi\nmov    %r8d,%r11d\njmp    11e0 <func0+0xd0>\nnop\nadd    $0x1,%esi\nadd    $0xffffffff,%r11d\ncmp    %r8d,%esi\njge    1272 <func0+0x162>\nmov    %esi,%ecx\nnot    %ecx\nadd    %r9d,%ecx\ntest   %ecx,%ecx\njle    11d0 <func0+0xc0>\nmov    %r8d,%r10d\nsub    %esi,%r10d\nmov    (%rax),%edi\ncmp    $0x1,%r10d\njne    1220 <func0+0x110>\nxor    %edx,%edx\nmovslq %r10d,%rcx\ntest   $0x1,%cl\nje     11d0 <func0+0xc0>\nmov    0x4(%rax,%rdx,4),%ecx\ncmp    %ecx,%edi\njle    11d0 <func0+0xc0>\nmov    %ecx,(%rax,%rdx,4)\nmov    %edi,0x4(%rax,%rdx,4)\njmp    11d0 <func0+0xc0>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovslq %r11d,%rbx\nand    $0xfffffffffffffffe,%rbx\nxor    %ecx,%ecx\njmp    1240 <func0+0x130>\nnopl   0x0(%rax,%rax,1)\nmov    %ebp,0x4(%rax,%rcx,4)\nmov    %edi,0x8(%rax,%rcx,4)\nmov    %rdx,%rcx\ncmp    %rdx,%rbx\nje     11fb <func0+0xeb>\nmov    0x4(%rax,%rcx,4),%edx\ncmp    %edx,%edi\njle    1260 <func0+0x150>\nmov    %edx,(%rax,%rcx,4)\nmov    %edi,0x4(%rax,%rcx,4)\njmp    1262 <func0+0x152>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %edx,%edi\nlea    0x2(%rcx),%rdx\nmov    0x8(%rax,%rcx,4),%ebp\ncmp    %ebp,%edi\njg     1230 <func0+0x120>\nmov    %ebp,%edi\njmp    1238 <func0+0x128>\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 104,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rcx,%r14\nmov    %rdx,%r15\nmov    %esi,%ebp\nmov    %rdi,%r12\nmovslq %esi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,(%r15)\nmovl   $0x0,(%r14)\ntest   %ebx,%ebx\njle    127c <func0+0x16c>\nmov    %ebp,%r8d\nxor    %r9d,%r9d\nmov    $0x1,%esi\nmov    $0xcccccccd,%edi\nxor    %ebp,%ebp\njmp    1169 <func0+0x59>\nnopl   0x0(%rax)\nadd    $0x1,%rbp\ncmp    %r8,%rbp\nje     11ba <func0+0xaa>\nmov    (%r12,%rbp,4),%r10d\ntest   %r10d,%r10d\nsetne  %r11b\njle    11a5 <func0+0x95>\nsete   %cl\nmov    %r10d,%edx\nnopl   0x0(%rax)\ntest   $0x1,%dl\nmovzbl %cl,%ecx\ncmove  %esi,%ecx\nmov    %ecx,%ebx\nand    $0x1,%bl\nsete   %r11b\ncmp    $0xa,%edx\njb     11a5 <func0+0x95>\nmov    %edx,%edx\nimul   %rdi,%rdx\nshr    $0x23,%rdx\ntest   %bl,%bl\nje     1180 <func0+0x70>\ntest   %r11b,%r11b\nje     1160 <func0+0x50>\nmovslq %r9d,%r9\nmov    %r10d,(%rax,%r9,4)\nadd    $0x1,%r9d\nmov    %r9d,(%r14)\njmp    1160 <func0+0x50>\ncmp    $0x2,%r9d\njl     127c <func0+0x16c>\nlea    -0x1(%r9),%r8d\nxor    %esi,%esi\nmov    %r8d,%r11d\njmp    11e0 <func0+0xd0>\nnop\nadd    $0x1,%esi\nadd    $0xffffffff,%r11d\ncmp    %r8d,%esi\njge    127c <func0+0x16c>\nmov    %esi,%ecx\nnot    %ecx\nadd    %r9d,%ecx\ntest   %ecx,%ecx\njle    11d0 <func0+0xc0>\nmov    %r8d,%r10d\nsub    %esi,%r10d\nmov    (%rax),%edi\ncmp    $0x1,%r10d\njne    1200 <func0+0xf0>\nxor    %edx,%edx\njmp    1258 <func0+0x148>\nnopl   (%rax)\nmovslq %r11d,%rbx\nand    $0xfffffffffffffffe,%rbx\nxor    %ecx,%ecx\njmp    1220 <func0+0x110>\nnopl   0x0(%rax,%rax,1)\nmov    %ebp,0x4(%rax,%rcx,4)\nmov    %edi,0x8(%rax,%rcx,4)\nmov    %rdx,%rcx\ncmp    %rdx,%rbx\nje     1258 <func0+0x148>\nmov    0x4(%rax,%rcx,4),%edx\ncmp    %edx,%edi\njle    1240 <func0+0x130>\nmov    %edx,(%rax,%rcx,4)\nmov    %edi,0x4(%rax,%rcx,4)\nlea    0x2(%rcx),%rdx\nmov    0x8(%rax,%rcx,4),%ebp\ncmp    %ebp,%edi\njg     1210 <func0+0x100>\njmp    124e <func0+0x13e>\nnopl   (%rax)\nmov    %edx,%edi\nlea    0x2(%rcx),%rdx\nmov    0x8(%rax,%rcx,4),%ebp\ncmp    %ebp,%edi\njg     1210 <func0+0x100>\nmov    %ebp,%edi\nmov    %rdx,%rcx\ncmp    %rdx,%rbx\njne    1220 <func0+0x110>\nmovslq %r10d,%rcx\ntest   $0x1,%cl\nje     11d0 <func0+0xc0>\nmov    0x4(%rax,%rdx,4),%ecx\ncmp    %ecx,%edi\njle    11d0 <func0+0xc0>\nmov    %ecx,(%rax,%rdx,4)\nmov    %edi,0x4(%rax,%rdx,4)\njmp    11d0 <func0+0xc0>\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 105,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x80,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nlea    -0x70(%rbp),%rdi\nlea    0x2c8b(%rip),%rsi\nmov    $0x50,%edx\ncall   1030 <memcpy@plt>\nmovl   $0x0,-0x74(%rbp)\nmov    -0x74(%rbp),%eax\nmov    -0xc(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    1205 <func0+0xe5>\nmovl   $0x0,-0x78(%rbp)\nmov    -0x78(%rbp),%eax\nmov    -0xc(%rbp),%ecx\nsub    -0x74(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    11f2 <func0+0xd2>\nmov    -0x8(%rbp),%rax\nmovslq -0x78(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmov    -0x78(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\njle    11df <func0+0xbf>\nmov    -0x8(%rbp),%rax\nmovslq -0x78(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x7c(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x78(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x8(%rbp),%rax\nmovslq -0x78(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x7c(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    -0x78(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    11e4 <func0+0xc4>\nmov    -0x78(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x78(%rbp)\njmp    116e <func0+0x4e>\njmp    11f7 <func0+0xd7>\nmov    -0x74(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x74(%rbp)\njmp    1156 <func0+0x36>\nmov    -0x20(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x74(%rbp)\ncmpl   $0x0,-0x74(%rbp)\njl     1264 <func0+0x144>\nmov    -0x8(%rbp),%rax\nmovslq -0x74(%rbp),%rcx\ncmpl   $0x1,(%rax,%rcx,4)\njl     1251 <func0+0x131>\nmov    -0x8(%rbp),%rax\nmovslq -0x74(%rbp),%rcx\ncmpl   $0x9,(%rax,%rcx,4)\njg     1251 <func0+0x131>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax)\njmp    1256 <func0+0x136>\nmov    -0x74(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x74(%rbp)\njmp    1218 <func0+0xf8>\nmov    -0x20(%rbp),%rax\nmovslq (%rax),%rdi\nshl    $0x3,%rdi\ncall   1040 <malloc@plt>\nmov    %rax,%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,(%rax)\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x74(%rbp)\nmovl   $0x0,-0x78(%rbp)\nxor    %eax,%eax\ncmpl   $0x0,-0x74(%rbp)\nmov    %al,-0x7d(%rbp)\njl     12ac <func0+0x18c>\nmov    -0x78(%rbp),%eax\nmov    -0x20(%rbp),%rcx\ncmp    (%rcx),%eax\nsetl   %al\nmov    %al,-0x7d(%rbp)\nmov    -0x7d(%rbp),%al\ntest   $0x1,%al\njne    12bc <func0+0x19c>\njmp    131d <func0+0x1fd>\nmov    -0x8(%rbp),%rax\nmovslq -0x74(%rbp),%rcx\ncmpl   $0x1,(%rax,%rcx,4)\njl     130a <func0+0x1ea>\nmov    -0x8(%rbp),%rax\nmovslq -0x74(%rbp),%rcx\ncmpl   $0x9,(%rax,%rcx,4)\njg     130a <func0+0x1ea>\nmov    -0x8(%rbp),%rax\nmovslq -0x74(%rbp),%rcx\nmovslq (%rax,%rcx,4),%rax\nmov    -0x70(%rbp,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x78(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x78(%rbp)\nmovslq %ecx,%rcx\nmov    %rdx,(%rax,%rcx,8)\njmp    130f <func0+0x1ef>\nmov    -0x74(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x74(%rbp)\njmp    128e <func0+0x16e>\nadd    $0x80,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 105,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%r13\ncmp    $0x2,%esi\njl     1186 <func0+0x76>\nlea    -0x1(%r15),%r8d\nxor    %r9d,%r9d\nmov    %r8d,%esi\njmp    114c <func0+0x3c>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x1,%r9d\nadd    $0xffffffff,%esi\ncmp    %r8d,%r9d\nje     1186 <func0+0x76>\nmov    %esi,%esi\nmov    %r9d,%eax\nnot    %eax\nadd    %r15d,%eax\ntest   %eax,%eax\njle    1140 <func0+0x30>\nxor    %edi,%edi\njmp    1168 <func0+0x58>\nxchg   %ax,%ax\nmov    %rax,%rdi\ncmp    %rax,%rsi\nje     1140 <func0+0x30>\nmov    0x0(%r13,%rdi,4),%edx\nmov    0x4(%r13,%rdi,4),%ebx\nlea    0x1(%rdi),%rax\ncmp    %ebx,%edx\njle    1160 <func0+0x50>\nmov    %ebx,0x0(%r13,%rdi,4)\nmov    %edx,0x4(%r13,%rdi,4)\njmp    1160 <func0+0x50>\nmovl   $0x0,(%rcx)\ntest   %r15d,%r15d\njle    11bc <func0+0xac>\nmovslq %r15d,%rax\nadd    $0x1,%rax\njmp    11aa <func0+0x9a>\nnopw   0x0(%rax,%rax,1)\nadd    $0xffffffffffffffff,%rax\ncmp    $0x1,%rax\njle    11bc <func0+0xac>\nmov    -0x8(%r13,%rax,4),%edx\nadd    $0xffffffff,%edx\ncmp    $0x8,%edx\nja     11a0 <func0+0x90>\naddl   $0x1,(%rcx)\njmp    11a0 <func0+0x90>\nmovslq (%rcx),%r12\nlea    0x0(,%r12,8),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,(%r14)\ntest   %r15d,%r15d\njle    1220 <func0+0x110>\ntest   %r12d,%r12d\njle    1220 <func0+0x110>\nmovslq %r15d,%rax\nxor    %ecx,%ecx\nlea    0xe4b(%rip),%rdx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovslq -0x4(%r13,%rax,4),%rsi\nlea    -0x1(%rsi),%edi\ncmp    $0x8,%edi\nja     1211 <func0+0x101>\nmovslq (%rdx,%rsi,4),%rsi\nadd    %rdx,%rsi\nmov    (%r14),%rdi\nmovslq %ecx,%rbx\nadd    $0x1,%ecx\nmov    %rsi,(%rdi,%rbx,8)\ncmp    $0x2,%rax\njl     1220 <func0+0x110>\nadd    $0xffffffffffffffff,%rax\ncmp    %r12d,%ecx\njl     11f0 <func0+0xe0>\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 105,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%rbx\nlea    -0x1(%r15),%r8d\ncmp    $0x2,%esi\njl     11e2 <func0+0xd2>\nxor    %r9d,%r9d\nmov    %r8d,%r10d\njmp    1151 <func0+0x41>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%r9d\nadd    $0xffffffff,%r10d\ncmp    %r8d,%r9d\nje     11e2 <func0+0xd2>\nmov    %r10d,%r10d\nmov    %r9d,%eax\nnot    %eax\nadd    %r15d,%eax\ntest   %eax,%eax\njle    1140 <func0+0x30>\nmov    (%rbx),%ebp\ncmp    $0x1,%r10d\njne    1190 <func0+0x80>\nxor    %edx,%edx\ntest   $0x1,%r10b\nje     1140 <func0+0x30>\nmov    0x4(%rbx,%rdx,4),%eax\ncmp    %eax,%ebp\njle    1140 <func0+0x30>\nmov    %eax,(%rbx,%rdx,4)\nmov    %ebp,0x4(%rbx,%rdx,4)\njmp    1140 <func0+0x30>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %r10d,%esi\nand    $0xfffffffe,%esi\nxor    %eax,%eax\njmp    11b0 <func0+0xa0>\nnopw   0x0(%rax,%rax,1)\nmov    %edi,0x4(%rbx,%rax,4)\nmov    %ebp,0x8(%rbx,%rax,4)\nmov    %rdx,%rax\ncmp    %rdx,%rsi\nje     116a <func0+0x5a>\nmov    0x4(%rbx,%rax,4),%edx\ncmp    %edx,%ebp\njle    11d0 <func0+0xc0>\nmov    %edx,(%rbx,%rax,4)\nmov    %ebp,0x4(%rbx,%rax,4)\njmp    11d2 <func0+0xc2>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %edx,%ebp\nlea    0x2(%rax),%rdx\nmov    0x8(%rbx,%rax,4),%edi\ncmp    %edi,%ebp\njg     11a0 <func0+0x90>\nmov    %edi,%ebp\njmp    11a8 <func0+0x98>\nmovl   $0x0,(%rcx)\nmov    %r8d,%r12d\ntest   %r15d,%r15d\njle    123d <func0+0x12d>\nlea    0x1(%r12),%rdx\ntest   %r8d,%r8d\nje     1241 <func0+0x131>\nmov    %rdx,%rsi\nand    $0xfffffffffffffffe,%rsi\nxor    %ebp,%ebp\nmov    %r12,%rax\njmp    121a <func0+0x10a>\nnopl   0x0(%rax,%rax,1)\nadd    $0xfffffffffffffffe,%rax\nadd    $0xfffffffffffffffe,%rsi\nje     1246 <func0+0x136>\nmov    (%rbx,%rax,4),%edi\nadd    $0xffffffff,%edi\ncmp    $0x8,%edi\nja     122a <func0+0x11a>\nadd    $0x1,%ebp\nmov    %ebp,(%rcx)\nmov    -0x4(%rbx,%rax,4),%edi\nadd    $0xffffffff,%edi\ncmp    $0x8,%edi\nja     1210 <func0+0x100>\nadd    $0x1,%ebp\nmov    %ebp,(%rcx)\njmp    1210 <func0+0x100>\nxor    %ebp,%ebp\njmp    125b <func0+0x14b>\nxor    %ebp,%ebp\nmov    %r12,%rax\ntest   $0x1,%dl\nje     125b <func0+0x14b>\nmov    (%rbx,%rax,4),%eax\nadd    $0xffffffff,%eax\ncmp    $0x8,%eax\nja     125b <func0+0x14b>\nadd    $0x1,%ebp\nmov    %ebp,(%rcx)\nmovslq %ebp,%rdi\nshl    $0x3,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,(%r14)\ntest   %r15d,%r15d\njle    12ad <func0+0x19d>\ntest   %ebp,%ebp\njle    12ad <func0+0x19d>\nxor    %eax,%eax\nlea    0xdb4(%rip),%rcx\nnopl   0x0(%rax)\nmov    (%rbx,%r12,4),%edx\nlea    -0x1(%rdx),%esi\ncmp    $0x8,%esi\nja     12a0 <func0+0x190>\nmovslq (%rcx,%rdx,4),%rdx\nadd    %rcx,%rdx\nmov    (%r14),%rsi\nmovslq %eax,%rdi\nadd    $0x1,%eax\nmov    %rdx,(%rsi,%rdi,8)\ntest   %r12,%r12\njle    12ad <func0+0x19d>\nadd    $0xffffffffffffffff,%r12\ncmp    %ebp,%eax\njl     1280 <func0+0x170>\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 105,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdx,%r14\nmov    %esi,%r15d\nmov    %rdi,%rbx\nlea    -0x1(%r15),%r8d\ncmp    $0x2,%esi\njl     11ea <func0+0xda>\nxor    %r9d,%r9d\nmov    %r8d,%r10d\njmp    1151 <func0+0x41>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%r9d\nadd    $0xffffffff,%r10d\ncmp    %r8d,%r9d\nje     11ea <func0+0xda>\nmov    %r10d,%r10d\nmov    %r9d,%eax\nnot    %eax\nadd    %r15d,%eax\ntest   %eax,%eax\njle    1140 <func0+0x30>\nmov    (%rbx),%ebp\ncmp    $0x1,%r10d\njne    1170 <func0+0x60>\nxor    %edx,%edx\njmp    11c8 <func0+0xb8>\nnopl   0x0(%rax)\nmov    %r10d,%esi\nand    $0xfffffffe,%esi\nxor    %eax,%eax\njmp    1190 <func0+0x80>\nnopw   0x0(%rax,%rax,1)\nmov    %edi,0x4(%rbx,%rax,4)\nmov    %ebp,0x8(%rbx,%rax,4)\nmov    %rdx,%rax\ncmp    %rdx,%rsi\nje     11c8 <func0+0xb8>\nmov    0x4(%rbx,%rax,4),%edx\ncmp    %edx,%ebp\njle    11b0 <func0+0xa0>\nmov    %edx,(%rbx,%rax,4)\nmov    %ebp,0x4(%rbx,%rax,4)\nlea    0x2(%rax),%rdx\nmov    0x8(%rbx,%rax,4),%edi\ncmp    %edi,%ebp\njg     1180 <func0+0x70>\njmp    11be <func0+0xae>\nnopl   (%rax)\nmov    %edx,%ebp\nlea    0x2(%rax),%rdx\nmov    0x8(%rbx,%rax,4),%edi\ncmp    %edi,%ebp\njg     1180 <func0+0x70>\nmov    %edi,%ebp\nmov    %rdx,%rax\ncmp    %rdx,%rsi\njne    1190 <func0+0x80>\ntest   $0x1,%r10b\nje     1140 <func0+0x30>\nmov    0x4(%rbx,%rdx,4),%eax\ncmp    %eax,%ebp\njle    1140 <func0+0x30>\nmov    %eax,(%rbx,%rdx,4)\nmov    %ebp,0x4(%rbx,%rdx,4)\njmp    1140 <func0+0x30>\nmovl   $0x0,(%rcx)\nmov    %r8d,%r12d\ntest   %r15d,%r15d\njle    1258 <func0+0x148>\nlea    0x1(%r12),%rdx\ntest   %r8d,%r8d\nje     125c <func0+0x14c>\nmov    %rdx,%rsi\nand    $0xfffffffffffffffe,%rsi\nxor    %ebp,%ebp\nmov    %r12,%rax\njmp    121a <func0+0x10a>\nadd    $0xfffffffffffffffe,%rax\nadd    $0xfffffffffffffffe,%rsi\nje     1261 <func0+0x151>\nmov    (%rbx,%rax,4),%edi\nadd    $0xffffffff,%edi\ncmp    $0x8,%edi\njbe    1240 <func0+0x130>\nmov    -0x4(%rbx,%rax,4),%edi\nadd    $0xffffffff,%edi\ncmp    $0x8,%edi\nja     1210 <func0+0x100>\njmp    1251 <func0+0x141>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x1,%ebp\nmov    %ebp,(%rcx)\nmov    -0x4(%rbx,%rax,4),%edi\nadd    $0xffffffff,%edi\ncmp    $0x8,%edi\nja     1210 <func0+0x100>\nadd    $0x1,%ebp\nmov    %ebp,(%rcx)\njmp    1210 <func0+0x100>\nxor    %ebp,%ebp\njmp    1276 <func0+0x166>\nxor    %ebp,%ebp\nmov    %r12,%rax\ntest   $0x1,%dl\nje     1276 <func0+0x166>\nmov    (%rbx,%rax,4),%eax\nadd    $0xffffffff,%eax\ncmp    $0x8,%eax\nja     1276 <func0+0x166>\nadd    $0x1,%ebp\nmov    %ebp,(%rcx)\nmovslq %ebp,%rdi\nshl    $0x3,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,(%r14)\ntest   %r15d,%r15d\njle    12cd <func0+0x1bd>\ntest   %ebp,%ebp\njle    12cd <func0+0x1bd>\nxor    %eax,%eax\nlea    0xd99(%rip),%rcx\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx,%r12,4),%edx\nlea    -0x1(%rdx),%esi\ncmp    $0x8,%esi\nja     12c0 <func0+0x1b0>\nmovslq (%rcx,%rdx,4),%rdx\nadd    %rcx,%rdx\nmov    (%r14),%rsi\nmovslq %eax,%rdi\nadd    $0x1,%eax\nmov    %rdx,(%rsi,%rdi,8)\ntest   %r12,%r12\njle    12cd <func0+0x1bd>\nadd    $0xffffffffffffffff,%r12\ncmp    %ebp,%eax\njl     12a0 <func0+0x190>\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 106,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x4(%rbp)\nmovslq -0x4(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x1,-0x18(%rbp)\nmovl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     11b2 <func0+0xa2>\nmov    -0x1c(%rbp),%eax\nadd    -0x14(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x1c(%rbp),%eax\nimul   -0x18(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    118c <func0+0x7c>\nmov    -0x18(%rbp),%edx\nmov    -0x10(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    119f <func0+0x8f>\nmov    -0x14(%rbp),%edx\nmov    -0x10(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    11a4 <func0+0x94>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1141 <func0+0x31>\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 106,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %edi,%ebx\nmovslq %edi,%r14\nlea    0x0(,%r14,4),%rdi\ncall   1030 <malloc@plt>\ntest   %r14d,%r14d\njle    115b <func0+0x4b>\nadd    $0x1,%ebx\nxor    %ecx,%ecx\nmov    $0x1,%edx\nmov    $0x1,%esi\nnopw   0x0(%rax,%rax,1)\nadd    %esi,%ecx\nimul   %esi,%edx\ntest   $0x1,%sil\nmov    %ecx,%edi\ncmove  %edx,%edi\nmov    %edi,-0x4(%rax,%rsi,4)\nadd    $0x1,%rsi\ncmp    %rsi,%rbx\njne    1140 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 106,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %edi,%ebp\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\njle    11a2 <func0+0x92>\nmov    %ebp,%r8d\ncmp    $0x1,%ebp\njne    113f <func0+0x2f>\nxor    %edx,%edx\nmov    $0x1,%esi\nmov    $0x1,%edi\njmp    118c <func0+0x7c>\nmov    %r8d,%ecx\nand    $0xfffffffe,%ecx\nneg    %rcx\nxor    %edx,%edx\nmov    $0x1,%esi\nmov    $0x1,%edi\nmov    $0x2,%ebx\nnopl   0x0(%rax)\nlea    -0x1(%rbx),%ebp\nadd    %ebx,%edx\nadd    $0xffffffff,%edx\nmov    %edx,-0x4(%rax,%rdi,4)\nadd    %ebx,%edx\nimul   %ebx,%esi\nimul   %ebp,%esi\nmov    %esi,(%rax,%rdi,4)\nadd    $0x2,%ebx\nlea    (%rcx,%rdi,1),%rbp\nadd    $0x2,%rbp\nadd    $0x2,%rdi\ncmp    $0x1,%rbp\njne    1160 <func0+0x50>\ntest   $0x1,%r8b\nje     11a2 <func0+0x92>\nadd    %edi,%edx\nimul   %edi,%esi\ntest   $0x1,%dil\ncmovne %edx,%esi\nmov    %esi,-0x4(%rax,%rdi,4)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 106,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %edi,%ebp\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\njle    11a2 <func0+0x92>\nmov    %ebp,%r8d\ncmp    $0x1,%ebp\njne    113f <func0+0x2f>\nxor    %edx,%edx\nmov    $0x1,%esi\nmov    $0x1,%edi\njmp    118c <func0+0x7c>\nmov    %r8d,%ecx\nand    $0xfffffffe,%ecx\nneg    %rcx\nxor    %edx,%edx\nmov    $0x1,%esi\nmov    $0x1,%edi\nmov    $0x2,%ebx\nnopl   0x0(%rax)\nlea    -0x1(%rbx),%ebp\nadd    %ebx,%edx\nadd    $0xffffffff,%edx\nmov    %edx,-0x4(%rax,%rdi,4)\nadd    %ebx,%edx\nimul   %ebx,%esi\nimul   %ebp,%esi\nmov    %esi,(%rax,%rdi,4)\nadd    $0x2,%ebx\nlea    (%rcx,%rdi,1),%rbp\nadd    $0x2,%rbp\nadd    $0x2,%rdi\ncmp    $0x1,%rbp\njne    1160 <func0+0x50>\ntest   $0x1,%r8b\nje     11a2 <func0+0x92>\nadd    %edi,%edx\nimul   %edi,%esi\ntest   $0x1,%dil\ncmovne %edx,%esi\nmov    %esi,-0x4(%rax,%rdi,4)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 107,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x4(%rbp)\nmov    $0x8,%edi\ncall   1030 <malloc@plt>\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x10(%rbp),%rax\nmovl   $0x0,0x4(%rax)\nmovl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     11f0 <func0+0xe0>\nmovl   $0x0,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x20(%rbp)\ncmpl   $0x0,-0x20(%rbp)\nje     119b <func0+0x8b>\nimul   $0xa,-0x18(%rbp),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x20(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x20(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x20(%rbp)\njmp    1164 <func0+0x54>\nmov    -0x1c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njne    11dd <func0+0xcd>\nmov    -0x1c(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    11cb <func0+0xbb>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax)\njmp    11d8 <func0+0xc8>\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%ecx\nadd    $0x1,%ecx\nmov    %ecx,0x4(%rax)\njmp    11dd <func0+0xcd>\njmp    11e2 <func0+0xd2>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1145 <func0+0x35>\nmov    -0x10(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 107,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %edi,%r14d\nmov    $0x8,%edi\ncall   1030 <malloc@plt>\nmovq   $0x0,(%rax)\ntest   %r14d,%r14d\njle    118e <func0+0x7e>\nmov    $0x1,%ecx\njmp    114a <func0+0x3a>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nlea    0x1(%rcx),%edx\ncmp    %r14d,%ecx\nmov    %edx,%ecx\nje     118e <func0+0x7e>\nxor    %esi,%esi\nmov    %ecx,%edx\nxchg   %ax,%ax\nlea    (%rsi,%rsi,4),%esi\nmovslq %edx,%rbp\nimul   $0x66666667,%rbp,%rdx\nmov    %rdx,%rbx\nshr    $0x3f,%rbx\nsar    $0x22,%rdx\nadd    %ebx,%edx\nlea    (%rdx,%rdx,1),%ebx\nlea    (%rbx,%rbx,4),%ebx\nmov    %ebp,%edi\nsub    %ebx,%edi\nlea    (%rdi,%rsi,2),%esi\nadd    $0x9,%ebp\ncmp    $0x12,%ebp\nja     1150 <func0+0x40>\ncmp    %esi,%ecx\njne    1140 <func0+0x30>\nmov    %ecx,%edx\nand    $0x1,%edx\naddl   $0x1,(%rax,%rdx,4)\njmp    1140 <func0+0x30>\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 107,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %edi,%r14d\nmov    $0x8,%edi\ncall   1030 <malloc@plt>\nmovq   $0x0,(%rax)\ntest   %r14d,%r14d\njle    11a2 <func0+0x92>\nmov    $0x1,%esi\nxor    %r8d,%r8d\nxor    %r9d,%r9d\njmp    1152 <func0+0x42>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%r9d\nmov    %r9d,0x4(%rax)\nlea    0x1(%rsi),%ecx\ncmp    %r14d,%esi\nmov    %ecx,%esi\nje     11a2 <func0+0x92>\nmov    %esi,%edi\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nlea    (%rcx,%rcx,4),%ecx\nmovslq %edi,%rbp\nimul   $0x66666667,%rbp,%rdi\nmov    %rdi,%rbx\nshr    $0x3f,%rbx\nsar    $0x22,%rdi\nadd    %ebx,%edi\nlea    (%rdi,%rdi,1),%ebx\nlea    (%rbx,%rbx,4),%ebx\nmov    %ebp,%edx\nsub    %ebx,%edx\nlea    (%rdx,%rcx,2),%ecx\nadd    $0x9,%ebp\ncmp    $0x12,%ebp\nja     1160 <func0+0x50>\ncmp    %ecx,%esi\njne    1148 <func0+0x38>\ntest   $0x1,%sil\njne    1140 <func0+0x30>\nadd    $0x1,%r8d\nmov    %r8d,(%rax)\njmp    1148 <func0+0x38>\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 107,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %edi,%r14d\nmov    $0x8,%edi\ncall   1030 <malloc@plt>\nmovq   $0x0,(%rax)\ntest   %r14d,%r14d\njle    11a2 <func0+0x92>\nmov    $0x1,%esi\nxor    %r8d,%r8d\nxor    %r9d,%r9d\njmp    1152 <func0+0x42>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%r9d\nmov    %r9d,0x4(%rax)\nlea    0x1(%rsi),%ecx\ncmp    %r14d,%esi\nmov    %ecx,%esi\nje     11a2 <func0+0x92>\nmov    %esi,%edi\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nlea    (%rcx,%rcx,4),%ecx\nmovslq %edi,%rbp\nimul   $0x66666667,%rbp,%rdi\nmov    %rdi,%rbx\nshr    $0x3f,%rbx\nsar    $0x22,%rdi\nadd    %ebx,%edi\nlea    (%rdi,%rdi,1),%ebx\nlea    (%rbx,%rbx,4),%ebx\nmov    %ebp,%edx\nsub    %ebx,%edx\nlea    (%rdx,%rcx,2),%ecx\nadd    $0x9,%ebp\ncmp    $0x12,%ebp\nja     1160 <func0+0x50>\ncmp    %ecx,%esi\njne    1148 <func0+0x38>\ntest   $0x1,%sil\njne    1140 <func0+0x30>\nadd    $0x1,%r8d\nmov    %r8d,(%rax)\njmp    1148 <func0+0x38>\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 108,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11d7 <func0+0xc7>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\ncmpl   $0x0,(%rax,%rcx,4)\njle    1159 <func0+0x49>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    11c4 <func0+0xb4>\nmovl   $0x0,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,4),%edi\ncall   1030 <abs@plt>\nmov    %eax,-0x1c(%rbp)\ncmpl   $0xa,-0x1c(%rbp)\njl     11a1 <func0+0x91>\nmov    -0x1c(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nadd    -0x18(%rbp),%edx\nmov    %edx,-0x18(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x1c(%rbp)\njmp    1173 <func0+0x63>\nmov    -0x1c(%rbp),%ecx\nmov    -0x18(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njle    11bf <func0+0xaf>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    11c4 <func0+0xb4>\njmp    11c9 <func0+0xb9>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    112d <func0+0x1d>\nmov    -0x10(%rbp),%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 108,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    117d <func0+0x7d>\nmov    %esi,%r8d\nxor    %r9d,%r9d\nxor    %eax,%eax\njmp    1123 <func0+0x23>\nxchg   %ax,%ax\nxor    %edx,%edx\ncmp    %esi,%r11d\nsetg   %dl\nadd    %edx,%eax\nadd    $0x1,%r9\ncmp    %r8,%r9\nje     117f <func0+0x7f>\nmov    (%rdi,%r9,4),%r10d\nmov    $0x1,%edx\ntest   %r10d,%r10d\njg     1118 <func0+0x18>\nmov    %r10d,%esi\nneg    %esi\nxor    %r11d,%r11d\ncmp    $0xfffffff6,%r10d\njg     1110 <func0+0x10>\nxor    %r11d,%r11d\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovslq %esi,%rdx\nimul   $0x66666667,%rdx,%rsi\nmov    %rsi,%rcx\nshr    $0x3f,%rcx\nsar    $0x22,%rsi\nadd    %ecx,%esi\nlea    (%rsi,%rsi,1),%ecx\nlea    (%rcx,%rcx,4),%r10d\nmov    %edx,%ecx\nsub    %r10d,%ecx\nadd    %ecx,%r11d\ncmp    $0x63,%edx\njg     1150 <func0+0x50>\njmp    1110 <func0+0x10>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 108,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ntest   %esi,%esi\njle    1170 <func0+0x70>\nmov    %esi,%r8d\nxor    %r10d,%r10d\nmov    $0xcccccccd,%r9d\nxor    %eax,%eax\njmp    112b <func0+0x2b>\nmov    %esi,%edx\nxor    %esi,%esi\ncmp    %edx,%r11d\nsetg   %sil\nadd    %esi,%eax\nadd    $0x1,%r10\ncmp    %r8,%r10\nje     1172 <func0+0x72>\nmov    (%rdi,%r10,4),%edx\nmov    $0x1,%esi\ntest   %edx,%edx\njg     1120 <func0+0x20>\nmov    %edx,%esi\nneg    %esi\nxor    %r11d,%r11d\ncmp    $0xfffffff6,%edx\njg     1115 <func0+0x15>\nxor    %r11d,%r11d\nnopw   0x0(%rax,%rax,1)\nmov    %esi,%edx\nimul   %r9,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,1),%ecx\nlea    (%rcx,%rcx,4),%ecx\nmov    %esi,%ebx\nsub    %ecx,%ebx\nadd    %ebx,%r11d\ncmp    $0x63,%esi\nmov    %edx,%esi\nja     1150 <func0+0x50>\njmp    1117 <func0+0x17>\nxor    %eax,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 108,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ntest   %esi,%esi\njle    1170 <func0+0x70>\nmov    %esi,%r8d\nxor    %r10d,%r10d\nmov    $0xcccccccd,%r9d\nxor    %eax,%eax\njmp    112b <func0+0x2b>\nmov    %esi,%edx\nxor    %esi,%esi\ncmp    %edx,%r11d\nsetg   %sil\nadd    %esi,%eax\nadd    $0x1,%r10\ncmp    %r8,%r10\nje     1172 <func0+0x72>\nmov    (%rdi,%r10,4),%edx\nmov    $0x1,%esi\ntest   %edx,%edx\njg     1120 <func0+0x20>\nmov    %edx,%esi\nneg    %esi\nxor    %r11d,%r11d\ncmp    $0xfffffff6,%edx\njg     1115 <func0+0x15>\nxor    %r11d,%r11d\nnopw   0x0(%rax,%rax,1)\nmov    %esi,%edx\nimul   %r9,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,1),%ecx\nlea    (%rcx,%rcx,4),%ecx\nmov    %esi,%ebx\nsub    %ecx,%ebx\nadd    %ebx,%r11d\ncmp    $0x63,%esi\nmov    %edx,%esi\nja     1150 <func0+0x50>\njmp    1117 <func0+0x17>\nxor    %eax,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 109,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1125 <func0+0x25>\nmovb   $0x1,-0x1(%rbp)\njmp    11b1 <func0+0xb1>\nmovl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1175 <func0+0x75>\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x1c(%rbp),%edx\nsub    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\njge    1162 <func0+0x62>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1167 <func0+0x67>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    112c <func0+0x2c>\nmov    -0x10(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x10(%rbp),%rcx\ncmp    (%rcx),%eax\njle    119a <func0+0x9a>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\ncmpl   $0x2,-0x18(%rbp)\njge    11ad <func0+0xad>\nmovb   $0x1,-0x1(%rbp)\njmp    11b1 <func0+0xb1>\nmovb   $0x0,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 109,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\nje     1150 <func0+0x50>\nxor    %eax,%eax\ncmp    $0x2,%esi\njl     1139 <func0+0x39>\nmov    %esi,%r8d\nxor    %eax,%eax\nmov    $0x1,%edx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    (%rdi,%rdx,4),%r9d\nxor    %ecx,%ecx\ncmp    -0x4(%rdi,%rdx,4),%r9d\nsetl   %cl\nadd    %ecx,%eax\nadd    $0x1,%rdx\ncmp    %rdx,%r8\njne    1120 <func0+0x20>\nmovslq %esi,%rcx\nmov    -0x4(%rdi,%rcx,4),%ecx\nxor    %edx,%edx\ncmp    (%rdi),%ecx\nsetg   %dl\nadd    %eax,%edx\ncmp    $0x2,%edx\nsetb   %al\nret\nmov    $0x1,%al\nret\n"
    },
    {
        "task_id": 109,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\nje     112a <func0+0x2a>\npush   %rbx\ncmp    $0x1,%esi\njle    112d <func0+0x2d>\nmov    %esi,%r10d\nmov    (%rdi),%r8d\nlea    -0x1(%r10),%r9\ncmp    $0x8,%r9\njae    1137 <func0+0x37>\nxor    %ebx,%ebx\nmov    $0x1,%r11d\nmov    %r8d,%edx\njmp    11c0 <func0+0xc0>\nmov    $0x1,%al\nret\nmov    (%rdi),%r8d\nxor    %ebx,%ebx\njmp    11d8 <func0+0xd8>\nmov    %r9,%rcx\nand    $0xfffffffffffffff8,%rcx\nlea    0x1(%rcx),%r11\nmovd   %r8d,%xmm0\npshufd $0x0,%xmm0,%xmm2\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npxor   %xmm1,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nmovups 0x4(%rdi,%rax,4),%xmm3\nshufps $0x3,%xmm3,%xmm2\nshufps $0x98,%xmm3,%xmm2\npcmpgtd %xmm3,%xmm2\npsubd  %xmm2,%xmm0\nmovups 0x14(%rdi,%rax,4),%xmm2\nshufps $0x3,%xmm2,%xmm3\nshufps $0x98,%xmm2,%xmm3\npcmpgtd %xmm2,%xmm3\npsubd  %xmm3,%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rcx\njne    1160 <func0+0x60>\npaddd  %xmm0,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%ebx\ncmp    %rcx,%r9\nje     11d8 <func0+0xd8>\npshufd $0xff,%xmm2,%xmm0\nmovd   %xmm0,%edx\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi,%r11,4),%ecx\nxor    %eax,%eax\ncmp    %edx,%ecx\nsetl   %al\nadd    %eax,%ebx\nadd    $0x1,%r11\nmov    %ecx,%edx\ncmp    %r11,%r10\njne    11c0 <func0+0xc0>\nmovslq %esi,%rcx\nxor    %edx,%edx\ncmp    %r8d,-0x4(%rdi,%rcx,4)\nsetg   %dl\nadd    %ebx,%edx\ncmp    $0x2,%edx\nsetb   %al\npop    %rbx\nret\n"
    },
    {
        "task_id": 109,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\nje     112a <func0+0x2a>\npush   %rbx\ncmp    $0x1,%esi\njle    112d <func0+0x2d>\nmov    %esi,%r10d\nmov    (%rdi),%r8d\nlea    -0x1(%r10),%r9\ncmp    $0x8,%r9\njae    1137 <func0+0x37>\nxor    %ebx,%ebx\nmov    $0x1,%r11d\nmov    %r8d,%edx\njmp    11c0 <func0+0xc0>\nmov    $0x1,%al\nret\nmov    (%rdi),%r8d\nxor    %ebx,%ebx\njmp    11d8 <func0+0xd8>\nmov    %r9,%rcx\nand    $0xfffffffffffffff8,%rcx\nlea    0x1(%rcx),%r11\nmovd   %r8d,%xmm0\npshufd $0x0,%xmm0,%xmm2\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npxor   %xmm1,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nmovups 0x4(%rdi,%rax,4),%xmm3\nshufps $0x3,%xmm3,%xmm2\nshufps $0x98,%xmm3,%xmm2\npcmpgtd %xmm3,%xmm2\npsubd  %xmm2,%xmm0\nmovups 0x14(%rdi,%rax,4),%xmm2\nshufps $0x3,%xmm2,%xmm3\nshufps $0x98,%xmm2,%xmm3\npcmpgtd %xmm2,%xmm3\npsubd  %xmm3,%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rcx\njne    1160 <func0+0x60>\npaddd  %xmm0,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%ebx\ncmp    %rcx,%r9\nje     11d8 <func0+0xd8>\npshufd $0xff,%xmm2,%xmm0\nmovd   %xmm0,%edx\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi,%r11,4),%ecx\nxor    %eax,%eax\ncmp    %edx,%ecx\nsetl   %al\nadd    %eax,%ebx\nadd    $0x1,%r11\nmov    %ecx,%edx\ncmp    %r11,%r10\njne    11c0 <func0+0xc0>\nmovslq %esi,%rcx\nxor    %edx,%edx\ncmp    %r8d,-0x4(%rdi,%rcx,4)\nsetg   %dl\nadd    %ebx,%edx\ncmp    $0x2,%edx\nsetb   %al\npop    %rbx\nret\n"
    },
    {
        "task_id": 110,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\nmov    %rdx,-0x20(%rbp)\nmov    %ecx,-0x24(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1164 <func0+0x64>\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    1151 <func0+0x51>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    1156 <func0+0x56>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1120 <func0+0x20>\nmovl   $0x0,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njge    11af <func0+0xaf>\nmov    -0x20(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    119c <func0+0x9c>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    11a1 <func0+0xa1>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    116b <func0+0x6b>\nmov    -0x28(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     11cb <func0+0xcb>\nlea    0xe3e(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    11d6 <func0+0xd6>\nlea    0xe32(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 110,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    112b <func0+0x2b>\nmov    %esi,%r8d\nxor    %r10d,%r10d\nxor    %r9d,%r9d\nnopl   (%rax)\nmov    (%rdi,%r10,4),%eax\nnot    %eax\nand    $0x1,%eax\nadd    %eax,%r9d\nadd    $0x1,%r10\ncmp    %r10,%r8\njne    1110 <func0+0x10>\ntest   %ecx,%ecx\njg     1132 <func0+0x32>\njmp    1154 <func0+0x54>\nxor    %r9d,%r9d\ntest   %ecx,%ecx\njle    1154 <func0+0x54>\nmov    %ecx,%ecx\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nmov    (%rdx,%rax,4),%edi\nnot    %edi\nand    $0x1,%edi\nadd    %edi,%r9d\nadd    $0x1,%rax\ncmp    %rax,%rcx\njne    1140 <func0+0x40>\ncmp    %esi,%r9d\nlea    0xea6(%rip),%rcx\nlea    0xe9b(%rip),%rax\ncmovl  %rcx,%rax\nret\n"
    },
    {
        "task_id": 110,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1117 <func0+0x17>\nmov    %esi,%r8d\ncmp    $0x8,%esi\njae    111f <func0+0x1f>\nxor    %r9d,%r9d\nxor    %r10d,%r10d\njmp    1200 <func0+0x100>\nxor    %r10d,%r10d\njmp    1215 <func0+0x115>\nmov    %r8d,%r9d\nand    $0xfffffff8,%r9d\nlea    -0x8(%r9),%rax\nmov    %rax,%r10\nshr    $0x3,%r10\nadd    $0x1,%r10\ntest   %rax,%rax\nje     133a <func0+0x23a>\nmov    %r10,%r11\nand    $0xfffffffffffffffe,%r11\npxor   %xmm3,%xmm3\nxor    %eax,%eax\nmovdqa 0xead(%rip),%xmm2\npxor   %xmm4,%xmm4\nnopw   0x0(%rax,%rax,1)\nmovdqu (%rdi,%rax,4),%xmm5\nmovdqu 0x10(%rdi,%rax,4),%xmm6\nmovdqu 0x20(%rdi,%rax,4),%xmm0\nmovdqu 0x30(%rdi,%rax,4),%xmm1\npandn  %xmm2,%xmm5\npaddd  %xmm3,%xmm5\npandn  %xmm2,%xmm6\npaddd  %xmm4,%xmm6\npandn  %xmm2,%xmm0\npaddd  %xmm5,%xmm0\npandn  %xmm2,%xmm1\npaddd  %xmm6,%xmm1\nadd    $0x10,%rax\nmovdqa %xmm0,%xmm3\nmovdqa %xmm1,%xmm4\nadd    $0xfffffffffffffffe,%r11\njne    1160 <func0+0x60>\ntest   $0x1,%r10b\nje     11d2 <func0+0xd2>\nmovdqu (%rdi,%rax,4),%xmm2\nmovdqu 0x10(%rdi,%rax,4),%xmm3\nmovdqa 0xe3e(%rip),%xmm4\npandn  %xmm4,%xmm2\npaddd  %xmm2,%xmm0\npandn  %xmm4,%xmm3\npaddd  %xmm3,%xmm1\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%r10d\ncmp    %r8,%r9\nje     1215 <func0+0x115>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    (%rdi,%r9,4),%eax\nnot    %eax\nand    $0x1,%eax\nadd    %eax,%r10d\nadd    $0x1,%r9\ncmp    %r9,%r8\njne    1200 <func0+0x100>\ntest   %ecx,%ecx\njle    1324 <func0+0x224>\nmov    %ecx,%r9d\ncmp    $0x8,%ecx\njae    122c <func0+0x12c>\nxor    %ecx,%ecx\njmp    1310 <func0+0x210>\nmov    %r9d,%ecx\nand    $0xfffffff8,%ecx\nmovd   %r10d,%xmm0\nlea    -0x8(%rcx),%rax\nmov    %rax,%r8\nshr    $0x3,%r8\nadd    $0x1,%r8\ntest   %rax,%rax\nje     1353 <func0+0x253>\nmov    %r8,%rdi\nand    $0xfffffffffffffffe,%rdi\npxor   %xmm3,%xmm3\nxor    %eax,%eax\nmovdqa 0xd9c(%rip),%xmm2\nmovdqa %xmm0,%xmm4\nnopl   0x0(%rax,%rax,1)\nmovdqu (%rdx,%rax,4),%xmm5\nmovdqu 0x10(%rdx,%rax,4),%xmm6\nmovdqu 0x20(%rdx,%rax,4),%xmm0\nmovdqu 0x30(%rdx,%rax,4),%xmm1\npandn  %xmm2,%xmm5\npaddd  %xmm4,%xmm5\npandn  %xmm2,%xmm6\npaddd  %xmm3,%xmm6\npandn  %xmm2,%xmm0\npaddd  %xmm5,%xmm0\npandn  %xmm2,%xmm1\npaddd  %xmm6,%xmm1\nadd    $0x10,%rax\nmovdqa %xmm0,%xmm4\nmovdqa %xmm1,%xmm3\nadd    $0xfffffffffffffffe,%rdi\njne    1270 <func0+0x170>\ntest   $0x1,%r8b\nje     12e2 <func0+0x1e2>\nmovdqu (%rdx,%rax,4),%xmm2\nmovdqu 0x10(%rdx,%rax,4),%xmm3\nmovdqa 0xd2e(%rip),%xmm4\npandn  %xmm4,%xmm2\npaddd  %xmm2,%xmm0\npandn  %xmm4,%xmm3\npaddd  %xmm3,%xmm1\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%r10d\ncmp    %r9,%rcx\nje     1324 <func0+0x224>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    (%rdx,%rcx,4),%eax\nnot    %eax\nand    $0x1,%eax\nadd    %eax,%r10d\nadd    $0x1,%rcx\ncmp    %rcx,%r9\njne    1310 <func0+0x210>\ncmp    %esi,%r10d\nlea    0xce6(%rip),%rcx\nlea    0xcdb(%rip),%rax\ncmovl  %rcx,%rax\nret\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npxor   %xmm1,%xmm1\ntest   $0x1,%r10b\njne    11af <func0+0xaf>\njmp    11d2 <func0+0xd2>\npxor   %xmm1,%xmm1\nxor    %eax,%eax\ntest   $0x1,%r8b\njne    12bf <func0+0x1bf>\njmp    12e2 <func0+0x1e2>\n"
    },
    {
        "task_id": 110,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1117 <func0+0x17>\nmov    %esi,%r8d\ncmp    $0x8,%esi\njae    111f <func0+0x1f>\nxor    %r9d,%r9d\nxor    %r10d,%r10d\njmp    1200 <func0+0x100>\nxor    %r10d,%r10d\njmp    1215 <func0+0x115>\nmov    %r8d,%r9d\nand    $0xfffffff8,%r9d\nlea    -0x8(%r9),%rax\nmov    %rax,%r10\nshr    $0x3,%r10\nadd    $0x1,%r10\ntest   %rax,%rax\nje     133a <func0+0x23a>\nmov    %r10,%r11\nand    $0xfffffffffffffffe,%r11\npxor   %xmm3,%xmm3\nxor    %eax,%eax\nmovdqa 0xead(%rip),%xmm2\npxor   %xmm4,%xmm4\nnopw   0x0(%rax,%rax,1)\nmovdqu (%rdi,%rax,4),%xmm5\nmovdqu 0x10(%rdi,%rax,4),%xmm6\nmovdqu 0x20(%rdi,%rax,4),%xmm0\nmovdqu 0x30(%rdi,%rax,4),%xmm1\npandn  %xmm2,%xmm5\npaddd  %xmm3,%xmm5\npandn  %xmm2,%xmm6\npaddd  %xmm4,%xmm6\npandn  %xmm2,%xmm0\npaddd  %xmm5,%xmm0\npandn  %xmm2,%xmm1\npaddd  %xmm6,%xmm1\nadd    $0x10,%rax\nmovdqa %xmm0,%xmm3\nmovdqa %xmm1,%xmm4\nadd    $0xfffffffffffffffe,%r11\njne    1160 <func0+0x60>\ntest   $0x1,%r10b\nje     11d2 <func0+0xd2>\nmovdqu (%rdi,%rax,4),%xmm2\nmovdqu 0x10(%rdi,%rax,4),%xmm3\nmovdqa 0xe3e(%rip),%xmm4\npandn  %xmm4,%xmm2\npaddd  %xmm2,%xmm0\npandn  %xmm4,%xmm3\npaddd  %xmm3,%xmm1\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%r10d\ncmp    %r8,%r9\nje     1215 <func0+0x115>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    (%rdi,%r9,4),%eax\nnot    %eax\nand    $0x1,%eax\nadd    %eax,%r10d\nadd    $0x1,%r9\ncmp    %r9,%r8\njne    1200 <func0+0x100>\ntest   %ecx,%ecx\njle    1324 <func0+0x224>\nmov    %ecx,%r9d\ncmp    $0x8,%ecx\njae    122c <func0+0x12c>\nxor    %ecx,%ecx\njmp    1310 <func0+0x210>\nmov    %r9d,%ecx\nand    $0xfffffff8,%ecx\nmovd   %r10d,%xmm0\nlea    -0x8(%rcx),%rax\nmov    %rax,%r8\nshr    $0x3,%r8\nadd    $0x1,%r8\ntest   %rax,%rax\nje     1353 <func0+0x253>\nmov    %r8,%rdi\nand    $0xfffffffffffffffe,%rdi\npxor   %xmm3,%xmm3\nxor    %eax,%eax\nmovdqa 0xd9c(%rip),%xmm2\nmovdqa %xmm0,%xmm4\nnopl   0x0(%rax,%rax,1)\nmovdqu (%rdx,%rax,4),%xmm5\nmovdqu 0x10(%rdx,%rax,4),%xmm6\nmovdqu 0x20(%rdx,%rax,4),%xmm0\nmovdqu 0x30(%rdx,%rax,4),%xmm1\npandn  %xmm2,%xmm5\npaddd  %xmm4,%xmm5\npandn  %xmm2,%xmm6\npaddd  %xmm3,%xmm6\npandn  %xmm2,%xmm0\npaddd  %xmm5,%xmm0\npandn  %xmm2,%xmm1\npaddd  %xmm6,%xmm1\nadd    $0x10,%rax\nmovdqa %xmm0,%xmm4\nmovdqa %xmm1,%xmm3\nadd    $0xfffffffffffffffe,%rdi\njne    1270 <func0+0x170>\ntest   $0x1,%r8b\nje     12e2 <func0+0x1e2>\nmovdqu (%rdx,%rax,4),%xmm2\nmovdqu 0x10(%rdx,%rax,4),%xmm3\nmovdqa 0xd2e(%rip),%xmm4\npandn  %xmm4,%xmm2\npaddd  %xmm2,%xmm0\npandn  %xmm4,%xmm3\npaddd  %xmm3,%xmm1\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%r10d\ncmp    %r9,%rcx\nje     1324 <func0+0x224>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    (%rdx,%rcx,4),%eax\nnot    %eax\nand    $0x1,%eax\nadd    %eax,%r10d\nadd    $0x1,%rcx\ncmp    %rcx,%r9\njne    1310 <func0+0x210>\ncmp    %esi,%r10d\nlea    0xce6(%rip),%rcx\nlea    0xcdb(%rip),%rax\ncmovl  %rcx,%rax\nret\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npxor   %xmm1,%xmm1\ntest   $0x1,%r10b\njne    11af <func0+0xaf>\njmp    11d2 <func0+0xd2>\npxor   %xmm1,%xmm1\nxor    %eax,%eax\ntest   $0x1,%r8b\njne    12bf <func0+0x1bf>\njmp    12e2 <func0+0x1e2>\n"
    },
    {
        "task_id": 111,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nlea    -0x90(%rbp),%rdi\nxor    %esi,%esi\nmov    $0x68,%edx\ncall   1030 <memset@plt>\nmovl   $0x0,-0x94(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,-0xa0(%rbp)\nmovl   $0x0,-0xa4(%rbp)\nmov    -0xa0(%rbp),%rax\ncmpb   $0x0,(%rax)\nje     11f5 <func0+0xe5>\nmov    -0xa0(%rbp),%rax\nmovsbl (%rax),%eax\ncmp    $0x20,%eax\nje     11de <func0+0xce>\nmov    -0xa0(%rbp),%rax\nmovsbl (%rax),%eax\nsub    $0x61,%eax\nmov    %eax,-0xa8(%rbp)\nmovslq -0xa8(%rbp),%rax\nmov    -0x90(%rbp,%rax,4),%ecx\nadd    $0x1,%ecx\nmov    %ecx,-0x90(%rbp,%rax,4)\nmovslq -0xa8(%rbp),%rax\nmov    -0x90(%rbp,%rax,4),%eax\ncmp    -0x94(%rbp),%eax\njle    11d9 <func0+0xc9>\nmovslq -0xa8(%rbp),%rax\nmov    -0x90(%rbp,%rax,4),%eax\nmov    %eax,-0x94(%rbp)\njmp    11de <func0+0xce>\nmov    -0xa0(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0xa0(%rbp)\njmp    115d <func0+0x4d>\nmovl   $0x0,-0xac(%rbp)\ncmpl   $0x1a,-0xac(%rbp)\njge    1281 <func0+0x171>\nmovslq -0xac(%rbp),%rax\nmov    -0x90(%rbp,%rax,4),%edx\nmov    -0x10(%rbp),%rax\nmovslq -0xac(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmovslq -0xac(%rbp),%rax\nmov    -0x90(%rbp,%rax,4),%eax\ncmp    -0x94(%rbp),%eax\njne    1268 <func0+0x158>\nmov    -0xac(%rbp),%eax\nadd    $0x61,%eax\nmov    %al,%dl\nmov    -0x20(%rbp),%rax\nmov    -0xa4(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0xa4(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\njmp    126d <func0+0x15d>\nmov    -0xac(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xac(%rbp)\njmp    11ff <func0+0xef>\nmov    -0x94(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x20(%rbp),%rax\nmovslq -0xa4(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0xb0,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 111,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxorps  %xmm0,%xmm0\nmovaps %xmm0,-0x18(%rsp)\nmovaps %xmm0,-0x28(%rsp)\nmovaps %xmm0,-0x38(%rsp)\nmovaps %xmm0,-0x48(%rsp)\nmovaps %xmm0,-0x58(%rsp)\nmovaps %xmm0,-0x68(%rsp)\nmovq   $0x0,-0x8(%rsp)\nxor    %r9d,%r9d\njmp    1134 <func0+0x34>\nnop\nadd    $0x1,%rdi\nmovsbq (%rdi),%rax\ncmp    $0x20,%rax\nje     1130 <func0+0x30>\ntest   %al,%al\nje     115f <func0+0x5f>\nmov    -0x1ec(%rsp,%rax,4),%r8d\nff\nlea    0x1(%r8),%r10d\nmov    %r10d,-0x1ec(%rsp,%rax,4)\nff\ncmp    %r9d,%r8d\ncmovge %r10d,%r9d\njmp    1130 <func0+0x30>\nxor    %edi,%edi\nxor    %r8d,%r8d\njmp    117a <func0+0x7a>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%rdi\ncmp    $0x1a,%rdi\nje     1196 <func0+0x96>\nmov    -0x68(%rsp,%rdi,4),%eax\nmov    %eax,(%rsi,%rdi,4)\ncmp    %r9d,%eax\njne    1170 <func0+0x70>\nmovslq %r8d,%r10\nadd    $0x1,%r8d\nlea    0x61(%rdi),%eax\nmov    %al,(%rcx,%r10,1)\njmp    1170 <func0+0x70>\nmov    %r9d,(%rdx)\nmovslq %r8d,%rax\nmovb   $0x0,(%rcx,%rax,1)\nret\n"
    },
    {
        "task_id": 111,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxorps  %xmm0,%xmm0\nmovaps %xmm0,-0x18(%rsp)\nmovaps %xmm0,-0x28(%rsp)\nmovaps %xmm0,-0x38(%rsp)\nmovaps %xmm0,-0x48(%rsp)\nmovaps %xmm0,-0x58(%rsp)\nmovaps %xmm0,-0x68(%rsp)\nmovq   $0x0,-0x8(%rsp)\nxor    %r9d,%r9d\njmp    1134 <func0+0x34>\nnop\nadd    $0x1,%rdi\nmovsbq (%rdi),%rax\ncmp    $0x20,%rax\nje     1130 <func0+0x30>\ntest   %al,%al\nje     115f <func0+0x5f>\nmov    -0x1ec(%rsp,%rax,4),%r8d\nff\nlea    0x1(%r8),%r10d\nmov    %r10d,-0x1ec(%rsp,%rax,4)\nff\ncmp    %r9d,%r8d\ncmovge %r10d,%r9d\njmp    1130 <func0+0x30>\nxor    %edi,%edi\nxor    %r8d,%r8d\njmp    117a <func0+0x7a>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x2,%rdi\ncmp    $0x1a,%rdi\nje     11b1 <func0+0xb1>\nmov    -0x68(%rsp,%rdi,4),%eax\nmov    %eax,(%rsi,%rdi,4)\ncmp    %r9d,%eax\njne    1194 <func0+0x94>\nmovslq %r8d,%r10\nadd    $0x1,%r8d\nlea    0x61(%rdi),%eax\nmov    %al,(%rcx,%r10,1)\nmov    -0x64(%rsp,%rdi,4),%eax\nmov    %eax,0x4(%rsi,%rdi,4)\ncmp    %r9d,%eax\njne    1170 <func0+0x70>\nmovslq %r8d,%r10\nadd    $0x1,%r8d\nlea    0x62(%rdi),%eax\nmov    %al,(%rcx,%r10,1)\njmp    1170 <func0+0x70>\nmov    %r9d,(%rdx)\nmovslq %r8d,%rax\nmovb   $0x0,(%rcx,%rax,1)\nret\n"
    },
    {
        "task_id": 111,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nxorps  %xmm0,%xmm0\nmovaps %xmm0,-0x18(%rsp)\nmovaps %xmm0,-0x28(%rsp)\nmovaps %xmm0,-0x38(%rsp)\nmovaps %xmm0,-0x48(%rsp)\nmovaps %xmm0,-0x58(%rsp)\nmovaps %xmm0,-0x68(%rsp)\nmovq   $0x0,-0x8(%rsp)\nxor    %r9d,%r9d\njmp    1134 <func0+0x34>\nnop\nadd    $0x1,%rdi\nmovsbq (%rdi),%rax\ncmp    $0x20,%rax\nje     1130 <func0+0x30>\ntest   %al,%al\nje     115f <func0+0x5f>\nmov    -0x1ec(%rsp,%rax,4),%r8d\nff\nlea    0x1(%r8),%r10d\nmov    %r10d,-0x1ec(%rsp,%rax,4)\nff\ncmp    %r9d,%r8d\ncmovge %r10d,%r9d\njmp    1130 <func0+0x30>\nxor    %edi,%edi\nxor    %r8d,%r8d\njmp    117a <func0+0x7a>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x2,%rdi\ncmp    $0x1a,%rdi\nje     11cb <func0+0xcb>\nmov    -0x68(%rsp,%rdi,4),%eax\nmov    %eax,(%rsi,%rdi,4)\ncmp    %r9d,%eax\nje     11a0 <func0+0xa0>\nmov    -0x64(%rsp,%rdi,4),%eax\nmov    %eax,0x4(%rsi,%rdi,4)\ncmp    %r9d,%eax\njne    1170 <func0+0x70>\njmp    11bb <func0+0xbb>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovslq %r8d,%r10\nadd    $0x1,%r8d\nlea    0x61(%rdi),%eax\nmov    %al,(%rcx,%r10,1)\nmov    -0x64(%rsp,%rdi,4),%eax\nmov    %eax,0x4(%rsi,%rdi,4)\ncmp    %r9d,%eax\njne    1170 <func0+0x70>\nmovslq %r8d,%r10\nadd    $0x1,%r8d\nlea    0x62(%rdi),%eax\nmov    %al,(%rcx,%r10,1)\njmp    1170 <func0+0x70>\nmov    %r9d,(%rdx)\nmovslq %r8d,%rax\nmovb   $0x0,(%rcx,%rax,1)\nret\n"
    },
    {
        "task_id": 112,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\nshl    $0x0,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     122b <func0+0xeb>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmovb   $0x0,-0x41(%rbp)\nmov    -0x40(%rbp),%rax\nmovsbl (%rax),%eax\ncmp    $0x0,%eax\nje     11ee <func0+0xae>\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nmov    -0x40(%rbp),%rcx\nmovsbl (%rcx),%ecx\ncmp    %ecx,%eax\njne    11dd <func0+0x9d>\nmovb   $0x1,-0x41(%rbp)\njmp    11ee <func0+0xae>\nmov    -0x40(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x40(%rbp)\njmp    11a9 <func0+0x69>\ntestb  $0x1,-0x41(%rbp)\njne    1218 <func0+0xd8>\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,1),%dl\nmov    -0x30(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x34(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\njmp    121d <func0+0xdd>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    1188 <func0+0x48>\nmov    -0x30(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x30(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %eax,-0x48(%rbp)\nmovb   $0x1,-0x49(%rbp)\nmovl   $0x0,-0x50(%rbp)\nmov    -0x50(%rbp),%eax\nmov    %eax,-0x54(%rbp)\nmov    -0x48(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x54(%rbp),%eax\ncmp    %ecx,%eax\njge    12b0 <func0+0x170>\nmov    -0x30(%rbp),%rax\nmovslq -0x50(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nmov    -0x30(%rbp),%rcx\nmov    -0x48(%rbp),%edx\nsub    $0x1,%edx\nsub    -0x50(%rbp),%edx\nmovslq %edx,%rdx\nmovsbl (%rcx,%rdx,1),%ecx\ncmp    %ecx,%eax\nje     129d <func0+0x15d>\nmovb   $0x0,-0x49(%rbp)\njmp    12b0 <func0+0x170>\njmp    12a2 <func0+0x162>\nmov    -0x50(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x50(%rbp)\njmp    124e <func0+0x10e>\nmov    -0x18(%rbp),%rdi\nmov    -0x30(%rbp),%rsi\ncall   1040 <strcpy@plt>\nmov    -0x20(%rbp),%rdi\nmov    -0x49(%rbp),%cl\nlea    0xd3a(%rip),%rsi\nlea    0xd2e(%rip),%rax\ntest   $0x1,%cl\ncmovne %rax,%rsi\ncall   1040 <strcpy@plt>\nmov    -0x30(%rbp),%rdi\ncall   1030 <free@plt>\nadd    $0x60,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 112,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rcx,%r14\nmov    %rdx,%r15\nmov    %rsi,%r13\nmov    %rdi,%rbp\ncall   1050 <strlen@plt>\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r12\nmov    0x0(%rbp),%dl\ntest   %dl,%dl\nje     11b1 <func0+0x71>\nmov    0x0(%r13),%bl\nadd    $0x1,%r13\nxor    %esi,%esi\nxor    %ecx,%ecx\njmp    1196 <func0+0x56>\nnop\nmovslq %ecx,%rax\nadd    $0x1,%ecx\nmov    %dl,(%r12,%rax,1)\nmov    0x1(%rbp,%rsi,1),%dl\nadd    $0x1,%rsi\ntest   %dl,%dl\nje     11b3 <func0+0x73>\nmov    %r13,%rdi\nmov    %ebx,%eax\ntest   %bl,%bl\nje     1180 <func0+0x40>\nnop\ncmp    %al,%dl\nje     118a <func0+0x4a>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\njne    11a0 <func0+0x60>\njmp    1180 <func0+0x40>\nxor    %ecx,%ecx\nmovslq %ecx,%rax\nmovb   $0x0,(%r12,%rax,1)\nmov    %r12,%rdi\ncall   1050 <strlen@plt>\nlea    0xe36(%rip),%rbp\ncmp    $0x2,%eax\njl     1223 <func0+0xe3>\nmovabs $0xffffffff00000000,%rcx\nff ff ff\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %eax,%edx\nsar    %edx\nshl    $0x20,%rax\nadd    %rcx,%rax\nxor    %esi,%esi\nlea    0xe13(%rip),%r8\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovzbl (%r12,%rsi,1),%ebx\nmov    %rax,%rdi\nsar    $0x20,%rdi\ncmp    (%r12,%rdi,1),%bl\njne    1220 <func0+0xe0>\nadd    $0x1,%rsi\nadd    %rcx,%rax\ncmp    %rsi,%rdx\njne    1200 <func0+0xc0>\njmp    1223 <func0+0xe3>\nmov    %r8,%rbp\nmov    %r15,%rdi\nmov    %r12,%rsi\ncall   1040 <strcpy@plt>\nmov    %r14,%rdi\nmov    %rbp,%rsi\ncall   1040 <strcpy@plt>\nmov    %r12,%rdi\ncall   1030 <free@plt>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 112,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rcx,%r14\nmov    %rdx,%r15\nmov    %rsi,%r13\nmov    %rdi,%rbp\ncall   1050 <strlen@plt>\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r12\nmov    0x0(%rbp),%dl\ntest   %dl,%dl\nje     11b1 <func0+0x71>\nmov    0x0(%r13),%bl\nadd    $0x1,%r13\nxor    %esi,%esi\nxor    %ecx,%ecx\njmp    1196 <func0+0x56>\nnop\nmovslq %ecx,%rax\nadd    $0x1,%ecx\nmov    %dl,(%r12,%rax,1)\nmov    0x1(%rbp,%rsi,1),%dl\nadd    $0x1,%rsi\ntest   %dl,%dl\nje     11b3 <func0+0x73>\nmov    %r13,%rdi\nmov    %ebx,%eax\ntest   %bl,%bl\nje     1180 <func0+0x40>\nnop\ncmp    %al,%dl\nje     118a <func0+0x4a>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\njne    11a0 <func0+0x60>\njmp    1180 <func0+0x40>\nxor    %ecx,%ecx\nmovslq %ecx,%rax\nmovb   $0x0,(%r12,%rax,1)\nmov    %r12,%rdi\ncall   1050 <strlen@plt>\nlea    0xe36(%rip),%rbp\ncmp    $0x2,%eax\njl     1213 <func0+0xd3>\nmovabs $0xffffffff00000000,%rcx\nff ff ff\nmov    %eax,%edx\nshr    %edx\nshl    $0x20,%rax\nadd    %rcx,%rax\nxor    %esi,%esi\nlea    0xe18(%rip),%r8\nnopl   (%rax)\nmovzbl (%r12,%rsi,1),%ebx\nmov    %rax,%rdi\nsar    $0x20,%rdi\ncmp    (%r12,%rdi,1),%bl\njne    1210 <func0+0xd0>\nadd    $0x1,%rsi\nadd    %rcx,%rax\ncmp    %rsi,%rdx\njne    11f0 <func0+0xb0>\njmp    1213 <func0+0xd3>\nmov    %r8,%rbp\nmov    %r15,%rdi\nmov    %r12,%rsi\ncall   1040 <strcpy@plt>\nmov    %r14,%rdi\nmov    %rbp,%rsi\ncall   1040 <strcpy@plt>\nmov    %r12,%rdi\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\njmp    1030 <free@plt>\n"
    },
    {
        "task_id": 112,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nmov    %rcx,%r14\nmov    %rdx,%r15\nmov    %rsi,%r13\nmov    %rdi,%rbx\ncall   1050 <strlen@plt>\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r12\nmov    (%rbx),%al\ntest   %al,%al\nje     11cb <func0+0x8b>\nmov    0x0(%r13),%r8b\ntest   %r8b,%r8b\nje     11cf <func0+0x8f>\nadd    $0x1,%r13\nxor    %esi,%esi\nxor    %ecx,%ecx\njmp    119c <func0+0x5c>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    0x1(%rbx,%rsi,1),%al\nadd    $0x1,%rsi\ntest   %al,%al\nje     11f1 <func0+0xb1>\nmov    %r13,%rdi\nmov    %r8d,%edx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\ncmp    %dl,%al\nje     1190 <func0+0x50>\nmovzbl (%rdi),%edx\nadd    $0x1,%rdi\ntest   %dl,%dl\njne    11b0 <func0+0x70>\nmovslq %ecx,%rdx\nadd    $0x1,%ecx\nmov    %al,(%r12,%rdx,1)\njmp    1190 <func0+0x50>\nxor    %ecx,%ecx\njmp    11f1 <func0+0xb1>\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %al,(%r12,%rcx,1)\nmovzbl 0x1(%rbx,%rcx,1),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    11e0 <func0+0xa0>\nmovslq %ecx,%rax\nmovb   $0x0,(%r12,%rax,1)\nmov    %r12,%rdi\ncall   1050 <strlen@plt>\nlea    0xdf8(%rip),%r13\ncmp    $0x2,%eax\njl     1253 <func0+0x113>\nmovabs $0xffffffff00000000,%rcx\nff ff ff\nmov    %eax,%edx\nshr    %edx\nshl    $0x20,%rax\nadd    %rcx,%rax\nxor    %esi,%esi\nlea    0xdda(%rip),%r8\nnopl   0x0(%rax,%rax,1)\nmovzbl (%r12,%rsi,1),%ebx\nmov    %rax,%rdi\nsar    $0x20,%rdi\ncmp    (%r12,%rdi,1),%bl\njne    1250 <func0+0x110>\nadd    $0x1,%rsi\nadd    %rcx,%rax\ncmp    %rsi,%rdx\njne    1230 <func0+0xf0>\njmp    1253 <func0+0x113>\nmov    %r8,%r13\nmov    %r15,%rdi\nmov    %r12,%rsi\ncall   1040 <strcpy@plt>\nmov    %r14,%rdi\nmov    %r13,%rsi\ncall   1040 <strcpy@plt>\nmov    %r12,%rdi\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    1030 <free@plt>\n"
    },
    {
        "task_id": 113,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovslq -0xc(%rbp),%rdi\nshl    $0x3,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1247 <func0+0x127>\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x24(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     11fc <func0+0xdc>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x24(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x30,%eax\njl     11e9 <func0+0xc9>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x24(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x39,%eax\njg     11e9 <func0+0xc9>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x24(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nsub    $0x30,%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    11e9 <func0+0xc9>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    11ee <func0+0xce>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1161 <func0+0x41>\nmov    $0x64,%edi\ncall   1030 <malloc@plt>\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nmov    -0x20(%rbp),%edx\nmov    -0x20(%rbp),%ecx\nmov    -0x20(%rbp),%r8d\nlea    0xdce(%rip),%rsi\nmov    $0x0,%al\ncall   1040 <sprintf@plt>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1147 <func0+0x27>\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 113,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %esi,%ebp\nmov    %rdi,%r14\nmovslq %esi,%rbx\nlea    0x0(,%rbx,8),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,%r13\ntest   %ebx,%ebx\njle    11e6 <func0+0xc6>\nmov    %ebp,%r12d\nlea    0xeab(%rip),%r15\nxor    %ebx,%ebx\njmp    118c <func0+0x6c>\nnopl   0x0(%rax)\nmov    $0x64,%edi\ncall   1030 <malloc@plt>\nmov    %rax,0x0(%r13,%rbx,8)\nmov    %rax,%rdi\nmov    %r15,%rsi\nmov    %ebp,%edx\nmov    %ebp,%ecx\nmov    %ebp,%r8d\nxor    %eax,%eax\ncall   1040 <sprintf@plt>\nadd    $0x1,%rbx\ncmp    %r12,%rbx\nje     11e6 <func0+0xc6>\nmov    (%r14,%rbx,8),%rax\nmov    (%rax),%cl\nmov    $0x0,%ebp\ntest   %cl,%cl\nje     1160 <func0+0x40>\nadd    $0x1,%rax\nxor    %ebp,%ebp\njmp    11bb <func0+0x9b>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmovzbl (%rax),%ecx\nadd    $0x1,%rax\ntest   %cl,%cl\nje     1160 <func0+0x40>\nlea    -0x30(%rcx),%edx\ncmp    $0x9,%dl\nja     11b0 <func0+0x90>\nmovsbl %cl,%ecx\nmov    %ecx,%edx\nadd    $0xffffffd0,%edx\nmov    %edx,%esi\nshr    $0x1f,%esi\nadd    %esi,%ecx\nadd    $0xffffffd0,%ecx\nand    $0xfffffffe,%ecx\nsub    %ecx,%edx\nxor    %ecx,%ecx\ncmp    $0x1,%edx\nsete   %cl\nadd    %ecx,%ebp\njmp    11b0 <func0+0x90>\nmov    %r13,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 113,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %esi,%ebp\nmov    %rdi,%r14\nmovslq %esi,%rbx\nlea    0x0(,%rbx,8),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,%r12\ntest   %ebx,%ebx\njle    11d1 <func0+0xb1>\nmov    %ebp,%r13d\nxor    %ebx,%ebx\nxor    %r15d,%r15d\njmp    118f <func0+0x6f>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    $0x64,%edi\ncall   1030 <malloc@plt>\nmov    %rax,(%r12,%r15,8)\nmov    %rax,%rdi\nlea    0xe88(%rip),%rsi\nmov    %ebp,%edx\nmov    %ebp,%ecx\nmov    %ebp,%r8d\nxor    %eax,%eax\ncall   1040 <sprintf@plt>\nadd    $0x1,%r15\ncmp    %r13,%r15\nje     11d1 <func0+0xb1>\nmov    (%r14,%r15,8),%rax\nmov    (%rax),%cl\nmov    $0x0,%ebp\ntest   %cl,%cl\nje     1160 <func0+0x40>\nadd    $0x1,%rax\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nlea    -0x30(%rcx),%edx\nand    $0x1,%cl\ncmp    $0xa,%dl\nmovzbl %cl,%ecx\ncmovae %ebx,%ecx\nmovzbl %cl,%ecx\nadd    %ecx,%ebp\nmovzbl (%rax),%ecx\nadd    $0x1,%rax\ntest   %cl,%cl\njne    11b0 <func0+0x90>\njmp    1160 <func0+0x40>\nmov    %r12,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 113,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %esi,%ebp\nmov    %rdi,%r14\nmovslq %esi,%rbx\nlea    0x0(,%rbx,8),%rdi\ncall   1030 <malloc@plt>\nmov    %rax,%r12\ntest   %ebx,%ebx\njle    11d1 <func0+0xb1>\nmov    %ebp,%r13d\nxor    %ebx,%ebx\nxor    %r15d,%r15d\njmp    118f <func0+0x6f>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    $0x64,%edi\ncall   1030 <malloc@plt>\nmov    %rax,(%r12,%r15,8)\nmov    %rax,%rdi\nlea    0xe88(%rip),%rsi\nmov    %ebp,%edx\nmov    %ebp,%ecx\nmov    %ebp,%r8d\nxor    %eax,%eax\ncall   1040 <sprintf@plt>\nadd    $0x1,%r15\ncmp    %r13,%r15\nje     11d1 <func0+0xb1>\nmov    (%r14,%r15,8),%rax\nmov    (%rax),%cl\nmov    $0x0,%ebp\ntest   %cl,%cl\nje     1160 <func0+0x40>\nadd    $0x1,%rax\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nlea    -0x30(%rcx),%edx\nand    $0x1,%cl\ncmp    $0xa,%dl\nmovzbl %cl,%ecx\ncmovae %ebx,%ecx\nmovzbl %cl,%ecx\nadd    %ecx,%ebp\nmovzbl (%rax),%ecx\nadd    $0x1,%rax\ntest   %cl,%cl\njne    11b0 <func0+0x90>\njmp    1160 <func0+0x40>\nmov    %r12,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 114,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x20(%rbp)\nmovl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1199 <func0+0x99>\ncmpq   $0x0,-0x18(%rbp)\njge    1158 <func0+0x58>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x24(%rbp),%rdx\nadd    (%rcx,%rdx,8),%rax\nmov    %rax,-0x30(%rbp)\njmp    1168 <func0+0x68>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njge    1186 <func0+0x86>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x20(%rbp)\njmp    118b <func0+0x8b>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1128 <func0+0x28>\nmov    -0x20(%rbp),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 114,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    (%rdi),%rax\ncmp    $0x2,%esi\njl     113e <func0+0x3e>\nmov    %esi,%r8d\nmov    $0x1,%edx\nmov    %rax,%rcx\nmov    %rax,%rsi\ncs nopw 0x0(%rax,%rax,1)\nsar    $0x3f,%rsi\nand    %rcx,%rsi\nadd    (%rdi,%rdx,8),%rsi\ncmp    %rax,%rsi\ncmovl  %rsi,%rax\nadd    $0x1,%rdx\nmov    %rsi,%rcx\ncmp    %rdx,%r8\njne    1120 <func0+0x20>\nret\n"
    },
    {
        "task_id": 114,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    (%rdi),%rax\ncmp    $0x2,%esi\njl     1198 <func0+0x98>\nmov    %esi,%r8d\nadd    $0xffffffffffffffff,%r8\ncmp    $0x2,%esi\njne    1122 <func0+0x22>\nmov    $0x1,%edx\nmov    %rax,%rsi\njmp    117d <func0+0x7d>\nmov    %r8,%r9\nand    $0xfffffffffffffffe,%r9\nneg    %r9\nmov    $0x1,%edx\nmov    %rax,%rsi\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %rsi,%rcx\nsar    $0x3f,%rcx\nand    %rsi,%rcx\nadd    (%rdi,%rdx,8),%rcx\ncmp    %rax,%rcx\ncmovl  %rcx,%rax\nmov    %rcx,%rsi\nsar    $0x3f,%rsi\nand    %rcx,%rsi\nadd    0x8(%rdi,%rdx,8),%rsi\ncmp    %rax,%rsi\ncmovl  %rsi,%rax\nlea    (%r9,%rdx,1),%rcx\nadd    $0x2,%rcx\nadd    $0x2,%rdx\ncmp    $0x1,%rcx\njne    1140 <func0+0x40>\ntest   $0x1,%r8b\nje     1198 <func0+0x98>\nmov    %rsi,%rcx\nsar    $0x3f,%rcx\nand    %rsi,%rcx\nadd    (%rdi,%rdx,8),%rcx\ncmp    %rax,%rcx\ncmovl  %rcx,%rax\nret\n"
    },
    {
        "task_id": 114,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    (%rdi),%rax\ncmp    $0x2,%esi\njl     1198 <func0+0x98>\nmov    %esi,%r8d\nadd    $0xffffffffffffffff,%r8\ncmp    $0x2,%esi\njne    1122 <func0+0x22>\nmov    $0x1,%edx\nmov    %rax,%rsi\njmp    117d <func0+0x7d>\nmov    %r8,%r9\nand    $0xfffffffffffffffe,%r9\nneg    %r9\nmov    $0x1,%edx\nmov    %rax,%rsi\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %rsi,%rcx\nsar    $0x3f,%rcx\nand    %rsi,%rcx\nadd    (%rdi,%rdx,8),%rcx\ncmp    %rax,%rcx\ncmovl  %rcx,%rax\nmov    %rcx,%rsi\nsar    $0x3f,%rsi\nand    %rcx,%rsi\nadd    0x8(%rdi,%rdx,8),%rsi\ncmp    %rax,%rsi\ncmovl  %rsi,%rax\nlea    (%r9,%rdx,1),%rcx\nadd    $0x2,%rcx\nadd    $0x2,%rdx\ncmp    $0x1,%rcx\njne    1140 <func0+0x40>\ntest   $0x1,%r8b\nje     1198 <func0+0x98>\nmov    %rsi,%rcx\nsar    $0x3f,%rcx\nand    %rsi,%rcx\nadd    (%rdi,%rdx,8),%rcx\ncmp    %rax,%rcx\ncmovl  %rcx,%rax\nret\n"
    },
    {
        "task_id": 115,
        "type": "O0",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\nmov    %ecx,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    119c <func0+0x9c>\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njge    116c <func0+0x6c>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nadd    -0x20(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1139 <func0+0x39>\ncmpl   $0x0,-0x20(%rbp)\njle    1189 <func0+0x89>\nmov    -0x20(%rbp),%eax\nadd    -0x14(%rbp),%eax\nsub    $0x1,%eax\ncltd\nidivl  -0x14(%rbp)\nadd    -0x18(%rbp),%eax\nmov    %eax,-0x18(%rbp)\njmp    118e <func0+0x8e>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    111f <func0+0x1f>\nmov    -0x18(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 115,
        "type": "O1",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\ntest   %esi,%esi\njle    115b <func0+0x5b>\nmov    %edx,%r8d\nlea    -0x1(%rcx),%r9d\nmov    %esi,%r10d\nmov    %edx,%esi\nxor    %r14d,%r14d\nxor    %r11d,%r11d\njmp    1129 <func0+0x29>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r14\ncmp    %r10,%r14\nje     115e <func0+0x5e>\nmov    $0x0,%eax\ntest   %r8d,%r8d\njle    114c <func0+0x4c>\nmov    (%rdi,%r14,8),%rdx\nxor    %ebx,%ebx\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\nadd    (%rdx,%rbx,4),%eax\nadd    $0x1,%rbx\ncmp    %rbx,%rsi\njne    1140 <func0+0x40>\ntest   %eax,%eax\njle    1120 <func0+0x20>\nadd    %r9d,%eax\ncltd\nidiv   %ecx\nadd    %eax,%r11d\njmp    1120 <func0+0x20>\nxor    %r11d,%r11d\nmov    %r11d,%eax\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 115,
        "type": "O2",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\ntest   %esi,%esi\njle    1293 <func0+0x193>\nmov    %edx,%r8d\nlea    -0x1(%rcx),%eax\nmov    %eax,-0xc(%rsp)\nmov    %esi,%r11d\nmov    %edx,%esi\nmov    %esi,%r13d\nand    $0xfffffff8,%r13d\nlea    -0x8(%r13),%r9\nmov    %r9,-0x8(%rsp)\nshr    $0x3,%r9\nadd    $0x1,%r9\nmov    %r9d,%r14d\nand    $0x3,%r14d\nand    $0xfffffffffffffffc,%r9\nmov    %r14,%r12\nshl    $0x5,%r12\nxor    %ebp,%ebp\nxor    %r10d,%r10d\njmp    116d <func0+0x6d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nadd    $0x1,%rbp\ncmp    %r11,%rbp\nje     1296 <func0+0x196>\ntest   %r8d,%r8d\njle    1160 <func0+0x60>\nmov    (%rdi,%rbp,8),%rdx\ncmp    $0x8,%r8d\njae    1190 <func0+0x90>\nxor    %ebx,%ebx\nxor    %eax,%eax\njmp    1270 <func0+0x170>\ncs nopw 0x0(%rax,%rax,1)\nnop\ncmpq   $0x18,-0x8(%rsp)\njae    11a4 <func0+0xa4>\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npxor   %xmm1,%xmm1\njmp    1219 <func0+0x119>\npxor   %xmm0,%xmm0\nmov    %r9,%r15\nxor    %eax,%eax\npxor   %xmm1,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovdqu (%rdx,%rax,4),%xmm2\npaddd  %xmm0,%xmm2\nmovdqu 0x10(%rdx,%rax,4),%xmm0\npaddd  %xmm1,%xmm0\nmovdqu 0x20(%rdx,%rax,4),%xmm1\nmovdqu 0x30(%rdx,%rax,4),%xmm3\nmovdqu 0x40(%rdx,%rax,4),%xmm4\npaddd  %xmm1,%xmm4\npaddd  %xmm2,%xmm4\nmovdqu 0x50(%rdx,%rax,4),%xmm2\npaddd  %xmm3,%xmm2\npaddd  %xmm0,%xmm2\nmovdqu 0x60(%rdx,%rax,4),%xmm0\npaddd  %xmm4,%xmm0\nmovdqu 0x70(%rdx,%rax,4),%xmm1\npaddd  %xmm2,%xmm1\nadd    $0x20,%rax\nadd    $0xfffffffffffffffc,%r15\njne    11c0 <func0+0xc0>\ntest   %r14,%r14\nje     124c <func0+0x14c>\nlea    (%rdx,%rax,4),%rax\nadd    $0x10,%rax\nxor    %ebx,%ebx\nnopl   0x0(%rax,%rax,1)\nmovdqu -0x10(%rax,%rbx,1),%xmm2\npaddd  %xmm2,%xmm0\nmovdqu (%rax,%rbx,1),%xmm2\npaddd  %xmm2,%xmm1\nadd    $0x20,%rbx\ncmp    %rbx,%r12\njne    1230 <func0+0x130>\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%eax\nmov    %r13,%rbx\ncmp    %rsi,%r13\nje     127c <func0+0x17c>\nxchg   %ax,%ax\nadd    (%rdx,%rbx,4),%eax\nadd    $0x1,%rbx\ncmp    %rbx,%rsi\njne    1270 <func0+0x170>\ntest   %eax,%eax\njle    1160 <func0+0x60>\nadd    -0xc(%rsp),%eax\ncltd\nidiv   %ecx\nadd    %eax,%r10d\njmp    1160 <func0+0x60>\nxor    %r10d,%r10d\nmov    %r10d,%eax\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 115,
        "type": "O3",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nxor    %r9d,%r9d\ntest   %esi,%esi\njle    1292 <func0+0x192>\nmov    %edx,%r8d\ntest   %edx,%edx\njle    1292 <func0+0x192>\nlea    -0x1(%rcx),%r10d\nmov    %esi,%r11d\nmov    %r8d,%esi\nmov    %esi,%r13d\nand    $0xfffffff8,%r13d\nlea    -0x8(%r13),%rax\nmov    %rax,-0x8(%rsp)\nshr    $0x3,%rax\nadd    $0x1,%rax\nmov    %eax,%r12d\nand    $0x3,%r12d\nand    $0xfffffffffffffffc,%rax\nmov    %rax,-0x10(%rsp)\nmov    %r12,%rbx\nshl    $0x5,%rbx\nxor    %r14d,%r14d\nxor    %r9d,%r9d\njmp    117d <func0+0x7d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r14\ncmp    %r11,%r14\nje     1292 <func0+0x192>\nmov    (%rdi,%r14,8),%rdx\ncmp    $0x8,%r8d\njae    1190 <func0+0x90>\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    1270 <func0+0x170>\ncmpq   $0x18,-0x8(%rsp)\njae    11b0 <func0+0xb0>\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npxor   %xmm1,%xmm1\njmp    1219 <func0+0x119>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\npxor   %xmm0,%xmm0\nmov    -0x10(%rsp),%r15\nxor    %eax,%eax\npxor   %xmm1,%xmm1\nnop\nmovdqu (%rdx,%rax,4),%xmm2\npaddd  %xmm0,%xmm2\nmovdqu 0x10(%rdx,%rax,4),%xmm0\npaddd  %xmm1,%xmm0\nmovdqu 0x20(%rdx,%rax,4),%xmm1\nmovdqu 0x30(%rdx,%rax,4),%xmm3\nmovdqu 0x40(%rdx,%rax,4),%xmm4\npaddd  %xmm1,%xmm4\npaddd  %xmm2,%xmm4\nmovdqu 0x50(%rdx,%rax,4),%xmm2\npaddd  %xmm3,%xmm2\npaddd  %xmm0,%xmm2\nmovdqu 0x60(%rdx,%rax,4),%xmm0\npaddd  %xmm4,%xmm0\nmovdqu 0x70(%rdx,%rax,4),%xmm1\npaddd  %xmm2,%xmm1\nadd    $0x20,%rax\nadd    $0xfffffffffffffffc,%r15\njne    11c0 <func0+0xc0>\ntest   %r12,%r12\nje     124c <func0+0x14c>\nlea    (%rdx,%rax,4),%rax\nadd    $0x10,%rax\nxor    %ebp,%ebp\nnopl   0x0(%rax,%rax,1)\nmovdqu -0x10(%rax,%rbp,1),%xmm2\npaddd  %xmm2,%xmm0\nmovdqu (%rax,%rbp,1),%xmm2\npaddd  %xmm2,%xmm1\nadd    $0x20,%rbp\ncmp    %rbp,%rbx\njne    1230 <func0+0x130>\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%eax\nmov    %r13,%rbp\ncmp    %rsi,%r13\nje     127c <func0+0x17c>\nxchg   %ax,%ax\nadd    (%rdx,%rbp,4),%eax\nadd    $0x1,%rbp\ncmp    %rbp,%rsi\njne    1270 <func0+0x170>\ntest   %eax,%eax\njle    1170 <func0+0x70>\nadd    %r10d,%eax\ncltd\nidiv   %ecx\nadd    %eax,%r9d\njmp    1170 <func0+0x70>\nmov    %r9d,%eax\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 116,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    123d <func0+0x13d>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    122a <func0+0x12a>\nmovl   $0x0,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njle    117a <func0+0x7a>\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\nsar    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1156 <func0+0x56>\nmov    -0x10(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njle    11ab <func0+0xab>\nmov    -0x18(%rbp),%eax\nand    $0x1,%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x18(%rbp),%eax\nsar    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1187 <func0+0x87>\nmov    -0x10(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     11e5 <func0+0xe5>\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njne    1217 <func0+0x117>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmovslq -0x20(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njge    1217 <func0+0x117>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x1c(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    121c <func0+0x11c>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1127 <func0+0x27>\njmp    122f <func0+0x12f>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1112 <func0+0x12>\npop    %rbp\nret\n"
    },
    {
        "task_id": 116,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\ntest   %esi,%esi\njle    11cd <func0+0xcd>\nmovslq %esi,%r8\nmov    %esi,%r11d\nmov    $0x1,%r10d\nxor    %r9d,%r9d\njmp    113d <func0+0x3d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r10\ncmp    %r11,%r9\nje     11cd <func0+0xcd>\nmov    %r9,%r14\nadd    $0x1,%r9\ncmp    %r8,%r9\njge    1130 <func0+0x30>\nmov    %r10,%rdx\njmp    1161 <func0+0x61>\nxchg   %ax,%ax\nmov    %r12d,(%rdi,%r14,4)\nmov    %r15d,(%rdi,%rdx,4)\nadd    $0x1,%rdx\ncmp    %r11,%rdx\nje     1130 <func0+0x30>\nmov    (%rdi,%r14,4),%r15d\nxor    %ecx,%ecx\nmov    $0x0,%ebx\ntest   %r15d,%r15d\njle    1190 <func0+0x90>\nxor    %ebx,%ebx\nmov    %r15d,%eax\nmov    %r15d,%ebp\nnopl   0x0(%rax)\nmov    %eax,%esi\nand    $0x1,%esi\nadd    %esi,%ebx\nsar    %ebp\ncmp    $0x1,%eax\nmov    %ebp,%eax\njg     1180 <func0+0x80>\nmov    (%rdi,%rdx,4),%r12d\ntest   %r12d,%r12d\njle    11c0 <func0+0xc0>\nxor    %ecx,%ecx\nmov    %r12d,%eax\nmov    %r12d,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %eax,%ebp\nand    $0x1,%ebp\nadd    %ebp,%ecx\nsar    %esi\ncmp    $0x1,%eax\nmov    %esi,%eax\njg     11b0 <func0+0xb0>\ncmp    %ebx,%ecx\njb     1150 <func0+0x50>\njne    1158 <func0+0x58>\ncmp    %r15d,%r12d\njl     1150 <func0+0x50>\njmp    1158 <func0+0x58>\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 116,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\ntest   %esi,%esi\njle    11bd <func0+0xbd>\nmov    %esi,%r10d\nmov    $0x1,%r9d\nxor    %r8d,%r8d\njmp    112d <func0+0x2d>\nnopl   0x0(%rax)\nadd    $0x1,%r9\ncmp    %r10,%r8\nje     11bd <func0+0xbd>\nmov    %r8,%r11\nadd    $0x1,%r8\ncmp    %r10,%r8\njae    1120 <func0+0x20>\nmov    %r9,%rcx\njmp    1151 <func0+0x51>\nxchg   %ax,%ax\nmov    %r15d,(%rdi,%r11,4)\nmov    %r14d,(%rdi,%rcx,4)\nadd    $0x1,%rcx\ncmp    %r10,%rcx\nje     1120 <func0+0x20>\nmov    (%rdi,%r11,4),%r14d\nxor    %eax,%eax\nmov    $0x0,%esi\ntest   %r14d,%r14d\njle    1180 <func0+0x80>\nxor    %esi,%esi\nmov    %r14d,%edx\nmov    %r14d,%ebx\nnopl   0x0(%rax)\nmov    %edx,%ebp\nand    $0x1,%ebp\nadd    %ebp,%esi\nshr    %ebx\ncmp    $0x2,%edx\nmov    %ebx,%edx\njae    1170 <func0+0x70>\nmov    (%rdi,%rcx,4),%r15d\ntest   %r15d,%r15d\njle    11b0 <func0+0xb0>\nxor    %eax,%eax\nmov    %r15d,%edx\nmov    %r15d,%ebp\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %edx,%ebx\nand    $0x1,%ebx\nadd    %ebx,%eax\nshr    %ebp\ncmp    $0x1,%edx\nmov    %ebp,%edx\nja     11a0 <func0+0xa0>\ncmp    %esi,%eax\njb     1140 <func0+0x40>\njne    1148 <func0+0x48>\ncmp    %r14d,%r15d\njl     1140 <func0+0x40>\njmp    1148 <func0+0x48>\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 116,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\ntest   %esi,%esi\njle    11bd <func0+0xbd>\nmov    %esi,%r10d\nmov    $0x1,%r9d\nxor    %r8d,%r8d\njmp    112d <func0+0x2d>\nnopl   0x0(%rax)\nadd    $0x1,%r9\ncmp    %r10,%r8\nje     11bd <func0+0xbd>\nmov    %r8,%r11\nadd    $0x1,%r8\ncmp    %r10,%r8\njae    1120 <func0+0x20>\nmov    %r9,%rcx\njmp    1151 <func0+0x51>\nxchg   %ax,%ax\nmov    %r15d,(%rdi,%r11,4)\nmov    %r14d,(%rdi,%rcx,4)\nadd    $0x1,%rcx\ncmp    %r10,%rcx\nje     1120 <func0+0x20>\nmov    (%rdi,%r11,4),%r14d\nxor    %eax,%eax\nmov    $0x0,%esi\ntest   %r14d,%r14d\njle    1180 <func0+0x80>\nxor    %esi,%esi\nmov    %r14d,%edx\nmov    %r14d,%ebx\nnopl   0x0(%rax)\nmov    %edx,%ebp\nand    $0x1,%ebp\nadd    %ebp,%esi\nshr    %ebx\ncmp    $0x2,%edx\nmov    %ebx,%edx\njae    1170 <func0+0x70>\nmov    (%rdi,%rcx,4),%r15d\ntest   %r15d,%r15d\njle    11b0 <func0+0xb0>\nxor    %eax,%eax\nmov    %r15d,%edx\nmov    %r15d,%ebp\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %edx,%ebx\nand    $0x1,%ebx\nadd    %ebx,%eax\nshr    %ebp\ncmp    $0x1,%edx\nmov    %ebp,%edx\nja     11a0 <func0+0xa0>\ncmp    %esi,%eax\njb     1140 <func0+0x40>\njne    1148 <func0+0x48>\ncmp    %r14d,%r15d\njl     1140 <func0+0x40>\njmp    1148 <func0+0x48>\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 117,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nlea    0xe76(%rip),%rax\nmov    %rax,-0x20(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %rax,-0x40(%rbp)\nmov    -0x40(%rbp),%rdi\nadd    $0x1,%rdi\ncall   1070 <malloc@plt>\nmov    %rax,-0x48(%rbp)\nmovl   $0x0,-0x4c(%rbp)\nmovslq -0x4c(%rbp),%rax\ncmp    -0x40(%rbp),%rax\nja     132e <func0+0x1be>\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x4c(%rbp),%rdx\nmovsbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x2000,%eax\ncmp    $0x0,%eax\njne    121c <func0+0xac>\nmov    -0x8(%rbp),%rax\nmovslq -0x4c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\njne    12aa <func0+0x13a>\nmov    -0x2c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njne    1295 <func0+0x125>\nmov    -0x48(%rbp),%rax\nmov    -0x4c(%rbp),%ecx\nsub    -0x34(%rbp),%ecx\nmovslq %ecx,%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x28(%rbp),%rdi\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rsi\nshl    $0x3,%rsi\ncall   1080 <realloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x48(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %rax,%rdi\nadd    $0x1,%rdi\ncall   1070 <malloc@plt>\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x28(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nmov    -0x48(%rbp),%rsi\ncall   1040 <strcpy@plt>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\nmov    -0x4c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    131b <func0+0x1ab>\nmov    -0x8(%rbp),%rax\nmovslq -0x4c(%rbp),%rcx\nmov    (%rax,%rcx,1),%dl\nmov    -0x48(%rbp),%rax\nmov    -0x4c(%rbp),%ecx\nsub    -0x34(%rbp),%ecx\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x20(%rbp),%rdi\nmov    -0x8(%rbp),%rax\nmovslq -0x4c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%esi\ncall   1060 <strchr@plt>\ncmp    $0x0,%rax\njne    1316 <func0+0x1a6>\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x4c(%rbp),%rdx\nmovzbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x400,%eax\ncmp    $0x0,%eax\nje     1316 <func0+0x1a6>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    131b <func0+0x1ab>\njmp    1320 <func0+0x1b0>\nmov    -0x4c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4c(%rbp)\njmp    11d0 <func0+0x60>\nmov    -0x48(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x30(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x28(%rbp),%rax\nadd    $0x50,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 117,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdx,0x18(%rsp)\nmov    %esi,0x14(%rsp)\nmov    %rdi,0x30(%rsp)\ncall   1050 <strlen@plt>\nadd    $0x1,%rax\nmov    %rax,0x28(%rsp)\nmov    %rax,%rdi\ncall   1070 <malloc@plt>\nmov    %rax,%rbx\nxor    %r14d,%r14d\ncall   1090 <__ctype_b_loc@plt>\nmov    %rax,0x20(%rsp)\nxor    %eax,%eax\nmov    %rax,0x8(%rsp)\nxor    %r13d,%r13d\nxor    %r12d,%r12d\nmovl   $0x0,0x4(%rsp)\njmp    11e6 <func0+0x76>\nnopl   0x0(%rax)\nlea    0x1(%r14),%r12d\nxor    %r13d,%r13d\nadd    $0x1,%r14\ncmp    %r14,0x28(%rsp)\nje     12a6 <func0+0x136>\nmov    0x20(%rsp),%rax\nmov    (%rax),%rbp\nmov    0x30(%rsp),%rax\nmovsbq (%rax,%r14,1),%r15\ntestb  $0x20,0x1(%rbp,%r15,2)\njne    1240 <func0+0xd0>\ntest   %r15b,%r15b\nje     1240 <func0+0xd0>\nmov    %r14d,%eax\nsub    %r12d,%eax\ncltq\nmov    %r15b,(%rbx,%rax,1)\nmov    $0xb,%edx\nlea    0xde3(%rip),%rdi\nmov    %r15d,%esi\ncall   1060 <memchr@plt>\ntest   %rax,%rax\njne    11d7 <func0+0x67>\nmovzbl %r15b,%eax\nmovzwl 0x0(%rbp,%rax,2),%eax\nshr    $0xa,%eax\nand    $0x1,%eax\nadd    %eax,%r13d\njmp    11d7 <func0+0x67>\nxchg   %ax,%ax\ncmp    0x14(%rsp),%r13d\njne    11d0 <func0+0x60>\nmov    %r14d,%eax\nsub    %r12d,%eax\ncltq\nmovb   $0x0,(%rbx,%rax,1)\nmov    0x4(%rsp),%eax\nmovslq %eax,%r15\nadd    $0x1,%eax\nmov    %eax,0x4(%rsp)\nlea    0x8(,%r15,8),%rsi\nmov    0x8(%rsp),%rdi\ncall   1080 <realloc@plt>\nmov    %rbx,%rbp\nmov    %rax,%rbx\nmov    %rbp,%rdi\ncall   1050 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1070 <malloc@plt>\nmov    %rbx,0x8(%rsp)\nmov    %rax,(%rbx,%r15,8)\nmov    %rbp,%rbx\nmov    %rax,%rdi\nmov    %rbp,%rsi\ncall   1040 <strcpy@plt>\njmp    11d0 <func0+0x60>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    0x18(%rsp),%rax\nmov    0x4(%rsp),%ecx\nmov    %ecx,(%rax)\nmov    0x8(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 117,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdx,0x18(%rsp)\nmov    %esi,0x14(%rsp)\nmov    %rdi,0x30(%rsp)\ncall   1050 <strlen@plt>\nadd    $0x1,%rax\nmov    %rax,0x28(%rsp)\nmov    %rax,%rdi\ncall   1070 <malloc@plt>\nmov    %rax,%rbx\nxor    %r14d,%r14d\ncall   1090 <__ctype_b_loc@plt>\nmov    %rax,0x20(%rsp)\nxor    %eax,%eax\nmov    %rax,0x8(%rsp)\nxor    %r13d,%r13d\nxor    %r12d,%r12d\nmovl   $0x0,0x4(%rsp)\njmp    11e6 <func0+0x76>\nnopl   0x0(%rax)\nlea    0x1(%r14),%r12d\nxor    %r13d,%r13d\nadd    $0x1,%r14\ncmp    %r14,0x28(%rsp)\nje     12a6 <func0+0x136>\nmov    0x20(%rsp),%rax\nmov    (%rax),%rbp\nmov    0x30(%rsp),%rax\nmovsbq (%rax,%r14,1),%r15\ntestb  $0x20,0x1(%rbp,%r15,2)\njne    1240 <func0+0xd0>\ntest   %r15b,%r15b\nje     1240 <func0+0xd0>\nmov    %r14d,%eax\nsub    %r12d,%eax\ncltq\nmov    %r15b,(%rbx,%rax,1)\nmov    $0xb,%edx\nlea    0xde3(%rip),%rdi\nmov    %r15d,%esi\ncall   1060 <memchr@plt>\ntest   %rax,%rax\njne    11d7 <func0+0x67>\nmovzbl %r15b,%eax\nmovzwl 0x0(%rbp,%rax,2),%eax\nshr    $0xa,%eax\nand    $0x1,%eax\nadd    %eax,%r13d\njmp    11d7 <func0+0x67>\nxchg   %ax,%ax\ncmp    0x14(%rsp),%r13d\njne    11d0 <func0+0x60>\nmov    %r14d,%eax\nsub    %r12d,%eax\ncltq\nmovb   $0x0,(%rbx,%rax,1)\nmov    0x4(%rsp),%eax\nmovslq %eax,%r15\nadd    $0x1,%eax\nmov    %eax,0x4(%rsp)\nlea    0x8(,%r15,8),%rsi\nmov    0x8(%rsp),%rdi\ncall   1080 <realloc@plt>\nmov    %rbx,%rbp\nmov    %rax,%rbx\nmov    %rbp,%rdi\ncall   1050 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1070 <malloc@plt>\nmov    %rbx,0x8(%rsp)\nmov    %rax,(%rbx,%r15,8)\nmov    %rbp,%rbx\nmov    %rax,%rdi\nmov    %rbp,%rsi\ncall   1040 <strcpy@plt>\njmp    11d0 <func0+0x60>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    0x18(%rsp),%rax\nmov    0x4(%rsp),%ecx\nmov    %ecx,(%rax)\nmov    0x8(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 117,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdx,0x18(%rsp)\nmov    %esi,0x14(%rsp)\nmov    %rdi,0x30(%rsp)\ncall   1050 <strlen@plt>\nadd    $0x1,%rax\nmov    %rax,0x28(%rsp)\nmov    %rax,%rdi\ncall   1070 <malloc@plt>\nmov    %rax,%rbx\nxor    %r14d,%r14d\ncall   1090 <__ctype_b_loc@plt>\nmov    %rax,0x20(%rsp)\nxor    %eax,%eax\nmov    %rax,0x8(%rsp)\nxor    %r13d,%r13d\nxor    %r12d,%r12d\nmovl   $0x0,0x4(%rsp)\njmp    11e6 <func0+0x76>\nnopl   0x0(%rax)\nlea    0x1(%r14),%r12d\nxor    %r13d,%r13d\nadd    $0x1,%r14\ncmp    %r14,0x28(%rsp)\nje     12a6 <func0+0x136>\nmov    0x20(%rsp),%rax\nmov    (%rax),%rbp\nmov    0x30(%rsp),%rax\nmovsbq (%rax,%r14,1),%r15\ntestb  $0x20,0x1(%rbp,%r15,2)\njne    1240 <func0+0xd0>\ntest   %r15b,%r15b\nje     1240 <func0+0xd0>\nmov    %r14d,%eax\nsub    %r12d,%eax\ncltq\nmov    %r15b,(%rbx,%rax,1)\nmov    $0xb,%edx\nlea    0xde3(%rip),%rdi\nmov    %r15d,%esi\ncall   1060 <memchr@plt>\ntest   %rax,%rax\njne    11d7 <func0+0x67>\nmovzbl %r15b,%eax\nmovzwl 0x0(%rbp,%rax,2),%eax\nshr    $0xa,%eax\nand    $0x1,%eax\nadd    %eax,%r13d\njmp    11d7 <func0+0x67>\nxchg   %ax,%ax\ncmp    0x14(%rsp),%r13d\njne    11d0 <func0+0x60>\nmov    %r14d,%eax\nsub    %r12d,%eax\ncltq\nmovb   $0x0,(%rbx,%rax,1)\nmov    0x4(%rsp),%eax\nmovslq %eax,%r15\nadd    $0x1,%eax\nmov    %eax,0x4(%rsp)\nlea    0x8(,%r15,8),%rsi\nmov    0x8(%rsp),%rdi\ncall   1080 <realloc@plt>\nmov    %rbx,%rbp\nmov    %rax,%rbx\nmov    %rbp,%rdi\ncall   1050 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1070 <malloc@plt>\nmov    %rbx,0x8(%rsp)\nmov    %rax,(%rbx,%r15,8)\nmov    %rbp,%rbx\nmov    %rax,%rdi\nmov    %rbp,%rsi\ncall   1040 <strcpy@plt>\njmp    11d0 <func0+0x60>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    0x18(%rsp),%rax\nmov    0x4(%rsp),%ecx\nmov    %ecx,(%rax)\nmov    0x8(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 118,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nlea    0xecd(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nsub    $0x2,%rax\nmov    %eax,-0x24(%rbp)\ncmpl   $0x1,-0x24(%rbp)\njl     11f4 <func0+0xd4>\nmov    -0x18(%rbp),%rdi\nmov    -0x10(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%esi\ncall   1040 <strchr@plt>\ncmp    $0x0,%rax\nje     11e1 <func0+0xc1>\nmov    -0x18(%rbp),%rdi\nmov    -0x10(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmovsbl (%rax,%rcx,1),%esi\ncall   1040 <strchr@plt>\ncmp    $0x0,%rax\njne    11e1 <func0+0xc1>\nmov    -0x18(%rbp),%rdi\nmov    -0x10(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmovsbl (%rax,%rcx,1),%esi\ncall   1040 <strchr@plt>\ncmp    $0x0,%rax\njne    11e1 <func0+0xc1>\nmov    -0x10(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,0x2e60(%rip)\nlea    0x2e59(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    1206 <func0+0xe6>\njmp    11e6 <func0+0xc6>\nmov    -0x24(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x24(%rbp)\njmp    114f <func0+0x2f>\nmovb   $0x0,0x2e36(%rip)\nlea    0x2e2f(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 118,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r15\ncall   1030 <strlen@plt>\nadd    $0xfffffffe,%eax\ntest   %eax,%eax\njle    11a7 <func0+0x87>\nmovslq %eax,%rbx\nadd    $0x1,%rbx\nlea    0xebc(%rip),%r14\njmp    115a <func0+0x3a>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0xffffffffffffffff,%rbx\ncmp    $0x1,%rbx\njle    11a7 <func0+0x87>\nmovzbl -0x1(%r15,%rbx,1),%ebp\nmovsbl %bpl,%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1040 <memchr@plt>\ntest   %rax,%rax\nje     1150 <func0+0x30>\nmovsbl (%r15,%rbx,1),%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1040 <memchr@plt>\ntest   %rax,%rax\njne    1150 <func0+0x30>\nmovsbl -0x2(%r15,%rbx,1),%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1040 <memchr@plt>\ntest   %rax,%rax\njne    1150 <func0+0x30>\njmp    11a9 <func0+0x89>\nxor    %ebp,%ebp\nmov    %bpl,0x2e81(%rip)\nlea    0x2e7a(%rip),%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 118,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdi,%r15\ncall   1030 <strlen@plt>\nadd    $0xfffffffe,%eax\ntest   %eax,%eax\njle    11ad <func0+0x8d>\nmov    %eax,%ebx\nmov    $0xffffffff,%r12d\nadd    %rbx,%r12\nadd    $0x1,%rbx\nlea    0xeb3(%rip),%r14\njmp    115e <func0+0x3e>\nnop\nadd    $0xffffffffffffffff,%r12\nadd    $0xffffffffffffffff,%rbx\ncmp    $0x1,%rbx\njle    11ad <func0+0x8d>\nmovzbl -0x1(%r15,%rbx,1),%ebp\nmovsbl %bpl,%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1040 <memchr@plt>\ntest   %rax,%rax\nje     1150 <func0+0x30>\nmovsbl (%r15,%rbx,1),%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1040 <memchr@plt>\ntest   %rax,%rax\njne    1150 <func0+0x30>\nmov    %r12d,%eax\nmovsbl (%r15,%rax,1),%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1040 <memchr@plt>\ntest   %rax,%rax\njne    1150 <func0+0x30>\njmp    11af <func0+0x8f>\nxor    %ebp,%ebp\nmov    %bpl,0x2e7b(%rip)\nlea    0x2e74(%rip),%rax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 118,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdi,%r15\ncall   1030 <strlen@plt>\nadd    $0xfffffffe,%eax\ntest   %eax,%eax\njle    11ad <func0+0x8d>\nmov    %eax,%ebx\nmov    $0xffffffff,%r12d\nadd    %rbx,%r12\nadd    $0x1,%rbx\nlea    0xeb3(%rip),%r14\njmp    115e <func0+0x3e>\nnop\nadd    $0xffffffffffffffff,%r12\nadd    $0xffffffffffffffff,%rbx\ncmp    $0x1,%rbx\njle    11ad <func0+0x8d>\nmovzbl -0x1(%r15,%rbx,1),%ebp\nmovsbl %bpl,%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1040 <memchr@plt>\ntest   %rax,%rax\nje     1150 <func0+0x30>\nmovsbl (%r15,%rbx,1),%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1040 <memchr@plt>\ntest   %rax,%rax\njne    1150 <func0+0x30>\nmov    %r12d,%eax\nmovsbl (%r15,%rax,1),%esi\nmov    $0xb,%edx\nmov    %r14,%rdi\ncall   1040 <memchr@plt>\ntest   %rax,%rax\njne    1150 <func0+0x30>\njmp    11af <func0+0x8f>\nxor    %ebp,%ebp\nmov    %bpl,0x2e7b(%rip)\nlea    0x2e74(%rip),%rax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 119,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %rsi,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x20(%rbp)\nmov    -0x18(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x24(%rbp)\nmovl   $0x1,-0x2c(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    11b9 <func0+0xa9>\nmov    -0x10(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x28,%eax\njne    1177 <func0+0x67>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x29,%eax\njne    1195 <func0+0x85>\nmov    -0x1c(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njge    11a6 <func0+0x96>\nmovl   $0x0,-0x2c(%rbp)\njmp    11ab <func0+0x9b>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    114d <func0+0x3d>\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njge    122c <func0+0x11c>\nmov    -0x18(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x28,%eax\njne    11ea <func0+0xda>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x29,%eax\njne    1208 <func0+0xf8>\nmov    -0x1c(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njge    1219 <func0+0x109>\nmovl   $0x0,-0x2c(%rbp)\njmp    121e <func0+0x10e>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    11c0 <func0+0xb0>\ncmpl   $0x0,-0x1c(%rbp)\njne    1250 <func0+0x140>\ncmpl   $0x0,-0x2c(%rbp)\nje     1250 <func0+0x140>\nlea    0xdb9(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    1373 <func0+0x263>\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x1,-0x2c(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njge    12d1 <func0+0x1c1>\nmov    -0x18(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x28,%eax\njne    128f <func0+0x17f>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x29,%eax\njne    12ad <func0+0x19d>\nmov    -0x1c(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njge    12be <func0+0x1ae>\nmovl   $0x0,-0x2c(%rbp)\njmp    12c3 <func0+0x1b3>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    1265 <func0+0x155>\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    1344 <func0+0x234>\nmov    -0x10(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x28,%eax\njne    1302 <func0+0x1f2>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x29,%eax\njne    1320 <func0+0x210>\nmov    -0x1c(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njge    1331 <func0+0x221>\nmovl   $0x0,-0x2c(%rbp)\njmp    1336 <func0+0x226>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    12d8 <func0+0x1c8>\ncmpl   $0x0,-0x1c(%rbp)\njne    1368 <func0+0x258>\ncmpl   $0x0,-0x2c(%rbp)\nje     1368 <func0+0x258>\nlea    0xca1(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    1373 <func0+0x263>\nlea    0xc95(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 119,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r12\nmov    %rdi,%r15\ncall   1030 <strlen@plt>\nmov    %rax,%r14\nmov    %r12,%rdi\ncall   1030 <strlen@plt>\ntest   %r14d,%r14d\njle    11c1 <func0+0xb1>\nmov    %r14d,%r9d\nxor    %r8d,%r8d\nmov    $0x1,%ecx\nxor    %edi,%edi\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%r15,%rdi,1),%edx\nxor    %esi,%esi\ncmp    $0x28,%dl\nsete   %sil\nadd    %ebx,%esi\nxor    %ebx,%ebx\ncmp    $0x29,%dl\nsete   %bl\nsub    %ebx,%esi\ncmovs  %r8d,%ecx\nadd    $0x1,%rdi\nmov    %esi,%ebx\ncmp    %rdi,%r9\njne    1150 <func0+0x40>\ntest   %eax,%eax\njle    11cc <func0+0xbc>\nmov    %eax,%edi\nxor    %r8d,%r8d\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovzbl (%r12,%rbx,1),%r9d\nxor    %edx,%edx\ncmp    $0x28,%r9b\nsete   %dl\nadd    %esi,%edx\nxor    %esi,%esi\ncmp    $0x29,%r9b\nsete   %sil\nsub    %esi,%edx\ncmovs  %r8d,%ecx\nadd    $0x1,%rbx\nmov    %edx,%esi\ncmp    %rbx,%rdi\njne    1190 <func0+0x80>\ntest   %edx,%edx\nje     11d2 <func0+0xc2>\njmp    11e2 <func0+0xd2>\nmov    $0x1,%ecx\nxor    %esi,%esi\ntest   %eax,%eax\njg     117d <func0+0x6d>\nmov    %esi,%edx\ntest   %edx,%edx\njne    11e2 <func0+0xd2>\ntest   %ecx,%ecx\nje     11e2 <func0+0xd2>\nlea    0xe23(%rip),%rax\njmp    1293 <func0+0x183>\ntest   %eax,%eax\njle    126b <func0+0x15b>\nmov    %eax,%esi\nxor    %r8d,%r8d\nmov    $0x1,%eax\nxor    %edi,%edi\nxor    %ebx,%ebx\nnopl   0x0(%rax,%rax,1)\nmovzbl (%r12,%rdi,1),%edx\nxor    %ecx,%ecx\ncmp    $0x28,%dl\nsete   %cl\nadd    %ebx,%ecx\nxor    %ebx,%ebx\ncmp    $0x29,%dl\nsete   %bl\nsub    %ebx,%ecx\ncmovs  %r8d,%eax\nadd    $0x1,%rdi\nmov    %ecx,%ebx\ncmp    %rdi,%rsi\njne    1200 <func0+0xf0>\ntest   %r14d,%r14d\njle    1277 <func0+0x167>\nmov    %r14d,%esi\nxor    %r8d,%r8d\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovzbl (%r15,%rbx,1),%edx\nxor    %edi,%edi\ncmp    $0x28,%dl\nsete   %dil\nadd    %ecx,%edi\nxor    %ecx,%ecx\ncmp    $0x29,%dl\nsete   %cl\nsub    %ecx,%edi\ncmovs  %r8d,%eax\nadd    $0x1,%rbx\nmov    %edi,%ecx\ncmp    %rbx,%rsi\njne    1240 <func0+0x130>\njmp    1279 <func0+0x169>\nmov    $0x1,%eax\nxor    %ecx,%ecx\ntest   %r14d,%r14d\njg     122d <func0+0x11d>\nmov    %ecx,%edi\ntest   %eax,%eax\nlea    0xd7e(%rip),%rax\nlea    0xd7b(%rip),%rcx\ncmove  %rcx,%rax\ntest   %edi,%edi\ncmovne %rcx,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 119,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r12\nmov    %rdi,%r15\ncall   1030 <strlen@plt>\nmov    %rax,%r14\nmov    %r12,%rdi\ncall   1030 <strlen@plt>\ntest   %r14d,%r14d\njle    1151 <func0+0x41>\nmov    %r14d,%r10d\nmov    %r14d,%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r10\njne    115a <func0+0x4a>\nxor    %esi,%esi\nmov    $0x1,%ebp\nxor    %edi,%edi\njmp    11b4 <func0+0xa4>\nmov    $0x1,%ebp\nxor    %edi,%edi\njmp    11d8 <func0+0xc8>\nsub    %r8,%r10\nxor    %r9d,%r9d\nmov    $0x1,%ebp\nxor    %esi,%esi\nxor    %edi,%edi\nnopl   0x0(%rax)\nmovzbl (%r15,%rsi,1),%ebx\nmovzbl 0x1(%r15,%rsi,1),%ecx\nxor    %edx,%edx\ncmp    $0x28,%bl\nsete   %dl\nadd    %edi,%edx\nxor    %edi,%edi\ncmp    $0x29,%bl\nsete   %dil\nsub    %edi,%edx\nxor    %edi,%edi\ncmp    $0x28,%cl\nsete   %dil\nadd    %edx,%edi\nxor    %ebx,%ebx\ncmp    $0x29,%cl\nsete   %bl\nsub    %ebx,%edi\nor     %edi,%edx\ncmovs  %r9d,%ebp\nadd    $0x2,%rsi\ncmp    %rsi,%r10\njne    1170 <func0+0x60>\ntest   %r8,%r8\nje     11d8 <func0+0xc8>\nmov    (%r15,%rsi,1),%cl\nxor    %esi,%esi\ncmp    $0x28,%cl\nsete   %sil\nadd    %esi,%edi\nxor    %esi,%esi\ncmp    $0x29,%cl\nsete   %sil\nxor    %ecx,%ecx\nsub    %esi,%edi\ncmovs  %ecx,%ebp\ntest   %eax,%eax\njle    12fc <func0+0x1ec>\nmov    %eax,%r8d\nmov    %eax,%r10d\nand    $0x1,%r10d\nxor    %r11d,%r11d\nmov    %r8,%r9\nadd    $0xffffffffffffffff,%r9\nje     1318 <func0+0x208>\nmov    %r8,%r13\nsub    %r10,%r13\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovzbl (%r12,%rcx,1),%edx\nmovzbl 0x1(%r12,%rcx,1),%ebx\nxor    %esi,%esi\ncmp    $0x28,%dl\nsete   %sil\nadd    %edi,%esi\nxor    %edi,%edi\ncmp    $0x29,%dl\nsete   %dil\nsub    %edi,%esi\nxor    %edi,%edi\ncmp    $0x28,%bl\nsete   %dil\nadd    %esi,%edi\nxor    %edx,%edx\ncmp    $0x29,%bl\nsete   %dl\nsub    %edx,%edi\nor     %edi,%esi\ncmovs  %r11d,%ebp\nadd    $0x2,%rcx\ncmp    %rcx,%r13\njne    1210 <func0+0x100>\ntest   %r10,%r10\nje     1277 <func0+0x167>\nmov    (%r12,%rcx,1),%cl\nxor    %edx,%edx\ncmp    $0x28,%cl\nsete   %dl\nadd    %edx,%edi\nxor    %edx,%edx\ncmp    $0x29,%cl\nsete   %dl\nxor    %ecx,%ecx\nsub    %edx,%edi\ncmovs  %ecx,%ebp\ntest   %edi,%edi\njne    1283 <func0+0x173>\ntest   %ebp,%ebp\njne    130c <func0+0x1fc>\ntest   %eax,%eax\njle    1328 <func0+0x218>\nand    $0x1,%eax\ntest   %r9,%r9\nje     1332 <func0+0x222>\nsub    %rax,%r8\nxor    %edi,%edi\nmov    $0x1,%r9d\nxor    %edx,%edx\nxor    %esi,%esi\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%r12,%rdx,1),%ebx\nmovzbl 0x1(%r12,%rdx,1),%ecx\nxor    %ebp,%ebp\ncmp    $0x28,%bl\nsete   %bpl\nadd    %esi,%ebp\nxor    %esi,%esi\ncmp    $0x29,%bl\nsete   %sil\nsub    %esi,%ebp\nxor    %esi,%esi\ncmp    $0x28,%cl\nsete   %sil\nadd    %ebp,%esi\nxor    %ebx,%ebx\ncmp    $0x29,%cl\nsete   %bl\nsub    %ebx,%esi\nor     %esi,%ebp\ncmovs  %edi,%r9d\nadd    $0x2,%rdx\ncmp    %rdx,%r8\njne    12b0 <func0+0x1a0>\ntest   %rax,%rax\njne    1341 <func0+0x231>\njmp    135d <func0+0x24d>\nxor    %esi,%esi\nmov    $0x1,%r9d\ntest   %edi,%edi\njne    135d <func0+0x24d>\ntest   %ebp,%ebp\nje     135d <func0+0x24d>\nlea    0xced(%rip),%rax\njmp    1401 <func0+0x2f1>\nxor    %ecx,%ecx\ntest   %r10,%r10\njne    125a <func0+0x14a>\njmp    1277 <func0+0x167>\nmov    $0x1,%r9d\nxor    %esi,%esi\njmp    135d <func0+0x24d>\nxor    %edx,%edx\nmov    $0x1,%r9d\nxor    %esi,%esi\ntest   %rax,%rax\nje     135d <func0+0x24d>\nmov    (%r12,%rdx,1),%al\nxor    %edx,%edx\ncmp    $0x28,%al\nsete   %dl\nadd    %edx,%esi\nxor    %edx,%edx\ncmp    $0x29,%al\nsete   %dl\nxor    %eax,%eax\nsub    %edx,%esi\ncmovs  %eax,%r9d\ntest   %r14d,%r14d\njle    13e6 <func0+0x2d6>\nmov    %r14d,%edx\nand    $0x1,%r14d\nxor    %edi,%edi\ncmp    $0x1,%rdx\njne    1379 <func0+0x269>\nxor    %eax,%eax\njmp    13c5 <func0+0x2b5>\nsub    %r14,%rdx\nxor    %eax,%eax\nxchg   %ax,%ax\nmovzbl (%r15,%rax,1),%ecx\nmovzbl 0x1(%r15,%rax,1),%ebx\nxor    %ebp,%ebp\ncmp    $0x28,%cl\nsete   %bpl\nadd    %esi,%ebp\nxor    %esi,%esi\ncmp    $0x29,%cl\nsete   %sil\nsub    %esi,%ebp\nxor    %esi,%esi\ncmp    $0x28,%bl\nsete   %sil\nadd    %ebp,%esi\nxor    %ecx,%ecx\ncmp    $0x29,%bl\nsete   %cl\nsub    %ecx,%esi\nor     %esi,%ebp\ncmovs  %edi,%r9d\nadd    $0x2,%rax\ncmp    %rax,%rdx\njne    1380 <func0+0x270>\ntest   %r14,%r14\nje     13e6 <func0+0x2d6>\nmov    (%r15,%rax,1),%al\nxor    %ecx,%ecx\ncmp    $0x28,%al\nsete   %cl\nadd    %ecx,%esi\nxor    %ecx,%ecx\ncmp    $0x29,%al\nsete   %cl\nxor    %eax,%eax\nsub    %ecx,%esi\ncmovs  %eax,%r9d\ntest   %r9d,%r9d\nlea    0xc10(%rip),%rax\nlea    0xc0d(%rip),%rcx\ncmove  %rcx,%rax\ntest   %esi,%esi\ncmovne %rcx,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 119,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r12\nmov    %rdi,%r15\ncall   1030 <strlen@plt>\nmov    %rax,%r14\nmov    %r12,%rdi\ncall   1030 <strlen@plt>\ntest   %r14d,%r14d\njle    1151 <func0+0x41>\nmov    %r14d,%r10d\nmov    %r14d,%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r10\njne    115a <func0+0x4a>\nxor    %esi,%esi\nmov    $0x1,%ebp\nxor    %edi,%edi\njmp    11b4 <func0+0xa4>\nmov    $0x1,%ebp\nxor    %edi,%edi\njmp    11d8 <func0+0xc8>\nsub    %r8,%r10\nxor    %r9d,%r9d\nmov    $0x1,%ebp\nxor    %esi,%esi\nxor    %edi,%edi\nnopl   0x0(%rax)\nmovzbl (%r15,%rsi,1),%ebx\nmovzbl 0x1(%r15,%rsi,1),%ecx\nxor    %edx,%edx\ncmp    $0x28,%bl\nsete   %dl\nadd    %edi,%edx\nxor    %edi,%edi\ncmp    $0x29,%bl\nsete   %dil\nsub    %edi,%edx\nxor    %edi,%edi\ncmp    $0x28,%cl\nsete   %dil\nadd    %edx,%edi\nxor    %ebx,%ebx\ncmp    $0x29,%cl\nsete   %bl\nsub    %ebx,%edi\nor     %edi,%edx\ncmovs  %r9d,%ebp\nadd    $0x2,%rsi\ncmp    %rsi,%r10\njne    1170 <func0+0x60>\ntest   %r8,%r8\nje     11d8 <func0+0xc8>\nmov    (%r15,%rsi,1),%cl\nxor    %esi,%esi\ncmp    $0x28,%cl\nsete   %sil\nadd    %esi,%edi\nxor    %esi,%esi\ncmp    $0x29,%cl\nsete   %sil\nxor    %ecx,%ecx\nsub    %esi,%edi\ncmovs  %ecx,%ebp\ntest   %eax,%eax\njle    12fc <func0+0x1ec>\nmov    %eax,%r8d\nmov    %eax,%r10d\nand    $0x1,%r10d\nxor    %r11d,%r11d\nmov    %r8,%r9\nadd    $0xffffffffffffffff,%r9\nje     1318 <func0+0x208>\nmov    %r8,%r13\nsub    %r10,%r13\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovzbl (%r12,%rcx,1),%edx\nmovzbl 0x1(%r12,%rcx,1),%ebx\nxor    %esi,%esi\ncmp    $0x28,%dl\nsete   %sil\nadd    %edi,%esi\nxor    %edi,%edi\ncmp    $0x29,%dl\nsete   %dil\nsub    %edi,%esi\nxor    %edi,%edi\ncmp    $0x28,%bl\nsete   %dil\nadd    %esi,%edi\nxor    %edx,%edx\ncmp    $0x29,%bl\nsete   %dl\nsub    %edx,%edi\nor     %edi,%esi\ncmovs  %r11d,%ebp\nadd    $0x2,%rcx\ncmp    %rcx,%r13\njne    1210 <func0+0x100>\ntest   %r10,%r10\nje     1277 <func0+0x167>\nmov    (%r12,%rcx,1),%cl\nxor    %edx,%edx\ncmp    $0x28,%cl\nsete   %dl\nadd    %edx,%edi\nxor    %edx,%edx\ncmp    $0x29,%cl\nsete   %dl\nxor    %ecx,%ecx\nsub    %edx,%edi\ncmovs  %ecx,%ebp\ntest   %edi,%edi\njne    1283 <func0+0x173>\ntest   %ebp,%ebp\njne    130c <func0+0x1fc>\ntest   %eax,%eax\njle    1328 <func0+0x218>\nand    $0x1,%eax\ntest   %r9,%r9\nje     1332 <func0+0x222>\nsub    %rax,%r8\nxor    %edi,%edi\nmov    $0x1,%r9d\nxor    %edx,%edx\nxor    %esi,%esi\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%r12,%rdx,1),%ebx\nmovzbl 0x1(%r12,%rdx,1),%ecx\nxor    %ebp,%ebp\ncmp    $0x28,%bl\nsete   %bpl\nadd    %esi,%ebp\nxor    %esi,%esi\ncmp    $0x29,%bl\nsete   %sil\nsub    %esi,%ebp\nxor    %esi,%esi\ncmp    $0x28,%cl\nsete   %sil\nadd    %ebp,%esi\nxor    %ebx,%ebx\ncmp    $0x29,%cl\nsete   %bl\nsub    %ebx,%esi\nor     %esi,%ebp\ncmovs  %edi,%r9d\nadd    $0x2,%rdx\ncmp    %rdx,%r8\njne    12b0 <func0+0x1a0>\ntest   %rax,%rax\njne    1341 <func0+0x231>\njmp    135d <func0+0x24d>\nxor    %esi,%esi\nmov    $0x1,%r9d\ntest   %edi,%edi\njne    135d <func0+0x24d>\ntest   %ebp,%ebp\nje     135d <func0+0x24d>\nlea    0xced(%rip),%rax\njmp    1401 <func0+0x2f1>\nxor    %ecx,%ecx\ntest   %r10,%r10\njne    125a <func0+0x14a>\njmp    1277 <func0+0x167>\nmov    $0x1,%r9d\nxor    %esi,%esi\njmp    135d <func0+0x24d>\nxor    %edx,%edx\nmov    $0x1,%r9d\nxor    %esi,%esi\ntest   %rax,%rax\nje     135d <func0+0x24d>\nmov    (%r12,%rdx,1),%al\nxor    %edx,%edx\ncmp    $0x28,%al\nsete   %dl\nadd    %edx,%esi\nxor    %edx,%edx\ncmp    $0x29,%al\nsete   %dl\nxor    %eax,%eax\nsub    %edx,%esi\ncmovs  %eax,%r9d\ntest   %r14d,%r14d\njle    13e6 <func0+0x2d6>\nmov    %r14d,%edx\nand    $0x1,%r14d\nxor    %edi,%edi\ncmp    $0x1,%rdx\njne    1379 <func0+0x269>\nxor    %eax,%eax\njmp    13c5 <func0+0x2b5>\nsub    %r14,%rdx\nxor    %eax,%eax\nxchg   %ax,%ax\nmovzbl (%r15,%rax,1),%ecx\nmovzbl 0x1(%r15,%rax,1),%ebx\nxor    %ebp,%ebp\ncmp    $0x28,%cl\nsete   %bpl\nadd    %esi,%ebp\nxor    %esi,%esi\ncmp    $0x29,%cl\nsete   %sil\nsub    %esi,%ebp\nxor    %esi,%esi\ncmp    $0x28,%bl\nsete   %sil\nadd    %ebp,%esi\nxor    %ecx,%ecx\ncmp    $0x29,%bl\nsete   %cl\nsub    %ecx,%esi\nor     %esi,%ebp\ncmovs  %edi,%r9d\nadd    $0x2,%rax\ncmp    %rax,%rdx\njne    1380 <func0+0x270>\ntest   %r14,%r14\nje     13e6 <func0+0x2d6>\nmov    (%r15,%rax,1),%al\nxor    %ecx,%ecx\ncmp    $0x28,%al\nsete   %cl\nadd    %ecx,%esi\nxor    %ecx,%ecx\ncmp    $0x29,%al\nsete   %cl\nxor    %eax,%eax\nsub    %ecx,%esi\ncmovs  %eax,%r9d\ntest   %r9d,%r9d\nlea    0xc10(%rip),%rax\nlea    0xc0d(%rip),%rcx\ncmove  %rcx,%rax\ntest   %esi,%esi\ncmovne %rcx,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 120,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\nmov    %rcx,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    -0xc(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    11c8 <func0+0xc8>\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    -0xc(%rbp),%ecx\nsub    -0x1c(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    11b5 <func0+0xb5>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmov    -0x20(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\njle    11a2 <func0+0xa2>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x20(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x24(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    -0x20(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    11a7 <func0+0xa7>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1131 <func0+0x31>\njmp    11ba <func0+0xba>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1119 <func0+0x19>\nmovl   $0x0,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njge    1207 <func0+0x107>\nmov    -0x8(%rbp),%rax\nmov    -0xc(%rbp),%ecx\nsub    -0x10(%rbp),%ecx\nadd    -0x28(%rbp),%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    11cf <func0+0xcf>\npop    %rbp\nret\n"
    },
    {
        "task_id": 120,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\ncmp    $0x2,%esi\njl     1160 <func0+0x60>\nlea    -0x1(%rsi),%r8d\nxor    %r9d,%r9d\nmov    %r8d,%r10d\njmp    112d <func0+0x2d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x1,%r9d\nadd    $0xffffffff,%r10d\ncmp    %r8d,%r9d\nje     1160 <func0+0x60>\nmov    %r10d,%r10d\nmov    %r9d,%eax\nnot    %eax\nadd    %esi,%eax\ntest   %eax,%eax\njle    1120 <func0+0x20>\nxor    %eax,%eax\njmp    1148 <func0+0x48>\nnop\nmov    %r11,%rax\ncmp    %r11,%r10\nje     1120 <func0+0x20>\nmov    (%rdi,%rax,4),%ebx\nmov    0x4(%rdi,%rax,4),%ebp\nlea    0x1(%rax),%r11\ncmp    %ebp,%ebx\njle    1140 <func0+0x40>\nmov    %ebp,(%rdi,%rax,4)\nmov    %ebx,0x4(%rdi,%rax,4)\njmp    1140 <func0+0x40>\ntest   %edx,%edx\njle    118f <func0+0x8f>\nsub    %edx,%esi\nmovslq %esi,%rsi\nmov    %edx,%eax\nlea    (%rdi,%rsi,4),%rdx\nxor    %esi,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    (%rdx,%rsi,4),%edi\nmov    %edi,(%rcx,%rsi,4)\nadd    $0x1,%rsi\ncmp    %rsi,%rax\njne    1180 <func0+0x80>\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 120,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\ncmp    $0x2,%esi\njl     11c5 <func0+0xc5>\nlea    -0x1(%rsi),%r8d\nxor    %r9d,%r9d\nmov    %r8d,%r10d\njmp    1131 <func0+0x31>\nnopl   0x0(%rax)\nadd    $0x1,%r9d\nadd    $0xffffffff,%r10d\ncmp    %r8d,%r9d\nje     11c5 <func0+0xc5>\nmov    %r10d,%r10d\nmov    %r9d,%eax\nnot    %eax\nadd    %esi,%eax\ntest   %eax,%eax\njle    1120 <func0+0x20>\nmov    (%rdi),%r14d\ncmp    $0x1,%r10d\njne    1170 <func0+0x70>\nxor    %eax,%eax\ntest   $0x1,%r10b\nje     1120 <func0+0x20>\nmov    0x4(%rdi,%rax,4),%ebp\ncmp    %ebp,%r14d\njle    1120 <func0+0x20>\nmov    %ebp,(%rdi,%rax,4)\nmov    %r14d,0x4(%rdi,%rax,4)\njmp    1120 <func0+0x20>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %r10d,%r11d\nand    $0xfffffffe,%r11d\nxor    %ebx,%ebx\njmp    1191 <func0+0x91>\nnopl   0x0(%rax,%rax,1)\nmov    %ebp,0x4(%rdi,%rbx,4)\nmov    %r14d,0x8(%rdi,%rbx,4)\nmov    %rax,%rbx\ncmp    %rax,%r11\nje     114a <func0+0x4a>\nmov    0x4(%rdi,%rbx,4),%eax\ncmp    %eax,%r14d\njle    11b0 <func0+0xb0>\nmov    %eax,(%rdi,%rbx,4)\nmov    %r14d,0x4(%rdi,%rbx,4)\njmp    11b3 <func0+0xb3>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %eax,%r14d\nlea    0x2(%rbx),%rax\nmov    0x8(%rdi,%rbx,4),%ebp\ncmp    %ebp,%r14d\njg     1180 <func0+0x80>\nmov    %ebp,%r14d\njmp    1189 <func0+0x89>\ntest   %edx,%edx\njle    1344 <func0+0x244>\nsub    %edx,%esi\nmovslq %esi,%r8\nmov    %edx,%r10d\ncmp    $0x8,%edx\njb     11f8 <func0+0xf8>\nlea    (%r8,%r10,1),%rax\nlea    (%rdi,%rax,4),%rax\ncmp    %rcx,%rax\njbe    126c <func0+0x16c>\nlea    (%rcx,%r10,4),%rax\nlea    (%rdi,%r8,4),%rdx\ncmp    %rax,%rdx\njae    126c <func0+0x16c>\nxor    %edx,%edx\nmov    %rdx,%rax\nnot    %rax\nadd    %r10,%rax\nmov    %r10,%rsi\nand    $0x3,%rsi\nje     1221 <func0+0x121>\nlea    (%rdi,%r8,4),%rbp\nmov    0x0(%rbp,%rdx,4),%ebx\nmov    %ebx,(%rcx,%rdx,4)\nadd    $0x1,%rdx\nadd    $0xffffffffffffffff,%rsi\njne    1210 <func0+0x110>\ncmp    $0x3,%rax\njb     1344 <func0+0x244>\nlea    (%rdi,%r8,4),%rax\nadd    $0xc,%rax\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    -0xc(%rax,%rdx,4),%esi\nmov    %esi,(%rcx,%rdx,4)\nmov    -0x8(%rax,%rdx,4),%esi\nmov    %esi,0x4(%rcx,%rdx,4)\nmov    -0x4(%rax,%rdx,4),%esi\nmov    %esi,0x8(%rcx,%rdx,4)\nmov    (%rax,%rdx,4),%esi\nmov    %esi,0xc(%rcx,%rdx,4)\nadd    $0x4,%rdx\ncmp    %rdx,%r10\njne    1240 <func0+0x140>\njmp    1344 <func0+0x244>\nmov    %r10d,%edx\nand    $0xfffffff8,%edx\nlea    -0x8(%rdx),%rax\nmov    %rax,%rsi\nshr    $0x3,%rsi\nadd    $0x1,%rsi\nmov    %esi,%r9d\nand    $0x3,%r9d\ncmp    $0x18,%rax\njae    1292 <func0+0x192>\nxor    %eax,%eax\njmp    12f8 <func0+0x1f8>\nand    $0xfffffffffffffffc,%rsi\nlea    (%rdi,%r8,4),%rbx\nadd    $0x70,%rbx\nxor    %eax,%eax\nmovups -0x70(%rbx,%rax,4),%xmm0\nmovups -0x60(%rbx,%rax,4),%xmm1\nmovups %xmm0,(%rcx,%rax,4)\nmovups %xmm1,0x10(%rcx,%rax,4)\nmovups -0x50(%rbx,%rax,4),%xmm0\nmovups -0x40(%rbx,%rax,4),%xmm1\nmovups %xmm0,0x20(%rcx,%rax,4)\nmovups %xmm1,0x30(%rcx,%rax,4)\nmovups -0x30(%rbx,%rax,4),%xmm0\nmovups -0x20(%rbx,%rax,4),%xmm1\nmovups %xmm0,0x40(%rcx,%rax,4)\nmovups %xmm1,0x50(%rcx,%rax,4)\nmovups -0x10(%rbx,%rax,4),%xmm0\nmovups (%rbx,%rax,4),%xmm1\nmovups %xmm0,0x60(%rcx,%rax,4)\nmovups %xmm1,0x70(%rcx,%rax,4)\nadd    $0x20,%rax\nadd    $0xfffffffffffffffc,%rsi\njne    12a0 <func0+0x1a0>\ntest   %r9,%r9\nje     133b <func0+0x23b>\nlea    (%rcx,%rax,4),%rsi\nadd    $0x10,%rsi\nadd    %r8,%rax\nlea    (%rdi,%rax,4),%rax\nadd    $0x10,%rax\nshl    $0x5,%r9\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nmovups -0x10(%rax,%rbp,1),%xmm0\nmovups (%rax,%rbp,1),%xmm1\nmovups %xmm0,-0x10(%rsi,%rbp,1)\nmovups %xmm1,(%rsi,%rbp,1)\nadd    $0x20,%rbp\ncmp    %rbp,%r9\njne    1320 <func0+0x220>\ncmp    %r10,%rdx\njne    11fa <func0+0xfa>\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 120,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\ncmp    $0x2,%esi\njl     11df <func0+0xdf>\nlea    -0x1(%rsi),%r8d\nxor    %r9d,%r9d\nmov    %r8d,%r10d\njmp    1131 <func0+0x31>\nnopl   0x0(%rax)\nadd    $0x1,%r9d\nadd    $0xffffffff,%r10d\ncmp    %r8d,%r9d\nje     11df <func0+0xdf>\nmov    %r10d,%r10d\nmov    %r9d,%eax\nnot    %eax\nadd    %esi,%eax\ntest   %eax,%eax\njle    1120 <func0+0x20>\nmov    (%rdi),%r14d\ncmp    $0x1,%r10d\njne    1150 <func0+0x50>\nxor    %eax,%eax\njmp    11bb <func0+0xbb>\nnopl   0x0(%rax)\nmov    %r10d,%r11d\nand    $0xfffffffe,%r11d\nxor    %ebx,%ebx\njmp    1171 <func0+0x71>\nnopl   0x0(%rax,%rax,1)\nmov    %ebp,0x4(%rdi,%rbx,4)\nmov    %r14d,0x8(%rdi,%rbx,4)\nmov    %rax,%rbx\ncmp    %rax,%r11\nje     11bb <func0+0xbb>\nmov    0x4(%rdi,%rbx,4),%eax\ncmp    %eax,%r14d\njle    11a0 <func0+0xa0>\nmov    %eax,(%rdi,%rbx,4)\nmov    %r14d,0x4(%rdi,%rbx,4)\nlea    0x2(%rbx),%rax\nmov    0x8(%rdi,%rbx,4),%ebp\ncmp    %ebp,%r14d\njg     1160 <func0+0x60>\njmp    11b0 <func0+0xb0>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %eax,%r14d\nlea    0x2(%rbx),%rax\nmov    0x8(%rdi,%rbx,4),%ebp\ncmp    %ebp,%r14d\njg     1160 <func0+0x60>\nmov    %ebp,%r14d\nmov    %rax,%rbx\ncmp    %rax,%r11\njne    1171 <func0+0x71>\ntest   $0x1,%r10b\nje     1120 <func0+0x20>\nmov    0x4(%rdi,%rax,4),%ebp\ncmp    %ebp,%r14d\njle    1120 <func0+0x20>\nmov    %ebp,(%rdi,%rax,4)\nmov    %r14d,0x4(%rdi,%rax,4)\njmp    1120 <func0+0x20>\ntest   %edx,%edx\njle    1364 <func0+0x264>\nsub    %edx,%esi\nmovslq %esi,%r8\nmov    %edx,%r10d\ncmp    $0x8,%edx\njb     1212 <func0+0x112>\nlea    (%r8,%r10,1),%rax\nlea    (%rdi,%rax,4),%rax\ncmp    %rcx,%rax\njbe    128c <func0+0x18c>\nlea    (%rcx,%r10,4),%rax\nlea    (%rdi,%r8,4),%rdx\ncmp    %rax,%rdx\njae    128c <func0+0x18c>\nxor    %edx,%edx\nmov    %rdx,%rax\nnot    %rax\nadd    %r10,%rax\nmov    %r10,%rsi\nand    $0x3,%rsi\nje     1241 <func0+0x141>\nlea    (%rdi,%r8,4),%rbp\nnopw   0x0(%rax,%rax,1)\nmov    0x0(%rbp,%rdx,4),%ebx\nmov    %ebx,(%rcx,%rdx,4)\nadd    $0x1,%rdx\nadd    $0xffffffffffffffff,%rsi\njne    1230 <func0+0x130>\ncmp    $0x3,%rax\njb     1364 <func0+0x264>\nlea    (%rdi,%r8,4),%rax\nadd    $0xc,%rax\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    -0xc(%rax,%rdx,4),%esi\nmov    %esi,(%rcx,%rdx,4)\nmov    -0x8(%rax,%rdx,4),%esi\nmov    %esi,0x4(%rcx,%rdx,4)\nmov    -0x4(%rax,%rdx,4),%esi\nmov    %esi,0x8(%rcx,%rdx,4)\nmov    (%rax,%rdx,4),%esi\nmov    %esi,0xc(%rcx,%rdx,4)\nadd    $0x4,%rdx\ncmp    %rdx,%r10\njne    1260 <func0+0x160>\njmp    1364 <func0+0x264>\nmov    %r10d,%edx\nand    $0xfffffff8,%edx\nlea    -0x8(%rdx),%rax\nmov    %rax,%rsi\nshr    $0x3,%rsi\nadd    $0x1,%rsi\nmov    %esi,%r9d\nand    $0x3,%r9d\ncmp    $0x18,%rax\njae    12b2 <func0+0x1b2>\nxor    %eax,%eax\njmp    1318 <func0+0x218>\nand    $0xfffffffffffffffc,%rsi\nlea    (%rdi,%r8,4),%rbx\nadd    $0x70,%rbx\nxor    %eax,%eax\nmovups -0x70(%rbx,%rax,4),%xmm0\nmovups -0x60(%rbx,%rax,4),%xmm1\nmovups %xmm0,(%rcx,%rax,4)\nmovups %xmm1,0x10(%rcx,%rax,4)\nmovups -0x50(%rbx,%rax,4),%xmm0\nmovups -0x40(%rbx,%rax,4),%xmm1\nmovups %xmm0,0x20(%rcx,%rax,4)\nmovups %xmm1,0x30(%rcx,%rax,4)\nmovups -0x30(%rbx,%rax,4),%xmm0\nmovups -0x20(%rbx,%rax,4),%xmm1\nmovups %xmm0,0x40(%rcx,%rax,4)\nmovups %xmm1,0x50(%rcx,%rax,4)\nmovups -0x10(%rbx,%rax,4),%xmm0\nmovups (%rbx,%rax,4),%xmm1\nmovups %xmm0,0x60(%rcx,%rax,4)\nmovups %xmm1,0x70(%rcx,%rax,4)\nadd    $0x20,%rax\nadd    $0xfffffffffffffffc,%rsi\njne    12c0 <func0+0x1c0>\ntest   %r9,%r9\nje     135b <func0+0x25b>\nlea    (%rcx,%rax,4),%rsi\nadd    $0x10,%rsi\nadd    %r8,%rax\nlea    (%rdi,%rax,4),%rax\nadd    $0x10,%rax\nshl    $0x5,%r9\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nmovups -0x10(%rax,%rbp,1),%xmm0\nmovups (%rax,%rbp,1),%xmm1\nmovups %xmm0,-0x10(%rsi,%rbp,1)\nmovups %xmm1,(%rsi,%rbp,1)\nadd    $0x20,%rbp\ncmp    %rbp,%r9\njne    1340 <func0+0x240>\ncmp    %r10,%rdx\njne    1214 <func0+0x114>\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 121,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nshl    $0x1,%eax\ncmp    -0xc(%rbp),%eax\njge    1172 <func0+0x72>\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nshl    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    115f <func0+0x5f>\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nshl    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    1164 <func0+0x64>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1119 <func0+0x19>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 121,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1149 <func0+0x49>\nadd    $0xffffffff,%esi\nshr    %esi\nadd    $0x1,%esi\nxor    %r8d,%r8d\nxor    %r9d,%r9d\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    (%rdi,%r9,8),%r10d\nmov    %r10d,%ecx\nshr    $0x1f,%ecx\nadd    %r10d,%ecx\nand    $0xfffffffe,%ecx\nmov    %r10d,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\ncmovne %r8d,%r10d\nadd    %r10d,%eax\nadd    $0x1,%r9\ncmp    %r9,%rsi\njne    1120 <func0+0x20>\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 121,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1125 <func0+0x25>\nadd    $0xffffffff,%esi\nmov    %esi,%r10d\nshr    %r10d\nadd    $0x1,%r10d\nxor    %r9d,%r9d\ncmp    $0x10,%esi\njae    1128 <func0+0x28>\nxor    %esi,%esi\nxor    %r8d,%r8d\nxor    %eax,%eax\njmp    11f0 <func0+0xf0>\nxor    %eax,%eax\nret\nmov    %r10d,%eax\nand    $0x7,%eax\ntest   %rax,%rax\nmov    $0x8,%r8d\ncmovne %rax,%r8\nmov    %r10,%rsi\nsub    %r8,%rsi\nlea    (%rsi,%rsi,1),%r8\npxor   %xmm0,%xmm0\nxor    %eax,%eax\nmovdqa 0xead(%rip),%xmm2\npxor   %xmm1,%xmm1\nnopw   0x0(%rax,%rax,1)\nmovups (%rdi,%rax,8),%xmm3\nmovups 0x10(%rdi,%rax,8),%xmm4\nshufps $0x88,%xmm4,%xmm3\nmovups 0x20(%rdi,%rax,8),%xmm4\nmovups 0x30(%rdi,%rax,8),%xmm5\nshufps $0x88,%xmm5,%xmm4\nmovaps %xmm3,%xmm5\npsrld  $0x1f,%xmm5\npaddd  %xmm3,%xmm5\npsrad  $0x1,%xmm5\npaddd  %xmm5,%xmm5\nmovdqa %xmm3,%xmm6\npsubd  %xmm5,%xmm6\nmovaps %xmm4,%xmm5\npsrld  $0x1f,%xmm5\npaddd  %xmm4,%xmm5\npsrad  $0x1,%xmm5\npaddd  %xmm5,%xmm5\nmovdqa %xmm4,%xmm7\npsubd  %xmm5,%xmm7\npcmpeqd %xmm2,%xmm6\npcmpeqd %xmm2,%xmm7\npand   %xmm3,%xmm6\npaddd  %xmm6,%xmm0\npand   %xmm4,%xmm7\npaddd  %xmm7,%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rsi\njne    1160 <func0+0x60>\npaddd  %xmm0,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\nsub    %rsi,%r10\nlea    (%rdi,%r8,4),%r8\nxor    %edi,%edi\nnopl   0x0(%rax)\nmov    (%r8,%rdi,8),%esi\nmov    %esi,%edx\nshr    $0x1f,%edx\nadd    %esi,%edx\nand    $0xfffffffe,%edx\nmov    %esi,%ecx\nsub    %edx,%ecx\ncmp    $0x1,%ecx\ncmovne %r9d,%esi\nadd    %esi,%eax\nadd    $0x1,%rdi\ncmp    %rdi,%r10\njne    1200 <func0+0x100>\nret\n"
    },
    {
        "task_id": 121,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1125 <func0+0x25>\nadd    $0xffffffff,%esi\nmov    %esi,%r10d\nshr    %r10d\nadd    $0x1,%r10d\nxor    %r9d,%r9d\ncmp    $0x10,%esi\njae    1128 <func0+0x28>\nxor    %esi,%esi\nxor    %r8d,%r8d\nxor    %eax,%eax\njmp    11f0 <func0+0xf0>\nxor    %eax,%eax\nret\nmov    %r10d,%eax\nand    $0x7,%eax\ntest   %rax,%rax\nmov    $0x8,%r8d\ncmovne %rax,%r8\nmov    %r10,%rsi\nsub    %r8,%rsi\nlea    (%rsi,%rsi,1),%r8\npxor   %xmm0,%xmm0\nxor    %eax,%eax\nmovdqa 0xead(%rip),%xmm2\npxor   %xmm1,%xmm1\nnopw   0x0(%rax,%rax,1)\nmovups (%rdi,%rax,8),%xmm3\nmovups 0x10(%rdi,%rax,8),%xmm4\nshufps $0x88,%xmm4,%xmm3\nmovups 0x20(%rdi,%rax,8),%xmm4\nmovups 0x30(%rdi,%rax,8),%xmm5\nshufps $0x88,%xmm5,%xmm4\nmovaps %xmm3,%xmm5\npsrld  $0x1f,%xmm5\npaddd  %xmm3,%xmm5\npsrad  $0x1,%xmm5\npaddd  %xmm5,%xmm5\nmovdqa %xmm3,%xmm6\npsubd  %xmm5,%xmm6\nmovaps %xmm4,%xmm5\npsrld  $0x1f,%xmm5\npaddd  %xmm4,%xmm5\npsrad  $0x1,%xmm5\npaddd  %xmm5,%xmm5\nmovdqa %xmm4,%xmm7\npsubd  %xmm5,%xmm7\npcmpeqd %xmm2,%xmm6\npcmpeqd %xmm2,%xmm7\npand   %xmm3,%xmm6\npaddd  %xmm6,%xmm0\npand   %xmm4,%xmm7\npaddd  %xmm7,%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rsi\njne    1160 <func0+0x60>\npaddd  %xmm0,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\nsub    %rsi,%r10\nlea    (%rdi,%r8,4),%r8\nxor    %edi,%edi\nnopl   0x0(%rax)\nmov    (%r8,%rdi,8),%esi\nmov    %esi,%edx\nshr    $0x1f,%edx\nadd    %esi,%edx\nand    $0xfffffffe,%edx\nmov    %esi,%ecx\nsub    %edx,%ecx\ncmp    $0x1,%ecx\ncmovne %r9d,%esi\nadd    %esi,%eax\nadd    $0x1,%rdi\ncmp    %rdi,%r10\njne    1200 <func0+0x100>\nret\n"
    },
    {
        "task_id": 122,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    116d <func0+0x6d>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\ncmpl   $0xffffff9d,(%rax,%rcx,4)\njl     115a <func0+0x5a>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\ncmpl   $0x63,(%rax,%rcx,4)\njg     115a <func0+0x5a>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    115f <func0+0x5f>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1119 <func0+0x19>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 122,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    112c <func0+0x2c>\nmov    %esi,%r9d\nxor    %r8d,%r8d\nxor    %esi,%esi\nxor    %eax,%eax\nxchg   %ax,%ax\nmov    (%rdi,%rsi,4),%edx\nlea    0x63(%rdx),%ecx\ncmp    $0xc7,%ecx\ncmovae %r8d,%edx\nadd    %edx,%eax\nadd    $0x1,%rsi\ncmp    %rsi,%r9\njne    1110 <func0+0x10>\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 122,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1118 <func0+0x18>\nmov    %esi,%r10d\nxor    %r9d,%r9d\ncmp    $0x8,%esi\njae    111b <func0+0x1b>\nxor    %esi,%esi\nxor    %eax,%eax\njmp    1290 <func0+0x190>\nxor    %eax,%eax\nret\nmov    %r10d,%esi\nand    $0xfffffff8,%esi\nlea    -0x8(%rsi),%rax\nmov    %rax,%r8\nshr    $0x3,%r8\nadd    $0x1,%r8\ntest   %rax,%rax\nje     12ac <func0+0x1ac>\nmov    %r8,%rdx\nand    $0xfffffffffffffffe,%rdx\npxor   %xmm0,%xmm0\nxor    %eax,%eax\nmovdqa 0xeb1(%rip),%xmm8\nmovdqa 0xeb8(%rip),%xmm9\nmovdqa 0xebf(%rip),%xmm10\npxor   %xmm1,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovdqu (%rdi,%rax,4),%xmm3\nmovdqu 0x10(%rdi,%rax,4),%xmm4\nmovdqu 0x20(%rdi,%rax,4),%xmm6\nmovdqu 0x30(%rdi,%rax,4),%xmm11\nmovdqa %xmm3,%xmm7\npaddd  %xmm8,%xmm7\nmovdqa %xmm4,%xmm2\npaddd  %xmm8,%xmm2\npxor   %xmm9,%xmm7\nmovdqa %xmm10,%xmm5\npcmpgtd %xmm7,%xmm5\npxor   %xmm9,%xmm2\nmovdqa %xmm10,%xmm7\npcmpgtd %xmm2,%xmm7\npand   %xmm3,%xmm5\npaddd  %xmm0,%xmm5\npand   %xmm4,%xmm7\npaddd  %xmm1,%xmm7\nmovdqa %xmm6,%xmm1\npaddd  %xmm8,%xmm1\nmovdqa %xmm11,%xmm2\npaddd  %xmm8,%xmm2\npxor   %xmm9,%xmm1\nmovdqa %xmm10,%xmm0\npcmpgtd %xmm1,%xmm0\npxor   %xmm9,%xmm2\nmovdqa %xmm10,%xmm1\npcmpgtd %xmm2,%xmm1\npand   %xmm6,%xmm0\npaddd  %xmm5,%xmm0\npand   %xmm11,%xmm1\npaddd  %xmm7,%xmm1\nadd    $0x10,%rax\nadd    $0xfffffffffffffffe,%rdx\njne    1170 <func0+0x70>\ntest   $0x1,%r8b\nje     1270 <func0+0x170>\nmovdqu (%rdi,%rax,4),%xmm2\nmovdqu 0x10(%rdi,%rax,4),%xmm3\nmovdqa 0xdd3(%rip),%xmm4\nmovdqa %xmm2,%xmm5\npaddd  %xmm4,%xmm5\npaddd  %xmm3,%xmm4\nmovdqa 0xdce(%rip),%xmm8\npxor   %xmm8,%xmm5\nmovdqa 0xdd1(%rip),%xmm7\nmovdqa %xmm7,%xmm6\npcmpgtd %xmm5,%xmm6\npxor   %xmm8,%xmm4\npcmpgtd %xmm4,%xmm7\npand   %xmm2,%xmm6\npaddd  %xmm6,%xmm0\npand   %xmm3,%xmm7\npaddd  %xmm7,%xmm1\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%eax\ncmp    %r10,%rsi\nje     12ab <func0+0x1ab>\nnop\nmov    (%rdi,%rsi,4),%edx\nlea    0x63(%rdx),%ecx\ncmp    $0xc7,%ecx\ncmovae %r9d,%edx\nadd    %edx,%eax\nadd    $0x1,%rsi\ncmp    %rsi,%r10\njne    1290 <func0+0x190>\nret\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npxor   %xmm1,%xmm1\ntest   $0x1,%r8b\njne    121a <func0+0x11a>\njmp    1270 <func0+0x170>\n"
    },
    {
        "task_id": 122,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1118 <func0+0x18>\nmov    %esi,%r10d\nxor    %r9d,%r9d\ncmp    $0x8,%esi\njae    111b <func0+0x1b>\nxor    %esi,%esi\nxor    %eax,%eax\njmp    1290 <func0+0x190>\nxor    %eax,%eax\nret\nmov    %r10d,%esi\nand    $0xfffffff8,%esi\nlea    -0x8(%rsi),%rax\nmov    %rax,%r8\nshr    $0x3,%r8\nadd    $0x1,%r8\ntest   %rax,%rax\nje     12ac <func0+0x1ac>\nmov    %r8,%rdx\nand    $0xfffffffffffffffe,%rdx\npxor   %xmm0,%xmm0\nxor    %eax,%eax\nmovdqa 0xeb1(%rip),%xmm8\nmovdqa 0xeb8(%rip),%xmm9\nmovdqa 0xebf(%rip),%xmm10\npxor   %xmm1,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovdqu (%rdi,%rax,4),%xmm3\nmovdqu 0x10(%rdi,%rax,4),%xmm4\nmovdqu 0x20(%rdi,%rax,4),%xmm6\nmovdqu 0x30(%rdi,%rax,4),%xmm11\nmovdqa %xmm3,%xmm7\npaddd  %xmm8,%xmm7\nmovdqa %xmm4,%xmm2\npaddd  %xmm8,%xmm2\npxor   %xmm9,%xmm7\nmovdqa %xmm10,%xmm5\npcmpgtd %xmm7,%xmm5\npxor   %xmm9,%xmm2\nmovdqa %xmm10,%xmm7\npcmpgtd %xmm2,%xmm7\npand   %xmm3,%xmm5\npaddd  %xmm0,%xmm5\npand   %xmm4,%xmm7\npaddd  %xmm1,%xmm7\nmovdqa %xmm6,%xmm1\npaddd  %xmm8,%xmm1\nmovdqa %xmm11,%xmm2\npaddd  %xmm8,%xmm2\npxor   %xmm9,%xmm1\nmovdqa %xmm10,%xmm0\npcmpgtd %xmm1,%xmm0\npxor   %xmm9,%xmm2\nmovdqa %xmm10,%xmm1\npcmpgtd %xmm2,%xmm1\npand   %xmm6,%xmm0\npaddd  %xmm5,%xmm0\npand   %xmm11,%xmm1\npaddd  %xmm7,%xmm1\nadd    $0x10,%rax\nadd    $0xfffffffffffffffe,%rdx\njne    1170 <func0+0x70>\ntest   $0x1,%r8b\nje     1270 <func0+0x170>\nmovdqu (%rdi,%rax,4),%xmm2\nmovdqu 0x10(%rdi,%rax,4),%xmm3\nmovdqa 0xdd3(%rip),%xmm4\nmovdqa %xmm2,%xmm5\npaddd  %xmm4,%xmm5\npaddd  %xmm3,%xmm4\nmovdqa 0xdce(%rip),%xmm8\npxor   %xmm8,%xmm5\nmovdqa 0xdd1(%rip),%xmm7\nmovdqa %xmm7,%xmm6\npcmpgtd %xmm5,%xmm6\npxor   %xmm8,%xmm4\npcmpgtd %xmm4,%xmm7\npand   %xmm2,%xmm6\npaddd  %xmm6,%xmm0\npand   %xmm3,%xmm7\npaddd  %xmm7,%xmm1\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%eax\ncmp    %r10,%rsi\nje     12ab <func0+0x1ab>\nnop\nmov    (%rdi,%rsi,4),%edx\nlea    0x63(%rdx),%ecx\ncmp    $0xc7,%ecx\ncmovae %r9d,%edx\nadd    %edx,%eax\nadd    $0x1,%rsi\ncmp    %rsi,%r10\njne    1290 <func0+0x190>\nret\npxor   %xmm0,%xmm0\nxor    %eax,%eax\npxor   %xmm1,%xmm1\ntest   $0x1,%r8b\njne    121a <func0+0x11a>\njmp    1270 <func0+0x170>\n"
    },
    {
        "task_id": 123,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0xa,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmovl   $0x1,(%rax)\nmov    -0x10(%rbp),%rax\nmovl   $0x1,(%rax)\ncmpl   $0x1,-0x4(%rbp)\nje     11c5 <func0+0xb5>\nmov    -0x4(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    11b2 <func0+0xa2>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\ncmp    -0x1c(%rbp),%eax\njl     1189 <func0+0x79>\nmov    -0x1c(%rbp),%eax\nshl    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x10(%rbp),%rdi\nmovslq -0x1c(%rbp),%rsi\nshl    $0x2,%rsi\ncall   1030 <realloc@plt>\nmov    %rax,-0x10(%rbp)\nmov    -0x4(%rbp),%edx\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%rsi\nmov    (%rsi),%ecx\nmov    %ecx,%edi\nadd    $0x1,%edi\nmov    %edi,(%rsi)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nimul   $0x3,-0x4(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    11c0 <func0+0xb0>\nmov    -0x4(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x4(%rbp)\njmp    113e <func0+0x2e>\nmovl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    -0x18(%rbp),%rcx\ncmp    (%rcx),%eax\njge    126f <func0+0x15f>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x20(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x28(%rbp)\nxor    %eax,%eax\ncmpl   $0x0,-0x28(%rbp)\nmov    %al,-0x29(%rbp)\njl     1215 <func0+0x105>\nmov    -0x10(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x24(%rbp),%eax\nsetg   %al\nmov    %al,-0x29(%rbp)\nmov    -0x29(%rbp),%al\ntest   $0x1,%al\njne    1225 <func0+0x115>\njmp    124e <func0+0x13e>\nmov    -0x10(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x10(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x28(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    11f2 <func0+0xe2>\nmov    -0x24(%rbp),%edx\nmov    -0x10(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    11cc <func0+0xbc>\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 123,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %rdx,%r14\nmov    %rsi,%rax\nmovl   $0x1,(%rdx)\nmovl   $0x1,(%rsi)\ncmp    $0x1,%edi\njne    1182 <func0+0x72>\ncmpl   $0x2,(%r14)\njl     117d <func0+0x6d>\nmov    $0x1,%ecx\njmp    1152 <func0+0x42>\nnopl   0x0(%rax,%rax,1)\nmovslq %esi,%rsi\nmov    %edx,(%rax,%rsi,4)\nadd    $0x1,%rcx\nmovslq (%r14),%rdx\ncmp    %rdx,%rcx\njge    117d <func0+0x6d>\nmov    (%rax,%rcx,4),%edx\nmov    %rcx,%rsi\nnopl   0x0(%rax,%rax,1)\nmov    -0x4(%rax,%rsi,4),%edi\ncmp    %edx,%edi\njle    1140 <func0+0x30>\nmov    %edi,(%rax,%rsi,4)\nadd    $0xffffffffffffffff,%rsi\nlea    0x1(%rsi),%rdi\ncmp    $0x1,%rdi\njg     1160 <func0+0x50>\nxor    %esi,%esi\njmp    1140 <func0+0x30>\npop    %rbx\npop    %r14\npop    %rbp\nret\nmov    %edi,%ebx\nmov    $0xa,%ebp\njmp    1199 <func0+0x89>\nnopl   0x0(%rax,%rax,1)\nsar    %ecx\nmov    %ecx,%ebx\ncmp    $0x1,%ebx\nje     112b <func0+0x1b>\nmov    %ebx,%ecx\nshr    $0x1f,%ecx\nadd    %ebx,%ecx\nmov    %ecx,%edx\nand    $0xfffffffe,%edx\nmov    %ebx,%esi\nsub    %edx,%esi\ncmp    $0x1,%esi\njne    1190 <func0+0x80>\ncmp    %ebp,(%r14)\njl     11c4 <func0+0xb4>\nadd    %ebp,%ebp\nmovslq %ebp,%rsi\nshl    $0x2,%rsi\nmov    %rax,%rdi\ncall   1030 <realloc@plt>\nmovslq (%r14),%rcx\nlea    0x1(%rcx),%edx\nmov    %edx,(%r14)\nmov    %ebx,(%rax,%rcx,4)\nlea    (%rbx,%rbx,2),%ebx\nadd    $0x1,%ebx\njmp    1194 <func0+0x84>\n"
    },
    {
        "task_id": 123,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %rdx,%r14\nmov    %rsi,%rax\nmovl   $0x1,(%rdx)\nmovl   $0x1,(%rsi)\ncmp    $0x1,%edi\njne    1186 <func0+0x76>\ncmpl   $0x2,(%r14)\njl     1181 <func0+0x71>\nmov    $0x1,%ecx\njmp    1152 <func0+0x42>\nnopl   0x0(%rax,%rax,1)\nmovslq %esi,%rsi\nmov    %edx,(%rax,%rsi,4)\nadd    $0x1,%rcx\nmovslq (%r14),%rdx\ncmp    %rdx,%rcx\njge    1181 <func0+0x71>\nmov    (%rax,%rcx,4),%edx\nmov    %rcx,%rsi\nnopl   0x0(%rax,%rax,1)\nlea    -0x1(%rsi),%rdi\nmov    %edi,%ebp\nmov    (%rax,%rbp,4),%ebp\ncmp    %edx,%ebp\njle    1140 <func0+0x30>\nmov    %ebp,(%rax,%rsi,4)\nlea    0x1(%rdi),%rbp\nmov    %rdi,%rsi\ncmp    $0x1,%rbp\njg     1160 <func0+0x50>\nxor    %esi,%esi\njmp    1140 <func0+0x30>\npop    %rbx\npop    %r14\npop    %rbp\nret\nmov    %edi,%ebx\nmov    $0xa,%ebp\njmp    1199 <func0+0x89>\nnop\nsar    %ecx\nmov    %ecx,%ebx\ncmp    $0x1,%ebx\nje     112b <func0+0x1b>\nmov    %ebx,%ecx\nshr    $0x1f,%ecx\nadd    %ebx,%ecx\nmov    %ecx,%edx\nand    $0xfffffffe,%edx\nmov    %ebx,%esi\nsub    %edx,%esi\ncmp    $0x1,%esi\njne    1190 <func0+0x80>\nmov    (%r14),%ecx\ncmp    %ebp,%ecx\njl     11c9 <func0+0xb9>\nadd    %ebp,%ebp\nmovslq %ebp,%rsi\nshl    $0x2,%rsi\nmov    %rax,%rdi\ncall   1030 <realloc@plt>\nmov    (%r14),%ecx\nlea    0x1(%rcx),%edx\nmov    %edx,(%r14)\nmovslq %ecx,%rcx\nmov    %ebx,(%rax,%rcx,4)\nlea    (%rbx,%rbx,2),%ebx\nadd    $0x1,%ebx\njmp    1194 <func0+0x84>\n"
    },
    {
        "task_id": 123,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %rdx,%r14\nmov    %rsi,%rax\nmovl   $0x1,(%rdx)\nmovl   $0x1,(%rsi)\ncmp    $0x1,%edi\nje     1190 <func0+0x80>\nmov    %edi,%ebx\nmov    $0xa,%ebp\njmp    1149 <func0+0x39>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nsar    %ecx\nmov    %ecx,%ebx\ncmp    $0x1,%ebx\nje     1190 <func0+0x80>\nmov    %ebx,%ecx\nshr    $0x1f,%ecx\nadd    %ebx,%ecx\nmov    %ecx,%edx\nand    $0xfffffffe,%edx\nmov    %ebx,%esi\nsub    %edx,%esi\ncmp    $0x1,%esi\njne    1140 <func0+0x30>\nmov    (%r14),%ecx\ncmp    %ebp,%ecx\njl     1179 <func0+0x69>\nadd    %ebp,%ebp\nmovslq %ebp,%rsi\nshl    $0x2,%rsi\nmov    %rax,%rdi\ncall   1030 <realloc@plt>\nmov    (%r14),%ecx\nlea    0x1(%rcx),%edx\nmov    %edx,(%r14)\nmovslq %ecx,%rcx\nmov    %ebx,(%rax,%rcx,4)\nlea    (%rbx,%rbx,2),%ebx\nadd    $0x1,%ebx\ncmp    $0x1,%ebx\njne    1149 <func0+0x39>\ncmpl   $0x2,(%r14)\njl     11e1 <func0+0xd1>\nmov    $0x1,%ecx\njmp    11b2 <func0+0xa2>\nnopl   (%rax)\nmovslq %esi,%rsi\nmov    %edx,(%rax,%rsi,4)\nadd    $0x1,%rcx\nmovslq (%r14),%rdx\ncmp    %rdx,%rcx\njge    11e1 <func0+0xd1>\nmov    (%rax,%rcx,4),%edx\nmov    %rcx,%rsi\nnopl   0x0(%rax,%rax,1)\nlea    -0x1(%rsi),%rdi\nmov    %edi,%ebp\nmov    (%rax,%rbp,4),%ebp\ncmp    %edx,%ebp\njle    11a0 <func0+0x90>\nmov    %ebp,(%rax,%rsi,4)\nlea    0x1(%rdi),%rbp\nmov    %rdi,%rsi\ncmp    $0x1,%rbp\njg     11c0 <func0+0xb0>\nxor    %esi,%esi\njmp    11a0 <func0+0x90>\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 124,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\ncmp    $0xa,%rax\nje     114b <func0+0x2b>\nmovl   $0x0,-0x4(%rbp)\njmp    1308 <func0+0x1e8>\nmovl   $0x0,-0x20(%rbp)\ncmpl   $0xa,-0x20(%rbp)\njge    11e4 <func0+0xc4>\ncmpl   $0x2,-0x20(%rbp)\nje     1170 <func0+0x50>\ncmpl   $0x5,-0x20(%rbp)\njne    1196 <func0+0x76>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x2d,%eax\nje     1191 <func0+0x71>\nmovl   $0x0,-0x4(%rbp)\njmp    1308 <func0+0x1e8>\njmp    11d1 <func0+0xb1>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x30,%eax\njl     11c0 <func0+0xa0>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x39,%eax\njle    11cc <func0+0xac>\nmovl   $0x0,-0x4(%rbp)\njmp    1308 <func0+0x1e8>\njmp    11d1 <func0+0xb1>\njmp    11d6 <func0+0xb6>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1152 <func0+0x32>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%al\nmov    %al,-0x23(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x1(%rax),%al\nmov    %al,-0x22(%rbp)\nmovb   $0x0,-0x21(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x3(%rax),%al\nmov    %al,-0x26(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%al\nmov    %al,-0x25(%rbp)\nmovb   $0x0,-0x24(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x6(%rax),%al\nmov    %al,-0x2b(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x7(%rax),%al\nmov    %al,-0x2a(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%al\nmov    %al,-0x29(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x9(%rax),%al\nmov    %al,-0x28(%rbp)\nmovb   $0x0,-0x27(%rbp)\nlea    -0x23(%rbp),%rdi\ncall   1040 <atoi@plt>\nmov    %eax,-0x14(%rbp)\nlea    -0x26(%rbp),%rdi\ncall   1040 <atoi@plt>\nmov    %eax,-0x18(%rbp)\nlea    -0x2b(%rbp),%rdi\ncall   1040 <atoi@plt>\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njl     1277 <func0+0x157>\ncmpl   $0xc,-0x14(%rbp)\njle    1283 <func0+0x163>\nmovl   $0x0,-0x4(%rbp)\njmp    1308 <func0+0x1e8>\ncmpl   $0x1,-0x18(%rbp)\njl     1297 <func0+0x177>\ncmpl   $0x1f,-0x18(%rbp)\njle    12a3 <func0+0x183>\nmovl   $0x0,-0x4(%rbp)\njmp    1308 <func0+0x1e8>\ncmpl   $0x4,-0x14(%rbp)\nje     12cb <func0+0x1ab>\ncmpl   $0x6,-0x14(%rbp)\nje     12cb <func0+0x1ab>\ncmpl   $0x9,-0x14(%rbp)\nje     12cb <func0+0x1ab>\ncmpl   $0xb,-0x14(%rbp)\njne    12e1 <func0+0x1c1>\ncmpl   $0x1f,-0x18(%rbp)\njne    12e1 <func0+0x1c1>\nmovl   $0x0,-0x4(%rbp)\njmp    1308 <func0+0x1e8>\ncmpl   $0x2,-0x14(%rbp)\njne    1301 <func0+0x1e1>\ncmpl   $0x1d,-0x18(%rbp)\njle    1301 <func0+0x1e1>\nmovl   $0x0,-0x4(%rbp)\njmp    1308 <func0+0x1e8>\nmovl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 124,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nxor    %r14d,%r14d\ncmp    $0xa,%rax\njne    11f7 <func0+0xd7>\nxor    %eax,%eax\njmp    1150 <func0+0x30>\nnopl   (%rax)\ncmpb   $0x2d,(%rbx,%rax,1)\njne    1166 <func0+0x46>\nadd    $0x1,%rax\ncmp    $0xa,%rax\nje     116e <func0+0x4e>\ncmp    $0x5,%eax\nje     1140 <func0+0x20>\ncmp    $0x2,%eax\nje     1140 <func0+0x20>\nmovzbl (%rbx,%rax,1),%ecx\nadd    $0xc6,%cl\ncmp    $0xf6,%cl\njae    1146 <func0+0x26>\nxor    %r14d,%r14d\njmp    11f7 <func0+0xd7>\nmov    (%rbx),%al\nmov    %al,0x5(%rsp)\nmov    0x1(%rbx),%al\nmov    %al,0x6(%rsp)\nmovb   $0x0,0x7(%rsp)\nmov    0x3(%rbx),%al\nmov    %al,0x2(%rsp)\nmov    0x4(%rbx),%al\nmov    %al,0x3(%rsp)\nmovb   $0x0,0x4(%rsp)\nxor    %r14d,%r14d\nlea    0x5(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1040 <strtol@plt>\nmov    %rax,%rbx\nlea    0x2(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1040 <strtol@plt>\nlea    -0xd(%rbx),%ecx\ncmp    $0xfffffff4,%ecx\njb     11f7 <func0+0xd7>\nlea    -0x20(%rax),%ecx\ncmp    $0xffffffe1,%ecx\njb     11f7 <func0+0xd7>\nmov    %ebx,%ecx\nand    $0xfffffffd,%ecx\ncmp    $0x4,%ecx\nsetne  %dl\ncmp    $0x9,%ecx\nsetne  %cl\ntest   %dl,%cl\njne    11e5 <func0+0xc5>\ncmp    $0x1f,%eax\nje     11f7 <func0+0xd7>\ncmp    $0x2,%ebx\nsetne  %cl\ncmp    $0x1e,%eax\nsetl   %al\nor     %cl,%al\nmovzbl %al,%r14d\nmov    %r14d,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 124,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nxor    %r14d,%r14d\ncmp    $0xa,%rax\njne    1249 <func0+0x129>\nmov    (%rbx),%al\nlea    -0x3a(%rax),%ecx\ncmp    $0xf6,%cl\njb     1249 <func0+0x129>\nmov    0x1(%rbx),%cl\nlea    -0x3a(%rcx),%edx\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\ncmpb   $0x2d,0x2(%rbx)\njne    1249 <func0+0x129>\nmov    0x3(%rbx),%r8b\nlea    -0x3a(%r8),%esi\ncmp    $0xf6,%sil\njb     1249 <func0+0x129>\nmov    0x4(%rbx),%sil\nlea    -0x3a(%rsi),%edi\ncmp    $0xf6,%dil\njb     1249 <func0+0x129>\ncmpb   $0x2d,0x5(%rbx)\njne    1249 <func0+0x129>\nmov    0x6(%rbx),%dl\nadd    $0xc6,%dl\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\nmov    0x7(%rbx),%dl\nadd    $0xc6,%dl\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\nmov    0x8(%rbx),%dl\nadd    $0xc6,%dl\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\nmov    0x9(%rbx),%dl\nadd    $0xc6,%dl\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\nmov    %al,0x5(%rsp)\nmov    %cl,0x6(%rsp)\nmovb   $0x0,0x7(%rsp)\nmov    %r8b,0x2(%rsp)\nmov    %sil,0x3(%rsp)\nmovb   $0x0,0x4(%rsp)\nxor    %r14d,%r14d\nlea    0x5(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1040 <strtol@plt>\nmov    %rax,%rbx\nlea    0x2(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1040 <strtol@plt>\nlea    -0xd(%rbx),%ecx\ncmp    $0xfffffff4,%ecx\njb     1249 <func0+0x129>\nlea    -0x20(%rax),%ecx\ncmp    $0xffffffe1,%ecx\njb     1249 <func0+0x129>\nmov    %ebx,%ecx\nand    $0xfffffffd,%ecx\ncmp    $0x4,%ecx\nsetne  %dl\ncmp    $0x9,%ecx\nsetne  %cl\ntest   %dl,%cl\njne    1237 <func0+0x117>\ncmp    $0x1f,%eax\nje     1249 <func0+0x129>\ncmp    $0x2,%ebx\nsetne  %cl\ncmp    $0x1e,%eax\nsetb   %al\nor     %cl,%al\nmovzbl %al,%r14d\nmov    %r14d,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 124,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%rbx\ncall   1030 <strlen@plt>\nxor    %r14d,%r14d\ncmp    $0xa,%rax\njne    1249 <func0+0x129>\nmov    (%rbx),%al\nlea    -0x3a(%rax),%ecx\ncmp    $0xf6,%cl\njb     1249 <func0+0x129>\nmov    0x1(%rbx),%cl\nlea    -0x3a(%rcx),%edx\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\ncmpb   $0x2d,0x2(%rbx)\njne    1249 <func0+0x129>\nmov    0x3(%rbx),%r8b\nlea    -0x3a(%r8),%esi\ncmp    $0xf6,%sil\njb     1249 <func0+0x129>\nmov    0x4(%rbx),%sil\nlea    -0x3a(%rsi),%edi\ncmp    $0xf6,%dil\njb     1249 <func0+0x129>\ncmpb   $0x2d,0x5(%rbx)\njne    1249 <func0+0x129>\nmov    0x6(%rbx),%dl\nadd    $0xc6,%dl\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\nmov    0x7(%rbx),%dl\nadd    $0xc6,%dl\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\nmov    0x8(%rbx),%dl\nadd    $0xc6,%dl\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\nmov    0x9(%rbx),%dl\nadd    $0xc6,%dl\ncmp    $0xf6,%dl\njb     1249 <func0+0x129>\nmov    %al,0x5(%rsp)\nmov    %cl,0x6(%rsp)\nmovb   $0x0,0x7(%rsp)\nmov    %r8b,0x2(%rsp)\nmov    %sil,0x3(%rsp)\nmovb   $0x0,0x4(%rsp)\nxor    %r14d,%r14d\nlea    0x5(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1040 <strtol@plt>\nmov    %rax,%rbx\nlea    0x2(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1040 <strtol@plt>\nlea    -0xd(%rbx),%ecx\ncmp    $0xfffffff4,%ecx\njb     1249 <func0+0x129>\nlea    -0x20(%rax),%ecx\ncmp    $0xffffffe1,%ecx\njb     1249 <func0+0x129>\nmov    %ebx,%ecx\nand    $0xfffffffd,%ecx\ncmp    $0x4,%ecx\nsetne  %dl\ncmp    $0x9,%ecx\nsetne  %cl\ntest   %dl,%cl\njne    1237 <func0+0x117>\ncmp    $0x1f,%eax\nje     1249 <func0+0x129>\ncmp    $0x2,%ebx\nsetne  %cl\ncmp    $0x1e,%eax\nsetb   %al\nor     %cl,%al\nmovzbl %al,%r14d\nmov    %r14d,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 125,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xa0,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x24(%rbp)\nmovq   $0x0,-0x30(%rbp)\nlea    -0xa0(%rbp),%rdi\nxor    %esi,%esi\nmov    $0x65,%edx\ncall   1050 <memset@plt>\nmov    -0x8(%rbp),%rdi\nmov    $0x20,%esi\ncall   1040 <strchr@plt>\ncmp    $0x0,%rax\njne    11ef <func0+0x7f>\nmov    -0x8(%rbp),%rdi\nmov    $0x2c,%esi\ncall   1040 <strchr@plt>\ncmp    $0x0,%rax\nje     12d4 <func0+0x164>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\nshl    $0x3,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njg     12cf <func0+0x15f>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x20,%eax\nje     1257 <func0+0xe7>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x2c,%eax\nje     1257 <func0+0xe7>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\njne    129d <func0+0x12d>\ncmpl   $0x0,-0x18(%rbp)\njle    1298 <func0+0x128>\nmovslq -0x18(%rbp),%rax\nmovb   $0x0,-0xa0(%rbp,%rax,1)\nlea    -0xa0(%rbp),%rdi\ncall   1080 <strdup@plt>\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    12bc <func0+0x14c>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmov    -0x18(%rbp),%eax\nmov    %eax,%edx\nadd    $0x1,%edx\nmov    %edx,-0x18(%rbp)\ncltq\nmov    %cl,-0xa0(%rbp,%rax,1)\njmp    12c1 <func0+0x151>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    120c <func0+0x9c>\njmp    138d <func0+0x21d>\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njge    134c <func0+0x1dc>\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x14(%rbp),%rdx\nmovsbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x200,%eax\ncmp    $0x0,%eax\nje     1339 <func0+0x1c9>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\nsub    $0x61,%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    1339 <func0+0x1c9>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    133e <func0+0x1ce>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    12db <func0+0x16b>\nmov    $0x8,%edi\ncall   1060 <malloc@plt>\nmov    %rax,-0x30(%rbp)\nmov    $0xc,%edi\ncall   1060 <malloc@plt>\nmov    %rax,%rcx\nmov    -0x30(%rbp),%rax\nmov    %rcx,(%rax)\nmov    -0x30(%rbp),%rax\nmov    (%rax),%rdi\nmov    -0x1c(%rbp),%edx\nlea    0xc81(%rip),%rsi\nmov    $0x0,%al\ncall   1070 <sprintf@plt>\nmovl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%ecx\nmov    -0x10(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x30(%rbp),%rax\nadd    $0xa0,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 125,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x78,%rsp\nmov    %rsi,%r14\nmov    %rdi,%r13\ncall   1030 <strlen@plt>\nmov    %rax,%rbp\nxorps  %xmm0,%xmm0\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovq   $0x0,0x6d(%rsp)\nmov    %r13,%rdi\nmov    $0x20,%esi\ncall   1040 <strchr@plt>\ntest   %rax,%rax\njne    11ce <func0+0x6e>\nmov    %r13,%rdi\nmov    $0x2c,%esi\ncall   1040 <strchr@plt>\ntest   %rax,%rax\nje     1269 <func0+0x109>\nmov    %rbp,%rax\nshl    $0x20,%rax\nmovabs $0x100000000,%rdi\nadd    %rax,%rdi\nsar    $0x1d,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\ntest   %ebp,%ebp\njs     1262 <func0+0x102>\nmov    %r14,0x8(%rsp)\nlea    0x1(%rbp),%ebx\nxor    %r14d,%r14d\nmovabs $0x100100000001,%r12\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    1223 <func0+0xc3>\nnopl   (%rax)\nmovslq %eax,%rdx\nadd    $0x1,%eax\nmov    %cl,0x10(%rsp,%rdx,1)\nadd    $0x1,%r14\ncmp    %r14,%rbx\nje     1258 <func0+0xf8>\nmovzbl 0x0(%r13,%r14,1),%ecx\ncmp    $0x2c,%rcx\nja     1210 <func0+0xb0>\nbt     %rcx,%r12\njae    1210 <func0+0xb0>\ntest   %eax,%eax\njle    121a <func0+0xba>\ncltq\nmovb   $0x0,0x10(%rsp,%rax,1)\nlea    0x10(%rsp),%rdi\ncall   1070 <strdup@plt>\nmovslq %ebp,%rbp\nmov    %rax,(%r15,%rbp,8)\nadd    $0x1,%ebp\nxor    %eax,%eax\njmp    121a <func0+0xba>\nmov    0x8(%rsp),%r14\njmp    12eb <func0+0x18b>\nxor    %ebp,%ebp\njmp    12eb <func0+0x18b>\ntest   %ebp,%ebp\njle    12b7 <func0+0x157>\ncall   1080 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    %ebp,%ecx\nxor    %edx,%edx\nxor    %ebp,%ebp\njmp    1289 <func0+0x129>\nnopl   (%rax)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\nje     12b9 <func0+0x159>\nmovsbq 0x0(%r13,%rdx,1),%rsi\ntestb  $0x2,0x1(%rax,%rsi,2)\nje     1280 <func0+0x120>\nmov    %esi,%edi\nadd    $0xffffff9f,%edi\nmov    %edi,%ebx\nshr    $0x1f,%ebx\nadd    %ebx,%esi\nadd    $0xffffff9f,%esi\nand    $0xfffffffe,%esi\nsub    %esi,%edi\nxor    %esi,%esi\ncmp    $0x1,%edi\nsete   %sil\nadd    %esi,%ebp\njmp    1280 <func0+0x120>\nxor    %ebp,%ebp\nmov    $0x8,%edi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    $0xc,%edi\ncall   1050 <malloc@plt>\nmov    %rax,(%r15)\nlea    0xd26(%rip),%rsi\nmov    %rax,%rdi\nmov    %ebp,%edx\nxor    %eax,%eax\ncall   1060 <sprintf@plt>\nmov    $0x1,%ebp\nmov    %ebp,(%r14)\nmov    %r15,%rax\nadd    $0x78,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 125,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x78,%rsp\nmov    %rsi,%rbx\nmov    %rdi,%r13\ncall   1030 <strlen@plt>\nmov    %rax,%rbp\nxorps  %xmm0,%xmm0\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovq   $0x0,0x6d(%rsp)\nmov    %r13,%rdi\nmov    $0x20,%esi\ncall   1040 <strchr@plt>\ntest   %rax,%rax\njne    11ce <func0+0x6e>\nmov    %r13,%rdi\nmov    $0x2c,%esi\ncall   1040 <strchr@plt>\ntest   %rax,%rax\nje     1269 <func0+0x109>\nmov    %rbp,%rax\nshl    $0x20,%rax\nmovabs $0x100000000,%rdi\nadd    %rax,%rdi\nsar    $0x1d,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\ntest   %ebp,%ebp\njs     1262 <func0+0x102>\nmov    %rbx,0x8(%rsp)\nlea    0x1(%rbp),%ebx\nxor    %r14d,%r14d\nmovabs $0x100100000001,%r12\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    1223 <func0+0xc3>\nnopl   (%rax)\nmovslq %eax,%rdx\nadd    $0x1,%eax\nmov    %cl,0x10(%rsp,%rdx,1)\nadd    $0x1,%r14\ncmp    %r14,%rbx\nje     1258 <func0+0xf8>\nmovzbl 0x0(%r13,%r14,1),%ecx\ncmp    $0x2c,%rcx\nja     1210 <func0+0xb0>\nbt     %rcx,%r12\njae    1210 <func0+0xb0>\ntest   %eax,%eax\njle    121a <func0+0xba>\nmov    %eax,%eax\nmovb   $0x0,0x10(%rsp,%rax,1)\nlea    0x10(%rsp),%rdi\ncall   1070 <strdup@plt>\nmovslq %ebp,%rbp\nmov    %rax,(%r15,%rbp,8)\nadd    $0x1,%ebp\nxor    %eax,%eax\njmp    121a <func0+0xba>\nmov    0x8(%rsp),%rbx\njmp    12ed <func0+0x18d>\nxor    %ebp,%ebp\njmp    12ed <func0+0x18d>\ntest   %ebp,%ebp\njle    12b9 <func0+0x159>\ncall   1080 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    %ebp,%ecx\nxor    %edx,%edx\nxor    %ebp,%ebp\njmp    1289 <func0+0x129>\nnopl   (%rax)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\nje     12bb <func0+0x15b>\nmovsbq 0x0(%r13,%rdx,1),%rsi\ntestb  $0x2,0x1(%rax,%rsi,2)\nje     1280 <func0+0x120>\nmovswl %si,%esi\nadd    $0xffffff9f,%esi\nmovzwl %si,%esi\nmov    %esi,%edi\nshr    $0xf,%edi\nadd    %esi,%edi\nand    $0xfffffffe,%edi\nsub    %edi,%esi\nxor    %edi,%edi\ncmp    $0x1,%si\nsete   %dil\nadd    %edi,%ebp\njmp    1280 <func0+0x120>\nxor    %ebp,%ebp\nmov    $0x8,%edi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    $0xc,%edi\ncall   1050 <malloc@plt>\nmov    %rax,(%r15)\nlea    0xd24(%rip),%rsi\nmov    %rax,%rdi\nmov    %ebp,%edx\nxor    %eax,%eax\ncall   1060 <sprintf@plt>\nmov    $0x1,%ebp\nmov    %ebp,(%rbx)\nmov    %r15,%rax\nadd    $0x78,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 125,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x78,%rsp\nmov    %rsi,%rbx\nmov    %rdi,%r13\ncall   1030 <strlen@plt>\nmov    %rax,%rbp\nxorps  %xmm0,%xmm0\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovq   $0x0,0x6d(%rsp)\nmov    %r13,%rdi\nmov    $0x20,%esi\ncall   1040 <strchr@plt>\ntest   %rax,%rax\njne    11ce <func0+0x6e>\nmov    %r13,%rdi\nmov    $0x2c,%esi\ncall   1040 <strchr@plt>\ntest   %rax,%rax\nje     1269 <func0+0x109>\nmov    %rbp,%rax\nshl    $0x20,%rax\nmovabs $0x100000000,%rdi\nadd    %rax,%rdi\nsar    $0x1d,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\ntest   %ebp,%ebp\njs     1262 <func0+0x102>\nmov    %rbx,0x8(%rsp)\nlea    0x1(%rbp),%ebx\nxor    %r14d,%r14d\nmovabs $0x100100000001,%r12\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    1223 <func0+0xc3>\nnopl   (%rax)\nmovslq %eax,%rdx\nadd    $0x1,%eax\nmov    %cl,0x10(%rsp,%rdx,1)\nadd    $0x1,%r14\ncmp    %r14,%rbx\nje     1258 <func0+0xf8>\nmovzbl 0x0(%r13,%r14,1),%ecx\ncmp    $0x2c,%rcx\nja     1210 <func0+0xb0>\nbt     %rcx,%r12\njae    1210 <func0+0xb0>\ntest   %eax,%eax\njle    121a <func0+0xba>\nmov    %eax,%eax\nmovb   $0x0,0x10(%rsp,%rax,1)\nlea    0x10(%rsp),%rdi\ncall   1070 <strdup@plt>\nmovslq %ebp,%rbp\nmov    %rax,(%r15,%rbp,8)\nadd    $0x1,%ebp\nxor    %eax,%eax\njmp    121a <func0+0xba>\nmov    0x8(%rsp),%rbx\njmp    12ed <func0+0x18d>\nxor    %ebp,%ebp\njmp    12ed <func0+0x18d>\ntest   %ebp,%ebp\njle    12b9 <func0+0x159>\ncall   1080 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    %ebp,%ecx\nxor    %edx,%edx\nxor    %ebp,%ebp\njmp    1289 <func0+0x129>\nnopl   (%rax)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\nje     12bb <func0+0x15b>\nmovsbq 0x0(%r13,%rdx,1),%rsi\ntestb  $0x2,0x1(%rax,%rsi,2)\nje     1280 <func0+0x120>\nmovswl %si,%esi\nadd    $0xffffff9f,%esi\nmovzwl %si,%esi\nmov    %esi,%edi\nshr    $0xf,%edi\nadd    %esi,%edi\nand    $0xfffffffe,%edi\nsub    %edi,%esi\nxor    %edi,%edi\ncmp    $0x1,%si\nsete   %dil\nadd    %edi,%ebp\njmp    1280 <func0+0x120>\nxor    %ebp,%ebp\nmov    $0x8,%edi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    $0xc,%edi\ncall   1050 <malloc@plt>\nmov    %rax,(%r15)\nlea    0xd24(%rip),%rsi\nmov    %rax,%rdi\nmov    %ebp,%edx\nxor    %eax,%eax\ncall   1060 <sprintf@plt>\nmov    $0x1,%ebp\nmov    %ebp,(%rbx)\nmov    %r15,%rax\nadd    $0x78,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 126,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    111e <func0+0x1e>\nmovb   $0x1,-0x1(%rbp)\njmp    11c7 <func0+0xc7>\nmovl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11c3 <func0+0xc3>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x18(%rbp),%edx\nsub    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\njge    115b <func0+0x5b>\nmovb   $0x0,-0x1(%rbp)\njmp    11c7 <func0+0xc7>\ncmpl   $0x2,-0x18(%rbp)\njl     11b0 <func0+0xb0>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x18(%rbp),%edx\nsub    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\njne    11b0 <func0+0xb0>\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x10(%rbp),%rcx\nmov    -0x18(%rbp),%edx\nsub    $0x2,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\njne    11b0 <func0+0xb0>\nmovb   $0x0,-0x1(%rbp)\njmp    11c7 <func0+0xc7>\njmp    11b5 <func0+0xb5>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1125 <func0+0x25>\nmovb   $0x1,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 126,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%al\ncmp    $0x2,%esi\njl     114c <func0+0x4c>\nmov    %esi,%r8d\nmov    $0x1,%edx\nmov    $0xffffffff,%r9d\njmp    112d <func0+0x2d>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rdx\nadd    $0x1,%r9\ncmp    %rdx,%r8\nje     114c <func0+0x4c>\nmov    -0x4(%rdi,%rdx,4),%esi\nmov    (%rdi,%rdx,4),%ecx\ncmp    %esi,%ecx\njl     114a <func0+0x4a>\ncmp    $0x2,%rdx\njb     1120 <func0+0x20>\ncmp    %esi,%ecx\njne    1120 <func0+0x20>\nmov    %r9d,%esi\ncmp    (%rdi,%rsi,4),%ecx\njne    1120 <func0+0x20>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 126,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%al\ncmp    $0x2,%esi\njl     114e <func0+0x4e>\nmov    %esi,%r8d\nmov    (%rdi),%r9d\nmov    $0x1,%edx\nmov    $0xffffffff,%r10d\njmp    112d <func0+0x2d>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rdx\nadd    $0x1,%r10\ncmp    %rdx,%r8\nje     114e <func0+0x4e>\nmov    %r9d,%ecx\nmov    (%rdi,%rdx,4),%r9d\ncmp    %ecx,%r9d\njl     114c <func0+0x4c>\ncmp    $0x2,%rdx\njb     1120 <func0+0x20>\ncmp    %ecx,%r9d\njne    1120 <func0+0x20>\nmov    %r10d,%esi\ncmp    (%rdi,%rsi,4),%ecx\njne    1120 <func0+0x20>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 126,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0x1,%al\ncmp    $0x2,%esi\njl     114e <func0+0x4e>\nmov    %esi,%r8d\nmov    (%rdi),%r9d\nmov    $0x1,%edx\nmov    $0xffffffff,%r10d\njmp    112d <func0+0x2d>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rdx\nadd    $0x1,%r10\ncmp    %rdx,%r8\nje     114e <func0+0x4e>\nmov    %r9d,%ecx\nmov    (%rdi,%rdx,4),%r9d\ncmp    %ecx,%r9d\njl     114c <func0+0x4c>\ncmp    $0x2,%rdx\njb     1120 <func0+0x20>\ncmp    %ecx,%r9d\njne    1120 <func0+0x20>\nmov    %r10d,%esi\ncmp    (%rdi,%rsi,4),%ecx\njne    1120 <func0+0x20>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 127,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0xc(%rbp)\nmov    %esi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    %ecx,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    1127 <func0+0x27>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x2c(%rbp)\njmp    112d <func0+0x2d>\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njge    114a <func0+0x4a>\nmov    -0x10(%rbp),%eax\nmov    %eax,-0x30(%rbp)\njmp    1150 <func0+0x50>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\nmov    %eax,-0x24(%rbp)\ncmpl   $0x2,-0x24(%rbp)\njge    1179 <func0+0x79>\nlea    0xe90(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    11ce <func0+0xce>\nmovl   $0x2,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nimul   -0x28(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njg     11c3 <func0+0xc3>\nmov    -0x24(%rbp),%eax\ncltd\nidivl  -0x28(%rbp)\ncmp    $0x0,%edx\njne    11b0 <func0+0xb0>\nlea    0xe59(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    11ce <func0+0xce>\njmp    11b5 <func0+0xb5>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    1180 <func0+0x80>\nlea    0xe39(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 127,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    %edx,%edi\ncmovg  %edi,%edx\nmov    %ecx,%edi\ncmp    %ecx,%esi\ncmovl  %esi,%edi\nsub    %edx,%edi\nlea    0xeeb(%rip),%rcx\ncmp    $0x2,%edi\njge    111e <func0+0x1e>\nmov    %rcx,%rax\nret\nlea    0xede(%rip),%r8\ncmp    $0x4,%edi\njge    112e <func0+0x2e>\nmov    %r8,%rax\nret\nmov    $0x2,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     111a <func0+0x1a>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njle    1140 <func0+0x40>\nmov    %r8,%rax\nret\n"
    },
    {
        "task_id": 127,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    %edx,%edi\ncmovg  %edi,%edx\nmov    %ecx,%edi\ncmp    %ecx,%esi\ncmovl  %esi,%edi\nsub    %edx,%edi\nlea    0xeeb(%rip),%rcx\ncmp    $0x2,%edi\njge    111e <func0+0x1e>\nmov    %rcx,%rax\nret\nlea    0xede(%rip),%r8\ncmp    $0x4,%edi\njae    112e <func0+0x2e>\nmov    %r8,%rax\nret\nmov    $0x2,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     111a <func0+0x1a>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njle    1140 <func0+0x40>\nmov    %r8,%rax\nret\n"
    },
    {
        "task_id": 127,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    %edx,%edi\ncmovg  %edi,%edx\nmov    %ecx,%edi\ncmp    %ecx,%esi\ncmovl  %esi,%edi\nsub    %edx,%edi\nlea    0xeeb(%rip),%rcx\ncmp    $0x2,%edi\njge    111e <func0+0x1e>\nmov    %rcx,%rax\nret\nlea    0xede(%rip),%r8\ncmp    $0x4,%edi\njae    112e <func0+0x2e>\nmov    %r8,%rax\nret\nmov    $0x2,%esi\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     111a <func0+0x1a>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njle    1140 <func0+0x40>\nmov    %r8,%rax\nret\n"
    },
    {
        "task_id": 128,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1135 <func0+0x25>\nmovl   $0xffff8000,-0x4(%rbp)\njmp    11bc <func0+0xac>\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x1,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11b2 <func0+0xa2>\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%edi\ncall   1030 <abs@plt>\nadd    -0x18(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\ncmpl   $0x0,(%rax,%rcx,4)\njne    1185 <func0+0x75>\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\ncmpl   $0x0,(%rax,%rcx,4)\njge    119f <func0+0x8f>\nxor    %eax,%eax\nsub    -0x1c(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\njmp    11a4 <func0+0x94>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    114a <func0+0x3a>\nmov    -0x18(%rbp),%eax\nimul   -0x1c(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 128,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\nje     114b <func0+0x4b>\njle    1151 <func0+0x51>\nmov    %esi,%r8d\nxor    %edx,%edx\nmov    $0x1,%eax\nxor    %r9d,%r9d\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    (%rdi,%rdx,4),%ecx\ntest   %ecx,%ecx\nmov    %eax,%esi\ncmove  %ecx,%esi\nmov    %esi,%eax\nneg    %eax\ntest   %ecx,%ecx\ncmovns %esi,%eax\nmov    %ecx,%esi\nneg    %esi\ncmovs  %ecx,%esi\nadd    %esi,%r9d\nadd    $0x1,%rdx\ncmp    %rdx,%r8\njne    1120 <func0+0x20>\nimul   %r9d,%eax\nret\nmov    $0xffff8000,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 128,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\nje     111a <func0+0x1a>\njle    1120 <func0+0x20>\nmov    %esi,%r8d\ncmp    $0x1,%esi\njne    1123 <func0+0x23>\nxor    %r10d,%r10d\nmov    $0x1,%esi\nxor    %eax,%eax\njmp    1185 <func0+0x85>\nmov    $0xffff8000,%eax\nret\nxor    %eax,%eax\nret\nmov    %r8d,%r9d\nand    $0xfffffffe,%r9d\nxor    %r10d,%r10d\nmov    $0x1,%esi\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    (%rdi,%r10,4),%r11d\ntest   %r11d,%r11d\ncmove  %r11d,%esi\nmov    %esi,%ecx\nneg    %ecx\ntest   %r11d,%r11d\ncmovns %esi,%ecx\nmov    0x4(%rdi,%r10,4),%edx\ntest   %edx,%edx\ncmove  %edx,%ecx\nmov    %ecx,%esi\nneg    %esi\ntest   %edx,%edx\ncmovns %ecx,%esi\nmov    %r11d,%ecx\nneg    %ecx\ncmovs  %r11d,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nneg    %eax\ncmovs  %edx,%eax\nadd    %ecx,%eax\nadd    $0x2,%r10\ncmp    %r10,%r9\njne    1140 <func0+0x40>\ntest   $0x1,%r8b\nje     11a6 <func0+0xa6>\nmov    (%rdi,%r10,4),%ecx\ntest   %ecx,%ecx\ncmove  %ecx,%esi\nmov    %esi,%edx\nneg    %edx\ntest   %ecx,%ecx\ncmovs  %edx,%esi\nmov    %ecx,%edx\nneg    %edx\ncmovs  %ecx,%edx\nadd    %edx,%eax\nimul   %esi,%eax\nret\n"
    },
    {
        "task_id": 128,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\nje     111a <func0+0x1a>\njle    1120 <func0+0x20>\nmov    %esi,%r8d\ncmp    $0x1,%esi\njne    1123 <func0+0x23>\nxor    %r10d,%r10d\nmov    $0x1,%esi\nxor    %eax,%eax\njmp    1185 <func0+0x85>\nmov    $0xffff8000,%eax\nret\nxor    %eax,%eax\nret\nmov    %r8d,%r9d\nand    $0xfffffffe,%r9d\nxor    %r10d,%r10d\nmov    $0x1,%esi\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    (%rdi,%r10,4),%r11d\ntest   %r11d,%r11d\ncmove  %r11d,%esi\nmov    %esi,%ecx\nneg    %ecx\ntest   %r11d,%r11d\ncmovns %esi,%ecx\nmov    0x4(%rdi,%r10,4),%edx\ntest   %edx,%edx\ncmove  %edx,%ecx\nmov    %ecx,%esi\nneg    %esi\ntest   %edx,%edx\ncmovns %ecx,%esi\nmov    %r11d,%ecx\nneg    %ecx\ncmovs  %r11d,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nneg    %eax\ncmovs  %edx,%eax\nadd    %ecx,%eax\nadd    $0x2,%r10\ncmp    %r10,%r9\njne    1140 <func0+0x40>\ntest   $0x1,%r8b\nje     11a6 <func0+0xa6>\nmov    (%rdi,%r10,4),%ecx\ntest   %ecx,%ecx\ncmove  %ecx,%esi\nmov    %esi,%edx\nneg    %edx\ntest   %ecx,%ecx\ncmovs  %edx,%esi\nmov    %ecx,%edx\nneg    %edx\ncmovs  %ecx,%edx\nadd    %edx,%eax\nimul   %esi,%eax\nret\n"
    },
    {
        "task_id": 129,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\nmov    %rcx,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1198 <func0+0x88>\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1185 <func0+0x75>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x20(%rbp),%rcx\ncmpl   $0x1,(%rax,%rcx,4)\njne    1172 <func0+0x62>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,-0x28(%rbp)\njmp    1177 <func0+0x67>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1140 <func0+0x30>\njmp    118a <func0+0x7a>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    112d <func0+0x1d>\nmov    -0xc(%rbp),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,-0x2c(%rbp)\ncmpl   $0x0,-0x24(%rbp)\njle    11e8 <func0+0xd8>\nmov    -0x8(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x2c(%rbp),%eax\njge    11e8 <func0+0xd8>\nmov    -0x8(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x24(%rbp),%eax\nmov    -0xc(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    1235 <func0+0x125>\nmov    -0x8(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x2c(%rbp),%eax\njge    1235 <func0+0x125>\nmov    -0x8(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x2c(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njle    127b <func0+0x16b>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    -0x28(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x2c(%rbp),%eax\njge    127b <func0+0x16b>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    -0x28(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x28(%rbp),%eax\nmov    -0xc(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    12c8 <func0+0x1b8>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    -0x28(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x2c(%rbp),%eax\njge    12c8 <func0+0x1b8>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    -0x28(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x10(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmovslq -0x10(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x38(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njge    133e <func0+0x22e>\nmov    -0x1c(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    131d <func0+0x20d>\nmov    -0x38(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovl   $0x1,(%rax,%rcx,4)\njmp    132b <func0+0x21b>\nmov    -0x2c(%rbp),%edx\nmov    -0x38(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1330 <func0+0x220>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    12e9 <func0+0x1d9>\nmov    -0x38(%rbp),%rax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 129,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %edx,%r14d\ntest   %esi,%esi\njle    1160 <func0+0x50>\nmov    %esi,%r8d\nxor    %r9d,%r9d\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi,%r9,8),%rbp\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\ncmpl   $0x1,0x0(%rbp,%rbx,4)\ncmove  %r9d,%edx\ncmove  %ebx,%eax\nadd    $0x1,%rbx\ncmp    %rbx,%r8\njne    1140 <func0+0x30>\nadd    $0x1,%r9\ncmp    %r8,%r9\njne    1130 <func0+0x20>\njmp    1160 <func0+0x50>\nmov    %esi,%ebp\nimul   %esi,%ebp\nmovslq %eax,%r8\ntest   %edx,%edx\njle    117c <func0+0x6c>\nlea    -0x1(%rdx),%ebx\nmov    (%rdi,%rbx,8),%rbx\nmov    (%rbx,%r8,4),%ebx\ncmp    %ebp,%ebx\ncmovl  %ebx,%ebp\nadd    $0xffffffff,%esi\nmovslq %edx,%rbx\ncmp    %esi,%edx\njge    1194 <func0+0x84>\nmov    0x8(%rdi,%rbx,8),%rdx\nmov    (%rdx,%r8,4),%edx\ncmp    %ebp,%edx\ncmovl  %edx,%ebp\ntest   %eax,%eax\njle    11a8 <func0+0x98>\nmov    (%rdi,%rbx,8),%r9\nlea    -0x1(%rax),%edx\nmov    (%r9,%rdx,4),%edx\ncmp    %ebp,%edx\ncmovl  %edx,%ebp\ncmp    %esi,%eax\njge    11ba <func0+0xaa>\nmov    (%rdi,%rbx,8),%rax\nmov    0x4(%rax,%r8,4),%eax\ncmp    %ebp,%eax\ncmovl  %eax,%ebp\nmov    %r14d,(%rcx)\nmovslq %r14d,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\njle    11f4 <func0+0xe4>\nmov    %r14d,%ecx\nxor    %edx,%edx\nmov    $0x1,%esi\nnopl   0x0(%rax,%rax,1)\ntest   $0x1,%dl\nmov    %ebp,%edi\ncmove  %esi,%edi\nmov    %edi,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    11e0 <func0+0xd0>\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 129,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %edx,%r14d\ntest   %esi,%esi\njle    1237 <func0+0x127>\nmov    %esi,%r9d\nlea    -0x1(%r9),%r8\nmov    %r9d,%r10d\nand    $0x3,%r10d\nmov    %r9d,%r11d\nand    $0xfffffffc,%r11d\nxor    %r15d,%r15d\njmp    114d <func0+0x3d>\nadd    $0x1,%r15\ncmp    %r9,%r15\nje     11db <func0+0xcb>\nmov    (%rdi,%r15,8),%r12\nxor    %ebp,%ebp\ncmp    $0x3,%r8\njb     11a9 <func0+0x99>\nnopl   0x0(%rax)\nlea    0x1(%rbp),%ebx\nlea    0x2(%rbp),%r13d\ncmpl   $0x1,(%r12,%rbp,4)\ncmove  %ebp,%eax\ncmove  %r15d,%edx\ncmpl   $0x1,0x4(%r12,%rbp,4)\ncmove  %ebx,%eax\ncmove  %r15d,%edx\ncmpl   $0x1,0x8(%r12,%rbp,4)\nmov    %eax,%ebx\ncmove  %r13d,%ebx\ncmove  %r15d,%edx\nlea    0x3(%rbp),%eax\ncmpl   $0x1,0xc(%r12,%rbp,4)\ncmove  %r15d,%edx\ncmovne %ebx,%eax\nadd    $0x4,%rbp\ncmp    %r11,%rbp\njne    1160 <func0+0x50>\ntest   %r10,%r10\nje     1140 <func0+0x30>\nmov    %r10,%rbx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\ncmpl   $0x1,(%r12,%rbp,4)\ncmove  %r15d,%edx\ncmove  %ebp,%eax\nadd    $0x1,%rbp\nadd    $0xffffffffffffffff,%rbx\njne    11c0 <func0+0xb0>\njmp    1140 <func0+0x30>\nmov    %esi,%ebp\nimul   %esi,%ebp\nmovslq %eax,%r8\ntest   %edx,%edx\njle    11f7 <func0+0xe7>\nlea    -0x1(%rdx),%ebx\nmov    (%rdi,%rbx,8),%rbx\nmov    (%rbx,%r8,4),%ebx\ncmp    %ebp,%ebx\ncmovl  %ebx,%ebp\nadd    $0xffffffff,%esi\nmovslq %edx,%rbx\ncmp    %esi,%edx\njge    120f <func0+0xff>\nmov    0x8(%rdi,%rbx,8),%rdx\nmov    (%rdx,%r8,4),%edx\ncmp    %ebp,%edx\ncmovl  %edx,%ebp\ntest   %eax,%eax\njle    1223 <func0+0x113>\nmov    (%rdi,%rbx,8),%r9\nlea    -0x1(%rax),%edx\nmov    (%r9,%rdx,4),%edx\ncmp    %ebp,%edx\ncmovl  %edx,%ebp\ncmp    %esi,%eax\njge    123c <func0+0x12c>\nmov    (%rdi,%rbx,8),%rax\nmov    0x4(%rax,%r8,4),%eax\ncmp    %ebp,%eax\ncmovl  %eax,%ebp\njmp    123c <func0+0x12c>\nimul   %esi,%esi\nmov    %esi,%ebp\nmov    %r14d,(%rcx)\nmovslq %r14d,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\njle    12b5 <func0+0x1a5>\nmov    %r14d,%esi\nlea    -0x1(%rsi),%rdx\nmov    %esi,%ecx\nand    $0x3,%ecx\ncmp    $0x3,%rdx\njae    1269 <func0+0x159>\nxor    %edx,%edx\njmp    1290 <func0+0x180>\nand    $0xfffffffc,%esi\nxor    %edx,%edx\nxchg   %ax,%ax\nmovl   $0x1,(%rax,%rdx,4)\nmov    %ebp,0x4(%rax,%rdx,4)\nmovl   $0x1,0x8(%rax,%rdx,4)\nmov    %ebp,0xc(%rax,%rdx,4)\nadd    $0x4,%rdx\ncmp    %rdx,%rsi\njne    1270 <func0+0x160>\ntest   %rcx,%rcx\nje     12b5 <func0+0x1a5>\nmov    $0x1,%esi\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%dl\nmov    %ebp,%edi\ncmove  %esi,%edi\nmov    %edi,(%rax,%rdx,4)\nadd    $0x1,%rdx\nadd    $0xffffffffffffffff,%rcx\njne    12a0 <func0+0x190>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 129,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %edx,%r14d\ntest   %esi,%esi\njle    1237 <func0+0x127>\nmov    %esi,%r9d\nlea    -0x1(%r9),%r8\nmov    %r9d,%r10d\nand    $0x3,%r10d\nmov    %r9d,%r11d\nand    $0xfffffffc,%r11d\nxor    %r15d,%r15d\njmp    114d <func0+0x3d>\nadd    $0x1,%r15\ncmp    %r9,%r15\nje     11db <func0+0xcb>\nmov    (%rdi,%r15,8),%r12\nxor    %ebp,%ebp\ncmp    $0x3,%r8\njb     11a9 <func0+0x99>\nnopl   0x0(%rax)\nlea    0x1(%rbp),%ebx\nlea    0x2(%rbp),%r13d\ncmpl   $0x1,(%r12,%rbp,4)\ncmove  %ebp,%eax\ncmove  %r15d,%edx\ncmpl   $0x1,0x4(%r12,%rbp,4)\ncmove  %ebx,%eax\ncmove  %r15d,%edx\ncmpl   $0x1,0x8(%r12,%rbp,4)\nmov    %eax,%ebx\ncmove  %r13d,%ebx\ncmove  %r15d,%edx\nlea    0x3(%rbp),%eax\ncmpl   $0x1,0xc(%r12,%rbp,4)\ncmove  %r15d,%edx\ncmovne %ebx,%eax\nadd    $0x4,%rbp\ncmp    %r11,%rbp\njne    1160 <func0+0x50>\ntest   %r10,%r10\nje     1140 <func0+0x30>\nmov    %r10,%rbx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\ncmpl   $0x1,(%r12,%rbp,4)\ncmove  %r15d,%edx\ncmove  %ebp,%eax\nadd    $0x1,%rbp\nadd    $0xffffffffffffffff,%rbx\njne    11c0 <func0+0xb0>\njmp    1140 <func0+0x30>\nmov    %esi,%ebp\nimul   %esi,%ebp\nmovslq %eax,%r8\ntest   %edx,%edx\njle    11f7 <func0+0xe7>\nlea    -0x1(%rdx),%ebx\nmov    (%rdi,%rbx,8),%rbx\nmov    (%rbx,%r8,4),%ebx\ncmp    %ebp,%ebx\ncmovl  %ebx,%ebp\nadd    $0xffffffff,%esi\nmovslq %edx,%rbx\ncmp    %esi,%edx\njge    120f <func0+0xff>\nmov    0x8(%rdi,%rbx,8),%rdx\nmov    (%rdx,%r8,4),%edx\ncmp    %ebp,%edx\ncmovl  %edx,%ebp\ntest   %eax,%eax\njle    1223 <func0+0x113>\nmov    (%rdi,%rbx,8),%r9\nlea    -0x1(%rax),%edx\nmov    (%r9,%rdx,4),%edx\ncmp    %ebp,%edx\ncmovl  %edx,%ebp\ncmp    %esi,%eax\njge    123c <func0+0x12c>\nmov    (%rdi,%rbx,8),%rax\nmov    0x4(%rax,%r8,4),%eax\ncmp    %ebp,%eax\ncmovl  %eax,%ebp\njmp    123c <func0+0x12c>\nimul   %esi,%esi\nmov    %esi,%ebp\nmov    %r14d,(%rcx)\nmovslq %r14d,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1030 <malloc@plt>\ntest   %ebx,%ebx\njle    12b5 <func0+0x1a5>\nmov    %r14d,%esi\nlea    -0x1(%rsi),%rdx\nmov    %esi,%ecx\nand    $0x3,%ecx\ncmp    $0x3,%rdx\njae    1269 <func0+0x159>\nxor    %edx,%edx\njmp    1290 <func0+0x180>\nand    $0xfffffffc,%esi\nxor    %edx,%edx\nxchg   %ax,%ax\nmovl   $0x1,(%rax,%rdx,4)\nmov    %ebp,0x4(%rax,%rdx,4)\nmovl   $0x1,0x8(%rax,%rdx,4)\nmov    %ebp,0xc(%rax,%rdx,4)\nadd    $0x4,%rdx\ncmp    %rdx,%rsi\njne    1270 <func0+0x160>\ntest   %rcx,%rcx\nje     12b5 <func0+0x1a5>\nmov    $0x1,%esi\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%dl\nmov    %ebp,%edi\ncmove  %esi,%edi\nmov    %edi,(%rax,%rdx,4)\nadd    $0x1,%rdx\nadd    $0xffffffffffffffff,%rcx\njne    12a0 <func0+0x190>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 130,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovl   $0x1,(%rax)\ncmpl   $0x0,-0xc(%rbp)\njne    1152 <func0+0x42>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    1203 <func0+0xf3>\nmov    -0x18(%rbp),%rax\nmovl   $0x3,0x4(%rax)\nmovl   $0x2,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njg     11fb <func0+0xeb>\nmov    -0x1c(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    11a4 <func0+0x94>\nmov    -0x1c(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%edx\nadd    $0x1,%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    11e8 <func0+0xd8>\nmov    -0x18(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x18(%rbp),%rcx\nmov    -0x1c(%rbp),%edx\nsub    $0x2,%edx\nmovslq %edx,%rdx\nadd    (%rcx,%rdx,4),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    -0x20(%rbp),%edx\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    11ed <func0+0xdd>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1164 <func0+0x54>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 130,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %edi,%ebx\nmovslq %edi,%r14\nlea    0x4(,%r14,4),%rdi\ncall   1030 <malloc@plt>\nmovl   $0x1,(%rax)\ntest   %r14d,%r14d\nje     113d <func0+0x2d>\nmovl   $0x3,0x4(%rax)\ncmp    $0x2,%ebx\njge    1145 <func0+0x35>\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\nadd    $0x1,%ebx\nmov    $0x2,%ecx\nmov    $0x3,%edx\njmp    1180 <func0+0x70>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    -0x8(%rax,%rcx,4),%esi\nmov    %edx,%edi\nshr    %edi\nadd    -0x4(%rax,%rcx,4),%edi\nadd    %edi,%esi\nadd    $0x1,%esi\nmov    %esi,(%rax,%rcx,4)\nadd    $0x1,%rcx\nadd    $0x1,%edx\ncmp    %rcx,%rbx\nje     113d <func0+0x2d>\ntest   $0x1,%cl\njne    1160 <func0+0x50>\nmov    %ecx,%esi\nshr    %esi\nadd    $0x1,%esi\njmp    1171 <func0+0x61>\n"
    },
    {
        "task_id": 130,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %edi,%ebx\nlea    0x1(%rbx),%ebp\nmovslq %ebp,%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmovl   $0x1,(%rax)\ntest   %ebx,%ebx\nje     113a <func0+0x2a>\nmovl   $0x3,0x4(%rax)\ncmp    $0x2,%ebx\njge    1141 <func0+0x31>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nmov    %ebp,%ecx\nmov    $0x2,%edx\nmov    $0x3,%esi\njmp    116f <func0+0x5f>\nnop\nmov    -0x8(%rax,%rdx,4),%ebp\nlea    0x1(%rdx),%rbx\nmov    %ebx,%edi\nshr    %edi\nadd    %esi,%edi\nlea    (%rdi,%rbp,1),%esi\nadd    $0x1,%esi\nmov    %esi,(%rax,%rdx,4)\nmov    %rbx,%rdx\ncmp    %rcx,%rbx\nje     113a <func0+0x2a>\ntest   $0x1,%dl\njne    1150 <func0+0x40>\nmov    %edx,%esi\nshr    %esi\nadd    $0x1,%esi\nlea    0x1(%rdx),%rbx\njmp    1164 <func0+0x54>\n"
    },
    {
        "task_id": 130,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %rbx\npush   %rax\nmov    %edi,%ebx\nlea    0x1(%rbx),%ebp\nmovslq %ebp,%rdi\nshl    $0x2,%rdi\ncall   1030 <malloc@plt>\nmovl   $0x1,(%rax)\ntest   %ebx,%ebx\nje     118a <func0+0x7a>\nmovl   $0x3,0x4(%rax)\ncmp    $0x2,%ebx\njl     118a <func0+0x7a>\nmov    %ebp,%ecx\nmov    $0x2,%edx\nmov    $0x3,%esi\njmp    116f <func0+0x5f>\nnopl   0x0(%rax,%rax,1)\nmov    -0x8(%rax,%rdx,4),%ebp\nlea    0x1(%rdx),%rbx\nmov    %ebx,%edi\nshr    %edi\nadd    %esi,%edi\nlea    (%rdi,%rbp,1),%esi\nadd    $0x1,%esi\nmov    %esi,(%rax,%rdx,4)\nmov    %rbx,%rdx\ncmp    %rcx,%rbx\nje     118a <func0+0x7a>\ntest   $0x1,%dl\njne    1150 <func0+0x40>\nmov    %edx,%esi\nshr    %esi\nadd    $0x1,%esi\nlea    0x1(%rdx),%rbx\nmov    %esi,(%rax,%rdx,4)\nmov    %rbx,%rdx\ncmp    %rcx,%rbx\njne    116f <func0+0x5f>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 131,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njle    1165 <func0+0x65>\nmov    -0x4(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %edx,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    1152 <func0+0x52>\nmovl   $0x1,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\nimul   -0x8(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x4(%rbp)\njmp    1115 <func0+0x15>\ncmpl   $0x0,-0xc(%rbp)\nje     117a <func0+0x7a>\nmov    -0x8(%rbp),%eax\nmov    %eax,-0x14(%rbp)\njmp    1184 <func0+0x84>\nxor    %eax,%eax\nmov    %eax,-0x14(%rbp)\njmp    1184 <func0+0x84>\nmov    -0x14(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 131,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    116c <func0+0x6c>\nmov    $0x1,%r8d\nxor    %r10d,%r10d\nmov    $0x1,%eax\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovslq %edi,%r9\nimul   $0x66666667,%r9,%rdi\nmov    %rdi,%rdx\nshr    $0x3f,%rdx\nsar    $0x22,%rdi\nadd    %edx,%edi\nlea    (%rdi,%rdi,1),%edx\nlea    (%rdx,%rdx,4),%edx\nmov    %r9d,%esi\nsub    %edx,%esi\nmov    %esi,%edx\nshr    $0x1f,%edx\nadd    %esi,%edx\nand    $0xfffffffe,%edx\nmov    %esi,%ecx\nsub    %edx,%ecx\ncmp    $0x1,%ecx\ncmovne %r8d,%esi\ncmove  %ecx,%r10d\nimul   %esi,%eax\ncmp    $0x9,%r9d\njg     1120 <func0+0x20>\ntest   %r10d,%r10d\ncmove  %r10d,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 131,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1151 <func0+0x51>\nmov    $0x1,%r9d\nxor    %ecx,%ecx\nmov    $0xcccccccd,%r8d\nmov    $0x1,%eax\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%esi\nimul   %r8,%rsi\nshr    $0x23,%rsi\nlea    (%rsi,%rsi,1),%edx\nlea    (%rdx,%rdx,4),%r10d\nmov    %edi,%edx\nsub    %r10d,%edx\ntest   $0x1,%dl\ncmove  %r9d,%edx\ncmovne %r9d,%ecx\nimul   %edx,%eax\ncmp    $0x9,%edi\nmov    %esi,%edi\nja     1120 <func0+0x20>\ntest   %ecx,%ecx\ncmove  %ecx,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 131,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1151 <func0+0x51>\nmov    $0x1,%r9d\nxor    %ecx,%ecx\nmov    $0xcccccccd,%r8d\nmov    $0x1,%eax\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%esi\nimul   %r8,%rsi\nshr    $0x23,%rsi\nlea    (%rsi,%rsi,1),%edx\nlea    (%rdx,%rdx,4),%r10d\nmov    %edi,%edx\nsub    %r10d,%edx\ntest   $0x1,%dl\ncmove  %r9d,%edx\ncmovne %r9d,%ecx\nimul   %edx,%eax\ncmp    $0x9,%edi\nmov    %esi,%edi\nja     1120 <func0+0x20>\ntest   %ecx,%ecx\ncmove  %ecx,%eax\nret\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 132,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovslq -0x1c(%rbp),%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\ncmp    %rcx,%rax\njae    11e1 <func0+0xd1>\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x5b,%eax\njne    1170 <func0+0x60>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x5d,%eax\njne    118e <func0+0x7e>\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njge    119f <func0+0x8f>\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njle    11b1 <func0+0xa1>\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmov    -0x18(%rbp),%ecx\nsub    $0x2,%ecx\ncmp    %ecx,%eax\njg     11ce <func0+0xbe>\nmovl   $0x1,-0x4(%rbp)\njmp    11e8 <func0+0xd8>\njmp    11d3 <func0+0xc3>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1131 <func0+0x21>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 132,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nsetne  %cl\nje     118d <func0+0x7d>\nmov    (%r14),%dl\nxor    %ecx,%ecx\ncmp    $0x5b,%dl\nsete   %cl\nxor    %esi,%esi\ncmp    $0x5d,%dl\nsete   %sil\nxor    %r8d,%r8d\nsub    %esi,%ecx\ncmovs  %r8d,%ecx\nmov    $0x1,%edi\nmov    %ecx,%esi\nnopl   0x0(%rax,%rax,1)\nmov    %rdi,%rdx\ncmp    %rdi,%rax\nje     1187 <func0+0x77>\nmovzbl (%r14,%rdx,1),%ebx\nxor    %edi,%edi\ncmp    $0x5b,%bl\nsete   %dil\nadd    %edi,%esi\nxor    %edi,%edi\ncmp    $0x5d,%bl\nsete   %dil\nsub    %edi,%esi\ncmovs  %r8d,%esi\ncmp    %ecx,%esi\ncmova  %esi,%ecx\nlea    -0x2(%rcx),%ebx\nlea    0x1(%rdx),%rdi\ncmp    %ebx,%esi\njg     1150 <func0+0x40>\ncmp    %rdx,%rax\nseta   %cl\nmovzbl %cl,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 132,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1191 <func0+0x81>\nmov    (%r14),%dl\nxor    %ecx,%ecx\ncmp    $0x5b,%dl\nsete   %cl\nxor    %esi,%esi\ncmp    $0x5d,%dl\nsete   %sil\nxor    %r8d,%r8d\nsub    %esi,%ecx\ncmovs  %r8d,%ecx\nmov    $0x1,%edi\nmov    %ecx,%esi\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %rdi,%rdx\ncmp    %rdi,%rax\nje     1187 <func0+0x77>\nmovzbl (%r14,%rdx,1),%ebx\nxor    %edi,%edi\ncmp    $0x5b,%bl\nsete   %dil\nadd    %edi,%esi\nxor    %edi,%edi\ncmp    $0x5d,%bl\nsete   %dil\nsub    %edi,%esi\ncmovs  %r8d,%esi\ncmp    %ecx,%esi\ncmova  %esi,%ecx\nlea    -0x2(%rcx),%ebx\nlea    0x1(%rdx),%rdi\ncmp    %ebx,%esi\njg     1150 <func0+0x40>\nxor    %ecx,%ecx\ncmp    %rdx,%rax\nseta   %cl\njmp    1193 <func0+0x83>\nxor    %ecx,%ecx\nmov    %ecx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 132,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\ntest   %rax,%rax\nje     1191 <func0+0x81>\nmov    (%r14),%dl\nxor    %ecx,%ecx\ncmp    $0x5b,%dl\nsete   %cl\nxor    %esi,%esi\ncmp    $0x5d,%dl\nsete   %sil\nxor    %r8d,%r8d\nsub    %esi,%ecx\ncmovs  %r8d,%ecx\nmov    $0x1,%edi\nmov    %ecx,%esi\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %rdi,%rdx\ncmp    %rdi,%rax\nje     1187 <func0+0x77>\nmovzbl (%r14,%rdx,1),%ebx\nxor    %edi,%edi\ncmp    $0x5b,%bl\nsete   %dil\nadd    %edi,%esi\nxor    %edi,%edi\ncmp    $0x5d,%bl\nsete   %dil\nsub    %edi,%esi\ncmovs  %r8d,%esi\ncmp    %ecx,%esi\ncmova  %esi,%ecx\nlea    -0x2(%rcx),%ebx\nlea    0x1(%rdx),%rdi\ncmp    %ebx,%esi\njg     1150 <func0+0x40>\nxor    %ecx,%ecx\ncmp    %rdx,%rax\nseta   %cl\njmp    1193 <func0+0x83>\nxor    %ecx,%ecx\nmov    %ecx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 133,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    118a <func0+0x7a>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\ncall   1030 <ceil@plt>\ncvttsd2si %xmm0,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\ncall   1030 <ceil@plt>\nmov    -0x18(%rbp),%eax\ncvttsd2si %xmm0,%ecx\nimul   %ecx,%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    112d <func0+0x1d>\nmov    -0x10(%rbp),%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 133,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %rbx\npush   %rax\ntest   %esi,%esi\njle    114f <func0+0x3f>\nmov    %rdi,%r14\nmov    %esi,%r15d\nxor    %ebx,%ebx\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nnop\nmovss  (%r14,%rbx,4),%xmm0\ncall   1030 <ceilf@plt>\ncvttss2si %xmm0,%eax\nimul   %eax,%eax\nadd    %eax,%ebp\nadd    $0x1,%rbx\ncmp    %rbx,%r15\njne    1130 <func0+0x20>\njmp    1151 <func0+0x41>\nxor    %ebp,%ebp\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 133,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x60,%rsp\ntest   %esi,%esi\njle    1134 <func0+0x24>\nmov    %rdi,%r15\nmov    %esi,%r14d\ncmp    $0x8,%esi\njae    113b <func0+0x2b>\nxor    %ebx,%ebx\nxor    %ebp,%ebp\njmp    12c0 <func0+0x1b0>\nxor    %ebp,%ebp\njmp    12dd <func0+0x1cd>\nmov    %r14d,%ebx\nand    $0xfffffff8,%ebx\nlea    0x0(,%r14,4),%r12\nand    $0xffffffffffffffe0,%r12\npxor   %xmm2,%xmm2\nxor    %ebp,%ebp\npxor   %xmm1,%xmm1\nnopw   0x0(%rax,%rax,1)\nmovdqa %xmm1,0x40(%rsp)\nmovdqa %xmm2,0x50(%rsp)\nmovups (%r15,%rbp,1),%xmm1\nmovaps %xmm1,(%rsp)\nmovups 0x10(%r15,%rbp,1),%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm1,%xmm0\nshufps $0xff,%xmm1,%xmm0\ncall   1030 <ceilf@plt>\nmovaps %xmm0,0x10(%rsp)\nmovaps (%rsp),%xmm0\nmovhlps %xmm0,%xmm0\ncall   1030 <ceilf@plt>\nunpcklps 0x10(%rsp),%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovaps (%rsp),%xmm0\ncall   1030 <ceilf@plt>\nmovaps %xmm0,0x10(%rsp)\nmovaps (%rsp),%xmm0\nshufps $0x55,%xmm0,%xmm0\ncall   1030 <ceilf@plt>\nmovaps 0x10(%rsp),%xmm1\nunpcklps %xmm0,%xmm1\nunpcklpd 0x30(%rsp),%xmm1\nmovaps %xmm1,0x10(%rsp)\nmovaps 0x20(%rsp),%xmm0\nshufps $0xff,%xmm0,%xmm0\ncall   1030 <ceilf@plt>\nmovaps %xmm0,(%rsp)\nmovaps 0x20(%rsp),%xmm0\nmovhlps %xmm0,%xmm0\ncall   1030 <ceilf@plt>\nunpcklps (%rsp),%xmm0\nmovaps %xmm0,(%rsp)\nmovaps 0x20(%rsp),%xmm0\ncall   1030 <ceilf@plt>\nmovaps %xmm0,0x30(%rsp)\nmovaps 0x20(%rsp),%xmm0\nshufps $0x55,%xmm0,%xmm0\ncall   1030 <ceilf@plt>\nmovaps 0x30(%rsp),%xmm1\nunpcklps %xmm0,%xmm1\nunpcklpd (%rsp),%xmm1\ncvttps2dq 0x10(%rsp),%xmm0\ncvttps2dq %xmm1,%xmm1\npshufd $0xf5,%xmm0,%xmm2\npmuludq %xmm0,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npmuludq %xmm2,%xmm2\npshufd $0xe8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm0\nmovdqa 0x50(%rsp),%xmm2\npaddd  %xmm0,%xmm2\npshufd $0xf5,%xmm1,%xmm0\npmuludq %xmm1,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm0,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npunpckldq %xmm0,%xmm1\nmovdqa 0x40(%rsp),%xmm0\npaddd  %xmm1,%xmm0\nmovdqa %xmm0,0x40(%rsp)\nmovdqa 0x40(%rsp),%xmm1\nadd    $0x20,%rbp\ncmp    %rbp,%r12\njne    1160 <func0+0x50>\npaddd  %xmm2,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%ebp\ncmp    %r14,%rbx\nje     12dd <func0+0x1cd>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovss  (%r15,%rbx,4),%xmm0\ncall   1030 <ceilf@plt>\ncvttss2si %xmm0,%eax\nimul   %eax,%eax\nadd    %eax,%ebp\nadd    $0x1,%rbx\ncmp    %rbx,%r14\njne    12c0 <func0+0x1b0>\nmov    %ebp,%eax\nadd    $0x60,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 133,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x60,%rsp\ntest   %esi,%esi\njle    1134 <func0+0x24>\nmov    %rdi,%r15\nmov    %esi,%r14d\ncmp    $0x8,%esi\njae    113b <func0+0x2b>\nxor    %ebx,%ebx\nxor    %ebp,%ebp\njmp    12c0 <func0+0x1b0>\nxor    %ebp,%ebp\njmp    12dd <func0+0x1cd>\nmov    %r14d,%ebx\nand    $0xfffffff8,%ebx\nlea    0x0(,%r14,4),%r12\nand    $0xffffffffffffffe0,%r12\npxor   %xmm2,%xmm2\nxor    %ebp,%ebp\npxor   %xmm1,%xmm1\nnopw   0x0(%rax,%rax,1)\nmovdqa %xmm1,0x40(%rsp)\nmovdqa %xmm2,0x50(%rsp)\nmovups (%r15,%rbp,1),%xmm1\nmovaps %xmm1,(%rsp)\nmovups 0x10(%r15,%rbp,1),%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm1,%xmm0\nshufps $0xff,%xmm1,%xmm0\ncall   1030 <ceilf@plt>\nmovaps %xmm0,0x10(%rsp)\nmovaps (%rsp),%xmm0\nmovhlps %xmm0,%xmm0\ncall   1030 <ceilf@plt>\nunpcklps 0x10(%rsp),%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovaps (%rsp),%xmm0\ncall   1030 <ceilf@plt>\nmovaps %xmm0,0x10(%rsp)\nmovaps (%rsp),%xmm0\nshufps $0x55,%xmm0,%xmm0\ncall   1030 <ceilf@plt>\nmovaps 0x10(%rsp),%xmm1\nunpcklps %xmm0,%xmm1\nunpcklpd 0x30(%rsp),%xmm1\nmovaps %xmm1,0x10(%rsp)\nmovaps 0x20(%rsp),%xmm0\nshufps $0xff,%xmm0,%xmm0\ncall   1030 <ceilf@plt>\nmovaps %xmm0,(%rsp)\nmovaps 0x20(%rsp),%xmm0\nmovhlps %xmm0,%xmm0\ncall   1030 <ceilf@plt>\nunpcklps (%rsp),%xmm0\nmovaps %xmm0,(%rsp)\nmovaps 0x20(%rsp),%xmm0\ncall   1030 <ceilf@plt>\nmovaps %xmm0,0x30(%rsp)\nmovaps 0x20(%rsp),%xmm0\nshufps $0x55,%xmm0,%xmm0\ncall   1030 <ceilf@plt>\nmovaps 0x30(%rsp),%xmm1\nunpcklps %xmm0,%xmm1\nunpcklpd (%rsp),%xmm1\ncvttps2dq 0x10(%rsp),%xmm0\ncvttps2dq %xmm1,%xmm1\npshufd $0xf5,%xmm0,%xmm2\npmuludq %xmm0,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npmuludq %xmm2,%xmm2\npshufd $0xe8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm0\nmovdqa 0x50(%rsp),%xmm2\npaddd  %xmm0,%xmm2\npshufd $0xf5,%xmm1,%xmm0\npmuludq %xmm1,%xmm1\npshufd $0xe8,%xmm1,%xmm1\npmuludq %xmm0,%xmm0\npshufd $0xe8,%xmm0,%xmm0\npunpckldq %xmm0,%xmm1\nmovdqa 0x40(%rsp),%xmm0\npaddd  %xmm1,%xmm0\nmovdqa %xmm0,0x40(%rsp)\nmovdqa 0x40(%rsp),%xmm1\nadd    $0x20,%rbp\ncmp    %rbp,%r12\njne    1160 <func0+0x50>\npaddd  %xmm2,%xmm1\npshufd $0xee,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\npshufd $0x55,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%ebp\ncmp    %r14,%rbx\nje     12dd <func0+0x1cd>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovss  (%r15,%rbx,4),%xmm0\ncall   1030 <ceilf@plt>\ncvttss2si %xmm0,%eax\nimul   %eax,%eax\nadd    %eax,%ebp\nadd    $0x1,%rbx\ncmp    %rbx,%r14\njne    12c0 <func0+0x1b0>\nmov    %ebp,%eax\nadd    $0x60,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 134,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    114e <func0+0x2e>\nmovl   $0x0,-0x4(%rbp)\njmp    11eb <func0+0xcb>\nmov    -0x10(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x15(%rbp)\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmovzbl -0x15(%rbp),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x400,%eax\ncmp    $0x0,%eax\njne    118e <func0+0x6e>\nmovl   $0x0,-0x4(%rbp)\njmp    11eb <func0+0xcb>\ncmpl   $0x1,-0x14(%rbp)\njne    11a4 <func0+0x84>\nmovl   $0x1,-0x4(%rbp)\njmp    11eb <func0+0xcb>\nmov    -0x10(%rbp),%rax\nmov    -0x14(%rbp),%ecx\nsub    $0x2,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x16(%rbp)\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmovzbl -0x16(%rbp),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x400,%eax\ncmp    $0x0,%eax\nje     11e4 <func0+0xc4>\nmovl   $0x0,-0x4(%rbp)\njmp    11eb <func0+0xcb>\nmovl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 134,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%rbx\nxor    %r15d,%r15d\ntest   %ebx,%ebx\nje     1193 <func0+0x73>\nmov    %ebx,%ebp\nshl    $0x20,%rbx\nmovabs $0xffffffff00000000,%rax\nff ff ff\nadd    %rbx,%rax\nsar    $0x20,%rax\nmovzbl (%r14,%rax,1),%r12d\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%r12,2)\nje     1193 <func0+0x73>\nmov    $0x1,%r15d\ncmp    $0x1,%ebp\nje     1193 <func0+0x73>\nmovabs $0xfffffffe00000000,%rcx\nff ff ff\nadd    %rcx,%rbx\nsar    $0x20,%rbx\nmovzbl (%r14,%rbx,1),%ecx\nxor    %r15d,%r15d\ntestb  $0x4,0x1(%rax,%rcx,2)\nsete   %r15b\nmov    %r15d,%eax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 134,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%rbx\nxor    %r15d,%r15d\ntest   %ebx,%ebx\nje     1193 <func0+0x73>\nmov    %ebx,%ebp\nshl    $0x20,%rbx\nmovabs $0xffffffff00000000,%rax\nff ff ff\nadd    %rbx,%rax\nsar    $0x20,%rax\nmovzbl (%r14,%rax,1),%r12d\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%r12,2)\nje     1193 <func0+0x73>\nmov    $0x1,%r15d\ncmp    $0x1,%ebp\nje     1193 <func0+0x73>\nmovabs $0xfffffffe00000000,%rcx\nff ff ff\nadd    %rcx,%rbx\nsar    $0x20,%rbx\nmovzbl (%r14,%rbx,1),%ecx\nxor    %r15d,%r15d\ntestb  $0x4,0x1(%rax,%rcx,2)\nsete   %r15b\nmov    %r15d,%eax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 134,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%rbx\nxor    %r15d,%r15d\ntest   %ebx,%ebx\nje     1193 <func0+0x73>\nmov    %ebx,%ebp\nshl    $0x20,%rbx\nmovabs $0xffffffff00000000,%rax\nff ff ff\nadd    %rbx,%rax\nsar    $0x20,%rax\nmovzbl (%r14,%rax,1),%r12d\ncall   1040 <__ctype_b_loc@plt>\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%r12,2)\nje     1193 <func0+0x73>\nmov    $0x1,%r15d\ncmp    $0x1,%ebp\nje     1193 <func0+0x73>\nmovabs $0xfffffffe00000000,%rcx\nff ff ff\nadd    %rcx,%rbx\nsar    $0x20,%rbx\nmovzbl (%r14,%rbx,1),%ecx\nxor    %r15d,%r15d\ntestb  $0x4,0x1(%rax,%rcx,2)\nsete   %r15b\nmov    %r15d,%eax\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 135,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0xffffffff,-0x10(%rbp)\nmovl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    115f <func0+0x5f>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmov    -0x14(%rbp),%edx\nsub    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\njge    114c <func0+0x4c>\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    1151 <func0+0x51>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1119 <func0+0x19>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 135,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    $0xffffffff,%eax\ncmp    $0x2,%esi\njl     1133 <func0+0x33>\nmov    %esi,%ecx\nmov    $0xffffffff,%eax\nmov    $0x1,%edx\ncs nopw 0x0(%rax,%rax,1)\nmov    (%rdi,%rdx,4),%esi\ncmp    -0x4(%rdi,%rdx,4),%esi\ncmovl  %edx,%eax\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    1120 <func0+0x20>\nret\n"
    },
    {
        "task_id": 135,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nmov    $0xffffffff,%eax\ncmp    $0x2,%esi\njl     11b4 <func0+0xb4>\nmov    %esi,%eax\nmov    (%rdi),%esi\nlea    -0x1(%rax),%r8\nadd    $0xfffffffffffffffe,%rax\nmov    %r8d,%r9d\nand    $0x3,%r9d\ncmp    $0x3,%rax\njae    1134 <func0+0x34>\nmov    $0xffffffff,%eax\nmov    $0x1,%edx\njmp    1190 <func0+0x90>\nand    $0xfffffffffffffffc,%r8\nmov    $0xffffffff,%eax\nmov    $0x1,%edx\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    (%rdi,%rdx,4),%r10d\nmov    0x4(%rdi,%rdx,4),%r11d\ncmp    %esi,%r10d\ncmovl  %edx,%eax\nlea    0x1(%rdx),%esi\ncmp    %r10d,%r11d\ncmovge %eax,%esi\nlea    0x2(%rdx),%ecx\nmov    0x8(%rdi,%rdx,4),%r10d\ncmp    %r11d,%r10d\ncmovge %esi,%ecx\nlea    0x3(%rdx),%eax\nmov    0xc(%rdi,%rdx,4),%esi\ncmp    %r10d,%esi\ncmovge %ecx,%eax\nadd    $0x4,%rdx\nadd    $0x4,%rbx\ncmp    %r8,%rbx\njne    1150 <func0+0x50>\ntest   %r9,%r9\nje     11b4 <func0+0xb4>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    (%rdi,%rdx,4),%ecx\ncmp    %esi,%ecx\ncmovl  %edx,%eax\nadd    $0x1,%rdx\nmov    %ecx,%esi\nadd    $0xffffffffffffffff,%r9\njne    11a0 <func0+0xa0>\npop    %rbx\nret\n"
    },
    {
        "task_id": 135,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\nmov    $0xffffffff,%eax\ncmp    $0x2,%esi\njl     11b4 <func0+0xb4>\nmov    %esi,%eax\nmov    (%rdi),%esi\nlea    -0x1(%rax),%r8\nadd    $0xfffffffffffffffe,%rax\nmov    %r8d,%r9d\nand    $0x3,%r9d\ncmp    $0x3,%rax\njae    1134 <func0+0x34>\nmov    $0xffffffff,%eax\nmov    $0x1,%edx\njmp    1190 <func0+0x90>\nand    $0xfffffffffffffffc,%r8\nmov    $0xffffffff,%eax\nmov    $0x1,%edx\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    (%rdi,%rdx,4),%r10d\nmov    0x4(%rdi,%rdx,4),%r11d\ncmp    %esi,%r10d\ncmovl  %edx,%eax\nlea    0x1(%rdx),%esi\ncmp    %r10d,%r11d\ncmovge %eax,%esi\nlea    0x2(%rdx),%ecx\nmov    0x8(%rdi,%rdx,4),%r10d\ncmp    %r11d,%r10d\ncmovge %esi,%ecx\nlea    0x3(%rdx),%eax\nmov    0xc(%rdi,%rdx,4),%esi\ncmp    %r10d,%esi\ncmovge %ecx,%eax\nadd    $0x4,%rdx\nadd    $0x4,%rbx\ncmp    %r8,%rbx\njne    1150 <func0+0x50>\ntest   %r9,%r9\nje     11b4 <func0+0xb4>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    (%rdi,%rdx,4),%ecx\ncmp    %esi,%ecx\ncmovl  %edx,%eax\nadd    $0x1,%rdx\nmov    %ecx,%esi\nadd    $0xffffffffffffffff,%r9\njne    11a0 <func0+0xa0>\npop    %rbx\nret\n"
    },
    {
        "task_id": 136,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11bf <func0+0xbf>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\ncmpl   $0x0,(%rax,%rcx,4)\njge    116e <func0+0x6e>\ncmpl   $0x0,-0x1c(%rbp)\nje     1160 <func0+0x60>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x1c(%rbp),%eax\njle    116e <func0+0x6e>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\ncmpl   $0x0,(%rax,%rcx,4)\njle    11ac <func0+0xac>\ncmpl   $0x0,-0x20(%rbp)\nje     119e <func0+0x9e>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\ncmp    -0x20(%rbp),%eax\njge    11ac <func0+0xac>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x20(%rbp)\njmp    11b1 <func0+0xb1>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    1124 <func0+0x24>\nmov    -0x1c(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x20(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,0x4(%rax)\npop    %rbp\nret\n"
    },
    {
        "task_id": 136,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1157 <func0+0x57>\nmov    %esi,%r8d\nxor    %r11d,%r11d\nxor    %r9d,%r9d\nxor    %r10d,%r10d\nmov    %r10d,%eax\nmov    %r9d,%esi\ncs nopw 0x0(%rax,%rax,1)\nmov    (%rdi,%r11,4),%ecx\ncmp    %r10d,%ecx\ncmovg  %ecx,%eax\ntest   %r10d,%r10d\ncmove  %ecx,%eax\ncmp    %r9d,%ecx\ncmovl  %ecx,%esi\ntest   %r9d,%r9d\ncmove  %ecx,%esi\ntest   %ecx,%ecx\ncmovns %r10d,%eax\ncmovle %r9d,%esi\nadd    $0x1,%r11\nmov    %esi,%r9d\nmov    %eax,%r10d\ncmp    %r11,%r8\njne    1120 <func0+0x20>\njmp    115b <func0+0x5b>\nxor    %eax,%eax\nxor    %esi,%esi\nmov    %eax,(%rdx)\nmov    %esi,0x4(%rdx)\nret\n"
    },
    {
        "task_id": 136,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1158 <func0+0x58>\nmov    %esi,%r8d\nxor    %esi,%esi\nxor    %r10d,%r10d\nxor    %r9d,%r9d\njmp    113b <func0+0x3b>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\ncmp    %r9d,%ecx\nmov    %r9d,%eax\ncmovg  %ecx,%eax\ntest   %r9d,%r9d\ncmove  %ecx,%eax\nmov    %eax,%r9d\nadd    $0x1,%rsi\ncmp    %rsi,%r8\nje     115e <func0+0x5e>\nmov    (%rdi,%rsi,4),%ecx\ntest   %ecx,%ecx\njs     1120 <func0+0x20>\nje     1132 <func0+0x32>\ncmp    %r10d,%ecx\nmov    %r10d,%eax\ncmovl  %ecx,%eax\ntest   %r10d,%r10d\ncmove  %ecx,%eax\nmov    %eax,%r10d\njmp    1132 <func0+0x32>\nxor    %r9d,%r9d\nxor    %r10d,%r10d\nmov    %r9d,(%rdx)\nmov    %r10d,0x4(%rdx)\nret\n"
    },
    {
        "task_id": 136,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1158 <func0+0x58>\nmov    %esi,%r8d\nxor    %esi,%esi\nxor    %r10d,%r10d\nxor    %r9d,%r9d\njmp    113b <func0+0x3b>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\ncmp    %r9d,%ecx\nmov    %r9d,%eax\ncmovg  %ecx,%eax\ntest   %r9d,%r9d\ncmove  %ecx,%eax\nmov    %eax,%r9d\nadd    $0x1,%rsi\ncmp    %rsi,%r8\nje     115e <func0+0x5e>\nmov    (%rdi,%rsi,4),%ecx\ntest   %ecx,%ecx\njs     1120 <func0+0x20>\nje     1132 <func0+0x32>\ncmp    %r10d,%ecx\nmov    %r10d,%eax\ncmovl  %ecx,%eax\ntest   %r10d,%r10d\ncmove  %ecx,%eax\nmov    %eax,%r10d\njmp    1132 <func0+0x32>\nxor    %r9d,%r9d\nxor    %r10d,%r10d\nmov    %r9d,(%rdx)\nmov    %r10d,0x4(%rdx)\nret\n"
    },
    {
        "task_id": 137,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1050 <strdup@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x18(%rbp),%rdi\ncall   1050 <strdup@plt>\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmov    -0x28(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\ncmpb   $0x0,(%rax,%rcx,1)\nje     11a7 <func0+0x77>\nmov    -0x28(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x2c,%eax\njne    1194 <func0+0x64>\nmov    -0x28(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmovb   $0x2e,(%rax,%rcx,1)\njmp    1199 <func0+0x69>\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    1161 <func0+0x31>\nmovl   $0x0,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\ncmpb   $0x0,(%rax,%rcx,1)\nje     11f4 <func0+0xc4>\nmov    -0x30(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x2c,%eax\njne    11e1 <func0+0xb1>\nmov    -0x30(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmovb   $0x2e,(%rax,%rcx,1)\njmp    11e6 <func0+0xb6>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    11ae <func0+0x7e>\nmov    -0x28(%rbp),%rdi\nlea    -0x20(%rbp),%rsi\ncall   1040 <strtod@plt>\nmovsd  %xmm0,-0x40(%rbp)\nmov    -0x20(%rbp),%rax\ncmpb   $0x0,(%rax)\nje     1235 <func0+0x105>\nmov    -0x28(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x30(%rbp),%rdi\ncall   1030 <free@plt>\nlea    0xdd4(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    12db <func0+0x1ab>\nmov    -0x30(%rbp),%rdi\nlea    -0x20(%rbp),%rsi\ncall   1040 <strtod@plt>\nmovsd  %xmm0,-0x48(%rbp)\nmov    -0x20(%rbp),%rax\ncmpb   $0x0,(%rax)\nje     1276 <func0+0x146>\nmov    -0x28(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x30(%rbp),%rdi\ncall   1030 <free@plt>\nlea    0xd93(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    12db <func0+0x1ab>\nmov    -0x28(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x30(%rbp),%rdi\ncall   1030 <free@plt>\nmovsd  -0x40(%rbp),%xmm0\nucomisd -0x48(%rbp),%xmm0\njne    12ae <func0+0x17e>\njp     12ae <func0+0x17e>\nlea    0xd69(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    12db <func0+0x1ab>\nmovsd  -0x40(%rbp),%xmm0\nucomisd -0x48(%rbp),%xmm0\njbe    12cb <func0+0x19b>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x50(%rbp)\njmp    12d3 <func0+0x1a3>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x50(%rbp)\nmov    -0x50(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x50,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 137,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x20,%rsp\nmov    %rsi,%r15\nmov    %rdi,%r14\ncall   1050 <strdup@plt>\nmov    %rax,%rbx\nmov    %r15,%rdi\ncall   1050 <strdup@plt>\nmov    %rax,%r12\nmov    %rbx,%rax\njmp    1167 <func0+0x37>\nnopw   0x0(%rax,%rax,1)\nmovb   $0x2e,(%rax)\nadd    $0x1,%rax\nmovzbl (%rax),%ecx\ncmp    $0x2c,%cl\nje     1160 <func0+0x30>\ntest   %cl,%cl\njne    1163 <func0+0x33>\nmov    %r12,%rax\njmp    1187 <func0+0x57>\nnopl   0x0(%rax,%rax,1)\nmovb   $0x2e,(%rax)\nadd    $0x1,%rax\nmovzbl (%rax),%ecx\ncmp    $0x2c,%cl\nje     1180 <func0+0x50>\ntest   %cl,%cl\njne    1183 <func0+0x53>\nlea    0x8(%rsp),%rsi\nmov    %rbx,%rdi\ncall   1040 <strtod@plt>\nmov    0x8(%rsp),%rax\ncmpb   $0x0,(%rax)\nje     11c3 <func0+0x93>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %r12,%rdi\ncall   1030 <free@plt>\nlea    0xe3f(%rip),%r15\njmp    121f <func0+0xef>\nmovsd  %xmm0,0x18(%rsp)\nlea    0x8(%rsp),%rsi\nmov    %r12,%rdi\ncall   1040 <strtod@plt>\nmovsd  %xmm0,0x10(%rsp)\nmov    0x8(%rsp),%rax\nmov    (%rax),%bpl\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %r12,%rdi\ncall   1030 <free@plt>\ntest   %bpl,%bpl\nje     1202 <func0+0xd2>\nlea    0xe00(%rip),%r15\njmp    121f <func0+0xef>\nmovsd  0x18(%rsp),%xmm0\nucomisd 0x10(%rsp),%xmm0\njne    121b <func0+0xeb>\njp     121b <func0+0xeb>\nlea    0xdf5(%rip),%r15\njmp    121f <func0+0xef>\ncmova  %r14,%r15\nmov    %r15,%rax\nadd    $0x20,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 137,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x20,%rsp\nmov    %rsi,%r15\nmov    %rdi,%r14\ncall   1050 <strdup@plt>\nmov    %rax,%rbx\nmov    %r15,%rdi\ncall   1050 <strdup@plt>\nmov    %rax,%r12\nmov    %rbx,%rax\njmp    1167 <func0+0x37>\nnopw   0x0(%rax,%rax,1)\nmovb   $0x2e,(%rax)\nadd    $0x1,%rax\nmovzbl (%rax),%ecx\ncmp    $0x2c,%cl\nje     1160 <func0+0x30>\ntest   %cl,%cl\njne    1163 <func0+0x33>\nmov    %r12,%rax\njmp    1187 <func0+0x57>\nnopl   0x0(%rax,%rax,1)\nmovb   $0x2e,(%rax)\nadd    $0x1,%rax\nmovzbl (%rax),%ecx\ncmp    $0x2c,%cl\nje     1180 <func0+0x50>\ntest   %cl,%cl\njne    1183 <func0+0x53>\nlea    0x8(%rsp),%rsi\nmov    %rbx,%rdi\ncall   1040 <strtod@plt>\nmov    0x8(%rsp),%rax\ncmpb   $0x0,(%rax)\nje     11c3 <func0+0x93>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %r12,%rdi\ncall   1030 <free@plt>\nlea    0xe3f(%rip),%r15\njmp    121f <func0+0xef>\nmovsd  %xmm0,0x18(%rsp)\nlea    0x8(%rsp),%rsi\nmov    %r12,%rdi\ncall   1040 <strtod@plt>\nmovsd  %xmm0,0x10(%rsp)\nmov    0x8(%rsp),%rax\nmov    (%rax),%bpl\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %r12,%rdi\ncall   1030 <free@plt>\ntest   %bpl,%bpl\nje     1202 <func0+0xd2>\nlea    0xe00(%rip),%r15\njmp    121f <func0+0xef>\nmovsd  0x18(%rsp),%xmm0\nucomisd 0x10(%rsp),%xmm0\njne    121b <func0+0xeb>\njp     121b <func0+0xeb>\nlea    0xdf5(%rip),%r15\njmp    121f <func0+0xef>\ncmova  %r14,%r15\nmov    %r15,%rax\nadd    $0x20,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 137,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x20,%rsp\nmov    %rsi,%r15\nmov    %rdi,%r14\ncall   1050 <strdup@plt>\nmov    %rax,%rbx\nmov    %r15,%rdi\ncall   1050 <strdup@plt>\nmov    %rax,%r12\nmov    %rbx,%rax\njmp    1167 <func0+0x37>\nnopw   0x0(%rax,%rax,1)\nmovb   $0x2e,(%rax)\nadd    $0x1,%rax\nmovzbl (%rax),%ecx\ncmp    $0x2c,%cl\nje     1160 <func0+0x30>\ntest   %cl,%cl\njne    1163 <func0+0x33>\nmov    %r12,%rax\njmp    1187 <func0+0x57>\nnopl   0x0(%rax,%rax,1)\nmovb   $0x2e,(%rax)\nadd    $0x1,%rax\nmovzbl (%rax),%ecx\ncmp    $0x2c,%cl\nje     1180 <func0+0x50>\ntest   %cl,%cl\njne    1183 <func0+0x53>\nlea    0x8(%rsp),%rsi\nmov    %rbx,%rdi\ncall   1040 <strtod@plt>\nmov    0x8(%rsp),%rax\ncmpb   $0x0,(%rax)\nje     11c3 <func0+0x93>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %r12,%rdi\ncall   1030 <free@plt>\nlea    0xe3f(%rip),%r15\njmp    121f <func0+0xef>\nmovsd  %xmm0,0x18(%rsp)\nlea    0x8(%rsp),%rsi\nmov    %r12,%rdi\ncall   1040 <strtod@plt>\nmovsd  %xmm0,0x10(%rsp)\nmov    0x8(%rsp),%rax\nmov    (%rax),%bpl\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %r12,%rdi\ncall   1030 <free@plt>\ntest   %bpl,%bpl\nje     1202 <func0+0xd2>\nlea    0xe00(%rip),%r15\njmp    121f <func0+0xef>\nmovsd  0x18(%rsp),%xmm0\nucomisd 0x10(%rsp),%xmm0\njne    121b <func0+0xeb>\njp     121b <func0+0xeb>\nlea    0xdf5(%rip),%r15\njmp    121f <func0+0xef>\ncmova  %r14,%r15\nmov    %r15,%rax\nadd    $0x20,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 138,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    1131 <func0+0x31>\ncmpl   $0x8,-0x8(%rbp)\njl     1131 <func0+0x31>\nmovl   $0x1,-0x4(%rbp)\njmp    1138 <func0+0x38>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 138,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   $0x1,%dil\nsete   %al\ncmp    $0x8,%edi\nsetge  %cl\nand    %al,%cl\nmovzbl %cl,%eax\nret\n"
    },
    {
        "task_id": 138,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   $0x1,%dil\nsete   %al\ncmp    $0x8,%edi\nsetge  %cl\nand    %al,%cl\nmovzbl %cl,%eax\nret\n"
    },
    {
        "task_id": 138,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   $0x1,%dil\nsete   %al\ncmp    $0x8,%edi\nsetge  %cl\nand    %al,%cl\nmovzbl %cl,%eax\nret\n"
    },
    {
        "task_id": 139,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmovq   $0x1,-0x10(%rbp)\nmovq   $0x1,-0x18(%rbp)\nmovl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     1155 <func0+0x55>\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nimul   %rcx,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nimul   -0x10(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    111e <func0+0x1e>\nmov    -0x18(%rbp),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 139,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1132 <func0+0x32>\nadd    $0x1,%edi\nmov    $0x1,%ecx\nmov    $0x1,%eax\nmov    $0x1,%edx\ncs nopw 0x0(%rax,%rax,1)\nimul   %rcx,%rdx\nimul   %rdx,%rax\nadd    $0x1,%rcx\ncmp    %rcx,%rdi\njne    1120 <func0+0x20>\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 139,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1135 <func0+0x35>\nmov    %edi,%r8d\nlea    -0x1(%r8),%rax\nmov    %r8d,%r9d\nand    $0x7,%r9d\ncmp    $0x7,%rax\njae    113b <func0+0x3b>\nmov    $0x1,%edx\nmov    $0x1,%eax\nmov    $0x1,%edi\ntest   %r9,%r9\njne    11e0 <func0+0xe0>\njmp    11f2 <func0+0xf2>\nmov    $0x1,%eax\nret\nand    $0xfffffff8,%r8d\nneg    %r8\nmov    $0x1,%eax\nmov    $0x8,%edx\nmov    $0x1,%edi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nlea    -0x7(%rdx),%rsi\nimul   %rdi,%rsi\nimul   %rsi,%rax\nlea    -0x6(%rdx),%rdi\nimul   %rsi,%rdi\nimul   %rdi,%rax\nlea    -0x5(%rdx),%rsi\nimul   %rdi,%rsi\nimul   %rsi,%rax\nlea    -0x4(%rdx),%rdi\nimul   %rsi,%rdi\nimul   %rdi,%rax\nlea    -0x3(%rdx),%rsi\nimul   %rdi,%rsi\nimul   %rsi,%rax\nlea    -0x2(%rdx),%rcx\nimul   %rsi,%rcx\nimul   %rcx,%rax\nlea    -0x1(%rdx),%rdi\nimul   %rcx,%rdi\nimul   %rdi,%rax\nimul   %rdx,%rdi\nimul   %rdi,%rax\nlea    (%r8,%rdx,1),%rcx\nadd    $0x8,%rcx\nadd    $0x8,%rdx\ncmp    $0x8,%rcx\njne    1160 <func0+0x60>\nadd    $0xfffffffffffffff9,%rdx\ntest   %r9,%r9\nje     11f2 <func0+0xf2>\nnopw   0x0(%rax,%rax,1)\nimul   %rdx,%rdi\nimul   %rdi,%rax\nadd    $0x1,%rdx\nadd    $0xffffffffffffffff,%r9\njne    11e0 <func0+0xe0>\nret\n"
    },
    {
        "task_id": 139,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %edi,%edi\njle    1135 <func0+0x35>\nmov    %edi,%r8d\nlea    -0x1(%r8),%rax\nmov    %r8d,%r9d\nand    $0x7,%r9d\ncmp    $0x7,%rax\njae    113b <func0+0x3b>\nmov    $0x1,%edx\nmov    $0x1,%eax\nmov    $0x1,%edi\ntest   %r9,%r9\njne    11e0 <func0+0xe0>\njmp    11f2 <func0+0xf2>\nmov    $0x1,%eax\nret\nand    $0xfffffff8,%r8d\nneg    %r8\nmov    $0x1,%eax\nmov    $0x8,%edx\nmov    $0x1,%edi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nlea    -0x7(%rdx),%rsi\nimul   %rdi,%rsi\nimul   %rsi,%rax\nlea    -0x6(%rdx),%rdi\nimul   %rsi,%rdi\nimul   %rdi,%rax\nlea    -0x5(%rdx),%rsi\nimul   %rdi,%rsi\nimul   %rsi,%rax\nlea    -0x4(%rdx),%rdi\nimul   %rsi,%rdi\nimul   %rdi,%rax\nlea    -0x3(%rdx),%rsi\nimul   %rdi,%rsi\nimul   %rsi,%rax\nlea    -0x2(%rdx),%rcx\nimul   %rsi,%rcx\nimul   %rcx,%rax\nlea    -0x1(%rdx),%rdi\nimul   %rcx,%rdi\nimul   %rdi,%rax\nimul   %rdx,%rdi\nimul   %rdi,%rax\nlea    (%r8,%rdx,1),%rcx\nadd    $0x8,%rcx\nadd    $0x8,%rdx\ncmp    $0x8,%rcx\njne    1160 <func0+0x60>\nadd    $0xfffffffffffffff9,%rdx\ntest   %r9,%r9\nje     11f2 <func0+0xf2>\nnopw   0x0(%rax,%rax,1)\nimul   %rdx,%rdi\nimul   %rdi,%rax\nadd    $0x1,%rdx\nadd    $0xffffffffffffffff,%r9\njne    11e0 <func0+0xe0>\nret\n"
    },
    {
        "task_id": 140,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovslq -0x1c(%rbp),%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\ncmp    %rcx,%rax\njae    1229 <func0+0x119>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x20,%eax\njne    1179 <func0+0x69>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1216 <func0+0x106>\ncmpl   $0x1,-0x14(%rbp)\njne    1199 <func0+0x89>\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x18(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x5f,(%rax,%rcx,1)\ncmpl   $0x2,-0x14(%rbp)\njne    11cf <func0+0xbf>\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x18(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x5f,(%rax,%rcx,1)\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x18(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x5f,(%rax,%rcx,1)\ncmpl   $0x2,-0x14(%rbp)\njle    11ef <func0+0xdf>\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x18(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x2d,(%rax,%rcx,1)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,1),%dl\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    %ecx,%esi\nadd    $0x1,%esi\nmov    %esi,-0x18(%rbp)\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\njmp    121b <func0+0x10b>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1135 <func0+0x25>\ncmpl   $0x1,-0x14(%rbp)\njne    1249 <func0+0x139>\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x18(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x5f,(%rax,%rcx,1)\ncmpl   $0x2,-0x14(%rbp)\njne    127f <func0+0x16f>\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x18(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x5f,(%rax,%rcx,1)\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x18(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x5f,(%rax,%rcx,1)\ncmpl   $0x2,-0x14(%rbp)\njle    129f <func0+0x18f>\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x18(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x2d,(%rax,%rcx,1)\nmov    -0x10(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 140,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rsi,%r14\ncmpb   $0x0,(%rdi)\nje     11b4 <func0+0xa4>\nmov    %rdi,%r15\nxor    %ebp,%ebp\nxor    %ebx,%ebx\nxor    %r12d,%r12d\njmp    1153 <func0+0x43>\nmovzbl (%r15,%rbp,1),%eax\nmovslq %ebx,%rcx\nadd    $0x1,%ebx\nmov    %al,(%r14,%rcx,1)\nxor    %r12d,%r12d\nadd    $0x1,%rbp\nmov    %r15,%rdi\ncall   1030 <strlen@plt>\ncmp    %rbp,%rax\njbe    11b9 <func0+0xa9>\ncmpb   $0x20,(%r15,%rbp,1)\njne    1160 <func0+0x50>\nadd    $0x1,%r12d\njmp    1142 <func0+0x32>\ncmp    $0x1,%r12d\nje     1180 <func0+0x70>\ncmp    $0x2,%r12d\nje     1191 <func0+0x81>\ncmp    $0x3,%r12d\njl     1130 <func0+0x20>\njmp    11a4 <func0+0x94>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmovslq %ebx,%rax\nadd    $0x1,%ebx\nmovb   $0x5f,(%r14,%rax,1)\ncmp    $0x2,%r12d\njne    116c <func0+0x5c>\nmovslq %ebx,%rbx\nmovw   $0x5f5f,(%r14,%rbx,1)\nadd    $0x2,%ebx\ncmp    $0x3,%r12d\njl     1130 <func0+0x20>\nmovslq %ebx,%rax\nadd    $0x1,%ebx\nmovb   $0x2d,(%r14,%rax,1)\njmp    1130 <func0+0x20>\nxor    %r12d,%r12d\nxor    %ebx,%ebx\ncmp    $0x1,%r12d\nje     11e7 <func0+0xd7>\ncmp    $0x2,%r12d\nje     11f8 <func0+0xe8>\ncmp    $0x3,%r12d\njl     11d6 <func0+0xc6>\nmovslq %ebx,%rax\nadd    $0x1,%ebx\nmovb   $0x2d,(%r14,%rax,1)\nmovslq %ebx,%rax\nmovb   $0x0,(%r14,%rax,1)\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\nmovslq %ebx,%rax\nadd    $0x1,%ebx\nmovb   $0x5f,(%r14,%rax,1)\ncmp    $0x2,%r12d\njne    11c5 <func0+0xb5>\nmovslq %ebx,%rbx\nmovw   $0x5f5f,(%r14,%rbx,1)\nadd    $0x2,%ebx\ncmp    $0x3,%r12d\njge    11cb <func0+0xbb>\njmp    11d6 <func0+0xc6>\n"
    },
    {
        "task_id": 140,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rsi,%r14\nmov    (%rdi),%al\ntest   %al,%al\nje     11d2 <func0+0xc2>\nmov    %rdi,%r12\nxor    %r15d,%r15d\nmov    $0x1,%ebx\nxor    %ebp,%ebp\ncmp    $0x20,%al\njne    1150 <func0+0x40>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%ebp\njmp    1198 <func0+0x88>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    $0x5f,%al\ncmp    $0x1,%ebp\nje     1179 <func0+0x69>\ncmp    $0x2,%ebp\njne    1170 <func0+0x60>\nlea    0x1(%r15),%ecx\nmovslq %r15d,%rdx\nmovb   $0x5f,(%r14,%rdx,1)\nmov    $0x2,%ebp\njmp    117c <func0+0x6c>\nnop\njle    1186 <func0+0x76>\nmov    $0x2d,%al\nmov    $0x1,%ebp\nmov    %r15d,%ecx\nadd    %ebp,%r15d\nmovslq %ecx,%rcx\nmov    %al,(%r14,%rcx,1)\nmov    -0x1(%r12,%rbx,1),%al\nmovslq %r15d,%rcx\nadd    $0x1,%r15d\nmov    %al,(%r14,%rcx,1)\nxor    %ebp,%ebp\nmov    %r12,%rdi\ncall   1030 <strlen@plt>\ncmp    %rbx,%rax\njbe    11b3 <func0+0xa3>\nmov    (%r12,%rbx,1),%al\nadd    $0x1,%rbx\ncmp    $0x20,%al\njne    1150 <func0+0x40>\njmp    1140 <func0+0x30>\nmov    $0x5f,%al\ncmp    $0x1,%ebp\nje     11e0 <func0+0xd0>\ncmp    $0x2,%ebp\njne    11d7 <func0+0xc7>\nlea    0x1(%r15),%ecx\nmovslq %r15d,%rdx\nmovb   $0x5f,(%r14,%rdx,1)\nmov    $0x2,%ebp\njmp    11e3 <func0+0xd3>\nxor    %r15d,%r15d\njmp    11ed <func0+0xdd>\njle    11ed <func0+0xdd>\nmov    $0x2d,%al\nmov    $0x1,%ebp\nmov    %r15d,%ecx\nadd    %ebp,%r15d\nmovslq %ecx,%rcx\nmov    %al,(%r14,%rcx,1)\nmovslq %r15d,%rax\nmovb   $0x0,(%r14,%rax,1)\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 140,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nmov    %rsi,%r14\nmov    (%rdi),%al\ntest   %al,%al\nje     11e5 <func0+0xd5>\nmov    %rdi,%r12\nxor    %r15d,%r15d\nmov    $0x1,%ebx\nxor    %ebp,%ebp\ncmp    $0x20,%al\njne    1160 <func0+0x50>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%ebp\nmov    %r12,%rdi\ncall   1030 <strlen@plt>\ncmp    %rbx,%rax\nja     11b5 <func0+0xa5>\njmp    11c6 <func0+0xb6>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    $0x5f,%al\ncmp    $0x1,%ebp\nje     1189 <func0+0x79>\ncmp    $0x2,%ebp\njne    1180 <func0+0x70>\nlea    0x1(%r15),%ecx\nmovslq %r15d,%rdx\nmovb   $0x5f,(%r14,%rdx,1)\nmov    $0x2,%ebp\njmp    118c <func0+0x7c>\nnop\njle    1196 <func0+0x86>\nmov    $0x2d,%al\nmov    $0x1,%ebp\nmov    %r15d,%ecx\nadd    %ebp,%r15d\nmovslq %ecx,%rcx\nmov    %al,(%r14,%rcx,1)\nmov    -0x1(%r12,%rbx,1),%al\nmovslq %r15d,%rcx\nadd    $0x1,%r15d\nmov    %al,(%r14,%rcx,1)\nxor    %ebp,%ebp\nmov    %r12,%rdi\ncall   1030 <strlen@plt>\ncmp    %rbx,%rax\njbe    11c6 <func0+0xb6>\nmov    (%r12,%rbx,1),%al\nadd    $0x1,%rbx\ncmp    $0x20,%al\njne    1160 <func0+0x50>\njmp    1140 <func0+0x30>\nmov    $0x5f,%al\ncmp    $0x1,%ebp\nje     11f3 <func0+0xe3>\ncmp    $0x2,%ebp\njne    11ea <func0+0xda>\nlea    0x1(%r15),%ecx\nmovslq %r15d,%rdx\nmovb   $0x5f,(%r14,%rdx,1)\nmov    $0x2,%ebp\njmp    11f6 <func0+0xe6>\nxor    %r15d,%r15d\njmp    1200 <func0+0xf0>\njle    1200 <func0+0xf0>\nmov    $0x2d,%al\nmov    $0x1,%ebp\nmov    %r15d,%ecx\nadd    %ebp,%r15d\nmovslq %ecx,%rcx\nmov    %al,(%r14,%rcx,1)\nmovslq %r15d,%rax\nmovb   $0x0,(%r14,%rax,1)\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 141,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x5,-0x1c(%rbp)\njge    1160 <func0+0x40>\nlea    0xea9(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    12c1 <func0+0x1a1>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%al\nmov    %al,-0x1d(%rbp)\nmovsbl -0x1d(%rbp),%eax\ncmp    $0x41,%eax\njl     119d <func0+0x7d>\nmovsbl -0x1d(%rbp),%eax\ncmp    $0x5a,%eax\njle    1190 <func0+0x70>\nmovsbl -0x1d(%rbp),%eax\ncmp    $0x61,%eax\njl     119d <func0+0x7d>\nmovsbl -0x1d(%rbp),%eax\ncmp    $0x7a,%eax\njle    11ad <func0+0x8d>\nlea    0xe5c(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    12c1 <func0+0x1a1>\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nadd    %rcx,%rax\nadd    $0xfffffffffffffffc,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rdi\nlea    0xe38(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\nje     121b <func0+0xfb>\nmov    -0x28(%rbp),%rdi\nlea    0xe24(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\nje     121b <func0+0xfb>\nmov    -0x28(%rbp),%rdi\nlea    0xe10(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\nje     121b <func0+0xfb>\nlea    0xdee(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    12c1 <func0+0x1a1>\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njge    1292 <func0+0x172>\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x30,%eax\njl     1261 <func0+0x141>\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x39,%eax\njg     1261 <func0+0x141>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x2e,%eax\njne    127f <func0+0x15f>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1284 <func0+0x164>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1222 <func0+0x102>\ncmpl   $0x3,-0x14(%rbp)\njg     12a6 <func0+0x186>\ncmpl   $0x1,-0x18(%rbp)\nje     12b6 <func0+0x196>\nlea    0xd53(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    12c1 <func0+0x1a1>\nlea    0xd55(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 141,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdi,%r15\ncall   1030 <strlen@plt>\nmov    %rax,%rbx\nlea    0xec6(%rip),%r14\ncmp    $0x5,%ebx\njl     115f <func0+0x3f>\nmov    (%r15),%al\ncmp    $0x41,%al\njl     115f <func0+0x3f>\nadd    $0xa5,%al\ncmp    $0x24,%al\nja     116e <func0+0x4e>\nmovzbl %al,%eax\nmovabs $0x1f0000003f,%rcx\nbt     %rax,%rcx\njae    116e <func0+0x4e>\nmov    %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\nret\nmovslq %ebx,%rax\nlea    (%r15,%rax,1),%r12\nadd    $0xfffffffffffffffc,%r12\nlea    0xe83(%rip),%rsi\nmov    %r12,%rdi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     11b2 <func0+0x92>\nlea    0xe75(%rip),%rsi\nmov    %r12,%rdi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     11b2 <func0+0x92>\nlea    0xe67(%rip),%rsi\nmov    %r12,%rdi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njne    115f <func0+0x3f>\ntest   %ebx,%ebx\njle    115f <func0+0x3f>\nmov    %ebx,%ecx\nxor    %edx,%edx\nxor    %eax,%eax\nxor    %esi,%esi\nxchg   %ax,%ax\nmovzbl (%r15,%rdx,1),%edi\nlea    -0x30(%rdi),%ebx\ncmp    $0xa,%bl\nadc    $0x0,%eax\nxor    %ebx,%ebx\ncmp    $0x2e,%dil\nsete   %bl\nadd    %ebx,%esi\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    11c0 <func0+0xa0>\ncmp    $0x1,%esi\nlea    0xe14(%rip),%rcx\nlea    0xe1f(%rip),%r14\ncmovne %rcx,%r14\ncmp    $0x4,%eax\ncmovae %rcx,%r14\njmp    115f <func0+0x3f>\n"
    },
    {
        "task_id": 141,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%rbx\nlea    0xf05(%rip),%r15\ncmp    $0x5,%ebx\njl     1164 <func0+0x44>\nmov    (%r14),%r13b\ncmp    $0x41,%r13b\njl     1164 <func0+0x44>\nlea    -0x5b(%r13),%eax\ncmp    $0x24,%al\nja     1171 <func0+0x51>\nmovzbl %al,%eax\nmovabs $0x1f0000003f,%rcx\nbt     %rax,%rcx\njae    1171 <func0+0x51>\nmov    %r15,%rax\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovslq %ebx,%rax\nlea    (%r14,%rax,1),%r12\nadd    $0xfffffffffffffffc,%r12\nlea    0xec0(%rip),%rsi\nmov    %r12,%rdi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     11b5 <func0+0x95>\nlea    0xeb2(%rip),%rsi\nmov    %r12,%rdi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     11b5 <func0+0x95>\nlea    0xea4(%rip),%rsi\nmov    %r12,%rdi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njne    1164 <func0+0x44>\nmov    %ebx,%eax\nlea    -0x30(%r13),%ecx\nxor    %edi,%edi\ncmp    $0xa,%cl\nsetb   %dil\nxor    %ebx,%ebx\ncmp    $0x2e,%r13b\nsete   %bl\ncmp    $0x1,%rax\nje     132e <func0+0x20e>\nlea    -0x1(%rax),%rdx\nmov    $0x1,%ecx\ncmp    $0x8,%rdx\njb     130b <func0+0x1eb>\nmov    %rdx,%rsi\nand    $0xfffffffffffffff8,%rsi\nlea    0x1(%rsi),%rcx\nmovd   %ebx,%xmm13\nmovd   %edi,%xmm2\npxor   %xmm0,%xmm0\nxor    %edi,%edi\nmovdqa 0xdf3(%rip),%xmm8\nmovdqa 0xdfa(%rip),%xmm9\npcmpeqd %xmm10,%xmm10\nmovdqa 0xdfc(%rip),%xmm12\nmovdqa 0xe03(%rip),%xmm11\npxor   %xmm7,%xmm7\nmovd   0x1(%r14,%rdi,1),%xmm5\nmovd   0x5(%r14,%rdi,1),%xmm4\nmovdqa %xmm5,%xmm1\npaddb  %xmm8,%xmm1\nmovdqa %xmm4,%xmm6\npaddb  %xmm8,%xmm6\nmovdqa %xmm1,%xmm3\npmaxub %xmm9,%xmm3\npcmpeqb %xmm1,%xmm3\npxor   %xmm10,%xmm3\npunpcklbw %xmm3,%xmm3\npunpcklwd %xmm3,%xmm3\npand   %xmm12,%xmm3\npaddd  %xmm3,%xmm2\nmovdqa %xmm6,%xmm1\npmaxub %xmm9,%xmm1\npcmpeqb %xmm6,%xmm1\npxor   %xmm10,%xmm1\npunpcklbw %xmm1,%xmm1\npunpcklwd %xmm1,%xmm1\npand   %xmm12,%xmm1\npaddd  %xmm1,%xmm7\npcmpeqb %xmm11,%xmm5\npunpcklbw %xmm5,%xmm5\npunpcklwd %xmm5,%xmm5\npand   %xmm12,%xmm5\npaddd  %xmm5,%xmm13\npcmpeqb %xmm11,%xmm4\npunpcklbw %xmm4,%xmm4\npunpcklwd %xmm4,%xmm4\npand   %xmm12,%xmm4\npaddd  %xmm4,%xmm0\nadd    $0x8,%rdi\ncmp    %rdi,%rsi\njne    1231 <func0+0x111>\npaddd  %xmm2,%xmm7\npshufd $0xee,%xmm7,%xmm1\npaddd  %xmm7,%xmm1\npshufd $0x55,%xmm1,%xmm2\npaddd  %xmm1,%xmm2\nmovd   %xmm2,%edi\npaddd  %xmm13,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%ebx\ncmp    %rsi,%rdx\nje     132e <func0+0x20e>\nmovzbl (%r14,%rcx,1),%edx\nlea    -0x30(%rdx),%esi\ncmp    $0xa,%sil\nadc    $0x0,%edi\nxor    %esi,%esi\ncmp    $0x2e,%dl\nsete   %sil\nadd    %esi,%ebx\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    130b <func0+0x1eb>\ncmp    $0x1,%ebx\nlea    0xd08(%rip),%rax\nlea    0xd13(%rip),%r15\ncmovne %rax,%r15\ncmp    $0x4,%edi\ncmovae %rax,%r15\njmp    1164 <func0+0x44>\n"
    },
    {
        "task_id": 141,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nmov    %rdi,%r14\ncall   1030 <strlen@plt>\nmov    %rax,%rbx\nlea    0xf05(%rip),%r15\ncmp    $0x5,%ebx\njl     1164 <func0+0x44>\nmov    (%r14),%r13b\ncmp    $0x41,%r13b\njl     1164 <func0+0x44>\nlea    -0x5b(%r13),%eax\ncmp    $0x24,%al\nja     1171 <func0+0x51>\nmovzbl %al,%eax\nmovabs $0x1f0000003f,%rcx\nbt     %rax,%rcx\njae    1171 <func0+0x51>\nmov    %r15,%rax\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovslq %ebx,%rax\nlea    (%r14,%rax,1),%r12\nadd    $0xfffffffffffffffc,%r12\nlea    0xec0(%rip),%rsi\nmov    %r12,%rdi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     11b5 <func0+0x95>\nlea    0xeb2(%rip),%rsi\nmov    %r12,%rdi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     11b5 <func0+0x95>\nlea    0xea4(%rip),%rsi\nmov    %r12,%rdi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njne    1164 <func0+0x44>\nmov    %ebx,%eax\nlea    -0x30(%r13),%ecx\nxor    %edi,%edi\ncmp    $0xa,%cl\nsetb   %dil\nxor    %ebx,%ebx\ncmp    $0x2e,%r13b\nsete   %bl\ncmp    $0x1,%rax\nje     132e <func0+0x20e>\nlea    -0x1(%rax),%rdx\nmov    $0x1,%ecx\ncmp    $0x8,%rdx\njb     130b <func0+0x1eb>\nmov    %rdx,%rsi\nand    $0xfffffffffffffff8,%rsi\nlea    0x1(%rsi),%rcx\nmovd   %ebx,%xmm13\nmovd   %edi,%xmm2\npxor   %xmm0,%xmm0\nxor    %edi,%edi\nmovdqa 0xdf3(%rip),%xmm8\nmovdqa 0xdfa(%rip),%xmm9\npcmpeqd %xmm10,%xmm10\nmovdqa 0xdfc(%rip),%xmm12\nmovdqa 0xe03(%rip),%xmm11\npxor   %xmm7,%xmm7\nmovd   0x1(%r14,%rdi,1),%xmm5\nmovd   0x5(%r14,%rdi,1),%xmm4\nmovdqa %xmm5,%xmm1\npaddb  %xmm8,%xmm1\nmovdqa %xmm4,%xmm6\npaddb  %xmm8,%xmm6\nmovdqa %xmm1,%xmm3\npmaxub %xmm9,%xmm3\npcmpeqb %xmm1,%xmm3\npxor   %xmm10,%xmm3\npunpcklbw %xmm3,%xmm3\npunpcklwd %xmm3,%xmm3\npand   %xmm12,%xmm3\npaddd  %xmm3,%xmm2\nmovdqa %xmm6,%xmm1\npmaxub %xmm9,%xmm1\npcmpeqb %xmm6,%xmm1\npxor   %xmm10,%xmm1\npunpcklbw %xmm1,%xmm1\npunpcklwd %xmm1,%xmm1\npand   %xmm12,%xmm1\npaddd  %xmm1,%xmm7\npcmpeqb %xmm11,%xmm5\npunpcklbw %xmm5,%xmm5\npunpcklwd %xmm5,%xmm5\npand   %xmm12,%xmm5\npaddd  %xmm5,%xmm13\npcmpeqb %xmm11,%xmm4\npunpcklbw %xmm4,%xmm4\npunpcklwd %xmm4,%xmm4\npand   %xmm12,%xmm4\npaddd  %xmm4,%xmm0\nadd    $0x8,%rdi\ncmp    %rdi,%rsi\njne    1231 <func0+0x111>\npaddd  %xmm2,%xmm7\npshufd $0xee,%xmm7,%xmm1\npaddd  %xmm7,%xmm1\npshufd $0x55,%xmm1,%xmm2\npaddd  %xmm1,%xmm2\nmovd   %xmm2,%edi\npaddd  %xmm13,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%ebx\ncmp    %rsi,%rdx\nje     132e <func0+0x20e>\nmovzbl (%r14,%rcx,1),%edx\nlea    -0x30(%rdx),%esi\ncmp    $0xa,%sil\nadc    $0x0,%edi\nxor    %esi,%esi\ncmp    $0x2e,%dl\nsete   %sil\nadd    %esi,%ebx\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    130b <func0+0x1eb>\ncmp    $0x1,%ebx\nlea    0xd08(%rip),%rax\nlea    0xd13(%rip),%r15\ncmovne %rax,%r15\ncmp    $0x4,%edi\ncmovae %rax,%r15\njmp    1164 <func0+0x44>\n"
    },
    {
        "task_id": 142,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11c6 <func0+0xc6>\nmov    -0x14(%rbp),%eax\nmov    $0x3,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    115b <func0+0x5b>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmovslq -0x14(%rbp),%rdx\nimul   (%rcx,%rdx,4),%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    11b3 <func0+0xb3>\nmov    -0x14(%rbp),%eax\nmov    $0x4,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    119d <func0+0x9d>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x8(%rbp),%rcx\nmovslq -0x14(%rbp),%rdx\nimul   (%rcx,%rdx,4),%eax\nmov    -0x8(%rbp),%rcx\nmovslq -0x14(%rbp),%rdx\nimul   (%rcx,%rdx,4),%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    11ae <func0+0xae>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nadd    -0x10(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    11b3 <func0+0xb3>\njmp    11b8 <func0+0xb8>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1119 <func0+0x19>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 142,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1154 <func0+0x54>\nmov    %esi,%r9d\nxor    %edx,%edx\nmov    $0xaaaaaaab,%r8d\nxor    %eax,%eax\njmp    1131 <func0+0x31>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    (%rdi,%rdx,4),%ecx\nimul   %ecx,%ecx\nadd    %ecx,%eax\nadd    $0x1,%rdx\ncmp    %rdx,%r9\nje     1156 <func0+0x56>\nmov    %edx,%esi\nimul   %r8,%rsi\nshr    $0x21,%rsi\nlea    (%rsi,%rsi,2),%esi\ncmp    %esi,%edx\nje     1120 <func0+0x20>\nmov    (%rdi,%rdx,4),%ecx\ntest   $0x3,%dl\njne    1126 <func0+0x26>\nmov    %ecx,%esi\nimul   %ecx,%esi\nimul   %esi,%ecx\njmp    1126 <func0+0x26>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 142,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1154 <func0+0x54>\nmov    %esi,%r9d\nxor    %edx,%edx\nmov    $0xaaaaaaab,%r8d\nxor    %eax,%eax\njmp    1131 <func0+0x31>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    (%rdi,%rdx,4),%ecx\nimul   %ecx,%ecx\nadd    %ecx,%eax\nadd    $0x1,%rdx\ncmp    %rdx,%r9\nje     1156 <func0+0x56>\nmov    %edx,%esi\nimul   %r8,%rsi\nshr    $0x21,%rsi\nlea    (%rsi,%rsi,2),%esi\ncmp    %esi,%edx\nje     1120 <func0+0x20>\nmov    (%rdi,%rdx,4),%ecx\ntest   $0x3,%dl\njne    1126 <func0+0x26>\nmov    %ecx,%esi\nimul   %ecx,%esi\nimul   %esi,%ecx\njmp    1126 <func0+0x26>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 142,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    1154 <func0+0x54>\nmov    %esi,%r9d\nxor    %edx,%edx\nmov    $0xaaaaaaab,%r8d\nxor    %eax,%eax\njmp    1131 <func0+0x31>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    (%rdi,%rdx,4),%ecx\nimul   %ecx,%ecx\nadd    %ecx,%eax\nadd    $0x1,%rdx\ncmp    %rdx,%r9\nje     1156 <func0+0x56>\nmov    %edx,%esi\nimul   %r8,%rsi\nshr    $0x21,%rsi\nlea    (%rsi,%rsi,2),%esi\ncmp    %esi,%edx\nje     1120 <func0+0x20>\nmov    (%rdi,%rdx,4),%ecx\ntest   $0x3,%dl\njne    1126 <func0+0x26>\nmov    %ecx,%esi\nimul   %ecx,%esi\nimul   %esi,%ecx\njmp    1126 <func0+0x26>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 143,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1246 <func0+0x136>\nmov    -0x8(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x20,%eax\nje     1174 <func0+0x64>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1233 <func0+0x123>\ncmpl   $0x1,-0x18(%rbp)\njle    11ca <func0+0xba>\nmovb   $0x1,-0x1d(%rbp)\nmovl   $0x2,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nimul   -0x28(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njg     11c5 <func0+0xb5>\nmov    -0x18(%rbp),%eax\ncltd\nidivl  -0x28(%rbp)\ncmp    $0x0,%edx\njne    11b2 <func0+0xa2>\nmovb   $0x0,-0x1d(%rbp)\njmp    11c5 <func0+0xb5>\njmp    11b7 <func0+0xa7>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    1189 <func0+0x79>\njmp    11ce <func0+0xbe>\nmovb   $0x0,-0x1d(%rbp)\ntestb  $0x1,-0x1d(%rbp)\nje     122c <func0+0x11c>\ncmpl   $0x0,-0x1c(%rbp)\njle    11f8 <func0+0xe8>\nmov    -0x10(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x20,(%rax,%rcx,1)\nmov    -0x10(%rbp),%rdi\nmovslq -0x1c(%rbp),%rax\nadd    %rax,%rdi\nmov    -0x8(%rbp),%rsi\nmovslq -0x24(%rbp),%rax\nadd    %rax,%rsi\nmovslq -0x18(%rbp),%rcx\nxor    %eax,%eax\nsub    %rcx,%rax\nadd    %rax,%rsi\nmovslq -0x18(%rbp),%rdx\ncall   1030 <memcpy@plt>\nmov    -0x18(%rbp),%eax\nadd    -0x1c(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    1238 <func0+0x128>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    113c <func0+0x2c>\ncmpl   $0x1,-0x18(%rbp)\njle    129c <func0+0x18c>\nmovb   $0x1,-0x1d(%rbp)\nmovl   $0x2,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nimul   -0x28(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njg     1297 <func0+0x187>\nmov    -0x18(%rbp),%eax\ncltd\nidivl  -0x28(%rbp)\ncmp    $0x0,%edx\njne    1284 <func0+0x174>\nmovb   $0x0,-0x1d(%rbp)\njmp    1297 <func0+0x187>\njmp    1289 <func0+0x179>\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    125b <func0+0x14b>\njmp    12a0 <func0+0x190>\nmovb   $0x0,-0x1d(%rbp)\ntestb  $0x1,-0x1d(%rbp)\nje     12fe <func0+0x1ee>\ncmpl   $0x0,-0x1c(%rbp)\njle    12ca <func0+0x1ba>\nmov    -0x10(%rbp),%rax\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%edx\nadd    $0x1,%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %ecx,%rcx\nmovb   $0x20,(%rax,%rcx,1)\nmov    -0x10(%rbp),%rdi\nmovslq -0x1c(%rbp),%rax\nadd    %rax,%rdi\nmov    -0x8(%rbp),%rsi\nmovslq -0x24(%rbp),%rax\nadd    %rax,%rsi\nmovslq -0x18(%rbp),%rcx\nxor    %eax,%eax\nsub    %rcx,%rax\nadd    %rax,%rsi\nmovslq -0x18(%rbp),%rdx\ncall   1030 <memcpy@plt>\nmov    -0x18(%rbp),%eax\nadd    -0x1c(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 143,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %rdi,%r12\nxor    %ebx,%ebx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\njmp    1147 <func0+0x37>\nmovslq %r15d,%r15\nlea    (%r14,%r15,1),%rdi\nmovslq %ebp,%rdx\nsub    %rdx,%rsi\ncall   1030 <memcpy@plt>\nadd    %ebp,%r15d\nnop\nadd    $0x1,%rbx\nmov    %r13d,%ebp\nlea    (%r12,%rbx,1),%rsi\nmov    (%r12,%rbx,1),%al\ncmp    $0x20,%al\nje     1160 <func0+0x50>\ntest   %al,%al\nje     11a8 <func0+0x98>\nadd    $0x1,%ebp\nmov    %ebp,%r13d\njmp    1140 <func0+0x30>\nnop\nxor    %r13d,%r13d\ncmp    $0x2,%ebp\njl     1140 <func0+0x30>\ncmp    $0x4,%ebp\njl     1195 <func0+0x85>\nmov    $0x2,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %ebp,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1140 <func0+0x30>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebp,%eax\njle    1180 <func0+0x70>\ntest   %r15d,%r15d\njle    112a <func0+0x1a>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovb   $0x20,(%r14,%rax,1)\njmp    112a <func0+0x1a>\ncmp    $0x2,%ebp\njl     11fb <func0+0xeb>\ncmp    $0x4,%ebp\njl     11d5 <func0+0xc5>\nmov    $0x2,%ecx\nnopw   0x0(%rax,%rax,1)\nmov    %ebp,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     11fb <func0+0xeb>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebp,%eax\njle    11c0 <func0+0xb0>\ntest   %r15d,%r15d\njle    11e6 <func0+0xd6>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovb   $0x20,(%r14,%rax,1)\nmovslq %r15d,%r15\nlea    (%r14,%r15,1),%rdi\nmovslq %ebp,%rdx\nsub    %rdx,%rsi\ncall   1030 <memcpy@plt>\nadd    %ebp,%r15d\nmovslq %r15d,%rax\nmovb   $0x0,(%r14,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 143,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %rdi,%r12\nxor    %ebx,%ebx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\njmp    1147 <func0+0x37>\nmovslq %r15d,%r15\nlea    (%r14,%r15,1),%rdi\nmovslq %ebp,%rdx\nsub    %rdx,%rsi\ncall   1030 <memcpy@plt>\nadd    %ebp,%r15d\nnop\nadd    $0x1,%rbx\nmov    %r13d,%ebp\nlea    (%r12,%rbx,1),%rsi\nmov    (%r12,%rbx,1),%al\ncmp    $0x20,%al\nje     1160 <func0+0x50>\ntest   %al,%al\nje     11a8 <func0+0x98>\nadd    $0x1,%ebp\nmov    %ebp,%r13d\njmp    1140 <func0+0x30>\nnop\nxor    %r13d,%r13d\ncmp    $0x2,%ebp\njl     1140 <func0+0x30>\ncmp    $0x4,%ebp\njb     1195 <func0+0x85>\nmov    $0x2,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %ebp,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1140 <func0+0x30>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebp,%eax\njle    1180 <func0+0x70>\ntest   %r15d,%r15d\njle    112a <func0+0x1a>\nmov    %r15d,%eax\nadd    $0x1,%r15d\nmovb   $0x20,(%r14,%rax,1)\njmp    112a <func0+0x1a>\ncmp    $0x2,%ebp\njl     11fb <func0+0xeb>\ncmp    $0x4,%ebp\njb     11d5 <func0+0xc5>\nmov    $0x2,%ecx\nnopw   0x0(%rax,%rax,1)\nmov    %ebp,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     11fb <func0+0xeb>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebp,%eax\njle    11c0 <func0+0xb0>\ntest   %r15d,%r15d\njle    11e6 <func0+0xd6>\nmov    %r15d,%eax\nadd    $0x1,%r15d\nmovb   $0x20,(%r14,%rax,1)\nmovslq %r15d,%r15\nlea    (%r14,%r15,1),%rdi\nmovslq %ebp,%rdx\nsub    %rdx,%rsi\ncall   1030 <memcpy@plt>\nadd    %ebp,%r15d\nmovslq %r15d,%rax\nmovb   $0x0,(%r14,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 143,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rsi,%r14\nmov    %rdi,%r12\nxor    %ebx,%ebx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\njmp    1147 <func0+0x37>\nmovslq %r15d,%r15\nlea    (%r14,%r15,1),%rdi\nmovslq %ebp,%rdx\nsub    %rdx,%rsi\ncall   1030 <memcpy@plt>\nadd    %ebp,%r15d\nnop\nadd    $0x1,%rbx\nmov    %r13d,%ebp\nlea    (%r12,%rbx,1),%rsi\nmov    (%r12,%rbx,1),%al\ncmp    $0x20,%al\nje     1160 <func0+0x50>\ntest   %al,%al\nje     11a8 <func0+0x98>\nadd    $0x1,%ebp\nmov    %ebp,%r13d\njmp    1140 <func0+0x30>\nnop\nxor    %r13d,%r13d\ncmp    $0x2,%ebp\njl     1140 <func0+0x30>\ncmp    $0x4,%ebp\njb     1195 <func0+0x85>\nmov    $0x2,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %ebp,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1140 <func0+0x30>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebp,%eax\njle    1180 <func0+0x70>\ntest   %r15d,%r15d\njle    112a <func0+0x1a>\nmov    %r15d,%eax\nadd    $0x1,%r15d\nmovb   $0x20,(%r14,%rax,1)\njmp    112a <func0+0x1a>\ncmp    $0x2,%ebp\njl     11fb <func0+0xeb>\ncmp    $0x4,%ebp\njb     11d5 <func0+0xc5>\nmov    $0x2,%ecx\nnopw   0x0(%rax,%rax,1)\nmov    %ebp,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     11fb <func0+0xeb>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebp,%eax\njle    11c0 <func0+0xb0>\ntest   %r15d,%r15d\njle    11e6 <func0+0xd6>\nmov    %r15d,%eax\nadd    $0x1,%r15d\nmovb   $0x20,(%r14,%rax,1)\nmovslq %r15d,%r15\nlea    (%r14,%r15,1),%rdi\nmovslq %ebp,%rdx\nsub    %rdx,%rsi\ncall   1030 <memcpy@plt>\nadd    %ebp,%r15d\nmovslq %r15d,%rax\nmovb   $0x0,(%r14,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 144,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x110,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %rsi,-0x18(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x2f,%eax\nje     1163 <func0+0x53>\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmovslq -0x2c(%rbp),%rax\nmov    %cl,-0xa0(%rbp,%rax,1)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    112a <func0+0x1a>\nmovslq -0x2c(%rbp),%rax\nmovb   $0x0,-0xa0(%rbp,%rax,1)\nlea    -0xa0(%rbp),%rdi\ncall   1030 <atoi@plt>\nmov    %eax,-0x1c(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     11d0 <func0+0xc0>\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmovslq -0x30(%rbp),%rax\nmov    %cl,-0x110(%rbp,%rax,1)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    118e <func0+0x7e>\nmovslq -0x30(%rbp),%rax\nmovb   $0x0,-0x110(%rbp,%rax,1)\nlea    -0x110(%rbp),%rdi\ncall   1030 <atoi@plt>\nmov    %eax,-0x20(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x18(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x2f,%eax\nje     122b <func0+0x11b>\nmov    -0x18(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmovslq -0x2c(%rbp),%rax\nmov    %cl,-0xa0(%rbp,%rax,1)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    11f2 <func0+0xe2>\nmovslq -0x2c(%rbp),%rax\nmovb   $0x0,-0xa0(%rbp,%rax,1)\nlea    -0xa0(%rbp),%rdi\ncall   1030 <atoi@plt>\nmov    %eax,-0x24(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x18(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1298 <func0+0x188>\nmov    -0x18(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmovslq -0x30(%rbp),%rax\nmov    %cl,-0x110(%rbp,%rax,1)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    1256 <func0+0x146>\nmovslq -0x30(%rbp),%rax\nmovb   $0x0,-0x110(%rbp,%rax,1)\nlea    -0x110(%rbp),%rdi\ncall   1030 <atoi@plt>\nmov    %eax,-0x28(%rbp)\nmov    -0x1c(%rbp),%eax\nimul   -0x24(%rbp),%eax\nmov    -0x20(%rbp),%ecx\nimul   -0x28(%rbp),%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    12d9 <func0+0x1c9>\nmovl   $0x1,-0x4(%rbp)\njmp    12e0 <func0+0x1d0>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x110,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 144,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0xd8,%rsp\nmov    %rsi,%r13\nmov    %rdi,%r15\nmov    (%rdi),%cl\nxor    %eax,%eax\ncmp    $0x2f,%cl\nje     1153 <func0+0x43>\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %cl,0x70(%rsp,%rax,1)\nmovzbl 0x1(%r15,%rax,1),%ecx\nadd    $0x1,%rax\ncmp    $0x2f,%cl\njne    1140 <func0+0x30>\nmov    %eax,%ebp\nmovb   $0x0,0x70(%rsp,%rbp,1)\nxor    %ebx,%ebx\nlea    0x70(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%r14\nmov    0x1(%rbp,%r15,1),%al\nmov    $0x0,%ecx\ntest   %al,%al\nje     11a1 <func0+0x91>\nlea    (%r15,%rbp,1),%rdx\nadd    $0x2,%rdx\nxor    %ecx,%ecx\nnopl   0x0(%rax,%rax,1)\nmov    %al,(%rsp,%rcx,1)\nmovzbl (%rdx,%rcx,1),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    1190 <func0+0x80>\nmov    %ecx,%ecx\nmovb   $0x0,(%rsp,%rcx,1)\nmov    %rsp,%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%r15\nmov    0x0(%r13),%al\ncmp    $0x2f,%al\nje     11e2 <func0+0xd2>\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %al,0x70(%rsp,%rbx,1)\nmovzbl 0x1(%r13,%rbx,1),%eax\nadd    $0x1,%rbx\ncmp    $0x2f,%al\njne    11d0 <func0+0xc0>\nmov    %ebx,%ebp\nmovb   $0x0,0x70(%rsp,%rbp,1)\nxor    %ebx,%ebx\nlea    0x70(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%r12\nmov    0x1(%rbp,%r13,1),%al\ntest   %al,%al\nje     1231 <func0+0x121>\nlea    0x2(,%r13,1),%rdx\nadd    %rbp,%rdx\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %al,(%rsp,%rcx,1)\nmovzbl (%rdx,%rcx,1),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    1220 <func0+0x110>\nmov    %ecx,%ebx\nmovb   $0x0,(%rsp,%rbx,1)\nmov    %rsp,%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%rcx\nimul   %r12d,%r14d\nimul   %r15d,%ecx\nmov    %r14d,%eax\ncltd\nidiv   %ecx\nxor    %eax,%eax\ntest   %edx,%edx\nsete   %al\nadd    $0xd8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 144,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0xd8,%rsp\nmov    %rsi,%r13\nmov    %rdi,%r15\nmov    (%rdi),%cl\nxor    %eax,%eax\ncmp    $0x2f,%cl\nje     1153 <func0+0x43>\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %cl,0x70(%rsp,%rax,1)\nmovzbl 0x1(%r15,%rax,1),%ecx\nadd    $0x1,%rax\ncmp    $0x2f,%cl\njne    1140 <func0+0x30>\nmov    %eax,%ebp\nmovb   $0x0,0x70(%rsp,%rbp,1)\nxor    %ebx,%ebx\nlea    0x70(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%r14\nmov    0x1(%rbp,%r15,1),%al\nmov    $0x0,%ecx\ntest   %al,%al\nje     11a1 <func0+0x91>\nlea    (%r15,%rbp,1),%rdx\nadd    $0x2,%rdx\nxor    %ecx,%ecx\nnopl   0x0(%rax,%rax,1)\nmov    %al,(%rsp,%rcx,1)\nmovzbl (%rdx,%rcx,1),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    1190 <func0+0x80>\nmov    %ecx,%ecx\nmovb   $0x0,(%rsp,%rcx,1)\nmov    %rsp,%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%r15\nmov    0x0(%r13),%al\ncmp    $0x2f,%al\nje     11e2 <func0+0xd2>\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %al,0x70(%rsp,%rbx,1)\nmovzbl 0x1(%r13,%rbx,1),%eax\nadd    $0x1,%rbx\ncmp    $0x2f,%al\njne    11d0 <func0+0xc0>\nmov    %ebx,%ebp\nmovb   $0x0,0x70(%rsp,%rbp,1)\nxor    %ebx,%ebx\nlea    0x70(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%r12\nmov    0x1(%rbp,%r13,1),%al\ntest   %al,%al\nje     1231 <func0+0x121>\nlea    0x2(,%r13,1),%rdx\nadd    %rbp,%rdx\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %al,(%rsp,%rcx,1)\nmovzbl (%rdx,%rcx,1),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    1220 <func0+0x110>\nmov    %ecx,%ebx\nmovb   $0x0,(%rsp,%rbx,1)\nmov    %rsp,%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%rcx\nimul   %r12d,%r14d\nimul   %r15d,%ecx\nmov    %r14d,%eax\ncltd\nidiv   %ecx\nxor    %eax,%eax\ntest   %edx,%edx\nsete   %al\nadd    $0xd8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 144,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0xd8,%rsp\nmov    %rsi,%r13\nmov    %rdi,%r15\nmov    (%rdi),%cl\nxor    %eax,%eax\ncmp    $0x2f,%cl\nje     1153 <func0+0x43>\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %cl,0x70(%rsp,%rax,1)\nmovzbl 0x1(%r15,%rax,1),%ecx\nadd    $0x1,%rax\ncmp    $0x2f,%cl\njne    1140 <func0+0x30>\nmov    %eax,%ebp\nmovb   $0x0,0x70(%rsp,%rbp,1)\nxor    %ebx,%ebx\nlea    0x70(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%r14\nmov    0x1(%rbp,%r15,1),%al\nmov    $0x0,%ecx\ntest   %al,%al\nje     11a1 <func0+0x91>\nlea    (%r15,%rbp,1),%rdx\nadd    $0x2,%rdx\nxor    %ecx,%ecx\nnopl   0x0(%rax,%rax,1)\nmov    %al,(%rsp,%rcx,1)\nmovzbl (%rdx,%rcx,1),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    1190 <func0+0x80>\nmov    %ecx,%ecx\nmovb   $0x0,(%rsp,%rcx,1)\nmov    %rsp,%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%r15\nmov    0x0(%r13),%al\ncmp    $0x2f,%al\nje     11e2 <func0+0xd2>\nxor    %ebx,%ebx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    %al,0x70(%rsp,%rbx,1)\nmovzbl 0x1(%r13,%rbx,1),%eax\nadd    $0x1,%rbx\ncmp    $0x2f,%al\njne    11d0 <func0+0xc0>\nmov    %ebx,%ebp\nmovb   $0x0,0x70(%rsp,%rbp,1)\nxor    %ebx,%ebx\nlea    0x70(%rsp),%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%r12\nmov    0x1(%rbp,%r13,1),%al\ntest   %al,%al\nje     1231 <func0+0x121>\nlea    0x2(,%r13,1),%rdx\nadd    %rbp,%rdx\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %al,(%rsp,%rcx,1)\nmovzbl (%rdx,%rcx,1),%eax\nadd    $0x1,%rcx\ntest   %al,%al\njne    1220 <func0+0x110>\nmov    %ecx,%ebx\nmovb   $0x0,(%rsp,%rbx,1)\nmov    %rsp,%rdi\nxor    %esi,%esi\nmov    $0xa,%edx\ncall   1030 <strtol@plt>\nmov    %rax,%rcx\nimul   %r12d,%r14d\nimul   %r15d,%ecx\nmov    %r14d,%eax\ncltd\nidiv   %ecx\nxor    %eax,%eax\ntest   %edx,%edx\nsete   %al\nadd    $0xd8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 145,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovslq -0xc(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1244 <func0+0xf4>\nlea    -0x28(%rbp),%rax\nmov    %rax,-0x48(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,4),%edi\ncall   1040 <abs@plt>\nmov    -0x48(%rbp),%rdi\nmov    %eax,%edx\nlea    0xe58(%rip),%rsi\nmov    $0x0,%al\ncall   1070 <sprintf@plt>\nmovl   $0x0,-0x2c(%rbp)\nlea    -0x28(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %eax,-0x30(%rbp)\nmovl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njge    11f5 <func0+0xa5>\nmovslq -0x34(%rbp),%rax\nmovsbl -0x28(%rbp,%rax,1),%eax\nsub    $0x30,%eax\nadd    -0x2c(%rbp),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    11c9 <func0+0x79>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\ncmpl   $0x0,(%rax,%rcx,4)\njle    1219 <func0+0xc9>\nmovsbl -0x28(%rbp),%eax\nsub    $0x30,%eax\nadd    -0x2c(%rbp),%eax\nmov    %eax,-0x2c(%rbp)\njmp    1228 <func0+0xd8>\nmovsbl -0x28(%rbp),%ecx\nsub    $0x30,%ecx\nmov    -0x2c(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1177 <func0+0x27>\nmovl   $0x0,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1329 <func0+0x1d9>\nmovl   $0x1,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    1316 <func0+0x1c6>\nmov    -0x18(%rbp),%rax\nmov    -0x40(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x18(%rbp),%rcx\nmovslq -0x40(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\njle    1303 <func0+0x1b3>\nmov    -0x18(%rbp),%rax\nmovslq -0x40(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x40(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x40(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x38(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    -0x40(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x8(%rbp),%rax\nmovslq -0x40(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x40(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x8(%rbp),%rax\nmovslq -0x40(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x38(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    -0x40(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1308 <func0+0x1b8>\nmov    -0x40(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x40(%rbp)\njmp    125e <func0+0x10e>\njmp    131b <func0+0x1cb>\nmov    -0x3c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x3c(%rbp)\njmp    124b <func0+0xfb>\nmov    -0x18(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x8(%rbp),%rax\nadd    $0x50,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 145,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %esi,%r14d\nmov    %rdi,%r13\nmovslq %esi,%r15\nlea    0x0(,%r15,4),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%rbp\nmov    %r14d,%ebx\ntest   %r15d,%r15d\njle    11f5 <func0+0xb5>\nlea    0xc(%rsp),%r12\nxor    %r15d,%r15d\njmp    11a7 <func0+0x67>\nnopl   (%rax)\nmovsbl 0xc(%rsp),%eax\nmov    %ecx,%edx\nsub    %eax,%edx\nadd    $0x30,%edx\ncmpl   $0x0,0x0(%r13,%r15,4)\nlea    -0x30(%rcx,%rax,1),%eax\ncmovle %edx,%eax\nmov    %eax,0x0(%rbp,%r15,4)\nadd    $0x1,%r15\ncmp    %rbx,%r15\nje     11f5 <func0+0xb5>\nmov    0x0(%r13,%r15,4),%eax\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nmov    %r12,%rdi\nlea    0xe43(%rip),%rsi\nxor    %eax,%eax\ncall   1060 <sprintf@plt>\nmov    %r12,%rdi\ncall   1040 <strlen@plt>\nmov    $0x0,%ecx\ncmp    $0x2,%eax\njl     1180 <func0+0x40>\nmov    %eax,%eax\nxor    %ecx,%ecx\nmov    $0x1,%edx\nnop\nmovsbl 0xc(%rsp,%rdx,1),%esi\nadd    %esi,%ecx\nadd    $0xffffffd0,%ecx\nadd    $0x1,%rdx\ncmp    %rdx,%rax\njne    11e0 <func0+0xa0>\njmp    1180 <func0+0x40>\ntest   %r14d,%r14d\njle    1245 <func0+0x105>\nxor    %eax,%eax\njmp    1208 <func0+0xc8>\nxchg   %ax,%ax\nadd    $0x1,%eax\ncmp    %r14d,%eax\nje     1245 <func0+0x105>\ncmp    $0x1,%r14d\nje     1200 <func0+0xc0>\nmov    $0x1,%ecx\njmp    1229 <func0+0xe9>\ncs nopw 0x0(%rax,%rax,1)\nnop\nadd    $0x1,%rcx\ncmp    %rcx,%rbx\nje     1200 <func0+0xc0>\nmov    -0x4(%rbp,%rcx,4),%edx\nmov    0x0(%rbp,%rcx,4),%esi\ncmp    %esi,%edx\njle    1220 <func0+0xe0>\nmov    %edx,0x0(%rbp,%rcx,4)\nmov    %esi,-0x4(%rbp,%rcx,4)\nrolq   $0x20,-0x4(%r13,%rcx,4)\njmp    1220 <func0+0xe0>\nmov    %rbp,%rdi\ncall   1030 <free@plt>\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 145,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %esi,%r14d\nmov    %rdi,%r13\nmovslq %esi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%rbp\ntest   %ebx,%ebx\njle    13a3 <func0+0x263>\nmov    %r14d,%ebx\nlea    0xc(%rsp),%r12\nxor    %r15d,%r15d\njmp    11ab <func0+0x6b>\nnopl   0x0(%rax)\nmovsbl 0xc(%rsp),%eax\nmov    %edx,%ecx\nsub    %eax,%ecx\nadd    $0x30,%ecx\ncmpl   $0x0,0x0(%r13,%r15,4)\nlea    -0x30(%rdx,%rax,1),%eax\ncmovle %ecx,%eax\nmov    %eax,0x0(%rbp,%r15,4)\nadd    $0x1,%r15\ncmp    %rbx,%r15\nje     134d <func0+0x20d>\nmov    0x0(%r13,%r15,4),%eax\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nmov    %r12,%rdi\nlea    0xe5f(%rip),%rsi\nxor    %eax,%eax\ncall   1060 <sprintf@plt>\nmov    %r12,%rdi\ncall   1040 <strlen@plt>\nmov    $0x0,%edx\ncmp    $0x2,%eax\njl     1180 <func0+0x40>\nmov    %eax,%eax\nlea    -0x1(%rax),%r8\ncmp    $0x8,%r8\njae    1200 <func0+0xc0>\nxor    %edx,%edx\nmov    $0x1,%ecx\njmp    1320 <func0+0x1e0>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %r8,%rcx\nand    $0xfffffffffffffff8,%rcx\nlea    -0x8(%rcx),%rsi\nmov    %rsi,%rdx\nshr    $0x3,%rdx\nadd    $0x1,%rdx\ntest   %rsi,%rsi\nmovdqa 0xddf(%rip),%xmm4\nje     1338 <func0+0x1f8>\nmov    %rdx,%rsi\nand    $0xfffffffffffffffe,%rsi\npxor   %xmm0,%xmm0\nxor    %edi,%edi\npxor   %xmm1,%xmm1\nnopl   0x0(%rax,%rax,1)\nmovd   0xd(%rsp,%rdi,1),%xmm2\npunpcklbw %xmm2,%xmm2\npunpcklwd %xmm2,%xmm2\nmovd   0x11(%rsp,%rdi,1),%xmm3\npunpcklbw %xmm3,%xmm3\npunpcklwd %xmm3,%xmm3\npsrad  $0x18,%xmm2\npaddd  %xmm0,%xmm2\npsrad  $0x18,%xmm3\npaddd  %xmm1,%xmm3\nmovd   0x15(%rsp,%rdi,1),%xmm0\npunpcklbw %xmm0,%xmm0\npunpcklwd %xmm0,%xmm0\npsrad  $0x18,%xmm0\nmovd   0x19(%rsp,%rdi,1),%xmm1\npunpcklbw %xmm1,%xmm1\npunpcklwd %xmm1,%xmm1\npsrad  $0x18,%xmm1\npaddd  %xmm4,%xmm0\npaddd  %xmm2,%xmm0\npaddd  %xmm4,%xmm1\npaddd  %xmm3,%xmm1\nadd    $0x10,%rdi\nadd    $0xfffffffffffffffe,%rsi\njne    1240 <func0+0x100>\ntest   $0x1,%dl\nje     12f5 <func0+0x1b5>\nor     $0x1,%rdi\nmovd   0xc(%rsp,%rdi,1),%xmm2\npunpcklbw %xmm2,%xmm2\npunpcklwd %xmm2,%xmm2\nmovd   0x10(%rsp,%rdi,1),%xmm3\npunpcklbw %xmm3,%xmm3\npunpcklwd %xmm3,%xmm3\npsrad  $0x18,%xmm2\npaddd  %xmm2,%xmm0\npsrad  $0x18,%xmm3\npaddd  %xmm3,%xmm1\nmovdqa 0xd23(%rip),%xmm2\npaddd  %xmm2,%xmm0\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%edx\ncmp    %rcx,%r8\nje     1180 <func0+0x40>\nor     $0x1,%rcx\nnopl   0x0(%rax)\nmovsbl 0xc(%rsp,%rcx,1),%esi\nadd    %esi,%edx\nadd    $0xffffffd0,%edx\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1320 <func0+0x1e0>\njmp    1180 <func0+0x40>\npxor   %xmm0,%xmm0\nxor    %edi,%edi\npxor   %xmm1,%xmm1\ntest   $0x1,%dl\njne    12b3 <func0+0x173>\njmp    12f5 <func0+0x1b5>\ntest   %r14d,%r14d\njle    13a3 <func0+0x263>\nxor    %eax,%eax\njmp    1368 <func0+0x228>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%eax\ncmp    %r14d,%eax\nje     13a3 <func0+0x263>\ncmp    $0x1,%r14d\nje     1360 <func0+0x220>\nmov    0x0(%rbp),%edx\nmov    $0x1,%ecx\njmp    1397 <func0+0x257>\nnopl   0x0(%rax,%rax,1)\nmov    %edx,0x0(%rbp,%rcx,4)\nmov    %esi,-0x4(%rbp,%rcx,4)\nrolq   $0x20,-0x4(%r13,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rbx\nje     1360 <func0+0x220>\nmov    0x0(%rbp,%rcx,4),%esi\ncmp    %esi,%edx\njg     1380 <func0+0x240>\nmov    %esi,%edx\njmp    138e <func0+0x24e>\nmov    %rbp,%rdi\ncall   1030 <free@plt>\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 145,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %esi,%r14d\nmov    %rdi,%r13\nmovslq %esi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%rbp\ntest   %ebx,%ebx\njle    13ac <func0+0x26c>\nmov    %r14d,%ebx\nlea    0xc(%rsp),%r12\nxor    %r15d,%r15d\njmp    11ab <func0+0x6b>\nnopl   0x0(%rax)\nmovsbl 0xc(%rsp),%eax\nmov    %edx,%ecx\nsub    %eax,%ecx\nadd    $0x30,%ecx\ncmpl   $0x0,0x0(%r13,%r15,4)\nlea    -0x30(%rdx,%rax,1),%eax\ncmovle %ecx,%eax\nmov    %eax,0x0(%rbp,%r15,4)\nadd    $0x1,%r15\ncmp    %rbx,%r15\nje     134d <func0+0x20d>\nmov    0x0(%r13,%r15,4),%eax\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nmov    %r12,%rdi\nlea    0xe5f(%rip),%rsi\nxor    %eax,%eax\ncall   1060 <sprintf@plt>\nmov    %r12,%rdi\ncall   1040 <strlen@plt>\nmov    $0x0,%edx\ncmp    $0x2,%eax\njl     1180 <func0+0x40>\nmov    %eax,%eax\nlea    -0x1(%rax),%r8\ncmp    $0x8,%r8\njae    1200 <func0+0xc0>\nxor    %edx,%edx\nmov    $0x1,%ecx\njmp    1320 <func0+0x1e0>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %r8,%rcx\nand    $0xfffffffffffffff8,%rcx\nlea    -0x8(%rcx),%rsi\nmov    %rsi,%rdx\nshr    $0x3,%rdx\nadd    $0x1,%rdx\ntest   %rsi,%rsi\nje     1338 <func0+0x1f8>\nmov    %rdx,%rsi\nand    $0xfffffffffffffffe,%rsi\npxor   %xmm0,%xmm0\nxor    %edi,%edi\npxor   %xmm1,%xmm1\nmovdqa 0xdc8(%rip),%xmm4\nnopl   0x0(%rax,%rax,1)\nmovd   0xd(%rsp,%rdi,1),%xmm2\npunpcklbw %xmm2,%xmm2\npunpcklwd %xmm2,%xmm2\nmovd   0x11(%rsp,%rdi,1),%xmm3\npunpcklbw %xmm3,%xmm3\npunpcklwd %xmm3,%xmm3\npsrad  $0x18,%xmm2\npaddd  %xmm0,%xmm2\npsrad  $0x18,%xmm3\npaddd  %xmm1,%xmm3\nmovd   0x15(%rsp,%rdi,1),%xmm0\npunpcklbw %xmm0,%xmm0\npunpcklwd %xmm0,%xmm0\npsrad  $0x18,%xmm0\nmovd   0x19(%rsp,%rdi,1),%xmm1\npunpcklbw %xmm1,%xmm1\npunpcklwd %xmm1,%xmm1\npsrad  $0x18,%xmm1\npaddd  %xmm4,%xmm0\npaddd  %xmm2,%xmm0\npaddd  %xmm4,%xmm1\npaddd  %xmm3,%xmm1\nadd    $0x10,%rdi\nadd    $0xfffffffffffffffe,%rsi\njne    1240 <func0+0x100>\ntest   $0x1,%dl\nje     12f5 <func0+0x1b5>\nor     $0x1,%rdi\nmovd   0xc(%rsp,%rdi,1),%xmm2\npunpcklbw %xmm2,%xmm2\npunpcklwd %xmm2,%xmm2\nmovd   0x10(%rsp,%rdi,1),%xmm3\npunpcklbw %xmm3,%xmm3\npunpcklwd %xmm3,%xmm3\npsrad  $0x18,%xmm2\npaddd  %xmm2,%xmm0\npsrad  $0x18,%xmm3\npaddd  %xmm3,%xmm1\nmovdqa 0xd23(%rip),%xmm2\npaddd  %xmm2,%xmm0\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\npshufd $0xee,%xmm0,%xmm1\npaddd  %xmm0,%xmm1\npshufd $0x55,%xmm1,%xmm0\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%edx\ncmp    %rcx,%r8\nje     1180 <func0+0x40>\nor     $0x1,%rcx\nnopl   0x0(%rax)\nmovsbl 0xc(%rsp,%rcx,1),%esi\nadd    %esi,%edx\nadd    $0xffffffd0,%edx\nadd    $0x1,%rcx\ncmp    %rcx,%rax\njne    1320 <func0+0x1e0>\njmp    1180 <func0+0x40>\npxor   %xmm0,%xmm0\nxor    %edi,%edi\npxor   %xmm1,%xmm1\ntest   $0x1,%dl\njne    12b3 <func0+0x173>\njmp    12f5 <func0+0x1b5>\ncmp    $0x2,%r14d\njl     13ac <func0+0x26c>\nxor    %eax,%eax\njmp    1368 <func0+0x228>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%eax\ncmp    %r14d,%eax\nje     13ac <func0+0x26c>\nmov    0x0(%rbp),%edx\nmov    $0x1,%ecx\njmp    1397 <func0+0x257>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %edx,0x0(%rbp,%rcx,4)\nmov    %esi,-0x4(%rbp,%rcx,4)\nrolq   $0x20,-0x4(%r13,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rbx\nje     1360 <func0+0x220>\nmov    0x0(%rbp,%rcx,4),%esi\ncmp    %esi,%edx\njg     1380 <func0+0x240>\nmov    %esi,%edx\nadd    $0x1,%rcx\ncmp    %rcx,%rbx\njne    1397 <func0+0x257>\njmp    1360 <func0+0x220>\nmov    %rbp,%rdi\ncall   1030 <free@plt>\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 146,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11c7 <func0+0xc7>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\ncmpl   $0xa,(%rax,%rcx,4)\njle    11b4 <func0+0xb4>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %edx,-0x1c(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x20(%rbp)\ncmpl   $0xa,-0x20(%rbp)\njl     1178 <func0+0x78>\nmov    -0x20(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x20(%rbp)\njmp    115b <func0+0x5b>\nmov    -0x20(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    11af <func0+0xaf>\nmov    -0x1c(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    11af <func0+0xaf>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    11b4 <func0+0xb4>\njmp    11b9 <func0+0xb9>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1119 <func0+0x19>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 146,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    11ac <func0+0xac>\nmov    %esi,%r8d\nxor    %r9d,%r9d\nxor    %eax,%eax\njmp    112d <func0+0x2d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nadd    $0x1,%r9\ncmp    %r8,%r9\nje     11ae <func0+0xae>\nmov    (%rdi,%r9,4),%r10d\ncmp    $0xb,%r10d\njl     1120 <func0+0x20>\nmov    %r10d,%ecx\nnopw   0x0(%rax,%rax,1)\nmovslq %ecx,%rdx\nimul   $0x66666667,%rdx,%rcx\nmov    %rcx,%rsi\nshr    $0x3f,%rsi\nsar    $0x22,%rcx\nadd    %esi,%ecx\ncmp    $0x63,%edx\njg     1140 <func0+0x40>\nmovslq %r10d,%rdx\nimul   $0x66666667,%rdx,%rdx\nmov    %rdx,%rsi\nshr    $0x3f,%rsi\nsar    $0x22,%rdx\nadd    %esi,%edx\nadd    %edx,%edx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r10d\nmov    %ecx,%edx\nshr    $0x1f,%edx\nadd    %ecx,%edx\nand    $0xfffffffe,%edx\nsub    %edx,%ecx\nxor    $0x1,%ecx\nmov    %r10d,%edx\nshr    $0x1f,%edx\nadd    %r10d,%edx\nand    $0xfffffffe,%edx\nsub    %edx,%r10d\nxor    $0x1,%r10d\nxor    %edx,%edx\nor     %ecx,%r10d\nsete   %dl\nadd    %edx,%eax\njmp    1120 <func0+0x20>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 146,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    115b <func0+0x5b>\nmov    %esi,%r8d\nxor    %r10d,%r10d\nmov    $0xcccccccd,%esi\nxor    %eax,%eax\njmp    1129 <func0+0x29>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x1,%r10\ncmp    %r8,%r10\nje     115d <func0+0x5d>\nmov    (%rdi,%r10,4),%r9d\ncmp    $0xb,%r9d\njl     1120 <func0+0x20>\nmov    %r9d,%ecx\ncs nopw 0x0(%rax,%rax,1)\nmov    %ecx,%edx\nmov    %ecx,%ecx\nimul   %rsi,%rcx\nshr    $0x23,%rcx\ncmp    $0x63,%edx\nja     1140 <func0+0x40>\nand    %r9d,%ecx\nand    $0x1,%ecx\nadd    %ecx,%eax\njmp    1120 <func0+0x20>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 146,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %esi,%esi\njle    115b <func0+0x5b>\nmov    %esi,%r8d\nxor    %r10d,%r10d\nmov    $0xcccccccd,%esi\nxor    %eax,%eax\njmp    1129 <func0+0x29>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nadd    $0x1,%r10\ncmp    %r8,%r10\nje     115d <func0+0x5d>\nmov    (%rdi,%r10,4),%r9d\ncmp    $0xb,%r9d\njl     1120 <func0+0x20>\nmov    %r9d,%ecx\ncs nopw 0x0(%rax,%rax,1)\nmov    %ecx,%edx\nmov    %ecx,%ecx\nimul   %rsi,%rcx\nshr    $0x23,%rcx\ncmp    $0x63,%edx\nja     1140 <func0+0x40>\nand    %r9d,%ecx\nand    $0x1,%ecx\nadd    %ecx,%eax\njmp    1120 <func0+0x20>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 147,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %edi,-0x4(%rbp)\nmovslq -0x4(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x10(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\nshl    $0x3,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\nshl    $0x3,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     11d5 <func0+0xa5>\nmov    $0x3,%edi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    $0x3,%edi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nmovslq -0x24(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x24(%rbp)\njmp    117f <func0+0x4f>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovl   $0x0,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovl   $0x0,0x4(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovl   $0x0,(%rax)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nmovl   $0x0,0x8(%rax)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nmovl   $0x0,0x4(%rax)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nmovl   $0x0,(%rax)\nmovl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     12dd <func0+0x1ad>\nmov    -0x28(%rbp),%eax\nimul   -0x28(%rbp),%eax\nsub    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    $0x3,%ecx\ncltd\nidiv   %ecx\nmov    -0x10(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\nmovl   $0x0,-0x2c(%rbp)\ncmpl   $0x3,-0x2c(%rbp)\njge    12a9 <func0+0x179>\nmov    -0x18(%rbp),%rax\nmov    -0x28(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1266 <func0+0x136>\nmov    -0x18(%rbp),%rax\nmovslq -0x28(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    -0x10(%rbp),%rcx\nmov    -0x28(%rbp),%edx\nsub    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nadd    $0x1,%edx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x28(%rbp)\njmp    122e <func0+0xfe>\nmovl   $0x1,-0x30(%rbp)\ncmpl   $0x3,-0x30(%rbp)\njge    1479 <func0+0x349>\nmovl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     13e4 <func0+0x2b4>\nmovl   $0x0,-0x38(%rbp)\ncmpl   $0x3,-0x38(%rbp)\njge    134b <func0+0x21b>\nmov    -0x20(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x20(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x38(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    1308 <func0+0x1d8>\ncmpl   $0x1,-0x34(%rbp)\njl     13d1 <func0+0x2a1>\nmovl   $0x0,-0x3c(%rbp)\ncmpl   $0x2,-0x3c(%rbp)\njg     13cc <func0+0x29c>\nmov    -0x18(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x3c(%rbp),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    %eax,-0x50(%rbp)\nmov    -0x20(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,4),%eax\nadd    -0x3c(%rbp),%eax\nmov    $0x3,%ecx\ncltd\nidiv   %ecx\nmov    -0x58(%rbp),%rax\nmov    %edx,%ecx\nmov    -0x50(%rbp),%edx\nmovslq %ecx,%rcx\nadd    (%rax,%rcx,4),%edx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x3c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x3c(%rbp)\njmp    135c <func0+0x22c>\njmp    13d1 <func0+0x2a1>\njmp    13d6 <func0+0x2a6>\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    12f5 <func0+0x1c5>\nmovl   $0x0,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     1466 <func0+0x336>\nmovl   $0x0,-0x44(%rbp)\ncmpl   $0x3,-0x44(%rbp)\njge    1453 <func0+0x323>\nmov    -0x20(%rbp),%rax\nmovslq -0x40(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x44(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x40(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x44(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x20(%rbp),%rax\nmovslq -0x40(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x44(%rbp),%rcx\nmovl   $0x0,(%rax,%rcx,4)\nmov    -0x44(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x44(%rbp)\njmp    13fe <func0+0x2ce>\njmp    1458 <func0+0x328>\nmov    -0x40(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x40(%rbp)\njmp    13eb <func0+0x2bb>\njmp    146b <func0+0x33b>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    12e4 <func0+0x1b4>\nmov    -0x18(%rbp),%rax\nmovslq -0x4(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    (%rax),%eax\nmov    %eax,-0x48(%rbp)\nmovl   $0x0,-0x4c(%rbp)\nmov    -0x4c(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     14cd <func0+0x39d>\nmov    -0x18(%rbp),%rax\nmovslq -0x4c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\ncall   1030 <free@plt>\nmov    -0x20(%rbp),%rax\nmovslq -0x4c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\ncall   1030 <free@plt>\nmov    -0x4c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4c(%rbp)\njmp    1491 <func0+0x361>\nmov    -0x18(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x20(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x10(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x48(%rbp),%eax\nadd    $0x60,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 147,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %edi,%r12d\nmovslq %edi,%rbp\nlea    0x0(,%rbp,4),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,0x8(%rsp)\nlea    0x8(,%rbp,8),%rbx\nmov    %rbx,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r14\nmov    %rbp,0x10(%rsp)\ntest   %ebp,%ebp\njs     11bf <func0+0x8f>\nlea    0x1(%r12),%ebp\nxor    %r13d,%r13d\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    $0x3,%edi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,(%r15,%r13,8)\nmov    $0x3,%edi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,(%r14,%r13,8)\nadd    $0x1,%r13\ncmp    %r13,%rbp\njne    1190 <func0+0x60>\nmov    (%r15),%rax\nmovl   $0x0,0x8(%rax)\nmovq   $0x0,(%rax)\nmov    (%r14),%rax\nmovl   $0x0,0x8(%rax)\nmovq   $0x0,(%rax)\ntest   %r12d,%r12d\nmov    0x8(%rsp),%r11\njle    1264 <func0+0x134>\nlea    0x1(%r12),%r8d\nmov    $0x1,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %ecx,%edx\nimul   %ecx,%edx\nsub    %ecx,%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nimul   $0x55555556,%rdx,%rsi\nmov    %rsi,%rdi\nshr    $0x3f,%rdi\nshr    $0x20,%rsi\nadd    %edi,%esi\nlea    (%rsi,%rsi,2),%esi\nsub    %esi,%edx\nmov    %edx,-0x4(%r11,%rcx,4)\nmov    -0x8(%r15,%rcx,8),%rsi\nmov    (%r15,%rcx,8),%rdi\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nmov    (%rsi,%rbp,4),%eax\nmov    %eax,(%rdi,%rbp,4)\nadd    $0x1,%rbp\ncmp    $0x3,%rbp\njne    1240 <func0+0x110>\nmov    (%r15,%rcx,8),%rsi\nmovslq %edx,%rdx\naddl   $0x1,(%rsi,%rdx,4)\nadd    $0x1,%rcx\ncmp    %r8,%rcx\njne    1200 <func0+0xd0>\nlea    0x1(%r12),%r13d\nmov    $0x1,%r8d\njmp    128e <func0+0x15e>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r8d\ncmp    $0x3,%r8d\nje     1355 <func0+0x225>\ntest   %r12d,%r12d\njle    130d <func0+0x1dd>\nmov    $0x1,%r9d\nnopl   0x0(%rax)\nmov    -0x8(%r14,%r9,8),%rax\nmov    (%r14,%r9,8),%rdx\nxor    %esi,%esi\nnopl   0x0(%rax,%rax,1)\nmov    (%rax,%rsi,4),%edi\nmov    %edi,(%rdx,%rsi,4)\nadd    $0x1,%rsi\ncmp    $0x3,%rsi\njne    12b0 <func0+0x180>\nmov    -0x8(%r15,%r9,8),%r10\nmov    (%r14,%r9,8),%rsi\nmov    -0x4(%r11,%r9,4),%edi\nxor    %eax,%eax\nmov    (%r10,%rax,4),%ebp\nlea    (%rdi,%rax,1),%rbx\nmovslq %ebx,%rbx\nimul   $0x55555556,%rbx,%rcx\nmov    %rcx,%rdx\nshr    $0x3f,%rdx\nshr    $0x20,%rcx\nadd    %edx,%ecx\nlea    (%rcx,%rcx,2),%ecx\nsub    %ecx,%ebx\nmovslq %ebx,%rcx\nadd    %ebp,(%rsi,%rcx,4)\nadd    $0x1,%rax\ncmp    $0x3,%rax\njne    12d0 <func0+0x1a0>\nadd    $0x1,%r9\ncmp    %r13,%r9\njne    12a0 <func0+0x170>\ntest   %r12d,%r12d\njs     1280 <func0+0x150>\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\nmov    (%r14,%rax,8),%rcx\nmov    (%r15,%rax,8),%rdx\nxor    %esi,%esi\nnopw   0x0(%rax,%rax,1)\nmov    (%rcx,%rsi,4),%edi\nmov    %edi,(%rdx,%rsi,4)\nmovl   $0x0,(%rcx,%rsi,4)\nadd    $0x1,%rsi\ncmp    $0x3,%rsi\njne    1330 <func0+0x200>\nadd    $0x1,%rax\ncmp    %r13,%rax\njne    1320 <func0+0x1f0>\njmp    1280 <func0+0x150>\nmov    0x10(%rsp),%rax\nmov    (%r15,%rax,8),%rax\nmov    (%rax),%ebp\ntest   %r12d,%r12d\njs     138b <func0+0x25b>\nxor    %r12d,%r12d\nnopl   0x0(%rax,%rax,1)\nmov    (%r15,%r12,8),%rdi\ncall   1030 <free@plt>\nmov    (%r14,%r12,8),%rdi\ncall   1030 <free@plt>\nadd    $0x1,%r12\ncmp    %r12,%r13\njne    1370 <func0+0x240>\nmov    %r15,%rdi\ncall   1030 <free@plt>\nmov    %r14,%rdi\ncall   1030 <free@plt>\nmov    0x8(%rsp),%rdi\ncall   1030 <free@plt>\nmov    %ebp,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 147,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %edi,0xc(%rsp)\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r14\nlea    0x1(%rbx),%r13d\nmovslq %r13d,%rbp\nshl    $0x3,%rbp\nmov    %rbp,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r12\nmov    %rbp,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    %r13d,0x8(%rsp)\nmov    %r13d,%r13d\nmov    %rbx,0x10(%rsp)\ntest   %ebx,%ebx\njs     11c8 <func0+0x98>\nxor    %ebp,%ebp\nnopl   0x0(%rax)\nmov    $0x3,%edi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,(%r12,%rbp,8)\nmov    $0x3,%edi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,(%r15,%rbp,8)\nadd    $0x1,%rbp\ncmp    %rbp,%r13\njne    1190 <func0+0x60>\nmov    (%r12),%r8\nmov    (%r15),%r9\njmp    11c8 <func0+0x98>\nmovl   $0x0,0x8(%r8)\nmovq   $0x0,(%r8)\nmovl   $0x0,0x8(%r9)\nmovq   $0x0,(%r9)\nmov    0xc(%rsp),%r11d\ntest   %r11d,%r11d\njle    131a <func0+0x1ea>\nmov    $0x1,%ecx\nxor    %edx,%edx\nmov    %r8,%rsi\nxchg   %ax,%ax\nmov    %ecx,%edi\nimul   %ecx,%edi\nadd    %edx,%edi\nmovslq %edi,%rdi\nimul   $0x55555556,%rdi,%rbp\nmov    %rbp,%rax\nshr    $0x3f,%rax\nshr    $0x20,%rbp\nadd    %eax,%ebp\nlea    0x0(%rbp,%rbp,2),%eax\nsub    %eax,%edi\nmov    %edi,-0x4(%r14,%rcx,4)\nmov    (%r12,%rcx,8),%rax\nmov    (%rsi),%ebp\nmov    %ebp,(%rax)\nmov    0x4(%rsi),%ebp\nmov    %ebp,0x4(%rax)\nmov    0x8(%rsi),%esi\nmov    %esi,0x8(%rax)\nmovslq %edi,%rsi\naddl   $0x1,(%rax,%rsi,4)\nadd    $0x1,%rcx\nadd    $0xffffffff,%edx\nmov    %rax,%rsi\ncmp    %rcx,%r13\njne    1200 <func0+0xd0>\ntest   %r11d,%r11d\njle    131a <func0+0x1ea>\nlea    -0x2(%r13),%r10\nxor    %esi,%esi\nmov    %r8,%rcx\nmov    %r9,%rdi\nnopl   0x0(%rax,%rax,1)\nmov    %rdi,%rax\nmov    0x8(%r15,%rsi,8),%rdi\nmov    (%rax),%ebp\nmov    %ebp,(%rdi)\nmov    0x4(%rax),%ebp\nmov    %ebp,0x4(%rdi)\nmov    0x8(%rax),%eax\nmov    %eax,0x8(%rdi)\nmovslq (%r14,%rsi,4),%rbp\nimul   $0x55555556,%rbp,%rax\nmov    %rax,%rdx\nshr    $0x3f,%rdx\nshr    $0x20,%rax\nadd    %edx,%eax\nlea    (%rax,%rax,2),%eax\nlea    0x1(%rbp),%edx\nmovslq %edx,%rdx\nimul   $0x55555556,%rdx,%rdx\nmov    %rdx,%rbx\nshr    $0x3f,%rbx\nshr    $0x20,%rdx\nadd    %ebx,%edx\nlea    (%rdx,%rdx,2),%edx\nneg    %edx\nadd    %ebp,%edx\nadd    $0x1,%edx\nmov    %ebp,%ebx\nsub    %eax,%ebx\nmov    (%rcx),%eax\nmovslq %ebx,%rbx\nadd    %eax,(%rdi,%rbx,4)\nmov    0x4(%rcx),%eax\nmovslq %edx,%rdx\nadd    %eax,(%rdi,%rdx,4)\nlea    0x2(%rbp),%eax\ncltq\nimul   $0x55555556,%rax,%rax\nmov    %rax,%rdx\nshr    $0x3f,%rdx\nshr    $0x20,%rax\nadd    %edx,%eax\nlea    (%rax,%rax,2),%eax\nneg    %eax\nadd    %ebp,%eax\nadd    $0x2,%eax\nmov    0x8(%rcx),%ecx\ncltq\nadd    %ecx,(%rdi,%rax,4)\ncmp    %rsi,%r10\nje     131a <func0+0x1ea>\nmov    0x8(%r12,%rsi,8),%rcx\nadd    $0x1,%rsi\njmp    1270 <func0+0x140>\ntest   %r11d,%r11d\njs     141d <func0+0x2ed>\nmov    (%r9),%eax\nmov    %eax,(%r8)\nmovl   $0x0,(%r9)\nmov    0x4(%r9),%eax\nmov    %eax,0x4(%r8)\nmovl   $0x0,0x4(%r9)\nmov    0x8(%r9),%eax\nmov    %eax,0x8(%r8)\nmovl   $0x0,0x8(%r9)\nje     141d <func0+0x2ed>\nlea    -0x1(%r13),%rcx\nmov    $0x1,%edx\ncmpl   $0x2,0x8(%rsp)\nje     13ec <func0+0x2bc>\nmov    %rcx,%rsi\nand    $0xfffffffffffffffe,%rsi\nneg    %rsi\nmov    $0x1,%edx\nnopl   0x0(%rax)\nmov    (%r15,%rdx,8),%rax\nmov    (%r12,%rdx,8),%rdi\nmov    (%rax),%ebp\nmov    %ebp,(%rdi)\nmovl   $0x0,(%rax)\nmov    0x4(%rax),%ebp\nmov    %ebp,0x4(%rdi)\nmovl   $0x0,0x4(%rax)\nmov    0x8(%rax),%ebp\nmov    %ebp,0x8(%rdi)\nmovl   $0x0,0x8(%rax)\nmov    0x8(%r15,%rdx,8),%rax\nmov    0x8(%r12,%rdx,8),%rdi\nmov    (%rax),%ebp\nmov    %ebp,(%rdi)\nmovl   $0x0,(%rax)\nmov    0x4(%rax),%ebp\nmov    %ebp,0x4(%rdi)\nmovl   $0x0,0x4(%rax)\nmov    0x8(%rax),%ebp\nmov    %ebp,0x8(%rdi)\nmovl   $0x0,0x8(%rax)\nlea    (%rsi,%rdx,1),%rax\nadd    $0x2,%rax\nadd    $0x2,%rdx\ncmp    $0x1,%rax\njne    1380 <func0+0x250>\ntest   $0x1,%cl\nje     141d <func0+0x2ed>\nmov    (%r15,%rdx,8),%rax\nmov    (%r12,%rdx,8),%rcx\nmov    (%rax),%edx\nmov    %edx,(%rcx)\nmovl   $0x0,(%rax)\nmov    0x4(%rax),%edx\nmov    %edx,0x4(%rcx)\nmovl   $0x0,0x4(%rax)\nmov    0x8(%rax),%edx\nmov    %edx,0x8(%rcx)\nmovl   $0x0,0x8(%rax)\ntest   %r11d,%r11d\njle    14ea <func0+0x3ba>\nlea    -0x2(%r13),%r10\nxor    %esi,%esi\nmov    %r8,%rcx\nmov    %r9,%rdi\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %rdi,%rax\nmov    0x8(%r15,%rsi,8),%rdi\nmov    (%rax),%ebp\nmov    %ebp,(%rdi)\nmov    0x4(%rax),%ebp\nmov    %ebp,0x4(%rdi)\nmov    0x8(%rax),%eax\nmov    %eax,0x8(%rdi)\nmovslq (%r14,%rsi,4),%rbp\nimul   $0x55555556,%rbp,%rax\nmov    %rax,%rbx\nshr    $0x3f,%rbx\nshr    $0x20,%rax\nadd    %ebx,%eax\nlea    (%rax,%rax,2),%eax\nlea    0x1(%rbp),%ebx\nmovslq %ebx,%rbx\nimul   $0x55555556,%rbx,%rbx\nmov    %rbx,%rdx\nshr    $0x3f,%rdx\nshr    $0x20,%rbx\nadd    %edx,%ebx\nlea    (%rbx,%rbx,2),%edx\nneg    %edx\nadd    %ebp,%edx\nadd    $0x1,%edx\nmov    %ebp,%ebx\nsub    %eax,%ebx\nmov    (%rcx),%eax\nmovslq %ebx,%rbx\nadd    %eax,(%rdi,%rbx,4)\nmov    0x4(%rcx),%eax\nmovslq %edx,%rdx\nadd    %eax,(%rdi,%rdx,4)\nlea    0x2(%rbp),%eax\ncltq\nimul   $0x55555556,%rax,%rax\nmov    %rax,%rdx\nshr    $0x3f,%rdx\nshr    $0x20,%rax\nadd    %edx,%eax\nlea    (%rax,%rax,2),%eax\nneg    %eax\nadd    %ebp,%eax\nadd    $0x2,%eax\nmov    0x8(%rcx),%ecx\ncltq\nadd    %ecx,(%rdi,%rax,4)\ncmp    %rsi,%r10\nje     14ea <func0+0x3ba>\nmov    0x8(%r12,%rsi,8),%rcx\nadd    $0x1,%rsi\njmp    1440 <func0+0x310>\ntest   %r11d,%r11d\njs     161d <func0+0x4ed>\nmov    (%r9),%eax\nmov    %eax,(%r8)\nmovl   $0x0,(%r9)\nmov    0x4(%r9),%eax\nmov    %eax,0x4(%r8)\nmovl   $0x0,0x4(%r9)\nmov    0x8(%r9),%eax\nmov    %eax,0x8(%r8)\nmovl   $0x0,0x8(%r9)\nje     15ec <func0+0x4bc>\nlea    -0x1(%r13),%rax\nmov    $0x1,%ecx\ncmpl   $0x2,0x8(%rsp)\nje     15bc <func0+0x48c>\nmov    %rax,%rdx\nand    $0xfffffffffffffffe,%rdx\nneg    %rdx\nmov    $0x1,%ecx\nnopl   0x0(%rax)\nmov    (%r15,%rcx,8),%rsi\nmov    (%r12,%rcx,8),%rdi\nmov    (%rsi),%ebp\nmov    %ebp,(%rdi)\nmovl   $0x0,(%rsi)\nmov    0x4(%rsi),%ebp\nmov    %ebp,0x4(%rdi)\nmovl   $0x0,0x4(%rsi)\nmov    0x8(%rsi),%ebp\nmov    %ebp,0x8(%rdi)\nmovl   $0x0,0x8(%rsi)\nmov    0x8(%r15,%rcx,8),%rsi\nmov    0x8(%r12,%rcx,8),%rdi\nmov    (%rsi),%ebp\nmov    %ebp,(%rdi)\nmovl   $0x0,(%rsi)\nmov    0x4(%rsi),%ebp\nmov    %ebp,0x4(%rdi)\nmovl   $0x0,0x4(%rsi)\nmov    0x8(%rsi),%ebp\nmov    %ebp,0x8(%rdi)\nmovl   $0x0,0x8(%rsi)\nlea    (%rdx,%rcx,1),%rsi\nadd    $0x2,%rsi\nadd    $0x2,%rcx\ncmp    $0x1,%rsi\njne    1550 <func0+0x420>\ntest   $0x1,%al\nje     15ec <func0+0x4bc>\nmov    (%r15,%rcx,8),%rax\nmov    (%r12,%rcx,8),%rcx\nmov    (%rax),%edx\nmov    %edx,(%rcx)\nmovl   $0x0,(%rax)\nmov    0x4(%rax),%edx\nmov    %edx,0x4(%rcx)\nmovl   $0x0,0x4(%rax)\nmov    0x8(%rax),%edx\nmov    %edx,0x8(%rcx)\nmovl   $0x0,0x8(%rax)\nmov    0x10(%rsp),%rax\nmov    (%r12,%rax,8),%rax\nmov    (%rax),%ebx\ntest   %r11d,%r11d\njs     1628 <func0+0x4f8>\nxor    %ebp,%ebp\nxchg   %ax,%ax\nmov    (%r12,%rbp,8),%rdi\ncall   1030 <free@plt>\nmov    (%r15,%rbp,8),%rdi\ncall   1030 <free@plt>\nadd    $0x1,%rbp\ncmp    %rbp,%r13\njne    1600 <func0+0x4d0>\njmp    1628 <func0+0x4f8>\nmov    0x10(%rsp),%rax\nmov    (%r12,%rax,8),%rax\nmov    (%rax),%ebx\nmov    %r12,%rdi\ncall   1030 <free@plt>\nmov    %r15,%rdi\ncall   1030 <free@plt>\nmov    %r14,%rdi\ncall   1030 <free@plt>\nmov    %ebx,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 147,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %edi,0xc(%rsp)\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r13\nlea    0x1(%rbx),%r12d\nmovslq %r12d,%rbp\nshl    $0x3,%rbp\nmov    %rbp,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r14\nmov    %rbp,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,%r15\nmov    %r12d,0x8(%rsp)\nmov    %r12d,%r12d\nmov    %rbx,0x10(%rsp)\ntest   %ebx,%ebx\njs     11ca <func0+0x9a>\nmov    %r13,%rbx\nxor    %r13d,%r13d\nnopl   (%rax)\nmov    $0x3,%edi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,(%r14,%r13,8)\nmov    $0x3,%edi\nmov    $0x4,%esi\ncall   1040 <calloc@plt>\nmov    %rax,(%r15,%r13,8)\nadd    $0x1,%r13\ncmp    %r13,%r12\njne    1190 <func0+0x60>\nmov    (%r14),%r8\nmov    (%r15),%r9\nmov    %rbx,%r13\njmp    11ca <func0+0x9a>\nmov    0xc(%rsp),%r11d\nmovl   $0x0,0x8(%r8)\nmovq   $0x0,(%r8)\nmovl   $0x0,0x8(%r9)\nmovq   $0x0,(%r9)\ntest   %r11d,%r11d\njle    1322 <func0+0x1f2>\nmov    $0x1,%eax\nxor    %ecx,%ecx\nmov    %r8,%rdx\nmov    %eax,%esi\nimul   %eax,%esi\nadd    %ecx,%esi\nmovslq %esi,%rsi\nimul   $0x55555556,%rsi,%rdi\nmov    %rdi,%rbp\nshr    $0x3f,%rbp\nshr    $0x20,%rdi\nadd    %ebp,%edi\nlea    (%rdi,%rdi,2),%edi\nsub    %edi,%esi\nmov    %esi,-0x4(%r13,%rax,4)\nmov    (%r14,%rax,8),%rdi\nmov    (%rdx),%ebp\nmov    %ebp,(%rdi)\nmov    0x4(%rdx),%ebp\nmov    %ebp,0x4(%rdi)\nmov    0x8(%rdx),%edx\nmov    %edx,0x8(%rdi)\nmovslq %esi,%rdx\naddl   $0x1,(%rdi,%rdx,4)\nadd    $0x1,%rax\nadd    $0xffffffff,%ecx\nmov    %rdi,%rdx\ncmp    %rax,%r12\njne    1200 <func0+0xd0>\ntest   %r11d,%r11d\njle    1322 <func0+0x1f2>\nlea    -0x2(%r12),%r10\nxor    %esi,%esi\nmov    %r8,%rcx\nmov    %r9,%rdi\nnopl   0x0(%rax,%rax,1)\nmov    %rdi,%rax\nmov    0x8(%r15,%rsi,8),%rdi\nmov    (%rax),%ebp\nmov    %ebp,(%rdi)\nmov    0x4(%rax),%ebp\nmov    %ebp,0x4(%rdi)\nmov    0x8(%rax),%eax\nmov    %eax,0x8(%rdi)\nmovslq 0x0(%r13,%rsi,4),%rax\nimul   $0x55555556,%rax,%rbp\nmov    %rbp,%rdx\nshr    $0x3f,%rdx\nshr    $0x20,%rbp\nadd    %edx,%ebp\nlea    0x0(%rbp,%rbp,2),%edx\nlea    0x1(%rax),%ebp\nmovslq %ebp,%rbp\nimul   $0x55555556,%rbp,%rbp\nmov    %rbp,%rbx\nshr    $0x3f,%rbx\nshr    $0x20,%rbp\nadd    %ebx,%ebp\nlea    0x0(%rbp,%rbp,2),%ebp\nneg    %ebp\nadd    %eax,%ebp\nadd    $0x1,%ebp\nmov    %eax,%ebx\nsub    %edx,%ebx\nmov    (%rcx),%edx\nmovslq %ebx,%rbx\nadd    %edx,(%rdi,%rbx,4)\nmov    0x4(%rcx),%edx\nmovslq %ebp,%rbp\nadd    %edx,(%rdi,%rbp,4)\nlea    0x2(%rax),%edx\nmovslq %edx,%rdx\nimul   $0x55555556,%rdx,%rdx\nmov    %rdx,%rbp\nshr    $0x3f,%rbp\nshr    $0x20,%rdx\nadd    %ebp,%edx\nlea    (%rdx,%rdx,2),%edx\nneg    %edx\nadd    %edx,%eax\nadd    $0x2,%eax\nmov    0x8(%rcx),%ecx\ncltq\nadd    %ecx,(%rdi,%rax,4)\ncmp    %rsi,%r10\nje     1399 <func0+0x269>\nmov    0x8(%r14,%rsi,8),%rcx\nadd    $0x1,%rsi\njmp    1270 <func0+0x140>\ntest   %r11d,%r11d\njs     169d <func0+0x56d>\nmov    %r13,%rbx\nmov    (%r9),%eax\nmov    %eax,(%r8)\nmovl   $0x0,(%r9)\nmov    0x4(%r9),%eax\nmov    %eax,0x4(%r8)\nmovl   $0x0,0x4(%r9)\nmov    0x8(%r9),%eax\nmov    %eax,0x8(%r8)\nmovl   $0x0,0x8(%r9)\nmov    (%r9),%eax\nmov    %eax,(%r8)\nmovl   $0x0,(%r9)\nmov    0x4(%r9),%eax\nmov    %eax,0x4(%r8)\nmovl   $0x0,0x4(%r9)\nmov    0x8(%r9),%eax\nmov    %eax,0x8(%r8)\nmovl   $0x0,0x8(%r9)\nmov    0x10(%rsp),%rax\nmov    (%r14,%rax,8),%rax\nmov    (%rax),%r13d\njmp    1670 <func0+0x540>\ntest   %r11d,%r11d\njs     149c <func0+0x36c>\nmov    (%r9),%eax\nmov    %eax,(%r8)\nmovl   $0x0,(%r9)\nmov    0x4(%r9),%eax\nmov    %eax,0x4(%r8)\nmovl   $0x0,0x4(%r9)\nmov    0x8(%r9),%eax\nmov    %eax,0x8(%r8)\nmovl   $0x0,0x8(%r9)\nlea    -0x1(%r12),%rax\nmov    $0x1,%ecx\ncmpl   $0x2,0x8(%rsp)\nje     146c <func0+0x33c>\nmov    %rax,%rsi\nand    $0xfffffffffffffffe,%rsi\nneg    %rsi\nmov    $0x1,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    (%r15,%rcx,8),%rdx\nmov    (%r14,%rcx,8),%rdi\nmov    (%rdx),%ebp\nmov    %ebp,(%rdi)\nmovl   $0x0,(%rdx)\nmov    0x4(%rdx),%ebp\nmov    %ebp,0x4(%rdi)\nmovl   $0x0,0x4(%rdx)\nmov    0x8(%rdx),%ebp\nmov    %ebp,0x8(%rdi)\nmovl   $0x0,0x8(%rdx)\nmov    0x8(%r15,%rcx,8),%rdx\nmov    0x8(%r14,%rcx,8),%rdi\nmov    (%rdx),%ebp\nmov    %ebp,(%rdi)\nmovl   $0x0,(%rdx)\nmov    0x4(%rdx),%ebp\nmov    %ebp,0x4(%rdi)\nmovl   $0x0,0x4(%rdx)\nmov    0x8(%rdx),%ebp\nmov    %ebp,0x8(%rdi)\nmovl   $0x0,0x8(%rdx)\nlea    (%rsi,%rcx,1),%rdx\nadd    $0x2,%rdx\nadd    $0x2,%rcx\ncmp    $0x1,%rdx\njne    1400 <func0+0x2d0>\ntest   $0x1,%al\nje     149c <func0+0x36c>\nmov    (%r15,%rcx,8),%rax\nmov    (%r14,%rcx,8),%rcx\nmov    (%rax),%edx\nmov    %edx,(%rcx)\nmovl   $0x0,(%rax)\nmov    0x4(%rax),%edx\nmov    %edx,0x4(%rcx)\nmovl   $0x0,0x4(%rax)\nmov    0x8(%rax),%edx\nmov    %edx,0x8(%rcx)\nmovl   $0x0,0x8(%rax)\nxor    %esi,%esi\nmov    %r8,%rcx\nmov    %r9,%rdi\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %rdi,%rax\nmov    0x8(%r15,%rsi,8),%rdi\nmov    (%rax),%edx\nmov    %edx,(%rdi)\nmov    0x4(%rax),%edx\nmov    %edx,0x4(%rdi)\nmov    0x8(%rax),%eax\nmov    %eax,0x8(%rdi)\nmovslq 0x0(%r13,%rsi,4),%rax\nimul   $0x55555556,%rax,%rdx\nmov    %rdx,%rbp\nshr    $0x3f,%rbp\nshr    $0x20,%rdx\nadd    %ebp,%edx\nlea    (%rdx,%rdx,2),%edx\nlea    0x1(%rax),%ebp\nmovslq %ebp,%rbp\nimul   $0x55555556,%rbp,%rbp\nmov    %rbp,%rbx\nshr    $0x3f,%rbx\nshr    $0x20,%rbp\nadd    %ebx,%ebp\nlea    0x0(%rbp,%rbp,2),%ebp\nneg    %ebp\nadd    %eax,%ebp\nadd    $0x1,%ebp\nmov    %eax,%ebx\nsub    %edx,%ebx\nmov    (%rcx),%edx\nmovslq %ebx,%rbx\nadd    %edx,(%rdi,%rbx,4)\nmov    0x4(%rcx),%edx\nmovslq %ebp,%rbp\nadd    %edx,(%rdi,%rbp,4)\nlea    0x2(%rax),%edx\nmovslq %edx,%rdx\nimul   $0x55555556,%rdx,%rdx\nmov    %rdx,%rbp\nshr    $0x3f,%rbp\nshr    $0x20,%rdx\nadd    %ebp,%edx\nlea    (%rdx,%rdx,2),%edx\nneg    %edx\nadd    %edx,%eax\nadd    $0x2,%eax\nmov    0x8(%rcx),%ecx\ncltq\nadd    %ecx,(%rdi,%rax,4)\ncmp    %rsi,%r10\nje     155d <func0+0x42d>\nmov    0x8(%r14,%rsi,8),%rcx\nadd    $0x1,%rsi\njmp    14b0 <func0+0x380>\ntest   %r11d,%r11d\njs     169d <func0+0x56d>\nmov    (%r9),%eax\nmov    %eax,(%r8)\nmovl   $0x0,(%r9)\nmov    0x4(%r9),%eax\nmov    %eax,0x4(%r8)\nmovl   $0x0,0x4(%r9)\nmov    0x8(%r9),%eax\nmov    %eax,0x8(%r8)\nmovl   $0x0,0x8(%r9)\nlea    -0x1(%r12),%rax\nmov    $0x1,%ecx\ncmpl   $0x2,0x8(%rsp)\nje     162c <func0+0x4fc>\nmov    %rax,%rdx\nand    $0xfffffffffffffffe,%rdx\nneg    %rdx\nmov    $0x1,%ecx\nnopw   0x0(%rax,%rax,1)\nmov    (%r15,%rcx,8),%rsi\nmov    (%r14,%rcx,8),%rdi\nmov    (%rsi),%ebp\nmov    %ebp,(%rdi)\nmovl   $0x0,(%rsi)\nmov    0x4(%rsi),%ebp\nmov    %ebp,0x4(%rdi)\nmovl   $0x0,0x4(%rsi)\nmov    0x8(%rsi),%ebp\nmov    %ebp,0x8(%rdi)\nmovl   $0x0,0x8(%rsi)\nmov    0x8(%r15,%rcx,8),%rsi\nmov    0x8(%r14,%rcx,8),%rdi\nmov    (%rsi),%ebp\nmov    %ebp,(%rdi)\nmovl   $0x0,(%rsi)\nmov    0x4(%rsi),%ebp\nmov    %ebp,0x4(%rdi)\nmovl   $0x0,0x4(%rsi)\nmov    0x8(%rsi),%ebp\nmov    %ebp,0x8(%rdi)\nmovl   $0x0,0x8(%rsi)\nlea    (%rdx,%rcx,1),%rsi\nadd    $0x2,%rsi\nadd    $0x2,%rcx\ncmp    $0x1,%rsi\njne    15c0 <func0+0x490>\nmov    %r13,%rbx\ntest   $0x1,%al\nje     165f <func0+0x52f>\nmov    (%r15,%rcx,8),%rax\nmov    (%r14,%rcx,8),%rcx\nmov    (%rax),%edx\nmov    %edx,(%rcx)\nmovl   $0x0,(%rax)\nmov    0x4(%rax),%edx\nmov    %edx,0x4(%rcx)\nmovl   $0x0,0x4(%rax)\nmov    0x8(%rax),%edx\nmov    %edx,0x8(%rcx)\nmovl   $0x0,0x8(%rax)\nmov    0x10(%rsp),%rax\nmov    (%r14,%rax,8),%rax\nmov    (%rax),%r13d\ntest   %r11d,%r11d\njs     16ac <func0+0x57c>\nxor    %ebp,%ebp\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    (%r14,%rbp,8),%rdi\ncall   1030 <free@plt>\nmov    (%r15,%rbp,8),%rdi\ncall   1030 <free@plt>\nadd    $0x1,%rbp\ncmp    %rbp,%r12\njne    1680 <func0+0x550>\njmp    16ac <func0+0x57c>\nmov    %r13,%rbx\nmov    0x10(%rsp),%rax\nmov    (%r14,%rax,8),%rax\nmov    (%rax),%r13d\nmov    %r14,%rdi\ncall   1030 <free@plt>\nmov    %r15,%rdi\ncall   1030 <free@plt>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %r13d,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 148,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x80,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    %rdx,-0x20(%rbp)\nlea    -0x60(%rbp),%rdi\nlea    0x2c8e(%rip),%rsi\nmov    $0x40,%edx\ncall   1040 <memcpy@plt>\nmovl   $0xffffffff,-0x64(%rbp)\nmovl   $0xffffffff,-0x68(%rbp)\nmovl   $0x0,-0x6c(%rbp)\ncmpl   $0x8,-0x6c(%rbp)\njge    11d0 <func0+0xa0>\nmovslq -0x6c(%rbp),%rax\nmov    -0x60(%rbp,%rax,8),%rdi\nmov    -0x10(%rbp),%rsi\ncall   1030 <strcmp@plt>\ncmp    $0x0,%eax\njne    119c <func0+0x6c>\nmov    -0x6c(%rbp),%eax\nmov    %eax,-0x64(%rbp)\nmovslq -0x6c(%rbp),%rax\nmov    -0x60(%rbp,%rax,8),%rdi\nmov    -0x18(%rbp),%rsi\ncall   1030 <strcmp@plt>\ncmp    $0x0,%eax\njne    11bd <func0+0x8d>\nmov    -0x6c(%rbp),%eax\nmov    %eax,-0x68(%rbp)\njmp    11c2 <func0+0x92>\nmov    -0x6c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\njmp    1171 <func0+0x41>\ncmpl   $0xffffffff,-0x64(%rbp)\nje     11f0 <func0+0xc0>\ncmpl   $0xffffffff,-0x68(%rbp)\nje     11f0 <func0+0xc0>\nmov    -0x64(%rbp),%eax\ncmp    -0x68(%rbp),%eax\njne    1207 <func0+0xd7>\nmov    -0x20(%rbp),%rax\nmovl   $0x0,(%rax)\nmovq   $0x0,-0x8(%rbp)\njmp    12b4 <func0+0x184>\nmov    -0x64(%rbp),%eax\ncmp    -0x68(%rbp),%eax\njle    1225 <func0+0xf5>\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x70(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,-0x64(%rbp)\nmov    -0x70(%rbp),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x68(%rbp),%ecx\nsub    -0x64(%rbp),%ecx\nsub    $0x1,%ecx\nmov    -0x20(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x20(%rbp),%rax\ncmpl   $0x0,(%rax)\njg     1258 <func0+0x128>\nmov    -0x20(%rbp),%rax\nmovl   $0x0,(%rax)\nmovq   $0x0,-0x8(%rbp)\njmp    12b4 <func0+0x184>\nmov    -0x20(%rbp),%rax\nmovslq (%rax),%rdi\nshl    $0x3,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x78(%rbp)\nmov    -0x64(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\nmov    -0x6c(%rbp),%eax\ncmp    -0x68(%rbp),%eax\njge    12ac <func0+0x17c>\nmovslq -0x6c(%rbp),%rax\nmov    -0x60(%rbp,%rax,8),%rdx\nmov    -0x78(%rbp),%rax\nmov    -0x6c(%rbp),%ecx\nsub    -0x64(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x6c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\njmp    1275 <func0+0x145>\nmov    -0x78(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x80,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 148,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdx,0x8(%rsp)\nmov    %rsi,0x10(%rsp)\nmov    %rdi,%r12\nmov    $0xffffffff,%r13d\nlea    0x2c98(%rip),%r14\nxor    %r15d,%r15d\nmov    $0xffffffff,%ebp\nmov    (%r14),%rbx\nmov    %rbx,%rdi\nmov    %r12,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %r15d,%r13d\nmov    %rbx,%rdi\nmov    0x10(%rsp),%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %r15d,%ebp\nadd    $0x1,%r15\nadd    $0x8,%r14\ncmp    $0x8,%r15\njne    1150 <func0+0x30>\ncmp    $0xffffffff,%r13d\nmov    0x8(%rsp),%rax\nje     11f5 <func0+0xd5>\ncmp    $0xffffffff,%ebp\nje     11f5 <func0+0xd5>\ncmp    %ebp,%r13d\nje     11f5 <func0+0xd5>\nmov    %ebp,%r14d\ncmovg  %r13d,%r14d\ncmovg  %ebp,%r13d\nmov    %r13d,%ebx\nnot    %ebx\nadd    %r14d,%ebx\nmov    %ebx,(%rax)\ntest   %ebx,%ebx\njle    11f5 <func0+0xd5>\nmovslq %ebx,%rdi\nshl    $0x3,%rdi\ncall   1040 <malloc@plt>\nadd    $0x1,%r13d\ncmp    %r14d,%r13d\njge    11fd <func0+0xdd>\nmovslq %r13d,%rcx\nlea    0x2c0e(%rip),%rdx\nlea    (%rdx,%rcx,8),%rcx\nmov    %ebx,%edx\nxor    %esi,%esi\nnopw   0x0(%rax,%rax,1)\nmov    (%rcx,%rsi,8),%rdi\nmovslq %esi,%rbp\nmov    %rdi,(%rax,%rbp,8)\nadd    $0x1,%rsi\ncmp    %esi,%edx\njne    11e0 <func0+0xc0>\njmp    11fd <func0+0xdd>\nmovl   $0x0,(%rax)\nxor    %eax,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 148,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdx,(%rsp)\nmov    %rsi,%r15\nmov    %rdi,%r13\nlea    0xec4(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\nneg    %eax\nsbb    %r14d,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\nneg    %eax\nsbb    %ebp,%ebp\nlea    0xea6(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x1,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xe7f(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x2,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xe58(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x3,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xe30(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x4,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xe0b(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x5,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xde5(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x6,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xdbf(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x7,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\nmov    (%rsp),%rcx\ntest   %eax,%eax\ncmove  %ebx,%ebp\ncmp    $0xffffffff,%r14d\nje     13d5 <func0+0x2b5>\ncmp    $0xffffffff,%ebp\nje     13d5 <func0+0x2b5>\ncmp    %ebp,%r14d\nje     13d5 <func0+0x2b5>\nmov    %ebp,%r15d\ncmova  %r14d,%r15d\ncmova  %ebp,%r14d\nmov    %r14d,%eax\nnot    %eax\nadd    %r15d,%eax\nmov    %eax,(%rcx)\ntest   %eax,%eax\njle    13d5 <func0+0x2b5>\nmov    %eax,%edi\nshl    $0x3,%rdi\ncall   1040 <malloc@plt>\nlea    0x1(%r14),%ecx\ncmp    %r15d,%ecx\njae    13dd <func0+0x2bd>\nmov    %ecx,%ebx\nmov    %r15d,%ecx\nsub    %r14d,%ecx\nlea    -0x2(%rcx),%r10d\ncmp    $0x3,%r10d\njb     13ec <func0+0x2cc>\nadd    $0xfffffffe,%ecx\njs     13ec <func0+0x2cc>\nadd    $0x1,%r10\nmov    %r10,%r8\nand    $0xfffffffffffffffc,%r8\nlea    -0x4(%r8),%rcx\nmov    %rcx,%r9\nshr    $0x2,%r9\nadd    $0x1,%r9\ntest   %rcx,%rcx\nje     1461 <func0+0x341>\nmov    %r9,%rdi\nand    $0xfffffffffffffffe,%rdi\nlea    0x2aa5(%rip),%rcx\nlea    (%rcx,%rbx,8),%rsi\nadd    $0x30,%rsi\nxor    %ecx,%ecx\nmovabs $0x400000000,%r11\nmovabs $0x800000000,%r12\nxor    %ebp,%ebp\nnopl   0x0(%rax,%rax,1)\nmov    %rcx,%rdx\nsar    $0x1d,%rdx\nmovups -0x30(%rsi,%rbp,8),%xmm0\nmovups -0x20(%rsi,%rbp,8),%xmm1\nmovups -0x10(%rsi,%rbp,8),%xmm2\nmovups (%rsi,%rbp,8),%xmm3\nmovups %xmm0,(%rax,%rdx,1)\nmovups %xmm1,0x10(%rax,%rdx,1)\nlea    (%rcx,%r11,1),%rdx\nsar    $0x1d,%rdx\nmovups %xmm2,(%rax,%rdx,1)\nmovups %xmm3,0x10(%rax,%rdx,1)\nadd    $0x8,%rbp\nadd    %r12,%rcx\nadd    $0xfffffffffffffffe,%rdi\njne    1360 <func0+0x240>\ntest   $0x1,%r9b\nje     13c7 <func0+0x2a7>\nlea    (%rbx,%rbp,1),%rcx\nlea    0x2a2e(%rip),%rdx\nmovups (%rdx,%rcx,8),%xmm0\nmovups 0x10(%rdx,%rcx,8),%xmm1\nmovslq %ebp,%rcx\nmovups %xmm0,(%rax,%rcx,8)\nmovups %xmm1,0x10(%rax,%rcx,8)\ncmp    %r8,%r10\nje     13dd <func0+0x2bd>\nadd    %r8,%rbx\nlea    (%r14,%r8,1),%edx\njmp    13ef <func0+0x2cf>\nmovl   $0x0,(%rcx)\nxor    %eax,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\nmov    %r14d,%edx\nmov    %r15d,%esi\nsub    %ebx,%esi\nlea    0x1(%rbx),%ecx\ntest   $0x1,%sil\nje     1418 <func0+0x2f8>\nlea    0x29dc(%rip),%rsi\nmov    (%rsi,%rbx,8),%rsi\nsub    %r14d,%edx\nmovslq %edx,%rdx\nmov    %rsi,(%rax,%rdx,8)\nmov    %ebx,%edx\nadd    $0x1,%rbx\ncmp    %ecx,%r15d\nje     13dd <func0+0x2bd>\nmov    %r15d,%r8d\nmov    %r14d,%edi\nneg    %edi\nlea    0x29b4(%rip),%r9\nmov    %rbx,%rcx\nnop\nsub    %r14d,%edx\nmovslq %edx,%rdx\nmov    (%r9,%rbx,8),%rsi\nmov    0x8(%r9,%rbx,8),%rbp\nmov    %rsi,(%rax,%rdx,8)\nlea    (%rdi,%rbx,1),%edx\nmovslq %edx,%rdx\nmov    %rbp,(%rax,%rdx,8)\nadd    $0x2,%rcx\nlea    0x1(%rbx),%edx\nmov    %rcx,%rbx\ncmp    %ecx,%r8d\njne    1430 <func0+0x310>\njmp    13dd <func0+0x2bd>\nxor    %ebp,%ebp\ntest   $0x1,%r9b\njne    13a7 <func0+0x287>\njmp    13c7 <func0+0x2a7>\n"
    },
    {
        "task_id": 148,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdx,(%rsp)\nmov    %rsi,%r15\nmov    %rdi,%r13\nlea    0xec4(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\nneg    %eax\nsbb    %r14d,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\nneg    %eax\nsbb    %ebp,%ebp\nlea    0xea6(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x1,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xe7f(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x2,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xe58(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x3,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xe30(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x4,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xe0b(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x5,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xde5(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x6,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nlea    0xdbf(%rip),%r12\nmov    %r12,%rdi\nmov    %r13,%rsi\ncall   1030 <strcmp@plt>\ntest   %eax,%eax\nmov    $0x7,%ebx\ncmove  %ebx,%r14d\nmov    %r12,%rdi\nmov    %r15,%rsi\ncall   1030 <strcmp@plt>\nmov    (%rsp),%rcx\ntest   %eax,%eax\ncmove  %ebx,%ebp\ncmp    $0xffffffff,%r14d\nje     13d5 <func0+0x2b5>\ncmp    $0xffffffff,%ebp\nje     13d5 <func0+0x2b5>\ncmp    %ebp,%r14d\nje     13d5 <func0+0x2b5>\nmov    %ebp,%r15d\ncmova  %r14d,%r15d\ncmova  %ebp,%r14d\nmov    %r14d,%eax\nnot    %eax\nadd    %r15d,%eax\nmov    %eax,(%rcx)\ntest   %eax,%eax\njle    13d5 <func0+0x2b5>\nmov    %eax,%edi\nshl    $0x3,%rdi\ncall   1040 <malloc@plt>\nlea    0x1(%r14),%ecx\ncmp    %r15d,%ecx\njae    13dd <func0+0x2bd>\nmov    %ecx,%ebx\nmov    %r15d,%ecx\nsub    %r14d,%ecx\nlea    -0x2(%rcx),%r10d\ncmp    $0x3,%r10d\njb     13ec <func0+0x2cc>\nadd    $0xfffffffe,%ecx\njs     13ec <func0+0x2cc>\nadd    $0x1,%r10\nmov    %r10,%r8\nand    $0xfffffffffffffffc,%r8\nlea    -0x4(%r8),%rcx\nmov    %rcx,%r9\nshr    $0x2,%r9\nadd    $0x1,%r9\ntest   %rcx,%rcx\nje     1461 <func0+0x341>\nmov    %r9,%rdi\nand    $0xfffffffffffffffe,%rdi\nlea    0x2aa5(%rip),%rcx\nlea    (%rcx,%rbx,8),%rsi\nadd    $0x30,%rsi\nxor    %ecx,%ecx\nmovabs $0x400000000,%r11\nmovabs $0x800000000,%r12\nxor    %ebp,%ebp\nnopl   0x0(%rax,%rax,1)\nmov    %rcx,%rdx\nsar    $0x1d,%rdx\nmovups -0x30(%rsi,%rbp,8),%xmm0\nmovups -0x20(%rsi,%rbp,8),%xmm1\nmovups -0x10(%rsi,%rbp,8),%xmm2\nmovups (%rsi,%rbp,8),%xmm3\nmovups %xmm0,(%rax,%rdx,1)\nmovups %xmm1,0x10(%rax,%rdx,1)\nlea    (%rcx,%r11,1),%rdx\nsar    $0x1d,%rdx\nmovups %xmm2,(%rax,%rdx,1)\nmovups %xmm3,0x10(%rax,%rdx,1)\nadd    $0x8,%rbp\nadd    %r12,%rcx\nadd    $0xfffffffffffffffe,%rdi\njne    1360 <func0+0x240>\ntest   $0x1,%r9b\nje     13c7 <func0+0x2a7>\nlea    (%rbx,%rbp,1),%rcx\nlea    0x2a2e(%rip),%rdx\nmovups (%rdx,%rcx,8),%xmm0\nmovups 0x10(%rdx,%rcx,8),%xmm1\nmovslq %ebp,%rcx\nmovups %xmm0,(%rax,%rcx,8)\nmovups %xmm1,0x10(%rax,%rcx,8)\ncmp    %r8,%r10\nje     13dd <func0+0x2bd>\nadd    %r8,%rbx\nlea    (%r14,%r8,1),%edx\njmp    13ef <func0+0x2cf>\nmovl   $0x0,(%rcx)\nxor    %eax,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\nmov    %r14d,%edx\nmov    %r15d,%esi\nsub    %ebx,%esi\nlea    0x1(%rbx),%ecx\ntest   $0x1,%sil\nje     1418 <func0+0x2f8>\nlea    0x29dc(%rip),%rsi\nmov    (%rsi,%rbx,8),%rsi\nsub    %r14d,%edx\nmovslq %edx,%rdx\nmov    %rsi,(%rax,%rdx,8)\nmov    %ebx,%edx\nadd    $0x1,%rbx\ncmp    %ecx,%r15d\nje     13dd <func0+0x2bd>\nmov    %r15d,%r8d\nmov    %r14d,%edi\nneg    %edi\nlea    0x29b4(%rip),%r9\nmov    %rbx,%rcx\nnop\nsub    %r14d,%edx\nmovslq %edx,%rdx\nmov    (%r9,%rbx,8),%rsi\nmov    0x8(%r9,%rbx,8),%rbp\nmov    %rsi,(%rax,%rdx,8)\nlea    (%rdi,%rbx,1),%edx\nmovslq %edx,%rdx\nmov    %rbp,(%rax,%rdx,8)\nadd    $0x2,%rcx\nlea    0x1(%rbx),%edx\nmov    %rcx,%rbx\ncmp    %ecx,%r8d\njne    1430 <func0+0x310>\njmp    13dd <func0+0x2bd>\nxor    %ebp,%ebp\ntest   $0x1,%r9b\njne    13a7 <func0+0x287>\njmp    13c7 <func0+0x2a7>\n"
    },
    {
        "task_id": 149,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    11b8 <func0+0x88>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\ncall   1030 <strlen@plt>\nand    $0x1,%rax\ncmp    $0x0,%rax\njne    11a5 <func0+0x75>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdx\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rcx\nmovslq (%rcx),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax)\njmp    11aa <func0+0x7a>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    1154 <func0+0x24>\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    -0x18(%rbp),%rcx\nmov    (%rcx),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    12cf <func0+0x19f>\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    -0x18(%rbp),%rcx\nmov    (%rcx),%ecx\nsub    -0x1c(%rbp),%ecx\nsub    $0x1,%ecx\ncmp    %ecx,%eax\njge    12bc <func0+0x18c>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,-0x30(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x20(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rdi\ncall   1030 <strlen@plt>\nmov    %rax,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nja     1267 <func0+0x137>\nmov    -0x30(%rbp),%rax\ncmp    -0x38(%rbp),%rax\njne    12a9 <func0+0x179>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nmov    -0x8(%rbp),%rax\nmov    -0x20(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\njle    12a9 <func0+0x179>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x20(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,8),%rdx\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x28(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nmov    -0x20(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %rdx,(%rax,%rcx,8)\njmp    12ae <func0+0x17e>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    11da <func0+0xaa>\njmp    12c1 <func0+0x191>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    11bf <func0+0x8f>\nmov    -0x18(%rbp),%rax\nmovslq (%rax),%rdi\nshl    $0x3,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    -0x18(%rbp),%rcx\ncmp    (%rcx),%eax\njge    131f <func0+0x1ef>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdx\nmov    -0x40(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmov    %rdx,(%rax,%rcx,8)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    12ea <func0+0x1ba>\nmov    -0x40(%rbp),%rax\nadd    $0x40,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 149,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdx,%r14\nmov    %rdi,(%rsp)\nmovl   $0x0,(%rdx)\ntest   %esi,%esi\njle    11a0 <func0+0x60>\nmov    %esi,%r12d\nxor    %ebp,%ebp\njmp    1179 <func0+0x39>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%rbp\ncmp    %rbp,%r12\nje     11a0 <func0+0x60>\nmov    (%rsp),%rax\nmov    (%rax,%rbp,8),%rbx\nmov    %rbx,%rdi\ncall   1030 <strlen@plt>\ntest   $0x1,%al\njne    1170 <func0+0x30>\nmovslq (%r14),%rax\nmov    (%rsp),%rcx\nmov    %rbx,(%rcx,%rax,8)\nadd    $0x1,%eax\nmov    %eax,(%r14)\njmp    1170 <func0+0x30>\nmovslq (%r14),%rbp\ncmp    $0x2,%rbp\njl     1262 <func0+0x122>\nlea    -0x1(%rbp),%eax\nxor    %ecx,%ecx\nmov    %eax,0xc(%rsp)\nmov    %eax,%edx\nmov    %rbp,0x10(%rsp)\nmov    (%rsp),%rbx\njmp    11e6 <func0+0xa6>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nmov    0x18(%rsp),%rcx\nadd    $0x1,%ecx\nadd    $0xffffffff,%edx\ncmp    0xc(%rsp),%ecx\nmov    0x10(%rsp),%rbp\nje     1262 <func0+0x122>\nmov    %edx,%edx\nmov    %rcx,0x18(%rsp)\nmov    %ecx,%eax\nnot    %eax\nadd    %ebp,%eax\ntest   %eax,%eax\njle    11d0 <func0+0x90>\nxor    %r13d,%r13d\nmov    %rdx,0x20(%rsp)\njmp    1227 <func0+0xe7>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmov    (%rsp),%rax\nmov    %r12,(%rax,%rbp,8)\nmov    %r14,0x8(%rax,%rbp,8)\nmov    0x20(%rsp),%rdx\ncmp    %r13,%rdx\nje     11d0 <func0+0x90>\nmov    %r13,%rbp\nmov    (%rbx,%r13,8),%r14\nmov    %r14,%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%r15\nadd    $0x1,%r13\nmov    0x8(%rbx,%rbp,8),%r12\nmov    %r12,%rdi\ncall   1030 <strlen@plt>\ncmp    %rax,%r15\nja     1210 <func0+0xd0>\njne    121d <func0+0xdd>\nmov    %r14,%rdi\nmov    %r12,%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njg     1210 <func0+0xd0>\njmp    121d <func0+0xdd>\nlea    0x0(,%rbp,8),%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rbx\ntest   %ebp,%ebp\njle    1288 <func0+0x148>\nmov    %ebp,%edx\nshl    $0x3,%rdx\nmov    %rbx,%rdi\nmov    (%rsp),%rsi\ncall   1050 <memcpy@plt>\nmov    %rbx,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 149,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmovl   $0x0,(%rdx)\ntest   %esi,%esi\nmov    %rdi,0x8(%rsp)\njle    126d <func0+0x12d>\nmov    %rdx,%r15\nmov    %rdi,%rbx\nmov    %esi,%r12d\nxor    %r13d,%r13d\nxor    %ebp,%ebp\njmp    1189 <func0+0x49>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rbp\ncmp    %rbp,%r12\nje     11a9 <func0+0x69>\nmov    (%rbx,%rbp,8),%r14\nmov    %r14,%rdi\ncall   1030 <strlen@plt>\ntest   $0x1,%al\njne    1180 <func0+0x40>\nmovslq %r13d,%r13\nmov    %r14,(%rbx,%r13,8)\nadd    $0x1,%r13d\nmov    %r13d,(%r15)\njmp    1180 <func0+0x40>\ncmp    $0x2,%r13d\njl     1277 <func0+0x137>\nmov    %r13,0x18(%rsp)\nlea    -0x1(%r13),%eax\nxor    %ecx,%ecx\nmov    %eax,0x14(%rsp)\nmov    %eax,%r13d\njmp    11e6 <func0+0xa6>\nnopw   0x0(%rax,%rax,1)\nmov    0x20(%rsp),%rcx\nadd    $0x1,%ecx\nadd    $0xffffffff,%r13d\ncmp    0x14(%rsp),%ecx\nje     1272 <func0+0x132>\nmov    %r13d,%r13d\nmov    %rcx,0x20(%rsp)\nmov    %ecx,%eax\nnot    %eax\nadd    0x18(%rsp),%eax\ntest   %eax,%eax\njle    11d0 <func0+0x90>\nmov    (%rbx),%r15\nxor    %r14d,%r14d\njmp    1226 <func0+0xe6>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rax\nmov    %rbx,(%rax,%rbp,8)\nmov    %rax,%rbx\nmov    %r15,0x8(%rax,%rbp,8)\ncmp    %r14,%r13\nje     11d0 <func0+0x90>\nmov    %r14,%rbp\nmov    %r15,%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%r12\nadd    $0x1,%r14\nmov    0x8(%rbx,%rbp,8),%rbx\nmov    %rbx,%rdi\ncall   1030 <strlen@plt>\ncmp    %rax,%r12\nja     1210 <func0+0xd0>\njne    125b <func0+0x11b>\nmov    %r15,%rdi\nmov    %rbx,%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njg     1210 <func0+0xd0>\nmov    %rbx,%r15\nmov    0x8(%rsp),%rbx\ncmp    %r14,%r13\njne    1226 <func0+0xe6>\njmp    11d0 <func0+0x90>\nxor    %r13d,%r13d\njmp    1277 <func0+0x137>\nmov    0x18(%rsp),%r13\nmovslq %r13d,%rbp\nlea    0x0(,%rbp,8),%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rbx\ntest   %ebp,%ebp\njle    12a2 <func0+0x162>\nmov    %r13d,%edx\nshl    $0x3,%rdx\nmov    %rbx,%rdi\nmov    0x8(%rsp),%rsi\ncall   1050 <memcpy@plt>\nmov    %rbx,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 149,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmovl   $0x0,(%rdx)\ntest   %esi,%esi\nmov    %rdi,0x8(%rsp)\njle    126d <func0+0x12d>\nmov    %rdx,%r15\nmov    %rdi,%rbx\nmov    %esi,%r12d\nxor    %r13d,%r13d\nxor    %ebp,%ebp\njmp    1189 <func0+0x49>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rbp\ncmp    %rbp,%r12\nje     11a9 <func0+0x69>\nmov    (%rbx,%rbp,8),%r14\nmov    %r14,%rdi\ncall   1030 <strlen@plt>\ntest   $0x1,%al\njne    1180 <func0+0x40>\nmovslq %r13d,%r13\nmov    %r14,(%rbx,%r13,8)\nadd    $0x1,%r13d\nmov    %r13d,(%r15)\njmp    1180 <func0+0x40>\ncmp    $0x2,%r13d\njl     1277 <func0+0x137>\nmov    %r13,0x18(%rsp)\nlea    -0x1(%r13),%eax\nxor    %ecx,%ecx\nmov    %eax,0x14(%rsp)\nmov    %eax,%r13d\njmp    11e6 <func0+0xa6>\nnopw   0x0(%rax,%rax,1)\nmov    0x20(%rsp),%rcx\nadd    $0x1,%ecx\nadd    $0xffffffff,%r13d\ncmp    0x14(%rsp),%ecx\nje     1272 <func0+0x132>\nmov    %r13d,%r13d\nmov    %rcx,0x20(%rsp)\nmov    %ecx,%eax\nnot    %eax\nadd    0x18(%rsp),%eax\ntest   %eax,%eax\njle    11d0 <func0+0x90>\nmov    (%rbx),%r15\nxor    %r14d,%r14d\njmp    1226 <func0+0xe6>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rax\nmov    %rbx,(%rax,%rbp,8)\nmov    %rax,%rbx\nmov    %r15,0x8(%rax,%rbp,8)\ncmp    %r14,%r13\nje     11d0 <func0+0x90>\nmov    %r14,%rbp\nmov    %r15,%rdi\ncall   1030 <strlen@plt>\nmov    %rax,%r12\nadd    $0x1,%r14\nmov    0x8(%rbx,%rbp,8),%rbx\nmov    %rbx,%rdi\ncall   1030 <strlen@plt>\ncmp    %rax,%r12\nja     1210 <func0+0xd0>\njne    125b <func0+0x11b>\nmov    %r15,%rdi\nmov    %rbx,%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njg     1210 <func0+0xd0>\nmov    %rbx,%r15\nmov    0x8(%rsp),%rbx\ncmp    %r14,%r13\njne    1226 <func0+0xe6>\njmp    11d0 <func0+0x90>\nxor    %r13d,%r13d\njmp    1277 <func0+0x137>\nmov    0x18(%rsp),%r13\nmovslq %r13d,%rbp\nlea    0x0(,%rbp,8),%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rbx\ntest   %ebp,%ebp\njle    12a2 <func0+0x162>\nmov    %r13d,%edx\nshl    $0x3,%rdx\nmov    %rbx,%rdi\nmov    0x8(%rsp),%rsi\ncall   1050 <memcpy@plt>\nmov    %rbx,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 150,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    %edx,-0x10(%rbp)\nmovl   $0x1,-0x14(%rbp)\ncmpl   $0x2,-0x8(%rbp)\njge    1125 <func0+0x25>\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x2,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nimul   -0x18(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njg     1166 <func0+0x66>\nmov    -0x8(%rbp),%eax\ncltd\nidivl  -0x18(%rbp)\ncmp    $0x0,%edx\njne    1153 <func0+0x53>\nmovl   $0x0,-0x14(%rbp)\njmp    1158 <func0+0x58>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    112c <func0+0x2c>\ncmpl   $0x0,-0x14(%rbp)\nje     117b <func0+0x7b>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\njmp    1181 <func0+0x81>\nmov    -0x10(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 150,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edx,%r8d\nmov    %esi,%r9d\nxor    %ecx,%ecx\ncmp    $0x2,%edi\nsetge  %cl\ncmp    $0x4,%edi\njl     1136 <func0+0x36>\nmov    $0x2,%esi\nnopl   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\ncmove  %edx,%ecx\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njle    1120 <func0+0x20>\ntest   %ecx,%ecx\ncmove  %r8d,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 150,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edx,%r8d\nmov    %esi,%r9d\nxor    %ecx,%ecx\ncmp    $0x2,%edi\nsetge  %cl\ncmp    $0x4,%edi\njl     1136 <func0+0x36>\nmov    $0x2,%esi\nnopl   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\ncmove  %edx,%ecx\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njle    1120 <func0+0x20>\ntest   %ecx,%ecx\ncmove  %r8d,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 150,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edx,%r8d\nmov    %esi,%r9d\nxor    %ecx,%ecx\ncmp    $0x2,%edi\nsetge  %cl\ncmp    $0x4,%edi\njl     1136 <func0+0x36>\nmov    $0x2,%esi\nnopl   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\ncmove  %edx,%ecx\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %edi,%eax\njle    1120 <func0+0x20>\ntest   %ecx,%ecx\ncmove  %r8d,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 151,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmovq   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    122f <func0+0x11f>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\ncall   1030 <round@plt>\nmovsd  -0x28(%rbp),%xmm1\nsubsd  %xmm0,%xmm1\nmovaps 0xe9a(%rip),%xmm0\npand   %xmm0,%xmm1\nmovsd  0xe7e(%rip),%xmm0\nucomisd %xmm1,%xmm0\njbe    121c <func0+0x10c>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\nxorps  %xmm1,%xmm1\nucomiss %xmm1,%xmm0\njbe    1217 <func0+0x107>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\ncall   1030 <round@plt>\ncvttsd2si %xmm0,%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x1,%edx\njne    1217 <func0+0x107>\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\ncall   1030 <round@plt>\ncvttsd2si %xmm0,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x1c(%rbp),%rcx\nmovss  (%rax,%rcx,4),%xmm0\ncvtss2sd %xmm0,%xmm0\ncall   1030 <round@plt>\nmov    -0x2c(%rbp),%eax\ncvttsd2si %xmm0,%ecx\nimul   %ecx,%eax\ncltq\nadd    -0x18(%rbp),%rax\nmov    %rax,-0x18(%rbp)\njmp    121c <func0+0x10c>\njmp    1221 <func0+0x111>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    112e <func0+0x1e>\nmov    -0x18(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 151,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\ntest   %esi,%esi\njle    11a1 <func0+0x91>\nmov    %rdi,%r15\nmov    %esi,%r12d\nxor    %ebx,%ebx\nxor    %r14d,%r14d\njmp    1139 <func0+0x29>\nadd    $0x1,%rbx\ncmp    %rbx,%r12\nje     11a4 <func0+0x94>\nmovss  (%r15,%rbx,4),%xmm0\nmovss  %xmm0,0xc(%rsp)\ncvtss2sd %xmm0,%xmm0\nmovaps %xmm0,0x10(%rsp)\ncall   1030 <round@plt>\nmovapd 0x10(%rsp),%xmm2\nsubsd  %xmm0,%xmm2\nandpd  0xe9b(%rip),%xmm2\nmovsd  0xea3(%rip),%xmm1\nucomisd %xmm2,%xmm1\njbe    1130 <func0+0x20>\nmovss  0xc(%rsp),%xmm1\nucomiss 0xe98(%rip),%xmm1\njbe    1130 <func0+0x20>\ncvttsd2si %xmm0,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nand    $0xfffffffe,%ecx\nmov    %eax,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\njne    1130 <func0+0x20>\nimul   %eax,%eax\nadd    %rax,%r14\njmp    1130 <func0+0x20>\nxor    %r14d,%r14d\nmov    %r14,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 151,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\ntest   %esi,%esi\njle    11a1 <func0+0x91>\nmov    %rdi,%r15\nmov    %esi,%r12d\nxor    %ebx,%ebx\nxor    %r14d,%r14d\njmp    1139 <func0+0x29>\nadd    $0x1,%rbx\ncmp    %rbx,%r12\nje     11a4 <func0+0x94>\nmovss  (%r15,%rbx,4),%xmm0\nmovss  %xmm0,0xc(%rsp)\ncvtss2sd %xmm0,%xmm0\nmovaps %xmm0,0x10(%rsp)\ncall   1030 <round@plt>\nmovapd 0x10(%rsp),%xmm2\nsubsd  %xmm0,%xmm2\nandpd  0xe9b(%rip),%xmm2\nmovsd  0xea3(%rip),%xmm1\nucomisd %xmm2,%xmm1\njbe    1130 <func0+0x20>\nmovss  0xc(%rsp),%xmm1\nucomiss 0xe98(%rip),%xmm1\njbe    1130 <func0+0x20>\ncvttsd2si %xmm0,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nand    $0xfffffffe,%ecx\nmov    %eax,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\njne    1130 <func0+0x20>\nimul   %eax,%eax\nadd    %rax,%r14\njmp    1130 <func0+0x20>\nxor    %r14d,%r14d\nmov    %r14,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 151,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r15\npush   %r14\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\ntest   %esi,%esi\njle    11a1 <func0+0x91>\nmov    %rdi,%r15\nmov    %esi,%r12d\nxor    %ebx,%ebx\nxor    %r14d,%r14d\njmp    1139 <func0+0x29>\nadd    $0x1,%rbx\ncmp    %rbx,%r12\nje     11a4 <func0+0x94>\nmovss  (%r15,%rbx,4),%xmm0\nmovss  %xmm0,0xc(%rsp)\ncvtss2sd %xmm0,%xmm0\nmovaps %xmm0,0x10(%rsp)\ncall   1030 <round@plt>\nmovapd 0x10(%rsp),%xmm2\nsubsd  %xmm0,%xmm2\nandpd  0xe9b(%rip),%xmm2\nmovsd  0xea3(%rip),%xmm1\nucomisd %xmm2,%xmm1\njbe    1130 <func0+0x20>\nmovss  0xc(%rsp),%xmm1\nucomiss 0xe98(%rip),%xmm1\njbe    1130 <func0+0x20>\ncvttsd2si %xmm0,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nand    $0xfffffffe,%ecx\nmov    %eax,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\njne    1130 <func0+0x20>\nimul   %eax,%eax\nadd    %rax,%r14\njmp    1130 <func0+0x20>\nxor    %r14d,%r14d\nmov    %r14,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 152,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %ecx,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njge    1170 <func0+0x60>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,4),%edi\nmov    -0x10(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nsub    (%rax,%rcx,4),%edi\ncall   1030 <abs@plt>\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    112e <func0+0x1e>\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 152,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ntest   %ecx,%ecx\njle    112d <func0+0x2d>\nmov    %ecx,%r8d\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nmov    (%rdi,%rcx,4),%r9d\nsub    (%rsi,%rcx,4),%r9d\nmov    %r9d,%eax\nneg    %eax\ncmovs  %r9d,%eax\nmov    %eax,(%rdx,%rcx,4)\nadd    $0x1,%rcx\ncmp    %rcx,%r8\njne    1110 <func0+0x10>\nret\n"
    },
    {
        "task_id": 152,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ntest   %ecx,%ecx\njle    121c <func0+0x11c>\nmov    %ecx,%r8d\ncmp    $0x8,%ecx\njae    1118 <func0+0x18>\nxor    %ebx,%ebx\njmp    11b9 <func0+0xb9>\nlea    (%rdx,%r8,4),%rcx\nlea    (%rdi,%r8,4),%rax\ncmp    %rdx,%rax\nseta   %r10b\nlea    (%rsi,%r8,4),%rax\ncmp    %rdi,%rcx\nseta   %r11b\ncmp    %rdx,%rax\nseta   %al\ncmp    %rsi,%rcx\nseta   %r9b\nxor    %ebx,%ebx\ntest   %r11b,%r10b\njne    11b9 <func0+0xb9>\nand    %r9b,%al\njne    11b9 <func0+0xb9>\nmov    %r8d,%ebx\nand    $0xfffffff8,%ebx\nlea    0x0(,%r8,4),%r9\nand    $0xffffffffffffffe0,%r9\nxor    %eax,%eax\nnop\nmovdqu (%rdi,%rax,1),%xmm0\nmovdqu 0x10(%rdi,%rax,1),%xmm1\nmovdqu (%rsi,%rax,1),%xmm2\npsubd  %xmm2,%xmm0\nmovdqu 0x10(%rsi,%rax,1),%xmm2\npsubd  %xmm2,%xmm1\nmovdqa %xmm0,%xmm2\npsrad  $0x1f,%xmm2\npaddd  %xmm2,%xmm0\npxor   %xmm2,%xmm0\nmovdqa %xmm1,%xmm2\npsrad  $0x1f,%xmm2\npaddd  %xmm2,%xmm1\npxor   %xmm2,%xmm1\nmovdqu %xmm0,(%rdx,%rax,1)\nmovdqu %xmm1,0x10(%rdx,%rax,1)\nadd    $0x20,%rax\ncmp    %rax,%r9\njne    1160 <func0+0x60>\ncmp    %r8,%rbx\nje     121c <func0+0x11c>\nmov    %rbx,%r10\nnot    %r10\ntest   $0x1,%r8b\nje     11dd <func0+0xdd>\nmov    (%rdi,%rbx,4),%r9d\nsub    (%rsi,%rbx,4),%r9d\nmov    %r9d,%eax\nneg    %eax\ncmovs  %r9d,%eax\nmov    %eax,(%rdx,%rbx,4)\nor     $0x1,%rbx\nadd    %r8,%r10\nje     121c <func0+0x11c>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    (%rdi,%rbx,4),%ecx\nsub    (%rsi,%rbx,4),%ecx\nmov    %ecx,%eax\nneg    %eax\ncmovs  %ecx,%eax\nmov    %eax,(%rdx,%rbx,4)\nmov    0x4(%rdi,%rbx,4),%eax\nsub    0x4(%rsi,%rbx,4),%eax\nmov    %eax,%ecx\nneg    %ecx\ncmovs  %eax,%ecx\nmov    %ecx,0x4(%rdx,%rbx,4)\nadd    $0x2,%rbx\ncmp    %rbx,%r8\njne    11f0 <func0+0xf0>\npop    %rbx\nret\n"
    },
    {
        "task_id": 152,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbx\ntest   %ecx,%ecx\njle    121c <func0+0x11c>\nmov    %ecx,%r8d\ncmp    $0x8,%ecx\njae    1118 <func0+0x18>\nxor    %ebx,%ebx\njmp    11b9 <func0+0xb9>\nlea    (%rdx,%r8,4),%rcx\nlea    (%rdi,%r8,4),%rax\ncmp    %rdx,%rax\nseta   %r10b\nlea    (%rsi,%r8,4),%rax\ncmp    %rdi,%rcx\nseta   %r11b\ncmp    %rdx,%rax\nseta   %al\ncmp    %rsi,%rcx\nseta   %r9b\nxor    %ebx,%ebx\ntest   %r11b,%r10b\njne    11b9 <func0+0xb9>\nand    %r9b,%al\njne    11b9 <func0+0xb9>\nmov    %r8d,%ebx\nand    $0xfffffff8,%ebx\nlea    0x0(,%r8,4),%r9\nand    $0xffffffffffffffe0,%r9\nxor    %eax,%eax\nnop\nmovdqu (%rdi,%rax,1),%xmm0\nmovdqu 0x10(%rdi,%rax,1),%xmm1\nmovdqu (%rsi,%rax,1),%xmm2\npsubd  %xmm2,%xmm0\nmovdqu 0x10(%rsi,%rax,1),%xmm2\npsubd  %xmm2,%xmm1\nmovdqa %xmm0,%xmm2\npsrad  $0x1f,%xmm2\npaddd  %xmm2,%xmm0\npxor   %xmm2,%xmm0\nmovdqa %xmm1,%xmm2\npsrad  $0x1f,%xmm2\npaddd  %xmm2,%xmm1\npxor   %xmm2,%xmm1\nmovdqu %xmm0,(%rdx,%rax,1)\nmovdqu %xmm1,0x10(%rdx,%rax,1)\nadd    $0x20,%rax\ncmp    %rax,%r9\njne    1160 <func0+0x60>\ncmp    %r8,%rbx\nje     121c <func0+0x11c>\nmov    %rbx,%r10\nnot    %r10\ntest   $0x1,%r8b\nje     11dd <func0+0xdd>\nmov    (%rdi,%rbx,4),%r9d\nsub    (%rsi,%rbx,4),%r9d\nmov    %r9d,%eax\nneg    %eax\ncmovs  %r9d,%eax\nmov    %eax,(%rdx,%rbx,4)\nor     $0x1,%rbx\nadd    %r8,%r10\nje     121c <func0+0x11c>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    (%rdi,%rbx,4),%ecx\nsub    (%rsi,%rbx,4),%ecx\nmov    %ecx,%eax\nneg    %eax\ncmovs  %ecx,%eax\nmov    %eax,(%rdx,%rbx,4)\nmov    0x4(%rdi,%rbx,4),%eax\nsub    0x4(%rsi,%rbx,4),%eax\nmov    %eax,%ecx\nneg    %ecx\ncmovs  %eax,%ecx\nmov    %ecx,0x4(%rdx,%rbx,4)\nadd    $0x2,%rbx\ncmp    %rbx,%r8\njne    11f0 <func0+0xf0>\npop    %rbx\nret\n"
    },
    {
        "task_id": 153,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    %rcx,-0x20(%rbp)\nmovl   $0xfffffc18,-0x24(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1210 <func0+0x100>\nmov    -0x10(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x44(%rbp)\nmovl   $0x0,-0x48(%rbp)\nmov    -0x40(%rbp),%rax\nmovslq -0x48(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     11e3 <func0+0xd3>\nmov    -0x40(%rbp),%rax\nmovslq -0x48(%rbp),%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x49(%rbp)\nmovsbl -0x49(%rbp),%eax\ncmp    $0x41,%eax\njl     11ad <func0+0x9d>\nmovsbl -0x49(%rbp),%eax\ncmp    $0x5a,%eax\njg     11ad <func0+0x9d>\nmov    -0x44(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x44(%rbp)\nmovsbl -0x49(%rbp),%eax\ncmp    $0x61,%eax\njl     11d0 <func0+0xc0>\nmovsbl -0x49(%rbp),%eax\ncmp    $0x7a,%eax\njg     11d0 <func0+0xc0>\nmov    -0x44(%rbp),%eax\nadd    $0xffffffff,%eax\nmov    %eax,-0x44(%rbp)\njmp    11d5 <func0+0xc5>\nmov    -0x48(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x48(%rbp)\njmp    1167 <func0+0x57>\nmov    -0x44(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    11fd <func0+0xed>\nmov    -0x44(%rbp),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x40(%rbp),%rax\nmov    %rax,-0x30(%rbp)\njmp    1202 <func0+0xf2>\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    113d <func0+0x2d>\nmov    -0x20(%rbp),%rdi\nmov    -0x8(%rbp),%rdx\nmov    -0x30(%rbp),%rcx\nlea    0xddd(%rip),%rsi\nmov    $0x0,%al\ncall   1030 <sprintf@plt>\nadd    $0x50,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 153,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %rdi,%r8\ntest   %edx,%edx\njle    1180 <func0+0x70>\nmov    %edx,%r9d\nmov    $0xfffffc18,%r14d\nxor    %edx,%edx\nxor    %r11d,%r11d\njmp    1144 <func0+0x34>\nnopl   0x0(%rax,%rax,1)\ncmp    %r14d,%eax\ncmovg  %r10,%r11\ncmovg  %eax,%r14d\nadd    $0x1,%rdx\ncmp    %r9,%rdx\nje     1183 <func0+0x73>\nmov    (%rsi,%rdx,8),%r10\nmov    (%r10),%bl\nmov    $0x0,%eax\ntest   %bl,%bl\nje     1130 <func0+0x20>\nlea    0x1(%r10),%rdi\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nlea    -0x41(%rbx),%ebp\ncmp    $0x1a,%bpl\nadc    $0x0,%eax\nadd    $0x9f,%bl\ncmp    $0x1a,%bl\nsbb    $0x0,%eax\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    1160 <func0+0x50>\njmp    1130 <func0+0x20>\nxor    %r11d,%r11d\nlea    0xe76(%rip),%rsi\nmov    %rcx,%rdi\nmov    %r8,%rdx\nmov    %r11,%rcx\nxor    %eax,%eax\ncall   1030 <sprintf@plt>\npop    %rbx\npop    %r14\npop    %rbp\nret\n"
    },
    {
        "task_id": 153,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %rdi,%r8\ntest   %edx,%edx\njle    1180 <func0+0x70>\nmov    %edx,%r9d\nmov    $0xfffffc18,%r14d\nxor    %edx,%edx\nxor    %r11d,%r11d\njmp    1144 <func0+0x34>\nnopl   0x0(%rax,%rax,1)\ncmp    %r14d,%eax\ncmovg  %r10,%r11\ncmovg  %eax,%r14d\nadd    $0x1,%rdx\ncmp    %r9,%rdx\nje     1183 <func0+0x73>\nmov    (%rsi,%rdx,8),%r10\nmov    (%r10),%bl\nmov    $0x0,%eax\ntest   %bl,%bl\nje     1130 <func0+0x20>\nlea    0x1(%r10),%rdi\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nlea    -0x41(%rbx),%ebp\ncmp    $0x1a,%bpl\nadc    $0x0,%eax\nadd    $0x9f,%bl\ncmp    $0x1a,%bl\nsbb    $0x0,%eax\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    1160 <func0+0x50>\njmp    1130 <func0+0x20>\nxor    %r11d,%r11d\nlea    0xe76(%rip),%rsi\nmov    %rcx,%rdi\nmov    %r8,%rdx\nmov    %r11,%rcx\nxor    %eax,%eax\npop    %rbx\npop    %r14\npop    %rbp\njmp    1030 <sprintf@plt>\n"
    },
    {
        "task_id": 153,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r14\npush   %rbx\nmov    %rdi,%r8\ntest   %edx,%edx\njle    1180 <func0+0x70>\nmov    %edx,%r9d\nmov    $0xfffffc18,%r14d\nxor    %edx,%edx\nxor    %r11d,%r11d\njmp    1144 <func0+0x34>\nnopl   0x0(%rax,%rax,1)\ncmp    %r14d,%eax\ncmovg  %r10,%r11\ncmovg  %eax,%r14d\nadd    $0x1,%rdx\ncmp    %r9,%rdx\nje     1183 <func0+0x73>\nmov    (%rsi,%rdx,8),%r10\nmov    (%r10),%bl\nmov    $0x0,%eax\ntest   %bl,%bl\nje     1130 <func0+0x20>\nlea    0x1(%r10),%rdi\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nlea    -0x41(%rbx),%ebp\ncmp    $0x1a,%bpl\nadc    $0x0,%eax\nadd    $0x9f,%bl\ncmp    $0x1a,%bl\nsbb    $0x0,%eax\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    1160 <func0+0x50>\njmp    1130 <func0+0x20>\nxor    %r11d,%r11d\nlea    0xe76(%rip),%rsi\nmov    %rcx,%rdi\nmov    %r8,%rdx\nmov    %r11,%rcx\nxor    %eax,%eax\npop    %rbx\npop    %r14\npop    %rbp\njmp    1030 <sprintf@plt>\n"
    },
    {
        "task_id": 154,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %rsi,-0x18(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %eax,-0x1c(%rbp)\nmov    -0x18(%rbp),%rdi\ncall   1050 <strlen@plt>\nmov    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nshl    $0x1,%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    1229 <func0+0xd9>\nmov    -0x28(%rbp),%rdi\nmov    -0x18(%rbp),%rsi\nmovslq -0x2c(%rbp),%rax\nadd    %rax,%rsi\nmov    -0x20(%rbp),%eax\nsub    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\ncall   1040 <strncpy@plt>\nmov    -0x28(%rbp),%rdi\nmovslq -0x20(%rbp),%rax\nadd    %rax,%rdi\nmovslq -0x2c(%rbp),%rcx\nxor    %eax,%eax\nsub    %rcx,%rax\nadd    %rax,%rdi\nmov    -0x18(%rbp),%rsi\nmovslq -0x2c(%rbp),%rdx\ncall   1040 <strncpy@plt>\nmov    -0x28(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmovb   $0x0,(%rax,%rcx,1)\nmov    -0x10(%rbp),%rdi\nmov    -0x28(%rbp),%rsi\ncall   1070 <strstr@plt>\ncmp    $0x0,%rax\nje     1216 <func0+0xc6>\nmov    -0x28(%rbp),%rdi\ncall   1030 <free@plt>\nmovb   $0x1,-0x1(%rbp)\njmp    1236 <func0+0xe6>\njmp    121b <func0+0xcb>\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    1194 <func0+0x44>\nmov    -0x28(%rbp),%rdi\ncall   1030 <free@plt>\nmovb   $0x0,-0x1(%rbp)\nmov    -0x1(%rbp),%al\nand    $0x1,%al\nmovzbl %al,%eax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 154,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,%r15\nmov    %rdi,0x10(%rsp)\nmov    %rsi,%rdi\ncall   1050 <strlen@plt>\nmov    %rax,%rbx\nadd    %eax,%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r13\ntest   %ebx,%ebx\nsetg   %r12b\njle    11ec <func0+0x9c>\nmovslq %ebx,%r14\nmov    %r14d,%eax\nmov    %rax,0x8(%rsp)\nxor    %ebp,%ebp\nmov    %r14,%rbx\nnopl   0x0(%rax)\nlea    (%r15,%rbp,1),%rsi\nmov    %r13,%rdi\nmov    %rbx,%rdx\ncall   1040 <strncpy@plt>\nlea    (%rbx,%r13,1),%rdi\nmov    %r15,%rsi\nmov    %rbp,%rdx\ncall   1040 <strncpy@plt>\nmovb   $0x0,0x0(%r13,%r14,1)\nmov    0x10(%rsp),%rdi\nmov    %r13,%rsi\ncall   1070 <strstr@plt>\ntest   %rax,%rax\njne    11ec <func0+0x9c>\nadd    $0x1,%rbp\ncmp    %r14,%rbp\nsetl   %r12b\nadd    $0xffffffffffffffff,%rbx\ncmp    %rbp,0x8(%rsp)\njne    11a0 <func0+0x50>\nmov    %r13,%rdi\ncall   1030 <free@plt>\nand    $0x1,%r12b\nmov    %r12d,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 154,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,%r15\nmov    %rdi,0x10(%rsp)\nmov    %rsi,%rdi\ncall   1050 <strlen@plt>\nmov    %rax,%rbx\nadd    %eax,%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r13\ntest   %ebx,%ebx\njle    11ee <func0+0x9e>\nmovslq %ebx,%r14\nmov    %r14d,%eax\nmov    %rax,0x8(%rsp)\nmov    $0x1,%r12b\nxor    %ebp,%ebp\nmov    %r14,%rbx\nnopl   0x0(%rax,%rax,1)\nlea    (%r15,%rbp,1),%rsi\nmov    %r13,%rdi\nmov    %rbx,%rdx\ncall   1040 <strncpy@plt>\nlea    (%rbx,%r13,1),%rdi\nmov    %r15,%rsi\nmov    %rbp,%rdx\ncall   1040 <strncpy@plt>\nmovb   $0x0,0x0(%r13,%r14,1)\nmov    0x10(%rsp),%rdi\nmov    %r13,%rsi\ncall   1070 <strstr@plt>\ntest   %rax,%rax\njne    11f1 <func0+0xa1>\nadd    $0x1,%rbp\ncmp    %r14,%rbp\nsetl   %r12b\nadd    $0xffffffffffffffff,%rbx\ncmp    %rbp,0x8(%rsp)\njne    11a0 <func0+0x50>\njmp    11f1 <func0+0xa1>\nxor    %r12d,%r12d\nmov    %r13,%rdi\ncall   1030 <free@plt>\nand    $0x1,%r12b\nmov    %r12d,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 154,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,%r15\nmov    %rdi,0x10(%rsp)\nmov    %rsi,%rdi\ncall   1050 <strlen@plt>\nmov    %rax,%rbx\nadd    %eax,%eax\nadd    $0x1,%eax\nmovslq %eax,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r13\ntest   %ebx,%ebx\njle    11ee <func0+0x9e>\nmovslq %ebx,%r14\nmov    %r14d,%eax\nmov    %rax,0x8(%rsp)\nmov    $0x1,%r12b\nxor    %ebp,%ebp\nmov    %r14,%rbx\nnopl   0x0(%rax,%rax,1)\nlea    (%r15,%rbp,1),%rsi\nmov    %r13,%rdi\nmov    %rbx,%rdx\ncall   1040 <strncpy@plt>\nlea    (%rbx,%r13,1),%rdi\nmov    %r15,%rsi\nmov    %rbp,%rdx\ncall   1040 <strncpy@plt>\nmovb   $0x0,0x0(%r13,%r14,1)\nmov    0x10(%rsp),%rdi\nmov    %r13,%rsi\ncall   1070 <strstr@plt>\ntest   %rax,%rax\njne    11f1 <func0+0xa1>\nadd    $0x1,%rbp\ncmp    %r14,%rbp\nsetl   %r12b\nadd    $0xffffffffffffffff,%rbx\ncmp    %rbp,0x8(%rsp)\njne    11a0 <func0+0x50>\njmp    11f1 <func0+0xa1>\nxor    %r12d,%r12d\nmov    %r13,%rdi\ncall   1030 <free@plt>\nand    $0x1,%r12b\nmov    %r12d,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 155,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x4(%rbp),%edi\ncall   1030 <abs@plt>\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %edx,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    1168 <func0+0x58>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1171 <func0+0x61>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x4(%rbp),%eax\nmov    $0xa,%ecx\ncltd\nidiv   %ecx\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njg     1138 <func0+0x28>\nmov    -0x14(%rbp),%ecx\nmov    -0x10(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x18(%rbp),%ecx\nmov    -0x10(%rbp),%rax\nmov    %ecx,0x4(%rax)\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 155,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\nneg    %eax\ncmovs  %edi,%eax\nxor    %ecx,%ecx\nxor    %edx,%edx\nnopl   0x0(%rax,%rax,1)\nmovslq %eax,%r8\nand    $0x1,%eax\nadd    %eax,%edx\nxor    $0x1,%eax\nadd    %eax,%ecx\nimul   $0x66666667,%r8,%rax\nmov    %rax,%rdi\nshr    $0x3f,%rdi\nsar    $0x22,%rax\nadd    %edi,%eax\ncmp    $0x9,%r8d\njg     1110 <func0+0x10>\nmov    %ecx,(%rsi)\nmov    %edx,0x4(%rsi)\nret\n"
    },
    {
        "task_id": 155,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\nneg    %eax\ncmovs  %edi,%eax\nxor    %ecx,%ecx\nxor    %edx,%edx\nnopl   0x0(%rax,%rax,1)\nmovslq %eax,%r8\nand    $0x1,%eax\nadd    %eax,%edx\nxor    $0x1,%eax\nadd    %eax,%ecx\nimul   $0x66666667,%r8,%rax\nmov    %rax,%rdi\nshr    $0x3f,%rdi\nsar    $0x22,%rax\nadd    %edi,%eax\ncmp    $0x9,%r8d\njg     1110 <func0+0x10>\nmov    %ecx,(%rsi)\nmov    %edx,0x4(%rsi)\nret\n"
    },
    {
        "task_id": 155,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edi,%eax\nneg    %eax\ncmovs  %edi,%eax\nxor    %ecx,%ecx\nxor    %edx,%edx\nnopl   0x0(%rax,%rax,1)\nmovslq %eax,%r8\nand    $0x1,%eax\nadd    %eax,%edx\nxor    $0x1,%eax\nadd    %eax,%ecx\nimul   $0x66666667,%r8,%rax\nmov    %rax,%rdi\nshr    $0x3f,%rdi\nsar    $0x22,%rax\nadd    %edi,%eax\ncmp    $0x9,%r8d\njg     1110 <func0+0x10>\nmov    %ecx,(%rsi)\nmov    %edx,0x4(%rsi)\nret\n"
    },
    {
        "task_id": 156,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xd0,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nlea    -0x80(%rbp),%rdi\nlea    0x2c73(%rip),%rsi\nmov    $0x68,%edx\ncall   1030 <memcpy@plt>\nlea    -0xc0(%rbp),%rdi\nlea    0xecb(%rip),%rsi\nmov    $0x34,%edx\ncall   1030 <memcpy@plt>\nmovl   $0x0,-0xc4(%rbp)\nmov    -0x10(%rbp),%rax\nmovb   $0x0,(%rax)\ncmpl   $0x0,-0x4(%rbp)\njle    11e4 <func0+0xc4>\njmp    117f <func0+0x5f>\nmov    -0x4(%rbp),%eax\nmovslq -0xc4(%rbp),%rcx\ncmp    -0xc0(%rbp,%rcx,4),%eax\njl     11c6 <func0+0xa6>\nmov    -0x10(%rbp),%rdi\nmovslq -0xc4(%rbp),%rax\nmov    -0x80(%rbp,%rax,8),%rsi\ncall   1040 <strcat@plt>\nmovslq -0xc4(%rbp),%rax\nmov    -0xc0(%rbp,%rax,4),%ecx\nmov    -0x4(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\njmp    117f <func0+0x5f>\ncmpl   $0x0,-0x4(%rbp)\njle    11df <func0+0xbf>\nmov    -0xc4(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc4(%rbp)\njmp    1170 <func0+0x50>\nadd    $0xd0,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 156,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmovb   $0x0,(%rsi)\ntest   %edi,%edi\njle    1185 <func0+0x75>\nmov    %rsi,%r14\nmov    %edi,%ebp\nxor    %eax,%eax\nlea    0xef0(%rip),%r12\njmp    114e <func0+0x3e>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nxor    %eax,%eax\ntest   %ebp,%ebp\nsetg   %al\nadd    %r13d,%eax\ntest   %ebp,%ebp\njle    1185 <func0+0x75>\nmov    %eax,%r13d\nlea    0xf08(%rip),%rax\nmov    (%rax,%r13,4),%r15d\ncmp    %r15d,%ebp\njl     1140 <func0+0x30>\nmovslq (%r12,%r13,4),%rbx\nadd    %r12,%rbx\nnopl   0x0(%rax,%rax,1)\nmov    %r14,%rdi\nmov    %rbx,%rsi\ncall   1030 <strcat@plt>\nsub    %r15d,%ebp\ncmp    %r15d,%ebp\njge    1170 <func0+0x60>\njmp    1140 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 156,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmovb   $0x0,(%rsi)\ntest   %edi,%edi\njle    1185 <func0+0x75>\nmov    %rsi,%r14\nmov    %edi,%ebp\nxor    %eax,%eax\nlea    0xef0(%rip),%r12\njmp    114e <func0+0x3e>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nxor    %eax,%eax\ntest   %ebp,%ebp\nsetg   %al\nadd    %r13d,%eax\ntest   %ebp,%ebp\njle    1185 <func0+0x75>\nmov    %eax,%r13d\nlea    0xf08(%rip),%rax\nmov    (%rax,%r13,4),%r15d\ncmp    %r15d,%ebp\njl     1140 <func0+0x30>\nmovslq (%r12,%r13,4),%rbx\nadd    %r12,%rbx\nnopl   0x0(%rax,%rax,1)\nmov    %r14,%rdi\nmov    %rbx,%rsi\ncall   1030 <strcat@plt>\nsub    %r15d,%ebp\ncmp    %r15d,%ebp\njge    1170 <func0+0x60>\njmp    1140 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 156,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmovb   $0x0,(%rsi)\ntest   %edi,%edi\njle    1185 <func0+0x75>\nmov    %rsi,%r14\nmov    %edi,%ebp\nxor    %eax,%eax\nlea    0xef0(%rip),%r12\njmp    114e <func0+0x3e>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nxor    %eax,%eax\ntest   %ebp,%ebp\nsetg   %al\nadd    %r13d,%eax\ntest   %ebp,%ebp\njle    1185 <func0+0x75>\nmov    %eax,%r13d\nlea    0xf08(%rip),%rax\nmov    (%rax,%r13,4),%r15d\ncmp    %r15d,%ebp\njl     1140 <func0+0x30>\nmovslq (%r12,%r13,4),%rbx\nadd    %r12,%rbx\nnopl   0x0(%rax,%rax,1)\nmov    %r14,%rdi\nmov    %rbx,%rsi\ncall   1030 <strcat@plt>\nsub    %r15d,%ebp\ncmp    %r15d,%ebp\njge    1170 <func0+0x60>\njmp    1140 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 157,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x8(%rbp)\nmovss  %xmm1,-0xc(%rbp)\nmovss  %xmm2,-0x10(%rbp)\nmovss  -0x8(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm2\nmovss  -0xc(%rbp),%xmm0\nmulss  -0xc(%rbp),%xmm0\nmulss  %xmm2,%xmm1\naddss  %xmm0,%xmm1\nmovss  -0x10(%rbp),%xmm0\nmovss  -0x10(%rbp),%xmm2\nmovd   %xmm0,%eax\nxor    $0x80000000,%eax\nmovd   %eax,%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm1\nmovaps 0xeb7(%rip),%xmm0\npand   %xmm0,%xmm1\nmovsd  0xe9b(%rip),%xmm0\nucomisd %xmm1,%xmm0\nja     1227 <func0+0x127>\nmovss  -0x8(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm2\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmulss  %xmm2,%xmm1\naddss  %xmm0,%xmm1\nmovss  -0xc(%rbp),%xmm0\nmovss  -0xc(%rbp),%xmm2\nmovd   %xmm0,%eax\nxor    $0x80000000,%eax\nmovd   %eax,%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm1\nmovaps 0xe5b(%rip),%xmm0\npand   %xmm0,%xmm1\nmovsd  0xe3f(%rip),%xmm0\nucomisd %xmm1,%xmm0\nja     1227 <func0+0x127>\nmovss  -0xc(%rbp),%xmm1\nmovss  -0xc(%rbp),%xmm2\nmovss  -0x10(%rbp),%xmm0\nmulss  -0x10(%rbp),%xmm0\nmulss  %xmm2,%xmm1\naddss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\nmovss  -0x8(%rbp),%xmm2\nmovd   %xmm0,%eax\nxor    $0x80000000,%eax\nmovd   %eax,%xmm0\nmulss  %xmm2,%xmm0\naddss  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm1\nmovaps 0xdff(%rip),%xmm0\npand   %xmm0,%xmm1\nmovsd  0xde3(%rip),%xmm0\nucomisd %xmm1,%xmm0\njbe    1233 <func0+0x133>\nmovl   $0x1,-0x4(%rbp)\njmp    123a <func0+0x13a>\nmovl   $0x0,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 157,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmulss  %xmm1,%xmm1\nmulss  %xmm0,%xmm0\nmovaps %xmm0,%xmm3\naddss  %xmm1,%xmm3\nmulss  %xmm2,%xmm2\nsubss  %xmm2,%xmm3\nandps  0xee2(%rip),%xmm3\ncvtss2sd %xmm3,%xmm4\nmov    $0x1,%eax\nmovsd  0xee1(%rip),%xmm3\nucomisd %xmm4,%xmm3\nja     116f <func0+0x6f>\nmovaps %xmm0,%xmm4\naddss  %xmm2,%xmm4\nsubss  %xmm1,%xmm4\nandps  0xeb9(%rip),%xmm4\ncvtss2sd %xmm4,%xmm4\nucomisd %xmm4,%xmm3\nja     116f <func0+0x6f>\naddss  %xmm2,%xmm1\nsubss  %xmm0,%xmm1\nandps  0xea0(%rip),%xmm1\nxorps  %xmm0,%xmm0\ncvtss2sd %xmm1,%xmm0\nucomisd %xmm0,%xmm3\nja     116f <func0+0x6f>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 157,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmulss  %xmm1,%xmm1\nmulss  %xmm0,%xmm0\nmovaps %xmm0,%xmm3\naddss  %xmm1,%xmm3\nmulss  %xmm2,%xmm2\nsubss  %xmm2,%xmm3\nandps  0xee2(%rip),%xmm3\ncvtss2sd %xmm3,%xmm4\nmov    $0x1,%eax\nmovsd  0xee1(%rip),%xmm3\nucomisd %xmm4,%xmm3\nja     116f <func0+0x6f>\nmovaps %xmm0,%xmm4\naddss  %xmm2,%xmm4\nsubss  %xmm1,%xmm4\nandps  0xeb9(%rip),%xmm4\ncvtss2sd %xmm4,%xmm4\nucomisd %xmm4,%xmm3\nja     116f <func0+0x6f>\naddss  %xmm2,%xmm1\nsubss  %xmm0,%xmm1\nandps  0xea0(%rip),%xmm1\nxorps  %xmm0,%xmm0\ncvtss2sd %xmm1,%xmm0\nucomisd %xmm0,%xmm3\nja     116f <func0+0x6f>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 157,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmulss  %xmm1,%xmm1\nmulss  %xmm0,%xmm0\nmovaps %xmm0,%xmm3\naddss  %xmm1,%xmm3\nmulss  %xmm2,%xmm2\nsubss  %xmm2,%xmm3\nandps  0xee2(%rip),%xmm3\ncvtss2sd %xmm3,%xmm4\nmov    $0x1,%eax\nmovsd  0xee1(%rip),%xmm3\nucomisd %xmm4,%xmm3\nja     116f <func0+0x6f>\nmovaps %xmm0,%xmm4\naddss  %xmm2,%xmm4\nsubss  %xmm1,%xmm4\nandps  0xeb9(%rip),%xmm4\ncvtss2sd %xmm4,%xmm4\nucomisd %xmm4,%xmm3\nja     116f <func0+0x6f>\naddss  %xmm2,%xmm1\nsubss  %xmm0,%xmm1\nandps  0xea0(%rip),%xmm1\nxorps  %xmm0,%xmm0\ncvtss2sd %xmm1,%xmm0\nucomisd %xmm0,%xmm3\nja     116f <func0+0x6f>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 158,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x130,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nlea    0xea7(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    12c4 <func0+0x184>\nlea    -0x120(%rbp),%rdi\nxor    %esi,%esi\nmov    $0x100,%edx\ncall   1050 <memset@plt>\nmovl   $0x0,-0x124(%rbp)\nmovl   $0x0,-0x128(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x128(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     125c <func0+0x11c>\nlea    -0x120(%rbp),%rdi\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x128(%rbp),%rcx\nmovsbl (%rax,%rcx,1),%esi\ncall   1040 <strchr@plt>\ncmp    $0x0,%rax\njne    1243 <func0+0x103>\nlea    -0x120(%rbp),%rdi\ncall   1030 <strlen@plt>\nmov    %eax,-0x12c(%rbp)\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmovslq -0x128(%rbp),%rcx\nmov    (%rax,%rcx,1),%cl\nmovslq -0x12c(%rbp),%rax\nmov    %cl,-0x120(%rbp,%rax,1)\nmov    -0x12c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmovb   $0x0,-0x120(%rbp,%rax,1)\nmov    -0x124(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x124(%rbp)\njmp    1248 <func0+0x108>\nmov    -0x128(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x128(%rbp)\njmp    119e <func0+0x5e>\nmov    -0x124(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njg     1298 <func0+0x158>\nmov    -0x124(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njne    12b1 <func0+0x171>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nmov    -0x18(%rbp),%rsi\ncall   1060 <strcmp@plt>\ncmp    $0x0,%eax\njge    12b1 <func0+0x171>\nmov    -0x8(%rbp),%rax\nmovslq -0x20(%rbp),%rcx\nmov    (%rax,%rcx,8),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x124(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\njmp    12b6 <func0+0x176>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    116b <func0+0x2b>\nmov    -0x18(%rbp),%rax\nadd    $0x130,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 158,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x128,%rsp\nmov    %rdi,0x18(%rsp)\ntest   %esi,%esi\njle    129b <func0+0x16b>\nmov    %esi,%eax\nmov    %rax,0x10(%rsp)\nxor    %ebp,%ebp\nlea    0xea2(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x20(%rsp),%rbx\nmovl   $0x0,0x4(%rsp)\njmp    1199 <func0+0x69>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %r14d,0x4(%rsp)\nmov    %r12,0x8(%rsp)\nadd    $0x1,%rbp\ncmp    0x10(%rsp),%rbp\nje     12a7 <func0+0x177>\nxorps  %xmm0,%xmm0\nmovaps %xmm0,0x110(%rsp)\nmovaps %xmm0,0x100(%rsp)\nmovaps %xmm0,0xf0(%rsp)\nmovaps %xmm0,0xe0(%rsp)\nmovaps %xmm0,0xd0(%rsp)\nmovaps %xmm0,0xc0(%rsp)\nmovaps %xmm0,0xb0(%rsp)\nmovaps %xmm0,0xa0(%rsp)\nmovaps %xmm0,0x90(%rsp)\nmovaps %xmm0,0x80(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmov    0x18(%rsp),%rax\nmov    (%rax,%rbp,8),%r12\nmov    (%r12),%r13b\nmov    $0x0,%r14d\ntest   %r13b,%r13b\nje     1270 <func0+0x140>\nlea    0x1(%r12),%r15\nxor    %r14d,%r14d\njmp    123d <func0+0x10d>\nnopl   0x0(%rax)\nmovzbl (%r15),%r13d\nadd    $0x1,%r15\ntest   %r13b,%r13b\nje     1270 <func0+0x140>\nmovsbl %r13b,%esi\nmov    %rbx,%rdi\ncall   1040 <strchr@plt>\ntest   %rax,%rax\njne    1230 <func0+0x100>\nmov    %rbx,%rdi\ncall   1030 <strlen@plt>\ncltq\nmov    %r13b,0x20(%rsp,%rax,1)\nadd    $0x1,%eax\ncltq\nmovb   $0x0,0x20(%rsp,%rax,1)\nadd    $0x1,%r14d\njmp    1230 <func0+0x100>\nnopl   (%rax)\ncmp    0x4(%rsp),%r14d\njg     1180 <func0+0x50>\njne    118a <func0+0x5a>\nmov    %r12,%rdi\nmov    0x8(%rsp),%rsi\ncall   1050 <strcmp@plt>\ntest   %eax,%eax\njs     1180 <func0+0x50>\njmp    118a <func0+0x5a>\nlea    0xd5e(%rip),%rax\nmov    %rax,0x8(%rsp)\nmov    0x8(%rsp),%rax\nadd    $0x128,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 158,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x128,%rsp\nmov    %rdi,0x18(%rsp)\ntest   %esi,%esi\njle    129b <func0+0x16b>\nmov    %esi,%eax\nmov    %rax,0x10(%rsp)\nxor    %ebp,%ebp\nlea    0xea2(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x20(%rsp),%rbx\nmovl   $0x0,0x4(%rsp)\njmp    1199 <func0+0x69>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %r14d,0x4(%rsp)\nmov    %r12,0x8(%rsp)\nadd    $0x1,%rbp\ncmp    0x10(%rsp),%rbp\nje     12a7 <func0+0x177>\nxorps  %xmm0,%xmm0\nmovaps %xmm0,0x110(%rsp)\nmovaps %xmm0,0x100(%rsp)\nmovaps %xmm0,0xf0(%rsp)\nmovaps %xmm0,0xe0(%rsp)\nmovaps %xmm0,0xd0(%rsp)\nmovaps %xmm0,0xc0(%rsp)\nmovaps %xmm0,0xb0(%rsp)\nmovaps %xmm0,0xa0(%rsp)\nmovaps %xmm0,0x90(%rsp)\nmovaps %xmm0,0x80(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmov    0x18(%rsp),%rax\nmov    (%rax,%rbp,8),%r12\nmov    (%r12),%r13b\nmov    $0x0,%r14d\ntest   %r13b,%r13b\nje     1270 <func0+0x140>\nlea    0x1(%r12),%r15\nxor    %r14d,%r14d\njmp    123d <func0+0x10d>\nnopl   0x0(%rax)\nmovzbl (%r15),%r13d\nadd    $0x1,%r15\ntest   %r13b,%r13b\nje     1270 <func0+0x140>\nmovsbl %r13b,%esi\nmov    %rbx,%rdi\ncall   1040 <strchr@plt>\ntest   %rax,%rax\njne    1230 <func0+0x100>\nmov    %rbx,%rdi\ncall   1030 <strlen@plt>\ncltq\nmov    %r13b,0x20(%rsp,%rax,1)\nadd    $0x1,%eax\ncltq\nmovb   $0x0,0x20(%rsp,%rax,1)\nadd    $0x1,%r14d\njmp    1230 <func0+0x100>\nnopl   (%rax)\ncmp    0x4(%rsp),%r14d\njg     1180 <func0+0x50>\njne    118a <func0+0x5a>\nmov    %r12,%rdi\nmov    0x8(%rsp),%rsi\ncall   1050 <strcmp@plt>\ntest   %eax,%eax\njs     1180 <func0+0x50>\njmp    118a <func0+0x5a>\nlea    0xd5e(%rip),%rax\nmov    %rax,0x8(%rsp)\nmov    0x8(%rsp),%rax\nadd    $0x128,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 158,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x128,%rsp\nmov    %rdi,0x18(%rsp)\ntest   %esi,%esi\njle    129b <func0+0x16b>\nmov    %esi,%eax\nmov    %rax,0x10(%rsp)\nxor    %ebp,%ebp\nlea    0xea2(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x20(%rsp),%rbx\nmovl   $0x0,0x4(%rsp)\njmp    1199 <func0+0x69>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %r14d,0x4(%rsp)\nmov    %r12,0x8(%rsp)\nadd    $0x1,%rbp\ncmp    0x10(%rsp),%rbp\nje     12a7 <func0+0x177>\nxorps  %xmm0,%xmm0\nmovaps %xmm0,0x110(%rsp)\nmovaps %xmm0,0x100(%rsp)\nmovaps %xmm0,0xf0(%rsp)\nmovaps %xmm0,0xe0(%rsp)\nmovaps %xmm0,0xd0(%rsp)\nmovaps %xmm0,0xc0(%rsp)\nmovaps %xmm0,0xb0(%rsp)\nmovaps %xmm0,0xa0(%rsp)\nmovaps %xmm0,0x90(%rsp)\nmovaps %xmm0,0x80(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmov    0x18(%rsp),%rax\nmov    (%rax,%rbp,8),%r12\nmov    (%r12),%r13b\nmov    $0x0,%r14d\ntest   %r13b,%r13b\nje     1270 <func0+0x140>\nlea    0x1(%r12),%r15\nxor    %r14d,%r14d\njmp    123d <func0+0x10d>\nnopl   0x0(%rax)\nmovzbl (%r15),%r13d\nadd    $0x1,%r15\ntest   %r13b,%r13b\nje     1270 <func0+0x140>\nmovsbl %r13b,%esi\nmov    %rbx,%rdi\ncall   1040 <strchr@plt>\ntest   %rax,%rax\njne    1230 <func0+0x100>\nmov    %rbx,%rdi\ncall   1030 <strlen@plt>\ncltq\nmov    %r13b,0x20(%rsp,%rax,1)\nadd    $0x1,%eax\ncltq\nmovb   $0x0,0x20(%rsp,%rax,1)\nadd    $0x1,%r14d\njmp    1230 <func0+0x100>\nnopl   (%rax)\ncmp    0x4(%rsp),%r14d\njg     1180 <func0+0x50>\njne    118a <func0+0x5a>\nmov    %r12,%rdi\nmov    0x8(%rsp),%rsi\ncall   1050 <strcmp@plt>\ntest   %eax,%eax\njs     1180 <func0+0x50>\njmp    118a <func0+0x5a>\nlea    0xd5e(%rip),%rax\nmov    %rax,0x8(%rsp)\nmov    0x8(%rsp),%rax\nadd    $0x128,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 159,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    %rcx,-0x18(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njle    1139 <func0+0x39>\nmov    -0x4(%rbp),%ecx\nadd    -0xc(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0x18(%rbp),%rax\nmovl   $0x0,0x4(%rax)\njmp    1152 <func0+0x52>\nmov    -0x4(%rbp),%ecx\nadd    -0x8(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,(%rax)\nmov    -0xc(%rbp),%ecx\nsub    -0x8(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,0x4(%rax)\npop    %rbp\nret\n"
    },
    {
        "task_id": 159,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edx,%eax\nsub    %esi,%eax\njge    1110 <func0+0x10>\nadd    %edi,%edx\nmov    %edx,(%rcx)\nxor    %eax,%eax\nmov    %eax,0x4(%rcx)\nret\nadd    %edi,%esi\nmov    %esi,(%rcx)\nmov    %eax,0x4(%rcx)\nret\n"
    },
    {
        "task_id": 159,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edx,%eax\nsub    %esi,%eax\njge    1110 <func0+0x10>\nadd    %edi,%edx\nmov    %edx,(%rcx)\nxor    %eax,%eax\nmov    %eax,0x4(%rcx)\nret\nadd    %edi,%esi\nmov    %esi,(%rcx)\nmov    %eax,0x4(%rcx)\nret\n"
    },
    {
        "task_id": 159,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nmov    %edx,%eax\nsub    %esi,%eax\njge    1110 <func0+0x10>\nadd    %edi,%edx\nmov    %edx,(%rcx)\nxor    %eax,%eax\nmov    %eax,0x4(%rcx)\nret\nadd    %edi,%esi\nmov    %esi,(%rcx)\nmov    %eax,0x4(%rcx)\nret\n"
    },
    {
        "task_id": 160,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    %ecx,-0x18(%rbp)\nmovslq -0x18(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmovslq -0x18(%rbp),%rdi\nshl    $0x2,%rdi\ncall   1050 <malloc@plt>\nmov    %rax,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njge    11bd <func0+0x7d>\nmov    -0x10(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x20(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x2c(%rbp),%edx\nmov    -0x28(%rbp),%rax\nmovslq -0x2c(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\njmp    117f <func0+0x3f>\nmovl   $0x0,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1316 <func0+0x1d6>\nmov    -0x8(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nlea    0xe1d(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\njne    1303 <func0+0x1c3>\njmp    11f6 <func0+0xb6>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x30(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x28(%rbp),%rcx\nmovslq -0x30(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\nje     123d <func0+0xfd>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x30(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x28(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    11f6 <func0+0xb6>\njmp    1242 <func0+0x102>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x30(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x28(%rbp),%rcx\nmov    -0x30(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\nje     129d <func0+0x15d>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x30(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x28(%rbp),%rax\nmov    -0x30(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1242 <func0+0x102>\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x30(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\ncvtsi2sdl (%rax,%rcx,4),%xmm0\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x30(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\ncvtsi2sdl (%rax,%rcx,4),%xmm1\ncall   1060 <pow@plt>\ncvttsd2si %xmm0,%edx\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x30(%rbp),%rsi\nmovslq (%rcx,%rsi,4),%rcx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x28(%rbp),%rax\nmovslq -0x30(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x28(%rbp),%rax\nmov    -0x30(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1308 <func0+0x1c8>\nmov    -0x30(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x30(%rbp)\njmp    11c4 <func0+0x84>\nmovl   $0x0,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    14d5 <func0+0x395>\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nlea    0xcc5(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\nje     136b <func0+0x22b>\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nlea    0xca6(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\njne    14c2 <func0+0x382>\njmp    1370 <func0+0x230>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x34(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x28(%rbp),%rcx\nmovslq -0x34(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\nje     13b7 <func0+0x277>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x34(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x28(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1370 <func0+0x230>\njmp    13bc <func0+0x27c>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x34(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x28(%rbp),%rcx\nmov    -0x34(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\nje     1417 <func0+0x2d7>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x34(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x28(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    13bc <func0+0x27c>\nmov    -0x8(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nlea    0xbd7(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\njne    146c <func0+0x32c>\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x34(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x34(%rbp),%rsi\nmovslq (%rcx,%rsi,4),%rcx\nimul   (%rax,%rcx,4),%edx\nmov    %edx,(%rax,%rcx,4)\njmp    14a7 <func0+0x367>\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x34(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%esi\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x48(%rbp)\nmov    -0x28(%rbp),%rcx\nmovslq -0x34(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%eax\ncltd\nidiv   %esi\nmov    %eax,%edx\nmov    -0x48(%rbp),%rax\nmov    %edx,(%rax,%rcx,4)\nmov    -0x28(%rbp),%rax\nmovslq -0x34(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x28(%rbp),%rax\nmov    -0x34(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    14c7 <func0+0x387>\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x34(%rbp)\njmp    131d <func0+0x1dd>\nmovl   $0x0,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    1688 <func0+0x548>\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nlea    0xb0b(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\nje     152a <func0+0x3ea>\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nlea    0xaec(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\njne    1675 <func0+0x535>\njmp    152f <func0+0x3ef>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x38(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x28(%rbp),%rcx\nmovslq -0x38(%rbp),%rdx\ncmp    (%rcx,%rdx,4),%eax\nje     1576 <func0+0x436>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x38(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x28(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    152f <func0+0x3ef>\njmp    157b <func0+0x43b>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x38(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%eax\nmov    -0x28(%rbp),%rcx\nmov    -0x38(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\ncmp    (%rcx,%rdx,4),%eax\nje     15d6 <func0+0x496>\nmov    -0x28(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x38(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x28(%rbp),%rax\nmov    -0x38(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    157b <func0+0x43b>\nmov    -0x8(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,8),%rdi\nlea    0xa1d(%rip),%rsi\ncall   1040 <strcmp@plt>\ncmp    $0x0,%eax\njne    162a <func0+0x4ea>\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x38(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x38(%rbp),%rsi\nmovslq (%rcx,%rsi,4),%rcx\nadd    (%rax,%rcx,4),%edx\nmov    %edx,(%rax,%rcx,4)\njmp    165a <func0+0x51a>\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x38(%rbp),%edx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%esi\nmov    -0x20(%rbp),%rax\nmov    -0x28(%rbp),%rcx\nmovslq -0x38(%rbp),%rdx\nmovslq (%rcx,%rdx,4),%rcx\nmov    (%rax,%rcx,4),%edx\nsub    %esi,%edx\nmov    %edx,(%rax,%rcx,4)\nmov    -0x28(%rbp),%rax\nmovslq -0x38(%rbp),%rcx\nmov    (%rax,%rcx,4),%edx\nmov    -0x28(%rbp),%rax\nmov    -0x38(%rbp),%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    167a <func0+0x53a>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\njmp    14dc <func0+0x39c>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x20(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x28(%rbp),%rdi\ncall   1030 <free@plt>\nmov    -0x3c(%rbp),%eax\nadd    $0x50,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 160,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %ecx,%r14d\nmov    %edx,0xc(%rsp)\nmov    %rsi,%r12\nmov    %rdi,0x10(%rsp)\nmovslq %ecx,%rbp\nlea    0x0(,%rbp,4),%rbx\nmov    %rbx,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rbx\ntest   %ebp,%ebp\njle    11bc <func0+0x6c>\nmov    %r14d,%ebp\nlea    0x0(,%rbp,4),%rdx\nmov    %r15,%rdi\nmov    %r12,%rsi\ncall   1050 <memcpy@plt>\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmov    %eax,(%rbx,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rbp\njne    11b0 <func0+0x60>\nmov    0xc(%rsp),%eax\nmov    %eax,%r14d\ntest   %eax,%eax\njle    1265 <func0+0x115>\nxor    %ebp,%ebp\nlea    0xe2c(%rip),%r12\njmp    1213 <func0+0xc3>\ncs nopw 0x0(%rax,%rax,1)\ncltq\nmovslq (%rbx,%rbp,4),%r13\nxorps  %xmm0,%xmm0\ncvtsi2sdl (%r15,%r13,4),%xmm0\nxorps  %xmm1,%xmm1\ncvtsi2sdl (%r15,%rax,4),%xmm1\ncall   1070 <pow@plt>\ncvttsd2si %xmm0,%eax\nmov    %eax,(%r15,%r13,4)\nmov    %r13d,0x4(%rbx,%rbp,4)\nadd    $0x1,%rbp\ncmp    %r14,%rbp\nje     1265 <func0+0x115>\nmov    0x10(%rsp),%rax\nmov    (%rax,%rbp,8),%rdi\nmov    %r12,%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njne    120a <func0+0xba>\nmovslq (%rbx,%rbp,4),%rcx\nnopl   0x0(%rax)\nmov    (%rbx,%rcx,4),%eax\ncmp    %ecx,%eax\nje     1240 <func0+0xf0>\nmov    %eax,(%rbx,%rbp,4)\nmovslq %eax,%rcx\njmp    1230 <func0+0xe0>\nnop\nmovslq 0x4(%rbx,%rbp,4),%rax\nmov    (%rbx,%rax,4),%ecx\ncmp    %eax,%ecx\nje     11e0 <func0+0x90>\nnopl   0x0(%rax)\nmov    %ecx,%eax\nmov    %ecx,0x4(%rbx,%rbp,4)\nmovslq %ecx,%rdx\nmov    (%rbx,%rdx,4),%ecx\ncmp    %edx,%ecx\njne    1250 <func0+0x100>\njmp    11e0 <func0+0x90>\ncmpl   $0x0,0xc(%rsp)\njle    1338 <func0+0x1e8>\nxor    %ebp,%ebp\njmp    12b2 <func0+0x162>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\ncltq\nmov    (%r15,%rax,4),%esi\nmovslq (%rbx,%rbp,4),%rcx\nmov    (%r15,%rcx,4),%eax\ntest   %r12d,%r12d\nje     1330 <func0+0x1e0>\ncltd\nidiv   %esi\nmov    %eax,(%r15,%rcx,4)\nmov    (%rbx,%rbp,4),%eax\nmov    %eax,0x4(%rbx,%rbp,4)\nadd    $0x1,%rbp\ncmp    %r14,%rbp\nje     1338 <func0+0x1e8>\nmov    0x10(%rsp),%rax\nmov    (%rax,%rbp,8),%r13\nmov    %r13,%rdi\nlea    0xd3c(%rip),%rsi\ncall   1040 <strcmp@plt>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     12e4 <func0+0x194>\nmov    %r13,%rdi\nlea    0xd28(%rip),%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njne    12a5 <func0+0x155>\nmovslq (%rbx,%rbp,4),%rcx\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx,%rcx,4),%eax\ncmp    %ecx,%eax\nje     1300 <func0+0x1b0>\nmov    %eax,(%rbx,%rbp,4)\nmovslq %eax,%rcx\njmp    12f0 <func0+0x1a0>\nnop\nmovslq 0x4(%rbx,%rbp,4),%rax\nmov    (%rbx,%rax,4),%ecx\ncmp    %eax,%ecx\nje     1280 <func0+0x130>\nmov    %ecx,%eax\nmov    %ecx,0x4(%rbx,%rbp,4)\nmovslq %ecx,%rdx\nmov    (%rbx,%rdx,4),%ecx\ncmp    %edx,%ecx\njne    1310 <func0+0x1c0>\njmp    1280 <func0+0x130>\ncs nopw 0x0(%rax,%rax,1)\nnop\nimul   %esi,%eax\njmp    129a <func0+0x14a>\ncmpl   $0x0,0xc(%rsp)\njle    13e6 <func0+0x296>\nxor    %r13d,%r13d\njmp    1379 <func0+0x229>\nnopl   0x0(%rax,%rax,1)\ncltq\nmov    (%r15,%rax,4),%eax\nmov    %eax,%ecx\nneg    %ecx\ntest   %ebp,%ebp\ncmove  %eax,%ecx\nmovslq (%rbx,%r13,4),%rax\nadd    %ecx,(%r15,%rax,4)\nmov    (%rbx,%r13,4),%eax\nmov    %eax,0x4(%rbx,%r13,4)\nadd    $0x1,%r13\ncmp    %r14,%r13\nje     13e6 <func0+0x296>\nmov    0x10(%rsp),%rax\nmov    (%rax,%r13,8),%r12\nmov    %r12,%rdi\nlea    0xc7a(%rip),%rsi\ncall   1040 <strcmp@plt>\nmov    %eax,%ebp\ntest   %eax,%eax\nje     13aa <func0+0x25a>\nmov    %r12,%rdi\nlea    0xc67(%rip),%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njne    1370 <func0+0x220>\nmovslq (%rbx,%r13,4),%rcx\nxchg   %ax,%ax\nmov    (%rbx,%rcx,4),%eax\ncmp    %ecx,%eax\nje     13c0 <func0+0x270>\nmov    %eax,(%rbx,%r13,4)\nmovslq %eax,%rcx\njmp    13b0 <func0+0x260>\nmovslq 0x4(%rbx,%r13,4),%rax\nmov    (%rbx,%rax,4),%ecx\ncmp    %eax,%ecx\nje     1350 <func0+0x200>\nnopl   0x0(%rax)\nmov    %ecx,%eax\nmov    %ecx,0x4(%rbx,%r13,4)\nmovslq %ecx,%rdx\nmov    (%rbx,%rdx,4),%ecx\ncmp    %edx,%ecx\njne    13d0 <func0+0x280>\njmp    1350 <func0+0x200>\nmov    (%r15),%ebp\nmov    %r15,%rdi\ncall   1030 <free@plt>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %ebp,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 160,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %ecx,%r14d\nmov    %edx,0x4(%rsp)\nmov    %rsi,%r12\nmov    %rdi,0x8(%rsp)\nmovslq %ecx,%rbp\nlea    0x0(,%rbp,4),%rbx\nmov    %rbx,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rbx\ntest   %ebp,%ebp\njle    131c <func0+0x1cc>\nmov    %r14d,%ebp\nlea    0x0(,%rbp,4),%rdx\nmov    %r15,%rdi\nmov    %r12,%rsi\ncall   1050 <memcpy@plt>\ncmp    $0x8,%r14d\njae    11b9 <func0+0x69>\nxor    %eax,%eax\njmp    1310 <func0+0x1c0>\nmov    %ebp,%eax\nand    $0xfffffff8,%eax\nlea    -0x8(%rax),%rsi\nmov    %rsi,%rdx\nshr    $0x3,%rdx\nadd    $0x1,%rdx\nmov    %edx,%ecx\nand    $0x3,%ecx\ncmp    $0x18,%rsi\njae    11e7 <func0+0x97>\nmovdqa 0xe20(%rip),%xmm0\nxor    %esi,%esi\njmp    12b8 <func0+0x168>\nand    $0xfffffffffffffffc,%rdx\nmovdqa 0xe0d(%rip),%xmm0\nxor    %esi,%esi\nmovdqa 0xe12(%rip),%xmm8\nmovdqa 0xe19(%rip),%xmm9\nmovdqa 0xe20(%rip),%xmm10\nmovdqa 0xe28(%rip),%xmm4\nmovdqa 0xe30(%rip),%xmm5\nmovdqa 0xe38(%rip),%xmm6\nmovdqa 0xe40(%rip),%xmm7\nmovdqa 0xe48(%rip),%xmm1\nnopl   0x0(%rax,%rax,1)\nmovdqa %xmm0,%xmm2\npaddd  %xmm8,%xmm2\nmovdqu %xmm0,(%rbx,%rsi,4)\nmovdqu %xmm2,0x10(%rbx,%rsi,4)\nmovdqa %xmm0,%xmm2\npaddd  %xmm9,%xmm2\nmovdqa %xmm0,%xmm3\npaddd  %xmm10,%xmm3\nmovdqu %xmm2,0x20(%rbx,%rsi,4)\nmovdqu %xmm3,0x30(%rbx,%rsi,4)\nmovdqa %xmm0,%xmm2\npaddd  %xmm4,%xmm2\nmovdqa %xmm0,%xmm3\npaddd  %xmm5,%xmm3\nmovdqu %xmm2,0x40(%rbx,%rsi,4)\nmovdqu %xmm3,0x50(%rbx,%rsi,4)\nmovdqa %xmm0,%xmm2\npaddd  %xmm6,%xmm2\nmovdqa %xmm0,%xmm3\npaddd  %xmm7,%xmm3\nmovdqu %xmm2,0x60(%rbx,%rsi,4)\nmovdqu %xmm3,0x70(%rbx,%rsi,4)\nadd    $0x20,%rsi\npaddd  %xmm1,%xmm0\nadd    $0xfffffffffffffffc,%rdx\njne    1240 <func0+0xf0>\ntest   %rcx,%rcx\nje     1300 <func0+0x1b0>\nlea    (%rbx,%rsi,4),%rdx\nadd    $0x10,%rdx\nshl    $0x5,%rcx\nxor    %esi,%esi\nmovdqa 0xd3d(%rip),%xmm1\nmovdqa 0xd45(%rip),%xmm2\nnopl   0x0(%rax,%rax,1)\nmovdqa %xmm0,%xmm3\npaddd  %xmm1,%xmm3\nmovdqu %xmm0,-0x10(%rdx,%rsi,1)\nmovdqu %xmm3,(%rdx,%rsi,1)\npaddd  %xmm2,%xmm0\nadd    $0x20,%rsi\ncmp    %rsi,%rcx\njne    12e0 <func0+0x190>\ncmp    %rbp,%rax\nje     131c <func0+0x1cc>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %eax,(%rbx,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rbp\njne    1310 <func0+0x1c0>\nmov    0x4(%rsp),%eax\ntest   %eax,%eax\njle    1575 <func0+0x425>\nmov    %eax,%r14d\nxor    %ebp,%ebp\nlea    0xd5c(%rip),%r12\nmov    %r14,0x10(%rsp)\njmp    137b <func0+0x22b>\nnopl   0x0(%rax,%rax,1)\nlea    0x1(%rbp),%r13\nmovslq %eax,%r12\nxorps  %xmm0,%xmm0\ncvtsi2sdl (%r15,%r12,4),%xmm0\nxorps  %xmm1,%xmm1\ncvtsi2sdl (%r15,%rcx,4),%xmm1\ncall   1070 <pow@plt>\ncvttsd2si %xmm0,%eax\nmov    %eax,(%r15,%r12,4)\nmov    %r12d,0x4(%rbx,%rbp,4)\nmov    %r13,%rbp\nmov    %r14,%r12\nmov    0x10(%rsp),%r14\ncmp    %r14,%rbp\nje     13e4 <func0+0x294>\nmov    0x8(%rsp),%rax\nmov    (%rax,%rbp,8),%rdi\nmov    %r12,%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     13a0 <func0+0x250>\nadd    $0x1,%rbp\njmp    1376 <func0+0x226>\ncs nopw 0x0(%rax,%rax,1)\nmovslq (%rbx,%rbp,4),%rax\nmov    (%rbx,%rax,4),%ecx\ncmp    %eax,%ecx\nje     13c1 <func0+0x271>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,(%rbx,%rbp,4)\nmovslq %ecx,%rdx\nmov    %ecx,%eax\nmov    (%rbx,%rdx,4),%esi\nmov    %esi,%ecx\ncmp    %edx,%esi\njne    13b0 <func0+0x260>\nmov    %r12,%r14\nmovslq 0x4(%rbx,%rbp,4),%rcx\nnopl   0x0(%rax)\nmov    (%rbx,%rcx,4),%edx\ncmp    %ecx,%edx\nje     1340 <func0+0x1f0>\nmov    %edx,0x4(%rbx,%rbp,4)\nmovslq %edx,%rcx\njmp    13d0 <func0+0x280>\ncmpl   $0x0,0x4(%rsp)\njle    1575 <func0+0x425>\nxor    %ebp,%ebp\njmp    1418 <func0+0x2c8>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\nimul   %esi,%eax\nmov    %eax,(%r15,%rcx,4)\nmov    %ecx,0x4(%rbx,%rbp,4)\nadd    $0x1,%rbp\ncmp    %r14,%rbp\nje     14ac <func0+0x35c>\nmov    0x8(%rsp),%rax\nmov    (%rax,%rbp,8),%r13\nmov    %r13,%rdi\nlea    0xc66(%rip),%rsi\ncall   1040 <strcmp@plt>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     144a <func0+0x2fa>\nmov    %r13,%rdi\nlea    0xc52(%rip),%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njne    140b <func0+0x2bb>\nmovslq (%rbx,%rbp,4),%rax\nmov    (%rbx,%rax,4),%ecx\ncmp    %eax,%ecx\nje     1471 <func0+0x321>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %ecx,(%rbx,%rbp,4)\nmovslq %ecx,%rdx\nmov    %ecx,%eax\nmov    (%rbx,%rdx,4),%esi\nmov    %esi,%ecx\ncmp    %edx,%esi\njne    1460 <func0+0x310>\nmovslq 0x4(%rbx,%rbp,4),%rcx\ncs nopw 0x0(%rax,%rax,1)\nmov    (%rbx,%rcx,4),%edx\ncmp    %ecx,%edx\nje     1490 <func0+0x340>\nmov    %edx,0x4(%rbx,%rbp,4)\nmovslq %edx,%rcx\njmp    1480 <func0+0x330>\nmov    (%r15,%rcx,4),%esi\nmovslq %eax,%rcx\nmov    (%r15,%rcx,4),%eax\ntest   %r12d,%r12d\nje     1400 <func0+0x2b0>\ncltd\nidiv   %esi\njmp    1403 <func0+0x2b3>\ncmpl   $0x0,0x4(%rsp)\njle    1575 <func0+0x425>\nxor    %r13d,%r13d\njmp    14e5 <func0+0x395>\nnopl   0x0(%rax)\nmov    (%r15,%rcx,4),%ecx\nmov    %ecx,%edx\nneg    %edx\ntest   %ebp,%ebp\ncltq\ncmove  %ecx,%edx\nmov    %eax,0x4(%rbx,%r13,4)\nadd    $0x1,%r13\nadd    %edx,(%r15,%rax,4)\ncmp    %r14,%r13\nje     1575 <func0+0x425>\nmov    0x8(%rsp),%rax\nmov    (%rax,%r13,8),%r12\nmov    %r12,%rdi\nlea    0xb9e(%rip),%rsi\ncall   1040 <strcmp@plt>\nmov    %eax,%ebp\ntest   %eax,%eax\nje     1530 <func0+0x3e0>\nmov    %r12,%rdi\nlea    0xb8b(%rip),%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     1530 <func0+0x3e0>\nadd    $0x1,%r13\ncmp    %r14,%r13\njne    14e5 <func0+0x395>\njmp    1575 <func0+0x425>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovslq (%rbx,%r13,4),%rax\nmov    (%rbx,%rax,4),%ecx\ncmp    %eax,%ecx\nje     1552 <func0+0x402>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,(%rbx,%r13,4)\nmovslq %ecx,%rdx\nmov    %ecx,%eax\nmov    (%rbx,%rdx,4),%esi\nmov    %esi,%ecx\ncmp    %edx,%esi\njne    1540 <func0+0x3f0>\nmovslq 0x4(%rbx,%r13,4),%rcx\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx,%rcx,4),%edx\ncmp    %ecx,%edx\nje     14c0 <func0+0x370>\nmov    %edx,0x4(%rbx,%r13,4)\nmovslq %edx,%rcx\njmp    1560 <func0+0x410>\nmov    (%r15),%ebp\nmov    %r15,%rdi\ncall   1030 <free@plt>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %ebp,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 160,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %ecx,%r14d\nmov    %edx,0x4(%rsp)\nmov    %rsi,%r12\nmov    %rdi,0x8(%rsp)\nmovslq %ecx,%rbp\nlea    0x0(,%rbp,4),%rbx\nmov    %rbx,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%r15\nmov    %rbx,%rdi\ncall   1060 <malloc@plt>\nmov    %rax,%rbx\ntest   %ebp,%ebp\njle    131c <func0+0x1cc>\nmov    %r14d,%ebp\nlea    0x0(,%rbp,4),%rdx\nmov    %r15,%rdi\nmov    %r12,%rsi\ncall   1050 <memcpy@plt>\ncmp    $0x8,%r14d\njae    11b9 <func0+0x69>\nxor    %eax,%eax\njmp    1310 <func0+0x1c0>\nmov    %ebp,%eax\nand    $0xfffffff8,%eax\nlea    -0x8(%rax),%rsi\nmov    %rsi,%rdx\nshr    $0x3,%rdx\nadd    $0x1,%rdx\nmov    %edx,%ecx\nand    $0x3,%ecx\ncmp    $0x18,%rsi\njae    11e7 <func0+0x97>\nmovdqa 0xe20(%rip),%xmm0\nxor    %esi,%esi\njmp    12b8 <func0+0x168>\nand    $0xfffffffffffffffc,%rdx\nmovdqa 0xe0d(%rip),%xmm0\nxor    %esi,%esi\nmovdqa 0xe12(%rip),%xmm8\nmovdqa 0xe19(%rip),%xmm9\nmovdqa 0xe20(%rip),%xmm10\nmovdqa 0xe28(%rip),%xmm4\nmovdqa 0xe30(%rip),%xmm5\nmovdqa 0xe38(%rip),%xmm6\nmovdqa 0xe40(%rip),%xmm7\nmovdqa 0xe48(%rip),%xmm1\nnopl   0x0(%rax,%rax,1)\nmovdqa %xmm0,%xmm2\npaddd  %xmm8,%xmm2\nmovdqu %xmm0,(%rbx,%rsi,4)\nmovdqu %xmm2,0x10(%rbx,%rsi,4)\nmovdqa %xmm0,%xmm2\npaddd  %xmm9,%xmm2\nmovdqa %xmm0,%xmm3\npaddd  %xmm10,%xmm3\nmovdqu %xmm2,0x20(%rbx,%rsi,4)\nmovdqu %xmm3,0x30(%rbx,%rsi,4)\nmovdqa %xmm0,%xmm2\npaddd  %xmm4,%xmm2\nmovdqa %xmm0,%xmm3\npaddd  %xmm5,%xmm3\nmovdqu %xmm2,0x40(%rbx,%rsi,4)\nmovdqu %xmm3,0x50(%rbx,%rsi,4)\nmovdqa %xmm0,%xmm2\npaddd  %xmm6,%xmm2\nmovdqa %xmm0,%xmm3\npaddd  %xmm7,%xmm3\nmovdqu %xmm2,0x60(%rbx,%rsi,4)\nmovdqu %xmm3,0x70(%rbx,%rsi,4)\nadd    $0x20,%rsi\npaddd  %xmm1,%xmm0\nadd    $0xfffffffffffffffc,%rdx\njne    1240 <func0+0xf0>\ntest   %rcx,%rcx\nje     1300 <func0+0x1b0>\nlea    (%rbx,%rsi,4),%rdx\nadd    $0x10,%rdx\nshl    $0x5,%rcx\nxor    %esi,%esi\nmovdqa 0xd3d(%rip),%xmm1\nmovdqa 0xd45(%rip),%xmm2\nnopl   0x0(%rax,%rax,1)\nmovdqa %xmm0,%xmm3\npaddd  %xmm1,%xmm3\nmovdqu %xmm0,-0x10(%rdx,%rsi,1)\nmovdqu %xmm3,(%rdx,%rsi,1)\npaddd  %xmm2,%xmm0\nadd    $0x20,%rsi\ncmp    %rsi,%rcx\njne    12e0 <func0+0x190>\ncmp    %rbp,%rax\nje     131c <func0+0x1cc>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %eax,(%rbx,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rbp\njne    1310 <func0+0x1c0>\nmov    0x4(%rsp),%eax\ntest   %eax,%eax\njle    1594 <func0+0x444>\nmov    %eax,%r14d\nxor    %ebp,%ebp\nlea    0xd5c(%rip),%r12\nmov    %r14,0x10(%rsp)\njmp    137b <func0+0x22b>\nnopl   0x0(%rax,%rax,1)\nlea    0x1(%rbp),%r13\nmovslq %eax,%r12\nxorps  %xmm0,%xmm0\ncvtsi2sdl (%r15,%r12,4),%xmm0\nxorps  %xmm1,%xmm1\ncvtsi2sdl (%r15,%rcx,4),%xmm1\ncall   1070 <pow@plt>\ncvttsd2si %xmm0,%eax\nmov    %eax,(%r15,%r12,4)\nmov    %r12d,0x4(%rbx,%rbp,4)\nmov    %r13,%rbp\nmov    %r14,%r12\nmov    0x10(%rsp),%r14\ncmp    %r14,%rbp\nje     13f3 <func0+0x2a3>\nmov    0x8(%rsp),%rax\nmov    (%rax,%rbp,8),%rdi\nmov    %r12,%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     13a0 <func0+0x250>\nadd    $0x1,%rbp\ncmp    %r14,%rbp\njne    137b <func0+0x22b>\njmp    13f3 <func0+0x2a3>\nnopl   0x0(%rax,%rax,1)\nmovslq (%rbx,%rbp,4),%rax\nmov    (%rbx,%rax,4),%ecx\ncmp    %eax,%ecx\nje     13c1 <func0+0x271>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,(%rbx,%rbp,4)\nmovslq %ecx,%rdx\nmov    %ecx,%eax\nmov    (%rbx,%rdx,4),%esi\nmov    %esi,%ecx\ncmp    %edx,%esi\njne    13b0 <func0+0x260>\nmov    %r12,%r14\nmovslq 0x4(%rbx,%rbp,4),%rcx\nmov    (%rbx,%rcx,4),%edx\ncmp    %ecx,%edx\nje     1340 <func0+0x1f0>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\nmov    %edx,0x4(%rbx,%rbp,4)\nmovslq %edx,%rcx\nmov    (%rbx,%rcx,4),%edx\ncmp    %ecx,%edx\njne    13e0 <func0+0x290>\njmp    1340 <func0+0x1f0>\ncmpl   $0x0,0x4(%rsp)\njle    1594 <func0+0x444>\nxor    %ebp,%ebp\njmp    1428 <func0+0x2d8>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nimul   %esi,%eax\nmov    %eax,(%r15,%rcx,4)\nmov    %ecx,0x4(%rbx,%rbp,4)\nadd    $0x1,%rbp\ncmp    %r14,%rbp\nje     14ba <func0+0x36a>\nmov    0x8(%rsp),%rax\nmov    (%rax,%rbp,8),%r13\nmov    %r13,%rdi\nlea    0xc56(%rip),%rsi\ncall   1040 <strcmp@plt>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     145a <func0+0x30a>\nmov    %r13,%rdi\nlea    0xc42(%rip),%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\njne    141b <func0+0x2cb>\nmovslq (%rbx,%rbp,4),%rax\nmov    (%rbx,%rax,4),%ecx\ncmp    %eax,%ecx\nje     1481 <func0+0x331>\ncs nopw 0x0(%rax,%rax,1)\nnop\nmov    %ecx,(%rbx,%rbp,4)\nmovslq %ecx,%rdx\nmov    %ecx,%eax\nmov    (%rbx,%rdx,4),%esi\nmov    %esi,%ecx\ncmp    %edx,%esi\njne    1470 <func0+0x320>\nmovslq 0x4(%rbx,%rbp,4),%rcx\nmov    (%rbx,%rcx,4),%edx\ncmp    %ecx,%edx\nje     149e <func0+0x34e>\nnopl   (%rax)\nmov    %edx,0x4(%rbx,%rbp,4)\nmovslq %edx,%rcx\nmov    (%rbx,%rcx,4),%edx\ncmp    %ecx,%edx\njne    1490 <func0+0x340>\nmov    (%r15,%rcx,4),%esi\nmovslq %eax,%rcx\nmov    (%r15,%rcx,4),%eax\ntest   %r12d,%r12d\nje     1410 <func0+0x2c0>\ncltd\nidiv   %esi\njmp    1413 <func0+0x2c3>\ncmpl   $0x0,0x4(%rsp)\njle    1594 <func0+0x444>\nxor    %r13d,%r13d\njmp    14f5 <func0+0x3a5>\nnopw   0x0(%rax,%rax,1)\nmov    (%r15,%rcx,4),%ecx\nmov    %ecx,%edx\nneg    %edx\ntest   %ebp,%ebp\ncltq\ncmove  %ecx,%edx\nmov    %eax,0x4(%rbx,%r13,4)\nadd    $0x1,%r13\nadd    %edx,(%r15,%rax,4)\ncmp    %r14,%r13\nje     1594 <func0+0x444>\nmov    0x8(%rsp),%rax\nmov    (%rax,%r13,8),%r12\nmov    %r12,%rdi\nlea    0xb8e(%rip),%rsi\ncall   1040 <strcmp@plt>\nmov    %eax,%ebp\ntest   %eax,%eax\nje     1540 <func0+0x3f0>\nmov    %r12,%rdi\nlea    0xb7b(%rip),%rsi\ncall   1040 <strcmp@plt>\ntest   %eax,%eax\nje     1540 <func0+0x3f0>\nadd    $0x1,%r13\ncmp    %r14,%r13\njne    14f5 <func0+0x3a5>\njmp    1594 <func0+0x444>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\nmovslq (%rbx,%r13,4),%rax\nmov    (%rbx,%rax,4),%ecx\ncmp    %eax,%ecx\nje     1562 <func0+0x412>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,(%rbx,%r13,4)\nmovslq %ecx,%rdx\nmov    %ecx,%eax\nmov    (%rbx,%rdx,4),%esi\nmov    %esi,%ecx\ncmp    %edx,%esi\njne    1550 <func0+0x400>\nmovslq 0x4(%rbx,%r13,4),%rcx\nmov    (%rbx,%rcx,4),%edx\ncmp    %ecx,%edx\nje     14d0 <func0+0x380>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmov    %edx,0x4(%rbx,%r13,4)\nmovslq %edx,%rcx\nmov    (%rbx,%rcx,4),%edx\ncmp    %ecx,%edx\njne    1580 <func0+0x430>\njmp    14d0 <func0+0x380>\nmov    (%r15),%ebp\nmov    %r15,%rdi\ncall   1030 <free@plt>\nmov    %rbx,%rdi\ncall   1030 <free@plt>\nmov    %ebp,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 161,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmov    -0x8(%rbp),%rdi\ncall   1040 <strlen@plt>\nmov    %eax,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njge    1254 <func0+0x114>\ncall   1060 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x14(%rbp),%rdx\nmovzbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x400,%eax\ncmp    $0x0,%eax\nje     1238 <func0+0xf8>\ncall   1060 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x14(%rbp),%rdx\nmovzbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x100,%eax\ncmp    $0x0,%eax\nje     11e7 <func0+0xa7>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovzbl (%rax,%rcx,1),%edi\ncall   1050 <tolower@plt>\nmov    %al,%dl\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\njmp    1233 <func0+0xf3>\ncall   1060 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rcx\nmovslq -0x14(%rbp),%rdx\nmovzbl (%rcx,%rdx,1),%ecx\nmovslq %ecx,%rcx\nmovzwl (%rax,%rcx,2),%eax\nand    $0x200,%eax\ncmp    $0x0,%eax\nje     122e <func0+0xee>\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmovzbl (%rax,%rcx,1),%edi\ncall   1030 <toupper@plt>\nmov    %al,%dl\nmov    -0x8(%rbp),%rax\nmovslq -0x14(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\njmp    1233 <func0+0xf3>\njmp    1241 <func0+0x101>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    1246 <func0+0x106>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1166 <func0+0x26>\nmov    -0xc(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njne    12da <func0+0x19a>\nmovl   $0x0,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x10(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\nmov    %eax,%ecx\nmov    -0x20(%rbp),%eax\ncmp    %ecx,%eax\njge    12d5 <func0+0x195>\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x19(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%ecx\nsub    -0x18(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    (%rax,%rcx,1),%dl\nmov    -0x8(%rbp),%rax\nmovslq -0x18(%rbp),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x19(%rbp),%dl\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%ecx\nsub    -0x18(%rbp),%ecx\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1267 <func0+0x127>\njmp    12da <func0+0x19a>\nmov    -0x8(%rbp),%rax\nadd    $0x20,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 161,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdi,%r14\ncall   1040 <strlen@plt>\nmov    %rax,%rbx\ntest   %ebx,%ebx\njle    11c7 <func0+0x87>\ncall   1060 <__ctype_b_loc@plt>\nmov    %rax,%rcx\nmov    %ebx,%r12d\nxor    %ebp,%ebp\nxor    %r13d,%r13d\nmov    %rax,(%rsp)\njmp    117d <func0+0x3d>\nadd    $0x1,%r13d\nadd    $0x1,%rbp\ncmp    %rbp,%r12\nje     11ca <func0+0x8a>\nmov    (%rcx),%rax\nmovzbl (%r14,%rbp,1),%r15d\nmovzwl (%rax,%r15,2),%eax\ntest   $0x400,%eax\nje     1170 <func0+0x30>\ntest   $0x100,%eax\njne    11b0 <func0+0x70>\ntest   $0x200,%eax\nje     1174 <func0+0x34>\ncall   1030 <__ctype_toupper_loc@plt>\njmp    11b5 <func0+0x75>\ncs nopw 0x0(%rax,%rax,1)\ncall   1050 <__ctype_tolower_loc@plt>\nmov    (%rsp),%rcx\nmov    (%rax),%rax\nmovzbl (%rax,%r15,4),%eax\nmov    %al,(%r14,%rbp,1)\njmp    1174 <func0+0x34>\nxor    %r13d,%r13d\ncmp    %ebx,%r13d\njne    1215 <func0+0xd5>\ncmp    $0x2,%ebx\njl     1215 <func0+0xd5>\nmovabs $0xffffffff00000000,%rsi\nff ff ff\nmov    %ebx,%ebp\nshr    $0x1f,%ebp\nadd    %ebx,%ebp\nsar    %ebp\nshl    $0x20,%rbx\nadd    %rsi,%rbx\nxor    %edx,%edx\nmovzbl (%r14,%rdx,1),%eax\nmov    %rbx,%rdi\nsar    $0x20,%rdi\nmovzbl (%r14,%rdi,1),%ecx\nmov    %cl,(%r14,%rdx,1)\nmov    %al,(%r14,%rdi,1)\nadd    $0x1,%rdx\nadd    %rsi,%rbx\ncmp    %rdx,%rbp\njne    11f0 <func0+0xb0>\nmov    %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 161,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdi,%r15\ncall   1040 <strlen@plt>\nmov    %rax,%rbp\ntest   %ebp,%ebp\nmov    %rax,(%rsp)\njle    11c3 <func0+0x83>\ncall   1060 <__ctype_b_loc@plt>\nmov    %rax,%rbx\nmov    %ebp,%r12d\nxor    %ebp,%ebp\nxor    %r13d,%r13d\njmp    117d <func0+0x3d>\nadd    $0x1,%r13d\nadd    $0x1,%rbp\ncmp    %rbp,%r12\nje     11c6 <func0+0x86>\nmov    (%rbx),%rax\nmovzbl (%r15,%rbp,1),%r14d\nmovzwl (%rax,%r14,2),%eax\ntest   $0x400,%eax\nje     1170 <func0+0x30>\ntest   $0x100,%eax\njne    11b0 <func0+0x70>\ntest   $0x200,%eax\nje     1174 <func0+0x34>\ncall   1030 <__ctype_toupper_loc@plt>\njmp    11b5 <func0+0x75>\ncs nopw 0x0(%rax,%rax,1)\ncall   1050 <__ctype_tolower_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r14,4),%eax\nmov    %al,(%r15,%rbp,1)\njmp    1174 <func0+0x34>\nxor    %r13d,%r13d\nmov    (%rsp),%r11\ncmp    %r11d,%r13d\njne    1292 <func0+0x152>\ncmp    $0x2,%r11d\njl     1292 <func0+0x152>\nmov    %r11,%r8\nshr    %r8\nmov    %r8d,%r10d\nand    $0x7fffffff,%r10d\nand    $0x1,%r8d\ncmp    $0x1,%r10\njne    11fb <func0+0xbb>\nxor    %ecx,%ecx\njmp    1273 <func0+0x133>\nmovabs $0xfffffffe00000000,%r9\nff ff ff\nsub    %r8,%r10\nmov    %r11,%rcx\nshl    $0x20,%rcx\nlea    (%rcx,%r9,1),%rdi\nmovabs $0xffffffff00000000,%rsi\nff ff ff\nadd    %rcx,%rsi\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovzbl (%r15,%rcx,1),%eax\nmov    %rsi,%rbp\nsar    $0x20,%rbp\nmovzbl (%r15,%rbp,1),%edx\nmov    %dl,(%r15,%rcx,1)\nmov    %al,(%r15,%rbp,1)\nmovzbl 0x1(%r15,%rcx,1),%eax\nmov    %rdi,%rdx\nsar    $0x20,%rdx\nmovzbl (%r15,%rdx,1),%ebx\nmov    %bl,0x1(%r15,%rcx,1)\nmov    %al,(%r15,%rdx,1)\nadd    $0x2,%rcx\nadd    %r9,%rdi\nadd    %r9,%rsi\ncmp    %rcx,%r10\njne    1230 <func0+0xf0>\ntest   %r8,%r8\nje     1292 <func0+0x152>\nmov    (%r15,%rcx,1),%al\nmov    %ecx,%edx\nnot    %edx\nadd    %r11d,%edx\nmovslq %edx,%rdx\nmov    (%r15,%rdx,1),%bl\nmov    %bl,(%r15,%rcx,1)\nmov    %al,(%r15,%rdx,1)\nmov    %r15,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 161,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\npush   %rax\nmov    %rdi,%r15\ncall   1040 <strlen@plt>\nmov    %rax,%rbp\ntest   %ebp,%ebp\nmov    %rax,(%rsp)\njle    11c3 <func0+0x83>\ncall   1060 <__ctype_b_loc@plt>\nmov    %rax,%rbx\nmov    %ebp,%r12d\nxor    %ebp,%ebp\nxor    %r13d,%r13d\njmp    117d <func0+0x3d>\nadd    $0x1,%r13d\nadd    $0x1,%rbp\ncmp    %rbp,%r12\nje     11c6 <func0+0x86>\nmov    (%rbx),%rax\nmovzbl (%r15,%rbp,1),%r14d\nmovzwl (%rax,%r14,2),%eax\ntest   $0x400,%eax\nje     1170 <func0+0x30>\ntest   $0x100,%eax\njne    11b0 <func0+0x70>\ntest   $0x200,%eax\nje     1174 <func0+0x34>\ncall   1030 <__ctype_toupper_loc@plt>\njmp    11b5 <func0+0x75>\ncs nopw 0x0(%rax,%rax,1)\ncall   1050 <__ctype_tolower_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r14,4),%eax\nmov    %al,(%r15,%rbp,1)\njmp    1174 <func0+0x34>\nxor    %r13d,%r13d\nmov    (%rsp),%r11\ncmp    %r11d,%r13d\njne    1292 <func0+0x152>\ncmp    $0x2,%r11d\njl     1292 <func0+0x152>\nmov    %r11,%r8\nshr    %r8\nmov    %r8d,%r10d\nand    $0x7fffffff,%r10d\nand    $0x1,%r8d\ncmp    $0x1,%r10\njne    11fb <func0+0xbb>\nxor    %ecx,%ecx\njmp    1273 <func0+0x133>\nmovabs $0xfffffffe00000000,%r9\nff ff ff\nsub    %r8,%r10\nmov    %r11,%rcx\nshl    $0x20,%rcx\nlea    (%rcx,%r9,1),%rdi\nmovabs $0xffffffff00000000,%rsi\nff ff ff\nadd    %rcx,%rsi\nxor    %ecx,%ecx\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\nmovzbl (%r15,%rcx,1),%eax\nmov    %rsi,%rbp\nsar    $0x20,%rbp\nmovzbl (%r15,%rbp,1),%edx\nmov    %dl,(%r15,%rcx,1)\nmov    %al,(%r15,%rbp,1)\nmovzbl 0x1(%r15,%rcx,1),%eax\nmov    %rdi,%rdx\nsar    $0x20,%rdx\nmovzbl (%r15,%rdx,1),%ebx\nmov    %bl,0x1(%r15,%rcx,1)\nmov    %al,(%r15,%rdx,1)\nadd    $0x2,%rcx\nadd    %r9,%rdi\nadd    %r9,%rsi\ncmp    %rcx,%r10\njne    1230 <func0+0xf0>\ntest   %r8,%r8\nje     1292 <func0+0x152>\nmov    (%r15,%rcx,1),%al\nmov    %ecx,%edx\nnot    %edx\nadd    %r11d,%edx\nmovslq %edx,%rdx\nmov    (%r15,%rdx,1),%bl\nmov    %bl,(%r15,%rcx,1)\nmov    %al,(%r15,%rdx,1)\nmov    %r15,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"
    },
    {
        "task_id": 162,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    -0x10(%rbp),%rdi\ncall   1030 <strlen@plt>\ncmp    $0x0,%rax\njne    1174 <func0+0x34>\nlea    0xe9a(%rip),%rdi\ncall   1060 <strdup@plt>\nmov    %rax,-0x8(%rbp)\njmp    1250 <func0+0x110>\nmovl   $0xffffffff,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmovsbl (%rax,%rcx,1),%eax\ncmp    $0x0,%eax\nje     1211 <func0+0xd1>\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%ecx\nmov    (%rax,%rcx,1),%al\nmov    %al,-0x1d(%rbp)\nmov    -0x14(%rbp),%eax\nmovzbl -0x1d(%rbp),%ecx\nxor    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x1c(%rbp)\ncmpl   $0x8,-0x1c(%rbp)\njae    11fe <func0+0xbe>\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\ncmp    $0x0,%eax\nje     11e2 <func0+0xa2>\nmov    -0x14(%rbp),%eax\nshr    $0x1,%eax\nxor    $0xedb88320,%eax\nmov    %eax,-0x14(%rbp)\njmp    11eb <func0+0xab>\nmov    -0x14(%rbp),%eax\nshr    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    11f0 <func0+0xb0>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    11b6 <func0+0x76>\njmp    1203 <func0+0xc3>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    1182 <func0+0x42>\nmov    -0x14(%rbp),%eax\nxor    $0xffffffff,%eax\nmov    %eax,-0x14(%rbp)\nmov    $0x9,%edi\ncall   1040 <malloc@plt>\nmov    %rax,-0x28(%rbp)\ncmpq   $0x0,-0x28(%rbp)\nje     1248 <func0+0x108>\nmov    -0x28(%rbp),%rdi\nmov    -0x14(%rbp),%edx\nlea    0xdc4(%rip),%rsi\nmov    $0x0,%al\ncall   1050 <sprintf@plt>\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x30,%rsp\npop    %rbp\nret\n"
    },
    {
        "task_id": 162,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\ncmpb   $0x0,(%rdi)\nje     1187 <func0+0x57>\nmov    (%rdi),%cl\ntest   %cl,%cl\nje     1198 <func0+0x68>\nxor    %eax,%eax\nmov    $0xffffffff,%ebx\ncs nopw 0x0(%rax,%rax,1)\nmovzbl %cl,%ecx\nxor    %ecx,%ebx\nmov    $0x8,%ecx\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%edx\nshr    %edx\nmov    %edx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%bl\nmov    %esi,%ebx\ncmove  %edx,%ebx\nadd    $0xffffffff,%ecx\njne    1160 <func0+0x30>\nadd    $0x1,%eax\nmov    (%rdi,%rax,1),%cl\ntest   %cl,%cl\njne    1150 <func0+0x20>\nnot    %ebx\njmp    119a <func0+0x6a>\nlea    0xe72(%rip),%rdi\ncall   1050 <strdup@plt>\nmov    %rax,%r14\njmp    11bf <func0+0x8f>\nxor    %ebx,%ebx\nmov    $0x9,%edi\ncall   1030 <malloc@plt>\nmov    %rax,%r14\ntest   %rax,%rax\nje     11bf <func0+0x8f>\nlea    0xe52(%rip),%rsi\nmov    %r14,%rdi\nmov    %ebx,%edx\nxor    %eax,%eax\ncall   1040 <sprintf@plt>\nmov    %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 162,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    (%rdi),%cl\ntest   %cl,%cl\nje     1223 <func0+0xf3>\nmov    $0xffffffff,%ebx\nmov    $0x1,%eax\nnopl   0x0(%rax,%rax,1)\nmovzbl %cl,%ecx\nxor    %ebx,%ecx\nmov    %ecx,%edx\nshr    %edx\nmov    %edx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%cl\ncmove  %edx,%esi\nmov    %esi,%ecx\nshr    %ecx\nmov    %ecx,%edx\nxor    $0xedb88320,%edx\ntest   $0x1,%sil\ncmove  %ecx,%edx\nmov    %edx,%ecx\nshr    %ecx\nmov    %ecx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%dl\ncmove  %ecx,%esi\nmov    %esi,%ecx\nshr    %ecx\nmov    %ecx,%edx\nxor    $0xedb88320,%edx\ntest   $0x1,%sil\ncmove  %ecx,%edx\nmov    %edx,%ecx\nshr    %ecx\nmov    %ecx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%dl\ncmove  %ecx,%esi\nmov    %esi,%ecx\nshr    %ecx\nmov    %ecx,%edx\nxor    $0xedb88320,%edx\ntest   $0x1,%sil\ncmove  %ecx,%edx\nmov    %edx,%ecx\nshr    %ecx\nmov    %ecx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%dl\ncmove  %ecx,%esi\nmov    %esi,%ecx\nshr    %ecx\nmov    %ecx,%ebx\nxor    $0xedb88320,%ebx\ntest   $0x1,%sil\ncmove  %ecx,%ebx\nmov    %eax,%ecx\nmovzbl (%rdi,%rcx,1),%ecx\nadd    $0x1,%eax\ntest   %cl,%cl\njne    1150 <func0+0x20>\nmov    $0x9,%edi\ncall   1030 <malloc@plt>\ntest   %rax,%rax\nje     1236 <func0+0x106>\nmov    %rax,%r14\nnot    %ebx\nlea    0xdf0(%rip),%rsi\nmov    %rax,%rdi\nmov    %ebx,%edx\nxor    %eax,%eax\ncall   1040 <sprintf@plt>\njmp    1239 <func0+0x109>\nlea    0xdd6(%rip),%rdi\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\njmp    1050 <strdup@plt>\nxor    %r14d,%r14d\nmov    %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 162,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %r14\npush   %rbx\npush   %rax\nmov    (%rdi),%cl\ntest   %cl,%cl\nje     1223 <func0+0xf3>\nmov    $0xffffffff,%ebx\nmov    $0x1,%eax\nnopl   0x0(%rax,%rax,1)\nmovzbl %cl,%ecx\nxor    %ebx,%ecx\nmov    %ecx,%edx\nshr    %edx\nmov    %edx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%cl\ncmove  %edx,%esi\nmov    %esi,%ecx\nshr    %ecx\nmov    %ecx,%edx\nxor    $0xedb88320,%edx\ntest   $0x1,%sil\ncmove  %ecx,%edx\nmov    %edx,%ecx\nshr    %ecx\nmov    %ecx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%dl\ncmove  %ecx,%esi\nmov    %esi,%ecx\nshr    %ecx\nmov    %ecx,%edx\nxor    $0xedb88320,%edx\ntest   $0x1,%sil\ncmove  %ecx,%edx\nmov    %edx,%ecx\nshr    %ecx\nmov    %ecx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%dl\ncmove  %ecx,%esi\nmov    %esi,%ecx\nshr    %ecx\nmov    %ecx,%edx\nxor    $0xedb88320,%edx\ntest   $0x1,%sil\ncmove  %ecx,%edx\nmov    %edx,%ecx\nshr    %ecx\nmov    %ecx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%dl\ncmove  %ecx,%esi\nmov    %esi,%ecx\nshr    %ecx\nmov    %ecx,%ebx\nxor    $0xedb88320,%ebx\ntest   $0x1,%sil\ncmove  %ecx,%ebx\nmov    %eax,%ecx\nmovzbl (%rdi,%rcx,1),%ecx\nadd    $0x1,%eax\ntest   %cl,%cl\njne    1150 <func0+0x20>\nmov    $0x9,%edi\ncall   1030 <malloc@plt>\ntest   %rax,%rax\nje     1236 <func0+0x106>\nmov    %rax,%r14\nnot    %ebx\nlea    0xdf0(%rip),%rsi\nmov    %rax,%rdi\nmov    %ebx,%edx\nxor    %eax,%eax\ncall   1040 <sprintf@plt>\njmp    1239 <func0+0x109>\nlea    0xdd6(%rip),%rdi\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\njmp    1050 <strdup@plt>\nxor    %r14d,%r14d\nmov    %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %r14\nret\n"
    },
    {
        "task_id": 163,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %rdx,-0x10(%rbp)\nmov    %rcx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    113a <func0+0x3a>\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x8(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njg     1197 <func0+0x97>\ncmpl   $0xa,-0x20(%rbp)\njge    1184 <func0+0x84>\nmov    -0x20(%rbp),%eax\nmov    $0x2,%ecx\ncltd\nidiv   %ecx\ncmp    $0x0,%edx\njne    1184 <func0+0x84>\nmov    -0x20(%rbp),%edx\nmov    -0x10(%rbp),%rax\nmov    -0x18(%rbp),%rsi\nmov    (%rsi),%ecx\nmov    %ecx,%edi\nadd    $0x1,%edi\nmov    %edi,(%rsi)\nmovslq %ecx,%rcx\nmov    %edx,(%rax,%rcx,4)\njmp    1189 <func0+0x89>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x20(%rbp)\njmp    1140 <func0+0x40>\npop    %rbp\nret\n"
    },
    {
        "task_id": 163,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    %edi,%esi\nmov    %esi,%r8d\ncmovl  %edi,%r8d\nmovl   $0x0,(%rcx)\ncmovl  %esi,%edi\nadd    $0x1,%r8d\njmp    1128 <func0+0x28>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%edi\ncmp    %edi,%r8d\nje     1141 <func0+0x41>\ncmp    $0x9,%edi\njg     1120 <func0+0x20>\nmov    %edi,%esi\nand    $0x1,%esi\njne    1120 <func0+0x20>\nmovslq (%rcx),%rsi\nlea    0x1(%rsi),%eax\nmov    %eax,(%rcx)\nmov    %edi,(%rdx,%rsi,4)\njmp    1120 <func0+0x20>\nret\n"
    },
    {
        "task_id": 163,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    %edi,%esi\nmov    %esi,%r8d\ncmovl  %edi,%r8d\ncmovl  %esi,%edi\nmovl   $0x0,(%rcx)\nlea    0x1(%r8),%r9d\nmov    %r9d,%eax\nsub    %edi,%eax\nmov    %edi,%esi\ntest   $0x1,%al\nje     113b <func0+0x3b>\ncmp    $0x9,%edi\njg     1138 <func0+0x38>\nmov    %edi,%eax\nand    $0x1,%eax\njne    1138 <func0+0x38>\nmovslq (%rcx),%rax\nlea    0x1(%rax),%esi\nmov    %esi,(%rcx)\nmov    %edi,(%rdx,%rax,4)\nlea    0x1(%rdi),%esi\ncmp    %edi,%r8d\njne    1141 <func0+0x41>\nret\nmov    %esi,%r8d\nand    $0x1,%r8d\njmp    1158 <func0+0x58>\nnopw   0x0(%rax,%rax,1)\nadd    $0x2,%esi\ncmp    %esi,%r9d\nje     1140 <func0+0x40>\ncmp    $0x9,%esi\njg     116d <func0+0x6d>\ntest   %r8d,%r8d\njne    116d <func0+0x6d>\nmovslq (%rcx),%rax\nlea    0x1(%rax),%edi\nmov    %edi,(%rcx)\nmov    %esi,(%rdx,%rax,4)\nlea    0x1(%rsi),%eax\ncmp    $0x9,%eax\njg     1150 <func0+0x50>\ntest   %r8d,%r8d\nje     1150 <func0+0x50>\nmovslq (%rcx),%r10\nlea    0x1(%r10),%edi\nmov    %edi,(%rcx)\nmov    %eax,(%rdx,%r10,4)\njmp    1150 <func0+0x50>\n"
    },
    {
        "task_id": 163,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\ncmp    %edi,%esi\nmov    %esi,%r8d\ncmovl  %edi,%r8d\ncmovl  %esi,%edi\nmovl   $0x0,(%rcx)\nlea    0x1(%r8),%r9d\nmov    %r9d,%eax\nsub    %edi,%eax\nmov    %edi,%esi\ntest   $0x1,%al\nje     113b <func0+0x3b>\ncmp    $0x9,%edi\njg     1138 <func0+0x38>\nmov    %edi,%eax\nand    $0x1,%eax\njne    1138 <func0+0x38>\nmovslq (%rcx),%rax\nlea    0x1(%rax),%esi\nmov    %esi,(%rcx)\nmov    %edi,(%rdx,%rax,4)\nlea    0x1(%rdi),%esi\ncmp    %edi,%r8d\njne    1141 <func0+0x41>\nret\nmov    %esi,%r8d\nand    $0x1,%r8d\njmp    1158 <func0+0x58>\nnopw   0x0(%rax,%rax,1)\nadd    $0x2,%esi\ncmp    %esi,%r9d\nje     1140 <func0+0x40>\ncmp    $0x9,%esi\njg     116d <func0+0x6d>\ntest   %r8d,%r8d\njne    116d <func0+0x6d>\nmovslq (%rcx),%rax\nlea    0x1(%rax),%edi\nmov    %edi,(%rcx)\nmov    %esi,(%rdx,%rax,4)\nlea    0x1(%rsi),%eax\ncmp    $0x9,%eax\njg     1150 <func0+0x50>\ntest   %r8d,%r8d\nje     1150 <func0+0x50>\nmovslq (%rcx),%r10\nlea    0x1(%r10),%edi\nmov    %edi,(%rcx)\nmov    %eax,(%rdx,%r10,4)\njmp    1150 <func0+0x50>\n"
    }
]