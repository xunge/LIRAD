[
    {
        "task_id": 0,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovss  %xmm0,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    11f1 <func0+0x88>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    11e5 <func0+0x7c>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmovss  0xf03(%rip),%xmm1\n00\nandps  %xmm0,%xmm1\nmovss  -0x20(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njbe    11e1 <func0+0x78>\nmov    $0x1,%eax\njmp    11fe <func0+0x95>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1191 <func0+0x28>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1186 <func0+0x1d>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 0,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11ac <func0+0x43>\nmov    %esi,%ecx\nmov    $0x1,%edx\nmovss  0xf40(%rip),%xmm3\n00\ncmp    %rcx,%rdx\nje     11b2 <func0+0x49>\nmovss  -0x4(%rdi,%rdx,4),%xmm2\nmov    %rdx,%rax\nmovaps %xmm2,%xmm1\nsubss  (%rdi,%rax,4),%xmm1\nandps  %xmm3,%xmm1\ncomiss %xmm1,%xmm0\nja     11b8 <func0+0x4f>\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     118e <func0+0x25>\nadd    $0x1,%rdx\njmp    1180 <func0+0x17>\nmov    $0x0,%eax\nret\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 0,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1439 <func0+0x59>\nmovslq %esi,%rcx\nmov    $0x1,%edx\nmovss  0xcc8(%rip),%xmm3\n00\ncmp    %rcx,%rdx\nje     1439 <func0+0x59>\nmovss  -0x4(%rdi,%rdx,4),%xmm2\nmov    %rdx,%rax\njmp    1418 <func0+0x38>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    1430 <func0+0x50>\nmovaps %xmm2,%xmm1\nsubss  (%rdi,%rax,4),%xmm1\nandps  %xmm3,%xmm1\ncomiss %xmm1,%xmm0\njbe    1410 <func0+0x30>\nmov    $0x1,%eax\nret\nxchg   %ax,%ax\nadd    $0x1,%rdx\ncmp    %rcx,%rdx\njne    13fd <func0+0x1d>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 0,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1199 <func0+0x59>\nmovslq %esi,%rcx\nmov    $0x1,%edx\nmovss  0xeb8(%rip),%xmm3\n00\ncmp    %rdx,%rcx\nje     1199 <func0+0x59>\nmovss  -0x4(%rdi,%rdx,4),%xmm2\nmov    %rdx,%rax\njmp    1178 <func0+0x38>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    1190 <func0+0x50>\nmovaps %xmm2,%xmm1\nsubss  (%rdi,%rax,4),%xmm1\nandps  %xmm3,%xmm1\ncomiss %xmm1,%xmm0\njbe    1170 <func0+0x30>\nmov    $0x1,%eax\nret\nxchg   %ax,%ax\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    115d <func0+0x1d>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 1,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   10f0 <strlen@plt>\nmov    %eax,-0x24(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0xa,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1130 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   1130 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x50(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x28(%rbp)\njmp    13a8 <func0+0x15f>\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x35(%rbp)\ncmpb   $0x28,-0x35(%rbp)\njne    12fc <func0+0xb3>\naddl   $0x1,-0x34(%rbp)\nmov    -0x2c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x2c(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x35(%rbp),%eax\nmov    %al,(%rdx)\njmp    13a4 <func0+0x15b>\ncmpb   $0x29,-0x35(%rbp)\njne    13a4 <func0+0x15b>\nsubl   $0x1,-0x34(%rbp)\nmov    -0x2c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x2c(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x35(%rbp),%eax\nmov    %al,(%rdx)\ncmpl   $0x0,-0x34(%rbp)\njne    13a4 <func0+0x15b>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x50(%rbp),%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1150 <strdup@plt>\nmov    %rax,(%rbx)\nmov    -0x50(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x50(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x50(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x30(%rbp)\njg     139d <func0+0x154>\nshll   -0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1140 <realloc@plt>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x2c(%rbp)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     12c1 <func0+0x78>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   10d0 <free@plt>\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 1,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r13\nmov    %rsi,%r14\ncall   10f0 <strlen@plt>\nmov    %rax,%rbp\nmov    $0x50,%edi\ncall   1130 <malloc@plt>\nmov    %rax,%r15\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\ncall   1130 <malloc@plt>\nmov    %rax,%r12\nmovl   $0x0,(%r14)\ntest   %ebp,%ebp\njle    1338 <func0+0xef>\nmov    %r13,%rbx\nlea    -0x1(%rbp),%eax\nlea    0x1(%r13,%rax,1),%r13\nmov    $0x0,%edx\nmovl   $0xa,0x4(%rsp)\n00\nmov    $0x0,%ebp\njmp    12c9 <func0+0x80>\nadd    $0x1,%ebp\nmovslq %edx,%rax\nmovb   $0x28,(%r12,%rax,1)\nlea    0x1(%rdx),%edx\nadd    $0x1,%rbx\ncmp    %r13,%rbx\nje     1338 <func0+0xef>\nmovzbl (%rbx),%eax\ncmp    $0x28,%al\nje     12b2 <func0+0x69>\ncmp    $0x29,%al\njne    12c0 <func0+0x77>\nlea    0x1(%rdx),%eax\nmovslq %edx,%rdx\nmovb   $0x29,(%r12,%rdx,1)\nmov    %eax,%edx\nsub    $0x1,%ebp\njne    12c0 <func0+0x77>\ncltq\nmovb   $0x0,(%r12,%rax,1)\nmovslq (%r14),%rax\nlea    (%r15,%rax,8),%rax\nmov    %rax,0x8(%rsp)\nmov    %r12,%rdi\ncall   1150 <strdup@plt>\nmov    0x8(%rsp),%rcx\nmov    %rax,(%rcx)\nmov    (%r14),%eax\nadd    $0x1,%eax\nmov    %eax,(%r14)\nmov    %ebp,%edx\ncmp    0x4(%rsp),%eax\njl     12c0 <func0+0x77>\nshll   0x4(%rsp)\nmov    0x4(%rsp),%eax\nmovslq %eax,%rsi\nshl    $0x3,%rsi\nmov    %r15,%rdi\ncall   1140 <realloc@plt>\nmov    %rax,%r15\nmov    %ebp,%edx\njmp    12c0 <func0+0x77>\nmov    %r12,%rdi\ncall   10d0 <free@plt>\nmov    %r15,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 1,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x18,%rsp\nmov    %rsi,(%rsp)\ncall   10f0 <strlen@plt>\nmov    $0x50,%edi\nmov    %rax,%rbp\ncall   1130 <malloc@plt>\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\nmov    %rax,%r14\ncall   1130 <malloc@plt>\nmov    (%rsp),%rdx\nmov    %rax,%r15\nmovl   $0x0,(%rdx)\ntest   %ebp,%ebp\njle    15bc <func0+0x8c>\nlea    -0x1(%rbp),%eax\nmov    $0xa,%ecx\nxor    %ebp,%ebp\nxor    %r12d,%r12d\nlea    0x1(%rbx,%rax,1),%r13\njmp    159d <func0+0x6d>\nxchg   %ax,%ax\ncmp    $0x29,%al\nje     15e0 <func0+0xb0>\nadd    $0x1,%rbx\ncmp    %r13,%rbx\nje     15bc <func0+0x8c>\nmovzbl (%rbx),%eax\ncmp    $0x28,%al\njne    1590 <func0+0x60>\nmovslq %ebp,%rax\nadd    $0x1,%rbx\nadd    $0x1,%r12d\nadd    $0x1,%ebp\nmovb   $0x28,(%r15,%rax,1)\ncmp    %r13,%rbx\njne    159d <func0+0x6d>\nmov    %r15,%rdi\ncall   10d0 <free@plt>\nadd    $0x18,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmovb   $0x29,(%r15,%rax,1)\nsub    $0x1,%r12d\njne    1594 <func0+0x64>\nmovslq (%rdx),%rax\nmovslq %ebp,%rbp\nmov    %r15,%rdi\nmov    %ecx,0x8(%rsp)\nmovb   $0x0,(%r15,%rbp,1)\nmov    %rdx,(%rsp)\nlea    (%r14,%rax,8),%rbp\ncall   1150 <strdup@plt>\nmov    (%rsp),%rdx\nmov    0x8(%rsp),%ecx\nmov    %rax,0x0(%rbp)\nxor    %ebp,%ebp\nmov    (%rdx),%eax\nadd    $0x1,%eax\nmov    %eax,(%rdx)\ncmp    %ecx,%eax\njl     1594 <func0+0x64>\nadd    %ecx,%ecx\nmov    %r14,%rdi\nmov    %rdx,0x8(%rsp)\nmovslq %ecx,%rsi\nmov    %ecx,(%rsp)\nshl    $0x3,%rsi\ncall   1140 <realloc@plt>\nmov    0x8(%rsp),%rdx\nmov    (%rsp),%ecx\nmov    %rax,%r14\njmp    1594 <func0+0x64>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\n"
    },
    {
        "task_id": 1,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x18,%rsp\nmov    %rsi,(%rsp)\ncall   10f0 <strlen@plt>\nmov    $0x50,%edi\nmov    %rax,%rbp\ncall   1130 <malloc@plt>\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\nmov    %rax,%r14\ncall   1130 <malloc@plt>\nmov    (%rsp),%rdx\nmov    %rax,%r15\nmovl   $0x0,(%rdx)\ntest   %ebp,%ebp\njle    161c <func0+0x8c>\nlea    -0x1(%rbp),%eax\nmov    $0xa,%ecx\nxor    %ebp,%ebp\nxor    %r12d,%r12d\nlea    0x1(%rbx,%rax,1),%r13\njmp    15fd <func0+0x6d>\nxchg   %ax,%ax\ncmp    $0x29,%al\nje     1640 <func0+0xb0>\nadd    $0x1,%rbx\ncmp    %r13,%rbx\nje     161c <func0+0x8c>\nmovzbl (%rbx),%eax\ncmp    $0x28,%al\njne    15f0 <func0+0x60>\nmovslq %ebp,%rax\nadd    $0x1,%rbx\nadd    $0x1,%r12d\nadd    $0x1,%ebp\nmovb   $0x28,(%r15,%rax,1)\ncmp    %r13,%rbx\njne    15fd <func0+0x6d>\nmov    %r15,%rdi\ncall   10d0 <free@plt>\nadd    $0x18,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmovb   $0x29,(%r15,%rax,1)\nsub    $0x1,%r12d\njne    15f4 <func0+0x64>\nmovslq (%rdx),%rax\nmovslq %ebp,%rbp\nmov    %r15,%rdi\nmov    %ecx,0x8(%rsp)\nmovb   $0x0,(%r15,%rbp,1)\nmov    %rdx,(%rsp)\nlea    (%r14,%rax,8),%rbp\ncall   1150 <strdup@plt>\nmov    (%rsp),%rdx\nmov    0x8(%rsp),%ecx\nmov    %rax,0x0(%rbp)\nxor    %ebp,%ebp\nmov    (%rdx),%eax\nadd    $0x1,%eax\nmov    %eax,(%rdx)\ncmp    %ecx,%eax\njl     15f4 <func0+0x64>\nadd    %ecx,%ecx\nmov    %r14,%rdi\nmov    %rdx,0x8(%rsp)\nmovslq %ecx,%rsi\nmov    %ecx,(%rsp)\nshl    $0x3,%rsi\ncall   1140 <realloc@plt>\nmov    0x8(%rsp),%rdx\nmov    (%rsp),%ecx\nmov    %rax,%r14\njmp    15f4 <func0+0x64>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\n"
    },
    {
        "task_id": 2,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nmovss  -0x4(%rbp),%xmm0\nsubss  %xmm1,%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 2,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nsubss  %xmm1,%xmm0\nret\n"
    },
    {
        "task_id": 2,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nsubss  %xmm1,%xmm0\nret\n"
    },
    {
        "task_id": 2,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nsubss  %xmm1,%xmm0\nret\n"
    },
    {
        "task_id": 3,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11b2 <func0+0x49>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njns    11ae <func0+0x45>\nmov    $0x1,%eax\njmp    11bf <func0+0x56>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1188 <func0+0x1f>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 3,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11a1 <func0+0x38>\nmov    (%rdi),%edx\ntest   %edx,%edx\njs     11a7 <func0+0x3e>\nadd    $0x4,%rdi\nlea    -0x1(%rsi),%eax\nlea    (%rdi,%rax,4),%rcx\ncmp    %rcx,%rdi\nje     119b <func0+0x32>\nmov    %edx,%eax\nadd    (%rdi),%eax\nmov    %eax,%edx\nadd    $0x4,%rdi\ntest   %eax,%eax\njns    1182 <func0+0x19>\nmov    $0x1,%eax\nret\nmov    $0x0,%eax\nret\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 3,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    13af <func0+0x2f>\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     13b8 <func0+0x38>\nadd    $0x4,%rdi\nlea    -0x1(%rsi),%edx\nlea    (%rdi,%rdx,4),%rdx\njmp    13aa <func0+0x2a>\nnopl   0x0(%rax,%rax,1)\nadd    (%rdi),%eax\nadd    $0x4,%rdi\ntest   %eax,%eax\njs     13b8 <func0+0x38>\ncmp    %rdx,%rdi\njne    13a0 <func0+0x20>\nxor    %eax,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 3,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    116f <func0+0x2f>\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     1178 <func0+0x38>\nadd    $0x4,%rdi\nlea    -0x1(%rsi),%edx\nlea    (%rdi,%rdx,4),%rdx\njmp    116a <func0+0x2a>\nnopl   0x0(%rax,%rax,1)\nadd    (%rdi),%eax\nadd    $0x4,%rdi\ntest   %eax,%eax\njs     1178 <func0+0x38>\ncmp    %rdx,%rdi\njne    1160 <func0+0x20>\nxor    %eax,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 4,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\npxor   %xmm0,%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    11bb <func0+0x52>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  -0x10(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x10(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1191 <func0+0x28>\npxor   %xmm1,%xmm1\ncvtsi2ssl -0x1c(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\npxor   %xmm0,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1226 <func0+0xbd>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nsubss  -0x4(%rbp),%xmm0\nmovss  0xe9f(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\nmovss  -0xc(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     11ec <func0+0x83>\npxor   %xmm1,%xmm1\ncvtsi2ssl -0x1c(%rbp),%xmm1\nmovss  -0xc(%rbp),%xmm0\ndivss  %xmm1,%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 4,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11c5 <func0+0x5c>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdx\npxor   %xmm0,%xmm0\naddss  (%rdi),%xmm0\nadd    $0x4,%rdi\ncmp    %rdx,%rdi\njne    1180 <func0+0x17>\npxor   %xmm4,%xmm4\ncvtsi2ss %esi,%xmm4\ndivss  %xmm4,%xmm0\npxor   %xmm2,%xmm2\nmovss  0xefb(%rip),%xmm3\n00\nmovss  (%rax),%xmm1\nsubss  %xmm0,%xmm1\nandps  %xmm3,%xmm1\naddss  %xmm1,%xmm2\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    11a5 <func0+0x3c>\ndivss  %xmm4,%xmm2\nmovaps %xmm2,%xmm0\nret\npxor   %xmm4,%xmm4\ncvtsi2ss %esi,%xmm4\npxor   %xmm2,%xmm2\njmp    11bd <func0+0x54>\n"
    },
    {
        "task_id": 4,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npxor   %xmm4,%xmm4\ncvtsi2ss %esi,%xmm4\ntest   %esi,%esi\njle    1330 <func0+0x60>\nlea    -0x1(%rsi),%eax\npxor   %xmm0,%xmm0\nlea    0x4(%rdi,%rax,4),%rdx\nmov    %rdi,%rax\nnop\naddss  (%rax),%xmm0\nadd    $0x4,%rax\ncmp    %rax,%rdx\njne    12f0 <func0+0x20>\ndivss  %xmm4,%xmm0\npxor   %xmm2,%xmm2\nmovss  0xd93(%rip),%xmm3\n00\nnopl   (%rax)\nmovss  (%rdi),%xmm1\nadd    $0x4,%rdi\nsubss  %xmm0,%xmm1\nandps  %xmm3,%xmm1\naddss  %xmm1,%xmm2\ncmp    %rdi,%rdx\njne    1310 <func0+0x40>\ndivss  %xmm4,%xmm2\nmovaps %xmm2,%xmm0\nret\npxor   %xmm2,%xmm2\ndivss  %xmm4,%xmm2\nmovaps %xmm2,%xmm0\nret\n"
    },
    {
        "task_id": 4,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npxor   %xmm2,%xmm2\nmov    %rdi,%rcx\nmov    %esi,%edx\ncvtsi2ss %esi,%xmm2\ntest   %esi,%esi\njle    12d0 <func0+0x190>\nlea    -0x1(%rsi),%r8d\ncmp    $0x2,%r8d\njbe    12e0 <func0+0x1a0>\nshr    $0x2,%esi\nmov    %rdi,%rax\npxor   %xmm4,%xmm4\nsub    $0x1,%esi\nlea    0x10(%rdi),%rdi\nmovaps %xmm4,%xmm1\nshl    $0x4,%rsi\nadd    %rdi,%rsi\nnopw   0x0(%rax,%rax,1)\nmovups (%rax),%xmm0\nadd    $0x10,%rax\naddss  %xmm0,%xmm1\nmovaps %xmm0,%xmm3\nshufps $0x55,%xmm0,%xmm3\naddss  %xmm3,%xmm1\nmovaps %xmm0,%xmm3\nunpckhps %xmm0,%xmm3\nshufps $0xff,%xmm0,%xmm0\naddss  %xmm3,%xmm1\naddss  %xmm0,%xmm1\ncmp    %rsi,%rax\njne    1188 <func0+0x48>\nmov    %edx,%eax\nand    $0xfffffffc,%eax\ncmp    %eax,%edx\nje     12c0 <func0+0x180>\nmovslq %eax,%rsi\naddss  (%rcx,%rsi,4),%xmm1\nlea    0x0(,%rsi,4),%rdi\n00\nlea    0x1(%rax),%esi\ncmp    %esi,%edx\njle    11ec <func0+0xac>\nadd    $0x2,%eax\naddss  0x4(%rcx,%rdi,1),%xmm1\ncmp    %eax,%edx\njle    11ec <func0+0xac>\naddss  0x8(%rcx,%rdi,1),%xmm1\nmovaps %xmm1,%xmm3\ndivss  %xmm2,%xmm3\ncmp    $0x2,%r8d\njbe    12d9 <func0+0x199>\nlea    0x10(%rcx),%rdi\nmov    %edx,%esi\nmovaps 0xea6(%rip),%xmm5\nmovaps %xmm3,%xmm6\nmov    %rcx,%rax\nshr    $0x2,%esi\nmovaps %xmm4,%xmm0\nshufps $0x0,%xmm6,%xmm6\nsub    $0x1,%esi\nshl    $0x4,%rsi\nadd    %rdi,%rsi\nnopl   0x0(%rax)\nmovups (%rax),%xmm1\nadd    $0x10,%rax\nsubps  %xmm6,%xmm1\nandps  %xmm5,%xmm1\naddss  %xmm1,%xmm0\nmovaps %xmm1,%xmm4\nshufps $0x55,%xmm1,%xmm4\naddss  %xmm0,%xmm4\nmovaps %xmm1,%xmm0\nunpckhps %xmm1,%xmm0\nshufps $0xff,%xmm1,%xmm1\naddss  %xmm4,%xmm0\naddss  %xmm1,%xmm0\ncmp    %rax,%rsi\njne    1228 <func0+0xe8>\nmov    %edx,%eax\nand    $0xfffffffc,%eax\ntest   $0x3,%dl\nje     12b8 <func0+0x178>\nmovslq %eax,%rsi\nmovss  0xe30(%rip),%xmm4\n00\nmovss  (%rcx,%rsi,4),%xmm1\nlea    0x0(,%rsi,4),%rdi\n00\nlea    0x1(%rax),%esi\nsubss  %xmm3,%xmm1\nandps  %xmm4,%xmm1\naddss  %xmm1,%xmm0\ncmp    %edx,%esi\njge    12b8 <func0+0x178>\nmovss  0x4(%rcx,%rdi,1),%xmm1\nadd    $0x2,%eax\nsubss  %xmm3,%xmm1\nandps  %xmm4,%xmm1\naddss  %xmm1,%xmm0\ncmp    %eax,%edx\njle    12b8 <func0+0x178>\nmovss  0x8(%rcx,%rdi,1),%xmm1\nsubss  %xmm3,%xmm1\nandps  %xmm4,%xmm1\naddss  %xmm1,%xmm0\ndivss  %xmm2,%xmm0\nret\nnopl   (%rax)\nmovaps %xmm1,%xmm3\ndivss  %xmm2,%xmm3\njmp    1201 <func0+0xc1>\nnopl   0x0(%rax)\npxor   %xmm0,%xmm0\ndivss  %xmm2,%xmm0\nret\nxor    %eax,%eax\nmovaps %xmm4,%xmm0\njmp    1265 <func0+0x125>\npxor   %xmm4,%xmm4\nxor    %eax,%eax\nmovaps %xmm4,%xmm1\njmp    11c2 <func0+0x82>\n"
    },
    {
        "task_id": 5,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    %rcx,-0x28(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njle    11d3 <func0+0x2a>\nmov    -0x1c(%rbp),%eax\nadd    %eax,%eax\nlea    -0x1(%rax),%edx\njmp    11d8 <func0+0x2f>\nmov    $0x0,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njle    1208 <func0+0x5f>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x1,-0xc(%rbp)\njmp    126e <func0+0xc5>\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1218 <func0+0x6f>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 5,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    11f9 <func0+0x50>\nmov    %rdi,%rbx\nmov    %esi,%r12d\nmov    %edx,%ebp\nlea    -0x1(%rsi,%rsi,1),%edi\nmov    %edi,(%rcx)\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    (%rbx),%edx\nmov    %edx,(%rax)\ncmp    $0x1,%r12d\njle    11f4 <func0+0x4b>\nmov    %r12d,%esi\nmov    $0x1,%edx\nmov    %ebp,-0x4(%rax,%rdx,8)\nmov    (%rbx,%rdx,4),%ecx\nmov    %ecx,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rdx,%rsi\njne    11e1 <func0+0x38>\npop    %rbx\npop    %rbp\npop    %r12\nret\nmovl   $0x0,(%rcx)\nmov    $0x0,%edi\ncall   10b0 <malloc@plt>\njmp    11f4 <func0+0x4b>\n"
    },
    {
        "task_id": 5,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    13d0 <func0+0x60>\npush   %r12\nmov    %edx,%r12d\npush   %rbp\nmov    %rdi,%rbp\nlea    -0x1(%rsi,%rsi,1),%edi\npush   %rbx\nmov    %esi,%ebx\nmov    %edi,(%rcx)\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    0x0(%rbp),%edx\nmov    %edx,(%rax)\ncmp    $0x1,%ebx\nje     13c5 <func0+0x55>\nmovslq %ebx,%rsi\nmov    $0x1,%edx\nnopl   0x0(%rax,%rax,1)\n00\nmov    0x0(%rbp,%rdx,4),%ecx\nmov    %r12d,-0x4(%rax,%rdx,8)\nmov    %ecx,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rdx,%rsi\njne    13b0 <func0+0x40>\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmovl   $0x0,(%rcx)\nxor    %edi,%edi\njmp    10b0 <malloc@plt>\nnopl   (%rax)\n"
    },
    {
        "task_id": 5,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1440 <func0+0x110>\npush   %r12\nmov    %edx,%r12d\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %rdi,%rbx\nlea    -0x1(%rsi,%rsi,1),%edi\nmov    %edi,(%rcx)\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%r8\nmov    (%rbx),%eax\nmov    %eax,(%r8)\ncmp    $0x1,%ebp\nje     1433 <func0+0x103>\nlea    -0x2(%rbp),%eax\nlea    -0x1(%rbp),%esi\ncmp    $0x2,%eax\njbe    144d <func0+0x11d>\nmov    %esi,%ecx\nmovd   %r12d,%xmm4\nxor    %eax,%eax\nshr    $0x2,%ecx\npshufd $0x0,%xmm4,%xmm0\nshl    $0x4,%rcx\nnop\nmovdqu 0x4(%rbx,%rax,1),%xmm2\nmovdqa %xmm0,%xmm1\npunpckldq %xmm2,%xmm1\nmovups %xmm1,0x4(%r8,%rax,2)\nmovdqa %xmm0,%xmm1\npunpckhdq %xmm2,%xmm1\nmovups %xmm1,0x14(%r8,%rax,2)\nadd    $0x10,%rax\ncmp    %rax,%rcx\njne    1390 <func0+0x60>\nmov    %esi,%ecx\nand    $0xfffffffc,%ecx\nlea    0x1(%rcx),%eax\nlea    0x1(%rcx,%rcx,1),%edx\ncmp    %ecx,%esi\nje     1433 <func0+0x103>\nmovslq %eax,%rcx\nmovd   %r12d,%xmm0\nmovslq %edx,%rdx\nlea    0x0(,%rcx,4),%rdi\n00\nmov    (%rbx,%rcx,4),%ecx\nlea    0x0(,%rdx,4),%rsi\n00\nmovd   %ecx,%xmm5\npunpckldq %xmm5,%xmm0\nmovq   %xmm0,(%r8,%rdx,4)\nlea    0x1(%rax),%edx\ncmp    %edx,%ebp\njle    1433 <func0+0x103>\nmovd   0x4(%rbx,%rdi,1),%xmm6\nmovd   %r12d,%xmm0\nadd    $0x2,%eax\npunpckldq %xmm6,%xmm0\nmovq   %xmm0,0x8(%r8,%rsi,1)\ncmp    %eax,%ebp\njle    1433 <func0+0x103>\nmov    0x8(%rbx,%rdi,1),%eax\nmovd   %r12d,%xmm0\nmovd   %eax,%xmm7\npunpckldq %xmm7,%xmm0\nmovq   %xmm0,0x10(%r8,%rsi,1)\npop    %rbx\nmov    %r8,%rax\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\nmovl   $0x0,(%rcx)\nxor    %edi,%edi\njmp    10b0 <malloc@plt>\nmov    $0x1,%edx\nmov    $0x1,%eax\njmp    13cb <func0+0x9b>\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 6,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovq   $0x0,-0x8(%rbp)\n00\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1277 <func0+0xce>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x19(%rbp)\ncmpb   $0x28,-0x19(%rbp)\njne    121a <func0+0x71>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    1273 <func0+0xca>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\njmp    1273 <func0+0xca>\ncmpb   $0x29,-0x19(%rbp)\njne    1273 <func0+0xca>\nsubl   $0x1,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njne    1273 <func0+0xca>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10b0 <realloc@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\nmovl   $0x0,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    11ed <func0+0x44>\nmov    -0x30(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 6,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rsi,%r13\nmovzbl (%rdi),%edx\ntest   %dl,%dl\nje     1226 <func0+0x7d>\nlea    0x1(%rdi),%rbx\nmov    $0x0,%r14d\nmov    $0x0,%r12d\nmov    $0x0,%ebp\nmov    $0x0,%eax\njmp    11f7 <func0+0x4e>\nadd    $0x1,%ebp\ncmp    %ebp,%r12d\ncmovl  %ebp,%r12d\nadd    $0x1,%rbx\nmovzbl -0x1(%rbx),%edx\ntest   %dl,%dl\nje     1231 <func0+0x88>\ncmp    $0x28,%dl\nje     11e1 <func0+0x38>\ncmp    $0x29,%dl\njne    11eb <func0+0x42>\nsub    $0x1,%ebp\njne    11eb <func0+0x42>\nadd    $0x1,%r14d\nmovslq %r14d,%r15\nshl    $0x2,%r15\nmov    %r15,%rsi\nmov    %rax,%rdi\ncall   10b0 <realloc@plt>\nmov    %r12d,-0x4(%rax,%r15,1)\nmov    %ebp,%r12d\njmp    11eb <func0+0x42>\nmov    $0x0,%r14d\nmov    $0x0,%eax\nmov    %r14d,0x0(%r13)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 6,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%edx\ntest   %dl,%dl\nje     13f8 <func0+0x98>\nlea    0x1(%rdi),%rbx\nxor    %r14d,%r14d\nxor    %r12d,%r12d\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    13a0 <func0+0x40>\nnopl   0x0(%rax)\ncmp    $0x29,%dl\nje     13d0 <func0+0x70>\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\nje     13ba <func0+0x5a>\ncmp    $0x28,%dl\njne    1390 <func0+0x30>\nadd    $0x1,%ebp\ncmp    %ebp,%r12d\ncmovl  %ebp,%r12d\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\njne    13a0 <func0+0x40>\nmov    %r14d,0x0(%r13)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nsub    $0x1,%ebp\njne    1395 <func0+0x35>\nadd    $0x1,%r14d\nmov    %rax,%rdi\nmovslq %r14d,%r15\nshl    $0x2,%r15\nmov    %r15,%rsi\ncall   10b0 <realloc@plt>\nmov    %r12d,-0x4(%rax,%r15,1)\nxor    %r12d,%r12d\njmp    1395 <func0+0x35>\nnopl   (%rax)\nxor    %r14d,%r14d\nxor    %eax,%eax\njmp    13ba <func0+0x5a>\nnop\n"
    },
    {
        "task_id": 6,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%edx\ntest   %dl,%dl\nje     13d8 <func0+0x98>\nlea    0x1(%rdi),%rbx\nxor    %r14d,%r14d\nxor    %r12d,%r12d\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    1380 <func0+0x40>\nnopl   0x0(%rax)\ncmp    $0x29,%dl\nje     13b0 <func0+0x70>\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\nje     139a <func0+0x5a>\ncmp    $0x28,%dl\njne    1370 <func0+0x30>\nadd    $0x1,%ebp\ncmp    %ebp,%r12d\ncmovl  %ebp,%r12d\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\njne    1380 <func0+0x40>\nmov    %r14d,0x0(%r13)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nsub    $0x1,%ebp\njne    1375 <func0+0x35>\nadd    $0x1,%r14d\nmov    %rax,%rdi\nmovslq %r14d,%r15\nshl    $0x2,%r15\nmov    %r15,%rsi\ncall   10b0 <realloc@plt>\nmov    %r12d,-0x4(%rax,%r15,1)\nxor    %r12d,%r12d\njmp    1375 <func0+0x35>\nnopl   (%rax)\nxor    %r14d,%r14d\nxor    %eax,%eax\njmp    139a <func0+0x5a>\nnop\n"
    },
    {
        "task_id": 7,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmovq   $0x0,-0x8(%rbp)\n00\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    12a4 <func0+0xbb>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10f0 <strstr@plt>\ntest   %rax,%rax\nje     12a0 <func0+0xb7>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10e0 <realloc@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     121f <func0+0x36>\nmov    -0x30(%rbp),%rax\nmov    -0x10(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 7,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdx,(%rsp)\nmov    %rcx,0x8(%rsp)\ntest   %esi,%esi\njle    125d <func0+0x74>\nmov    %rdi,%rbx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r15\nmov    $0x0,%r14d\nmov    $0x0,%ebp\njmp    1229 <func0+0x40>\nadd    $0x8,%rbx\ncmp    %r15,%rbx\nje     1268 <func0+0x7f>\nmov    (%rbx),%r13\nmov    (%rsp),%rsi\nmov    %r13,%rdi\ncall   10f0 <strstr@plt>\ntest   %rax,%rax\nje     1220 <func0+0x37>\nadd    $0x1,%r14d\nmovslq %r14d,%r12\nshl    $0x3,%r12\nmov    %r12,%rsi\nmov    %rbp,%rdi\ncall   10e0 <realloc@plt>\nmov    %rax,%rbp\nmov    %r13,-0x8(%rax,%r12,1)\njmp    1220 <func0+0x37>\nmov    $0x0,%r14d\nmov    $0x0,%ebp\nmov    0x8(%rsp),%rax\nmov    %r14d,(%rax)\nmov    %rbp,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 7,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,0x8(%rsp)\ntest   %esi,%esi\njle    15c8 <func0+0x98>\nlea    -0x1(%rsi),%eax\nmov    %rdx,%r13\nmov    %rdi,%rbx\nxor    %r12d,%r12d\nlea    0x8(%rdi,%rax,8),%rax\nxor    %ebp,%ebp\nmov    %rax,(%rsp)\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%r14\nmov    %r13,%rsi\nmov    %r14,%rdi\ncall   10f0 <strstr@plt>\ntest   %rax,%rax\nje     159d <func0+0x6d>\nadd    $0x1,%r12d\nmov    %rbp,%rdi\nmovslq %r12d,%rdx\nlea    0x0(,%rdx,8),%r15\n00\nmov    %r15,%rsi\ncall   10e0 <realloc@plt>\nmov    %r14,-0x8(%rax,%r15,1)\nmov    %rax,%rbp\nadd    $0x8,%rbx\ncmp    (%rsp),%rbx\njne    1568 <func0+0x38>\nmov    0x8(%rsp),%rax\nmov    %r12d,(%rax)\nadd    $0x18,%rsp\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nxor    %r12d,%r12d\nxor    %ebp,%ebp\njmp    15a7 <func0+0x77>\nnop\n"
    },
    {
        "task_id": 7,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,0x8(%rsp)\ntest   %esi,%esi\njle    1688 <func0+0x98>\nlea    -0x1(%rsi),%eax\nmov    %rdx,%r13\nmov    %rdi,%rbx\nxor    %r12d,%r12d\nlea    0x8(%rdi,%rax,8),%rax\nxor    %ebp,%ebp\nmov    %rax,(%rsp)\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%r14\nmov    %r13,%rsi\nmov    %r14,%rdi\ncall   10f0 <strstr@plt>\ntest   %rax,%rax\nje     165d <func0+0x6d>\nadd    $0x1,%r12d\nmov    %rbp,%rdi\nmovslq %r12d,%rdx\nlea    0x0(,%rdx,8),%r15\n00\nmov    %r15,%rsi\ncall   10e0 <realloc@plt>\nmov    %r14,-0x8(%rax,%r15,1)\nmov    %rax,%rbp\nadd    $0x8,%rbx\ncmp    (%rsp),%rbx\njne    1628 <func0+0x38>\nmov    0x8(%rsp),%rax\nmov    %r12d,(%rax)\nadd    $0x18,%rsp\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nxor    %r12d,%r12d\nxor    %ebp,%ebp\njmp    1667 <func0+0x77>\nnop\n"
    },
    {
        "task_id": 8,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11cf <func0+0x66>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1193 <func0+0x2a>\nmov    -0x28(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 8,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    119c <func0+0x33>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%ecx\nlea    0x4(%rdi,%rcx,4),%r8\nmov    $0x1,%esi\nmov    $0x0,%edi\nmov    (%rax),%ecx\nadd    %ecx,%edi\nimul   %ecx,%esi\nadd    $0x4,%rax\ncmp    %r8,%rax\njne    1186 <func0+0x1d>\nmov    %edi,(%rdx)\nmov    %esi,0x4(%rdx)\nret\nmov    $0x1,%esi\nmov    $0x0,%edi\njmp    1196 <func0+0x2d>\n"
    },
    {
        "task_id": 8,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1180 <func0+0x40>\nlea    -0x1(%rsi),%eax\nmov    $0x1,%ecx\nxor    %esi,%esi\nlea    0x4(%rdi,%rax,4),%r8\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    (%rdi),%eax\nadd    $0x4,%rdi\nimul   %eax,%ecx\nadd    %eax,%esi\ncmp    %r8,%rdi\njne    1160 <func0+0x20>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    $0x1,%ecx\nxor    %esi,%esi\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nret\nnopl   (%rax)\n"
    },
    {
        "task_id": 8,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r9\nmov    %esi,%r8d\ntest   %esi,%esi\njle    1240 <func0+0x100>\nlea    -0x1(%rsi),%eax\ncmp    $0x15,%eax\njbe    124d <func0+0x10d>\nmov    %esi,%ecx\nmovdqa 0xea8(%rip),%xmm0\n00\nmov    %rdi,%rax\npxor   %xmm1,%xmm1\nshr    $0x2,%ecx\nsub    $0x1,%ecx\nshl    $0x4,%rcx\nlea    0x10(%rdi,%rcx,1),%rcx\nxchg   %ax,%ax\nmovdqu (%rax),%xmm2\nmovdqa %xmm0,%xmm3\npsrlq  $0x20,%xmm0\nadd    $0x10,%rax\npmuludq %xmm2,%xmm3\npaddd  %xmm2,%xmm1\npsrlq  $0x20,%xmm2\npmuludq %xmm2,%xmm0\npshufd $0x8,%xmm3,%xmm2\npshufd $0x8,%xmm0,%xmm3\nmovdqa %xmm2,%xmm0\npunpckldq %xmm3,%xmm0\ncmp    %rcx,%rax\njne    1180 <func0+0x40>\nmovdqa %xmm0,%xmm2\nmov    %r8d,%ecx\npsrldq $0x8,%xmm2\nand    $0xfffffffc,%ecx\nmovdqa %xmm2,%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm0,%xmm3\npsrlq  $0x20,%xmm0\npmuludq %xmm0,%xmm2\npshufd $0x8,%xmm3,%xmm3\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa %xmm3,%xmm0\npsrldq $0x4,%xmm0\npmuludq %xmm3,%xmm0\nmovd   %xmm0,%edi\nmovdqa %xmm1,%xmm0\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ntest   $0x3,%r8b\nje     123a <func0+0xfa>\nmovslq %ecx,%rcx\nnopl   0x0(%rax)\nmov    (%r9,%rcx,4),%esi\nadd    $0x1,%rcx\nimul   %esi,%edi\nadd    %esi,%eax\ncmp    %ecx,%r8d\njg     1228 <func0+0xe8>\nmov    %eax,(%rdx)\nmov    %edi,0x4(%rdx)\nret\nmov    $0x1,%edi\nxor    %eax,%eax\nmov    %eax,(%rdx)\nmov    %edi,0x4(%rdx)\nret\nxor    %ecx,%ecx\nmov    $0x1,%edi\nxor    %eax,%eax\njmp    1221 <func0+0xe1>\nnopl   0x0(%rax,%rax,1)\n00\n"
    },
    {
        "task_id": 9,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njg     11cc <func0+0x23>\nmov    $0x0,%eax\njmp    125e <func0+0xb5>\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    11ef <func0+0x46>\nmov    $0x0,%eax\njmp    125e <func0+0xb5>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1252 <func0+0xa9>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    1235 <func0+0x8c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1201 <func0+0x58>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 9,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%eax\ntest   %esi,%esi\njle    11f6 <func0+0x4d>\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    %esi,%ebp\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\ntest   %rax,%rax\nje     11ef <func0+0x46>\nmov    (%rbx),%ecx\nmov    %ebp,%edi\nmov    $0x0,%edx\nmov    (%rbx,%rdx,4),%esi\ncmp    %esi,%ecx\ncmovl  %esi,%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdi,%rdx\njne    11db <func0+0x32>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nret\n"
    },
    {
        "task_id": 9,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1400 <func0+0x60>\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncall   10b0 <malloc@plt>\ntest   %rax,%rax\nje     13f4 <func0+0x54>\nmov    (%rbx),%ecx\nlea    -0x1(%rbp),%edi\nxor    %edx,%edx\nshl    $0x2,%rdi\nmov    %ecx,%esi\njmp    13e0 <func0+0x40>\nnopl   0x0(%rax,%rax,1)\nmov    0x4(%rbx,%rdx,1),%esi\nadd    $0x4,%rdx\ncmp    %esi,%ecx\ncmovl  %esi,%ecx\nmov    %ecx,(%rax,%rdx,1)\ncmp    %rdi,%rdx\njne    13d8 <func0+0x38>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\nxor    %eax,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nxchg   %ax,%ax\n"
    },
    {
        "task_id": 9,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1378 <func0+0x58>\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmovslq %esi,%rbx\nlea    0x0(,%rbx,4),%rdi\n00\nsub    $0x8,%rsp\ncall   10b0 <malloc@plt>\ntest   %rax,%rax\nje     136c <func0+0x4c>\nmov    0x0(%rbp),%ecx\nxor    %edx,%edx\nnopl   0x0(%rax,%rax,1)\nmov    0x0(%rbp,%rdx,4),%edi\ncmp    %edi,%ecx\ncmovl  %edi,%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rbx\njne    1350 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 10,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10c0 <strlen@plt>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    122f <func0+0x46>\nmov    $0x0,%eax\njmp    1392 <func0+0x1a9>\nmovl   $0x0,-0x18(%rbp)\njmp    1318 <func0+0x12f>\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    1287 <func0+0x9e>\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     1283 <func0+0x9a>\nmovl   $0x0,-0x10(%rbp)\njmp    129b <func0+0xb2>\naddl   $0x1,-0x14(%rbp)\nmov    -0xc(%rbp),%eax\nsub    -0x18(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x14(%rbp)\njl     124b <func0+0x62>\ncmpl   $0x0,-0x10(%rbp)\nje     1314 <func0+0x12b>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   10b0 <strncpy@plt>\nmovl   $0x0,-0x14(%rbp)\njmp    12f1 <func0+0x108>\nmov    -0x18(%rbp),%eax\nsub    -0x14(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%ecx\nmov    -0x14(%rbp),%edx\nadd    %ecx,%edx\nmovslq %edx,%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     12c3 <func0+0xda>\nmov    -0xc(%rbp),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\njmp    1392 <func0+0x1a9>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     123b <func0+0x52>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   10b0 <strncpy@plt>\nmovl   $0x0,-0x14(%rbp)\njmp    1374 <func0+0x18b>\nmov    -0xc(%rbp),%eax\nsub    -0x14(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%ecx\nmov    -0x14(%rbp),%edx\nadd    %ecx,%edx\nmovslq %edx,%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     1346 <func0+0x15d>\nmov    -0xc(%rbp),%eax\nadd    %eax,%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 10,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rbp\ncall   10c0 <strlen@plt>\nmov    %rax,%r14\nmov    %eax,%r13d\nlea    (%rax,%rax,1),%eax\nmov    %eax,0xc(%rsp)\nlea    0x1(%rax),%edi\nmovslq %edi,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,%r15\ntest   %rax,%rax\nje     1299 <func0+0xb0>\ntest   %r14d,%r14d\njle    1248 <func0+0x5f>\nmov    %r14d,%r8d\nlea    -0x1(%r14),%r12d\nmov    %rbp,%rsi\nmov    $0x0,%ebx\nmovslq %r14d,%rdi\nsub    $0x1,%rdi\njmp    12b7 <func0+0xce>\nmov    %r12d,%ebx\njmp    12ee <func0+0x105>\nmovslq %r14d,%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\ncall   10b0 <strncpy@plt>\njmp    128f <func0+0xa6>\nmovslq %ebx,%rbx\nmov    %rbx,%rdx\nmov    %rbp,%rsi\nmov    %r15,%rdi\ncall   10b0 <strncpy@plt>\nlea    -0x1(%rbp,%rbx,1),%rax\nlea    (%r15,%rbx,1),%rdx\nlea    -0x2(%rbp,%rbx,1),%rsi\nmov    %r12d,%r12d\nsub    %r12,%rsi\nmovzbl (%rax),%ecx\nmov    %cl,(%rdx)\nsub    $0x1,%rax\nadd    $0x1,%rdx\ncmp    %rsi,%rax\njne    127d <func0+0x94>\nmovslq 0xc(%rsp),%rax\nmovb   $0x0,(%r15,%rax,1)\nmov    %r15,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nadd    $0x1,%ebx\nadd    $0x1,%rsi\ncmp    %ebx,%r13d\nje     1258 <func0+0x6f>\nmov    %r8d,%eax\nsub    %ebx,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    %r12d,%ebx\nje     1240 <func0+0x57>\nlea    0x0(%rbp,%rdi,1),%rdx\nmov    $0x0,%eax\nmovzbl (%rdx),%r9d\ncmp    %r9b,(%rsi,%rax,1)\njne    12ab <func0+0xc2>\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%ecx\njg     12d8 <func0+0xef>\nmovslq %r14d,%r12\nmov    %r12,%rdx\nmov    %rbp,%rsi\nmov    %r15,%rdi\ncall   10b0 <strncpy@plt>\ntest   %ebx,%ebx\njle    132c <func0+0x143>\nmovslq %ebx,%rcx\nlea    -0x1(%rbp,%rcx,1),%rax\nlea    (%r15,%r12,1),%rdx\nlea    -0x2(%rbp,%rcx,1),%rsi\nlea    -0x1(%rbx),%ecx\nsub    %rcx,%rsi\nmovzbl (%rax),%ecx\nmov    %cl,(%rdx)\nsub    $0x1,%rax\nadd    $0x1,%rdx\ncmp    %rsi,%rax\njne    131a <func0+0x131>\nlea    (%rbx,%r14,1),%eax\ncltq\nmovb   $0x0,(%r15,%rax,1)\njmp    1299 <func0+0xb0>\n"
    },
    {
        "task_id": 10,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   10c0 <strlen@plt>\nlea    (%rax,%rax,1),%ebx\nmov    %rax,%r12\nmov    %eax,%r15d\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,%r8\ntest   %rax,%rax\nje     1470 <func0+0x100>\nmovslq %r12d,%r14\ntest   %r12d,%r12d\njle    14d5 <func0+0x165>\nxor    %ebp,%ebp\nmov    %r12d,%edx\nlea    -0x1(%r12),%edi\nmov    %r13,%rax\nsub    %ebp,%edx\nmov    %r12d,%r10d\nmovslq %edi,%rdi\nmov    %edx,%ecx\nsar    %ecx\nje     1420 <func0+0xb0>\nnopl   0x0(%rax)\nlea    0x1(%rax),%r9\nsub    $0x1,%ecx\nlea    0x0(%r13,%rdi,1),%rdx\nadd    %r9,%rcx\njmp    13fd <func0+0x8d>\nnopl   0x0(%rax)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %rcx,%rax\nje     1420 <func0+0xb0>\nmovzbl (%rdx),%esi\ncmp    %sil,(%rax)\nje     13f0 <func0+0x80>\nadd    $0x1,%ebp\ncmp    %ebp,%r15d\nje     1482 <func0+0x112>\nmov    %r12d,%edx\nmov    %r9,%rax\nsub    %ebp,%edx\nmov    %edx,%ecx\nsar    %ecx\njne    13d8 <func0+0x68>\nnopl   0x0(%rax,%rax,1)\nmov    %r8,%rdi\nmov    %r14,%rdx\nmov    %r13,%rsi\ncall   10b0 <strncpy@plt>\nmov    %rax,%r8\ntest   %ebp,%ebp\nje     1464 <func0+0xf4>\nmovslq %ebp,%rdx\nadd    %r8,%r14\nlea    -0x2(%r13,%rdx,1),%rcx\nlea    -0x1(%r13,%rdx,1),%rax\nlea    -0x1(%rbp),%edx\nsub    %rdx,%rcx\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rax),%edx\nsub    $0x1,%rax\nadd    $0x1,%r14\nmov    %dl,-0x1(%r14)\ncmp    %rcx,%rax\njne    1450 <func0+0xe0>\nlea    0x0(%rbp,%r12,1),%eax\ncltq\nmovb   $0x0,(%r8,%rax,1)\nadd    $0x18,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %r14,%rdx\nmov    %r13,%rsi\nmov    %r8,%rdi\nmov    %r10d,0xc(%rsp)\ncall   10b0 <strncpy@plt>\nmov    0xc(%rsp),%r10d\nlea    -0x2(%r13,%r14,1),%rsi\nmov    %rax,%r8\nlea    -0x1(%r13,%r14,1),%rax\nlea    -0x1(%r10),%ecx\nlea    (%r8,%r14,1),%rdx\nsub    %rcx,%rsi\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rax),%ecx\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %cl,-0x1(%rdx)\ncmp    %rax,%rsi\njne    14b8 <func0+0x148>\nmovslq %ebx,%rbx\nmovb   $0x0,(%r8,%rbx,1)\njmp    1470 <func0+0x100>\nmov    %r14,%rdx\nmov    %r13,%rsi\nmov    %rax,%rdi\ncall   10b0 <strncpy@plt>\nmov    %rax,%r8\njmp    14cb <func0+0x15b>\n"
    },
    {
        "task_id": 10,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   10c0 <strlen@plt>\nlea    (%rax,%rax,1),%ebx\nmov    %rax,%r12\nmov    %eax,%r15d\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,%r8\ntest   %rax,%rax\nje     1470 <func0+0x100>\nmovslq %r12d,%r14\ntest   %r12d,%r12d\njle    14d5 <func0+0x165>\nxor    %ebp,%ebp\nmov    %r12d,%edx\nlea    -0x1(%r12),%edi\nmov    %r13,%rax\nsub    %ebp,%edx\nmov    %r12d,%r10d\nmovslq %edi,%rdi\nmov    %edx,%ecx\nsar    %ecx\nje     1420 <func0+0xb0>\nnopl   0x0(%rax)\nlea    0x1(%rax),%r9\nsub    $0x1,%ecx\nlea    0x0(%r13,%rdi,1),%rdx\nadd    %r9,%rcx\njmp    13fd <func0+0x8d>\nnopl   0x0(%rax)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %rcx,%rax\nje     1420 <func0+0xb0>\nmovzbl (%rdx),%esi\ncmp    %sil,(%rax)\nje     13f0 <func0+0x80>\nadd    $0x1,%ebp\ncmp    %ebp,%r15d\nje     1482 <func0+0x112>\nmov    %r12d,%edx\nmov    %r9,%rax\nsub    %ebp,%edx\nmov    %edx,%ecx\nsar    %ecx\njne    13d8 <func0+0x68>\nnopl   0x0(%rax,%rax,1)\nmov    %r8,%rdi\nmov    %r14,%rdx\nmov    %r13,%rsi\ncall   10b0 <strncpy@plt>\nmov    %rax,%r8\ntest   %ebp,%ebp\nje     1464 <func0+0xf4>\nmovslq %ebp,%rdx\nadd    %r8,%r14\nlea    -0x2(%r13,%rdx,1),%rcx\nlea    -0x1(%r13,%rdx,1),%rax\nlea    -0x1(%rbp),%edx\nsub    %rdx,%rcx\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rax),%edx\nsub    $0x1,%rax\nadd    $0x1,%r14\nmov    %dl,-0x1(%r14)\ncmp    %rax,%rcx\njne    1450 <func0+0xe0>\nlea    0x0(%rbp,%r12,1),%eax\ncltq\nmovb   $0x0,(%r8,%rax,1)\nadd    $0x18,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %r14,%rdx\nmov    %r13,%rsi\nmov    %r8,%rdi\nmov    %r10d,0xc(%rsp)\ncall   10b0 <strncpy@plt>\nmov    0xc(%rsp),%r10d\nlea    -0x2(%r13,%r14,1),%rsi\nmov    %rax,%r8\nlea    -0x1(%r13,%r14,1),%rax\nlea    -0x1(%r10),%ecx\nlea    (%r8,%r14,1),%rdx\nsub    %rcx,%rsi\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rax),%ecx\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %cl,-0x1(%rdx)\ncmp    %rax,%rsi\njne    14b8 <func0+0x148>\nmovslq %ebx,%rbx\nmovb   $0x0,(%r8,%rbx,1)\njmp    1470 <func0+0x100>\nmov    %r14,%rdx\nmov    %r13,%rsi\nmov    %rax,%rdi\ncall   10b0 <strncpy@plt>\nmov    %rax,%r8\njmp    14cb <func0+0x15b>\n"
    },
    {
        "task_id": 11,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <strlen@plt>\nmov    %eax,-0x14(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <strlen@plt>\nmov    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%edx\nmov    -0x14(%rbp),%eax\ncmp    %eax,%edx\ncmovle %edx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    122b <func0+0x62>\nmov    $0x0,%eax\njmp    1293 <func0+0xca>\nmovl   $0x0,-0x18(%rbp)\njmp    1277 <func0+0xae>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    125f <func0+0x96>\nmov    $0x30,%edx\njmp    1264 <func0+0x9b>\nmov    $0x31,%edx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    %dl,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     1234 <func0+0x6b>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 11,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rsi,%rbp\ncall   10a0 <strlen@plt>\nmov    %rax,%r12\nmov    %rbp,%rdi\ncall   10a0 <strlen@plt>\ncmp    %eax,%r12d\ncmovg  %eax,%r12d\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\ncall   10d0 <malloc@plt>\ntest   %rax,%rax\nje     1230 <func0+0x67>\ntest   %r12d,%r12d\njle    1228 <func0+0x5f>\nmov    %r12d,%esi\nmov    $0x0,%edx\nmovzbl 0x0(%rbp,%rdx,1),%edi\ncmp    %dil,(%rbx,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%rax,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rsi,%rdx\njne    120d <func0+0x44>\nmovslq %r12d,%r12\nmovb   $0x0,(%rax,%r12,1)\npop    %rbx\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 11,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\ncall   10a0 <strlen@plt>\nmov    %r12,%rdi\nmov    %rax,%rbx\ncall   10a0 <strlen@plt>\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncall   10d0 <malloc@plt>\ntest   %rax,%rax\nje     132f <func0+0x5f>\nmovslq %ebx,%rsi\nxor    %edx,%edx\ntest   %ebx,%ebx\njle    132b <func0+0x5b>\nnopl   0x0(%rax)\nmovzbl (%r12,%rdx,1),%ebx\ncmp    %bl,0x0(%rbp,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%rax,%rdx,1)\nadd    $0x1,%rdx\ncmp    %rsi,%rdx\njne    1310 <func0+0x40>\nmovb   $0x0,(%rax,%rsi,1)\npop    %rbx\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 11,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\ncall   10a0 <strlen@plt>\nmov    %rbp,%rdi\nmov    %rax,%rbx\ncall   10a0 <strlen@plt>\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,%r8\ntest   %rax,%rax\nje     1558 <func0+0x288>\ntest   %ebx,%ebx\njle    1550 <func0+0x280>\nlea    -0x1(%rbx),%eax\ncmp    $0xe,%eax\njbe    1560 <func0+0x290>\nmov    %ebx,%edx\nmovdqa 0xd78(%rip),%xmm3\n00\nmovdqa 0xd80(%rip),%xmm2\n00\nxor    %eax,%eax\nshr    $0x4,%edx\nshl    $0x4,%rdx\nnopl   0x0(%rax)\nmovdqu (%r12,%rax,1),%xmm0\nmovdqu 0x0(%rbp,%rax,1),%xmm4\nmovdqa %xmm3,%xmm1\npcmpeqb %xmm4,%xmm0\npand   %xmm0,%xmm1\npandn  %xmm2,%xmm0\npor    %xmm1,%xmm0\nmovups %xmm0,(%r8,%rax,1)\nadd    $0x10,%rax\ncmp    %rdx,%rax\njne    1340 <func0+0x70>\nmov    %ebx,%eax\nand    $0xfffffff0,%eax\ntest   $0xf,%bl\nje     1550 <func0+0x280>\nmovslq %eax,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%esi\ncmp    %sil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0x1(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl (%r12,%rdx,1),%esi\ncmp    %sil,0x0(%rbp,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0x2(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%esi\ncmp    %sil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0x3(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%esi\ncmp    %sil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0x4(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%esi\ncmp    %sil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0x5(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%esi\ncmp    %sil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0x6(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%edi\ncmp    %dil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0x7(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%esi\ncmp    %sil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0x8(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%edi\ncmp    %dil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0x9(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%esi\ncmp    %sil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0xa(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%edi\ncmp    %dil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0xb(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%esi\ncmp    %sil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0xc(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%edi\ncmp    %dil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\nlea    0xd(%rax),%edx\ncmp    %edx,%ebx\njle    1550 <func0+0x280>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%edi\ncmp    %dil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0xe,%eax\nadd    $0x30,%ecx\nmov    %cl,(%r8,%rdx,1)\ncmp    %eax,%ebx\njle    1550 <func0+0x280>\ncltq\nmovzbl 0x0(%rbp,%rax,1),%esi\ncmp    %sil,(%r12,%rax,1)\nsetne  %dl\nadd    $0x30,%edx\nmov    %dl,(%r8,%rax,1)\nmovslq %ebx,%rbx\nmovb   $0x0,(%r8,%rbx,1)\npop    %rbx\nmov    %r8,%rax\npop    %rbp\npop    %r12\nret\nxor    %eax,%eax\njmp    137c <func0+0xac>\n"
    },
    {
        "task_id": 12,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nlea    0xe45(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1226 <func0+0x7d>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   1080 <strlen@plt>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    1222 <func0+0x79>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11d7 <func0+0x2e>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 12,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0xe78(%rip),%r14\ntest   %esi,%esi\njle    11f4 <func0+0x4b>\nmov    %rdi,%rbx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r13\nmov    $0x0,%r12d\njmp    11dc <func0+0x33>\nadd    $0x8,%rbx\ncmp    %r13,%rbx\nje     11f4 <func0+0x4b>\nmov    (%rbx),%rbp\nmov    %rbp,%rdi\ncall   1080 <strlen@plt>\ncmp    %r12d,%eax\njle    11d3 <func0+0x2a>\nmov    %eax,%r12d\nmov    %rbp,%r14\njmp    11d3 <func0+0x2a>\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n"
    },
    {
        "task_id": 12,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nlea    0xd23(%rip),%r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    1345 <func0+0x45>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nlea    0x8(%rdi,%rax,8),%r13\nnopl   0x0(%rax)\nmov    (%rbx),%r14\nmov    %r14,%rdi\ncall   1080 <strlen@plt>\ncmp    %ebp,%eax\njle    133c <func0+0x3c>\nmov    %eax,%ebp\nmov    %r14,%r12\nadd    $0x8,%rbx\ncmp    %r13,%rbx\njne    1328 <func0+0x28>\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n"
    },
    {
        "task_id": 12,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nlea    0xe93(%rip),%r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    11a5 <func0+0x45>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nlea    0x8(%rdi,%rax,8),%r13\nnopl   0x0(%rax)\nmov    (%rbx),%r14\nmov    %r14,%rdi\ncall   1050 <strlen@plt>\ncmp    %ebp,%eax\njle    119c <func0+0x3c>\nmov    %eax,%ebp\nmov    %r14,%r12\nadd    $0x8,%rbx\ncmp    %r13,%rbx\njne    1188 <func0+0x28>\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n"
    },
    {
        "task_id": 13,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\njmp    116f <func0+0x26>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x18(%rbp)\nmov    %edx,-0x4(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njne    1159 <func0+0x10>\nmov    -0x14(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 13,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\ntest   %esi,%esi\nje     1163 <func0+0x1a>\nmov    %esi,%ecx\ncltd\nidiv   %esi\nmov    %edx,%esi\nmov    %ecx,%eax\ntest   %edx,%edx\njne    1153 <func0+0xa>\nmov    %ecx,%eax\nret\nmov    %edi,%ecx\njmp    1160 <func0+0x17>\n"
    },
    {
        "task_id": 13,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nmov    %esi,%edx\ntest   %esi,%esi\nje     1298 <func0+0x28>\nnopl   0x0(%rax)\nmov    %edx,%r8d\ncltd\nidiv   %r8d\nmov    %r8d,%eax\ntest   %edx,%edx\njne    1280 <func0+0x10>\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 13,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nmov    %esi,%edx\ntest   %esi,%esi\nje     1298 <func0+0x28>\nnopl   0x0(%rax)\nmov    %edx,%r8d\ncltd\nidiv   %r8d\nmov    %r8d,%eax\ntest   %edx,%edx\njne    1280 <func0+0x10>\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 14,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   10e0 <strlen@plt>\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1120 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   1120 <malloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x30(%rbp)\njmp    133e <func0+0x115>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10e0 <strlen@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nlea    0x2(%rax),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1130 <realloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10e0 <strlen@plt>\nadd    $0x1,%rax\nmov    -0x30(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x20(%rbp),%rdx\nlea    (%rcx,%rdx,1),%rbx\nmov    %rax,%rdi\ncall   1120 <malloc@plt>\nmov    %rax,(%rbx)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10d0 <strcpy@plt>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1289 <func0+0x60>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10c0 <free@plt>\nmov    -0x40(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 14,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r14\nmov    %rsi,(%rsp)\ncall   10e0 <strlen@plt>\nmov    %rax,%r15\nmov    %rax,0x8(%rsp)\nmovslq %eax,%rdi\nshl    $0x3,%rdi\ncall   1120 <malloc@plt>\nmov    %rax,%r13\nlea    0x1(%r15),%edi\nmovslq %edi,%rdi\ncall   1120 <malloc@plt>\nmov    %rax,%rbx\nmovb   $0x0,(%rax)\ntest   %r15d,%r15d\njle    12d3 <func0+0xaa>\nlea    -0x1(%r15),%r15d\nmov    $0x0,%r12d\nmov    %rbx,%rdi\ncall   10e0 <strlen@plt>\nmov    %rax,%rbp\nlea    0x2(%rax),%rsi\nmov    %rbx,%rdi\ncall   1130 <realloc@plt>\nmov    %rax,%rbx\nmovzbl (%r14,%r12,1),%eax\nmov    %al,(%rbx,%rbp,1)\nmovb   $0x0,0x1(%rbx,%rbp,1)\nmov    %rbx,%rdi\ncall   10e0 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1120 <malloc@plt>\nmov    %rax,%rdi\nmov    %rax,0x0(%r13,%r12,8)\nmov    %rbx,%rsi\ncall   10d0 <strcpy@plt>\nmov    %r12,%rax\nadd    $0x1,%r12\ncmp    %r15,%rax\njne    127f <func0+0x56>\nmov    %rbx,%rdi\ncall   10c0 <free@plt>\nmov    (%rsp),%rax\nmov    0x8(%rsp),%edx\nmov    %edx,(%rax)\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 14,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,(%rsp)\ncall   10d0 <strlen@plt>\nmovslq %eax,%rdi\nmov    %rax,%rbx\nmov    %rax,0x8(%rsp)\nshl    $0x3,%rdi\ncall   1120 <malloc@plt>\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\nmov    %rax,%r12\ncall   1120 <malloc@plt>\nmovb   $0x0,(%rax)\nmov    %rax,%r15\ntest   %ebx,%ebx\njle    14fb <func0+0xab>\nlea    -0x1(%rbx),%r13d\nxor    %ebx,%ebx\nmov    %r15,%rdi\ncall   10d0 <strlen@plt>\nmov    %r15,%rdi\nlea    0x2(%rax),%rsi\nmov    %rax,%r14\ncall   1130 <realloc@plt>\nmov    %rax,%r15\nmovzbl 0x0(%rbp,%rbx,1),%eax\nmovb   $0x0,0x1(%r15,%r14,1)\nmov    %r15,%rdi\nmov    %al,(%r15,%r14,1)\ncall   10d0 <strlen@plt>\nlea    0x1(%rax),%r14\nmov    %r14,%rdi\ncall   1120 <malloc@plt>\nmov    %r14,%rdx\nmov    %r15,%rsi\nmov    %rax,%rdi\nmov    %rax,(%r12,%rbx,8)\ncall   1110 <memcpy@plt>\nmov    %rbx,%rax\nadd    $0x1,%rbx\ncmp    %r13,%rax\njne    14a0 <func0+0x50>\nmov    %r15,%rdi\ncall   10c0 <free@plt>\nmov    (%rsp),%rax\nmov    0x8(%rsp),%ecx\nmov    %ecx,(%rax)\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnop\n"
    },
    {
        "task_id": 14,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,(%rsp)\ncall   10d0 <strlen@plt>\nmovslq %eax,%rdi\nmov    %rax,%rbx\nmov    %rax,0x8(%rsp)\nshl    $0x3,%rdi\ncall   1120 <malloc@plt>\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\nmov    %rax,%r12\ncall   1120 <malloc@plt>\nmovb   $0x0,(%rax)\nmov    %rax,%r15\ntest   %ebx,%ebx\njle    152b <func0+0xab>\nlea    -0x1(%rbx),%r13d\nxor    %ebx,%ebx\nmov    %r15,%rdi\ncall   10d0 <strlen@plt>\nmov    %r15,%rdi\nlea    0x2(%rax),%rsi\nmov    %rax,%r14\ncall   1130 <realloc@plt>\nmov    %rax,%r15\nmovzbl 0x0(%rbp,%rbx,1),%eax\nmovb   $0x0,0x1(%r15,%r14,1)\nmov    %r15,%rdi\nmov    %al,(%r15,%r14,1)\ncall   10d0 <strlen@plt>\nlea    0x1(%rax),%r14\nmov    %r14,%rdi\ncall   1120 <malloc@plt>\nmov    %r14,%rdx\nmov    %r15,%rsi\nmov    %rax,%rdi\nmov    %rax,(%r12,%rbx,8)\ncall   1110 <memcpy@plt>\nmov    %rbx,%rax\nadd    $0x1,%rbx\ncmp    %rax,%r13\njne    14d0 <func0+0x50>\nmov    %r15,%rdi\ncall   10c0 <free@plt>\nmov    (%rsp),%rax\nmov    0x8(%rsp),%ecx\nmov    %ecx,(%rax)\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnop\n"
    },
    {
        "task_id": 15,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmovl   $0x2,-0x1c(%rbp)\nmovl   $0x1,-0x18(%rbp)\njmp    1232 <func0+0x49>\nmov    -0x18(%rbp),%eax\nmov    %eax,%ecx\nlea    0xdf4(%rip),%rax\nmov    %rax,%rdx\nmov    $0x0,%esi\nmov    $0x0,%edi\nmov    $0x0,%eax\ncall   10b0 <snprintf@plt>\nadd    %eax,-0x1c(%rbp)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    1208 <func0+0x1f>\nmov    -0x1c(%rbp),%eax\ncltq\nmov    %rax,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1259 <func0+0x70>\nmov    $0x0,%eax\njmp    12bf <func0+0xd6>\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nlea    0xda0(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   10f0 <sprintf@plt>\ncltq\nadd    %rax,-0x10(%rbp)\nmovl   $0x1,-0x14(%rbp)\njmp    12b3 <func0+0xca>\nmov    -0x14(%rbp),%edx\nmov    -0x10(%rbp),%rax\nlea    0xd6f(%rip),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   10f0 <sprintf@plt>\ncltq\nadd    %rax,-0x10(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    128b <func0+0xa2>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 15,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %edi,%edi\njle    12a3 <func0+0xba>\nmov    %edi,%r12d\nlea    0x1(%rdi),%r14d\nmov    $0x1,%ebx\nmov    $0x2,%ebp\nlea    0xdef(%rip),%r13\nmov    %ebx,%r9d\nmov    %r13,%r8\nmov    $0xffffffffffffffff,%rcx\nmov    $0x1,%edx\nmov    $0x0,%esi\nmov    $0x0,%edi\nmov    $0x0,%eax\ncall   10a0 <__snprintf_chk@plt>\nadd    %eax,%ebp\nadd    $0x1,%ebx\ncmp    %r14d,%ebx\njne    1215 <func0+0x2c>\nmovslq %ebp,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,%r14\ntest   %rax,%rax\nje     1297 <func0+0xae>\nmovw   $0x30,(%r14)\nlea    0x1(%r14),%rbp\nmov    $0x1,%ebx\nlea    0xd99(%rip),%r13\nmov    %ebx,%r8d\nmov    %r13,%rcx\nmov    $0xffffffffffffffff,%rdx\nmov    $0x1,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   10f0 <__sprintf_chk@plt>\ncltq\nadd    %rax,%rbp\nadd    $0x1,%ebx\ncmp    %ebx,%r12d\njge    126b <func0+0x82>\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    $0x2,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%r14\ntest   %rax,%rax\nje     1297 <func0+0xae>\nmovw   $0x30,(%rax)\njmp    1297 <func0+0xae>\n"
    },
    {
        "task_id": 15,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %edi,%edi\njle    1380 <func0+0xc0>\nlea    0x1(%rdi),%ebp\nmov    $0x1,%ebx\nmov    $0x2,%r12d\nlea    0xd1b(%rip),%r13\nnopl   0x0(%rax)\nmov    %ebx,%r9d\nmov    %r13,%r8\nmov    $0xffffffffffffffff,%rcx\nxor    %esi,%esi\nmov    $0x1,%edx\nxor    %edi,%edi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   10a0 <__snprintf_chk@plt>\nadd    %eax,%r12d\ncmp    %ebp,%ebx\njne    12f0 <func0+0x30>\nmovslq %r12d,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,%r13\ntest   %rax,%rax\nje     13a6 <func0+0xe6>\nmov    $0x30,%eax\nlea    0x1(%r13),%r14\nmov    $0x1,%ebx\nmov    %ax,0x0(%r13)\nlea    0xcc3(%rip),%r12\nnopl   0x0(%rax)\nmov    %ebx,%r8d\nmov    %r14,%rdi\nmov    %r12,%rcx\nmov    $0xffffffffffffffff,%rdx\nmov    $0x1,%esi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   10f0 <__sprintf_chk@plt>\ncltq\nadd    %rax,%r14\ncmp    %ebp,%ebx\njne    1348 <func0+0x88>\npop    %rbx\nmov    %r13,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\nmov    $0x2,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%r13\ntest   %rax,%rax\nje     13a6 <func0+0xe6>\nmov    $0x30,%edx\nmov    %dx,(%rax)\nmov    %r13,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nxor    %r13d,%r13d\njmp    1370 <func0+0xb0>\n"
    },
    {
        "task_id": 15,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %edi,%edi\njle    1380 <func0+0xc0>\nlea    0x1(%rdi),%ebp\nmov    $0x1,%ebx\nmov    $0x2,%r12d\nlea    0xd1b(%rip),%r13\nnopl   0x0(%rax)\nmov    %ebx,%r9d\nmov    %r13,%r8\nmov    $0xffffffffffffffff,%rcx\nxor    %esi,%esi\nmov    $0x1,%edx\nxor    %edi,%edi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   10a0 <__snprintf_chk@plt>\nadd    %eax,%r12d\ncmp    %ebp,%ebx\njne    12f0 <func0+0x30>\nmovslq %r12d,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,%r13\ntest   %rax,%rax\nje     13a6 <func0+0xe6>\nmov    $0x30,%eax\nlea    0x1(%r13),%r14\nmov    $0x1,%ebx\nmov    %ax,0x0(%r13)\nlea    0xcc3(%rip),%r12\nnopl   0x0(%rax)\nmov    %ebx,%r8d\nmov    %r14,%rdi\nmov    %r12,%rcx\nmov    $0xffffffffffffffff,%rdx\nmov    $0x1,%esi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   10f0 <__sprintf_chk@plt>\ncltq\nadd    %rax,%r14\ncmp    %ebp,%ebx\njne    1348 <func0+0x88>\npop    %rbx\nmov    %r13,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\nmov    $0x2,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%r13\ntest   %rax,%rax\nje     13a6 <func0+0xe6>\nmov    $0x30,%edx\nmov    %dx,(%rax)\nmov    %r13,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nxor    %r13d,%r13d\njmp    1370 <func0+0xb0>\n"
    },
    {
        "task_id": 16,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x430,%rsp\nmov    %rdi,-0x428(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x418(%rbp)\n00 00 00\nlea    -0x410(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x80,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0x414(%rbp)\n00 00 00\njmp    1281 <func0+0xd8>\nmov    -0x414(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x428(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   10a0 <tolower@plt>\nmov    %al,-0x419(%rbp)\nmovsbl -0x419(%rbp),%eax\ncltq\nmov    -0x410(%rbp,%rax,4),%eax\ntest   %eax,%eax\njne    127a <func0+0xd1>\ncall   10b0 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmovzbl -0x419(%rbp),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\nje     127a <func0+0xd1>\nmovsbl -0x419(%rbp),%eax\ncltq\nmovl   $0x1,-0x410(%rbp,%rax,4)\n01 00 00 00\naddl   $0x1,-0x418(%rbp)\naddl   $0x1,-0x414(%rbp)\nmov    -0x414(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x428(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    11fe <func0+0x55>\nmov    -0x418(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     12b9 <func0+0x110>\ncall   1080 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 16,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x410,%rsp\nmov    %rdi,%rbp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x408(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0x80,%ecx\nrep stos %rax,%es:(%rdi)\nmovzbl 0x0(%rbp),%ebx\ntest   %bl,%bl\nje     123d <func0+0x94>\ncall   10a0 <__ctype_tolower_loc@plt>\nmov    (%rax),%r12\nadd    $0x1,%rbp\nmov    $0x0,%r13d\njmp    1205 <func0+0x5c>\nadd    $0x1,%rbp\nmovzbl -0x1(%rbp),%ebx\ntest   %bl,%bl\nje     1243 <func0+0x9a>\nmovzbl %bl,%ebx\nmov    (%r12,%rbx,4),%ebx\nmovsbl %bl,%r14d\nmovsbq %bl,%rax\ncmpl   $0x0,(%rsp,%rax,4)\njne    11f9 <func0+0x50>\ncall   10b0 <__ctype_b_loc@plt>\nmovzbl %bl,%ebx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rbx,2)\nje     11f9 <func0+0x50>\nmovslq %r14d,%r14\nmovl   $0x1,(%rsp,%r14,4)\n00\nadd    $0x1,%r13d\njmp    11f9 <func0+0x50>\nmov    $0x0,%r13d\nmov    0x408(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    1269 <func0+0xc0>\nmov    %r13d,%eax\nadd    $0x410,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 16,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    $0x80,%ecx\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x410,%rsp\nmovzbl 0x0(%rbp),%ebx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x408(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nrep stos %rax,%es:(%rdi)\ntest   %bl,%bl\nje     1370 <func0+0xb0>\ncall   10a0 <__ctype_tolower_loc@plt>\nadd    $0x1,%rbp\nxor    %r12d,%r12d\nmov    (%rax),%r14\nnopl   0x0(%rax,%rax,1)\nmov    (%r14,%rbx,4),%ebx\nmovsbq %bl,%r13\nmov    (%rsp,%r13,4),%eax\ntest   %eax,%eax\njne    133e <func0+0x7e>\ncall   10b0 <__ctype_b_loc@plt>\nmovzbl %bl,%ebx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rbx,2)\nje     133e <func0+0x7e>\nmovl   $0x1,(%rsp,%r13,4)\n00\nadd    $0x1,%r12d\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\ntest   %bl,%bl\njne    1310 <func0+0x50>\nmov    0x408(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    1375 <func0+0xb5>\nadd    $0x410,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nxor    %r12d,%r12d\njmp    134a <func0+0x8a>\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 16,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    $0x80,%ecx\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x410,%rsp\nmovzbl 0x0(%rbp),%ebx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x408(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nrep stos %rax,%es:(%rdi)\ntest   %bl,%bl\nje     1370 <func0+0xb0>\ncall   10a0 <__ctype_tolower_loc@plt>\nadd    $0x1,%rbp\nxor    %r12d,%r12d\nmov    (%rax),%r14\nnopl   0x0(%rax,%rax,1)\nmov    (%r14,%rbx,4),%ebx\nmovsbq %bl,%r13\nmov    (%rsp,%r13,4),%eax\ntest   %eax,%eax\njne    133e <func0+0x7e>\ncall   10b0 <__ctype_b_loc@plt>\nmovzbl %bl,%ebx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rbx,2)\nje     133e <func0+0x7e>\nmovl   $0x1,(%rsp,%r13,4)\n00\nadd    $0x1,%r12d\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\ntest   %bl,%bl\njne    1310 <func0+0x50>\nmov    0x408(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    1375 <func0+0xb5>\nadd    $0x410,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nxor    %r12d,%r12d\njmp    134a <func0+0x8a>\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 17,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x28(%rbp)\n00\nmovl   $0x0,-0x38(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovw   $0x0,-0xb(%rbp)\nmovb   $0x0,-0x9(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   10e0 <strlen@plt>\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   1120 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x48(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10d0 <strcpy@plt>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   10e0 <strlen@plt>\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovw   $0x20,(%rax)\nmovl   $0x0,-0x30(%rbp)\njmp    1494 <func0+0x26b>\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\njne    144f <func0+0x226>\nlea    -0xb(%rbp),%rax\nlea    0xd19(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1110 <strcmp@plt>\ntest   %eax,%eax\njne    135b <func0+0x132>\nmov    -0x38(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njne    133b <func0+0x112>\ncmpl   $0x0,-0x34(%rbp)\njle    1313 <func0+0xea>\nmov    -0x34(%rbp),%eax\nadd    %eax,%eax\njmp    1318 <func0+0xef>\nmov    $0x4,%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1130 <realloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x4,(%rax)\nlea    -0xb(%rbp),%rax\nlea    0xca4(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1110 <strcmp@plt>\ntest   %eax,%eax\njne    13d2 <func0+0x1a9>\nmov    -0x38(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njne    13b2 <func0+0x189>\ncmpl   $0x0,-0x34(%rbp)\njle    138a <func0+0x161>\nmov    -0x34(%rbp),%eax\nadd    %eax,%eax\njmp    138f <func0+0x166>\nmov    $0x4,%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1130 <realloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x2,(%rax)\nlea    -0xb(%rbp),%rax\nlea    0xc30(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1110 <strcmp@plt>\ntest   %eax,%eax\njne    1449 <func0+0x220>\nmov    -0x38(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njne    1429 <func0+0x200>\ncmpl   $0x0,-0x34(%rbp)\njle    1401 <func0+0x1d8>\nmov    -0x34(%rbp),%eax\nadd    %eax,%eax\njmp    1406 <func0+0x1dd>\nmov    $0x4,%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1130 <realloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmovb   $0x0,-0xb(%rbp)\njmp    1490 <func0+0x267>\nlea    -0xb(%rbp),%rax\nmov    %rax,%rdi\ncall   10e0 <strlen@plt>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x1,-0x18(%rbp)\nja     1490 <func0+0x267>\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nlea    -0xb(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %al,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x1,%rax\nmovb   $0x0,-0xb(%rbp,%rax,1)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     12cc <func0+0xa3>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   10c0 <free@plt>\nmov    -0x50(%rbp),%rax\nmov    -0x38(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     14cd <func0+0x2a4>\ncall   10f0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 17,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%rbx\nmov    %rsi,0x18(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmovw   $0x0,0x25(%rsp)\nmovb   $0x0,0x27(%rsp)\ncall   10e0 <strlen@plt>\nmov    %rax,%rbp\nlea    0x2(%rax),%edi\nmovslq %edi,%rdi\ncall   1120 <malloc@plt>\nmov    %rax,0x10(%rsp)\nmov    %rbx,%rsi\nmov    %rax,%rbx\nmov    %rax,%rdi\ncall   10d0 <strcpy@plt>\nmov    %rbx,%rdi\ncall   10e0 <strlen@plt>\nmovw   $0x20,(%rbx,%rax,1)\nlea    0x1(%rbp),%eax\ntest   %eax,%eax\njle    140b <func0+0x1e2>\nmov    %ebp,%ebp\nlea    0x1(%rbx,%rbp,1),%r15\nmov    $0x0,%r14d\nmov    $0x0,%ebp\nmovq   $0x0,0x8(%rsp)\n00 00\nlea    0x25(%rsp),%r13\njmp    135f <func0+0x136>\nlea    0xd71(%rip),%rsi\nmov    %r13,%rdi\ncall   1110 <strcmp@plt>\ntest   %eax,%eax\njne    12f1 <func0+0xc8>\ncmp    %r14d,%ebp\nje     1387 <func0+0x15e>\nmovslq %ebp,%rax\nmov    0x8(%rsp),%rcx\nmovl   $0x4,(%rcx,%rax,4)\nlea    0x1(%rbp),%ebp\nlea    0xd58(%rip),%rsi\nmov    %r13,%rdi\ncall   1110 <strcmp@plt>\ntest   %eax,%eax\njne    131f <func0+0xf6>\ncmp    %r14d,%ebp\nje     13b3 <func0+0x18a>\nmovslq %ebp,%rax\nmov    0x8(%rsp),%rcx\nmovl   $0x2,(%rcx,%rax,4)\nlea    0x1(%rbp),%ebp\nlea    0xd00(%rip),%rsi\nmov    %r13,%rdi\ncall   1110 <strcmp@plt>\ntest   %eax,%eax\njne    134d <func0+0x124>\ncmp    %r14d,%ebp\nje     13df <func0+0x1b6>\nmovslq %ebp,%rax\nmov    0x8(%rsp),%rcx\nmovl   $0x1,(%rcx,%rax,4)\nlea    0x1(%rbp),%ebp\nmovb   $0x0,0x25(%rsp)\nadd    $0x1,%rbx\ncmp    %r15,%rbx\nje     1419 <func0+0x1f0>\nmovzbl (%rbx),%r12d\ncmp    $0x20,%r12b\nje     12c3 <func0+0x9a>\nmov    %r13,%rdi\ncall   10e0 <strlen@plt>\ncmp    $0x1,%rax\nja     1352 <func0+0x129>\nmov    %r12b,0x25(%rsp,%rax,1)\nmovb   $0x0,0x26(%rsp,%rax,1)\njmp    1352 <func0+0x129>\nlea    (%r14,%r14,1),%eax\ntest   %r14d,%r14d\nmov    $0x4,%r14d\ncmovg  %eax,%r14d\nmovslq %r14d,%rsi\nshl    $0x2,%rsi\nmov    0x8(%rsp),%rdi\ncall   1130 <realloc@plt>\nmov    %rax,0x8(%rsp)\njmp    12df <func0+0xb6>\nlea    (%r14,%r14,1),%eax\ntest   %r14d,%r14d\nmov    $0x4,%r14d\ncmovg  %eax,%r14d\nmovslq %r14d,%rsi\nshl    $0x2,%rsi\nmov    0x8(%rsp),%rdi\ncall   1130 <realloc@plt>\nmov    %rax,0x8(%rsp)\njmp    130d <func0+0xe4>\nlea    (%r14,%r14,1),%eax\ntest   %r14d,%r14d\nmov    $0x4,%r14d\ncmovg  %eax,%r14d\nmovslq %r14d,%rsi\nshl    $0x2,%rsi\nmov    0x8(%rsp),%rdi\ncall   1130 <realloc@plt>\nmov    %rax,0x8(%rsp)\njmp    133b <func0+0x112>\nmov    $0x0,%ebp\nmovq   $0x0,0x8(%rsp)\n00 00\nmov    0x10(%rsp),%rdi\ncall   10c0 <free@plt>\nmov    0x18(%rsp),%rax\nmov    %ebp,(%rax)\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    144e <func0+0x225>\nmov    0x8(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10f0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 17,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rsi,0x18(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmovb   $0x0,0x27(%rsp)\nmov    %ax,0x25(%rsp)\ncall   10c0 <strlen@plt>\nlea    0x2(%rax),%edi\nmov    %rax,%rbp\nmovslq %edi,%rdi\ncall   1100 <malloc@plt>\nmov    %rbp,%rdx\nmov    %r12,%rsi\nmov    %rax,%rdi\nmov    %rax,%rbx\nmov    %rax,0x10(%rsp)\ncall   10f0 <memcpy@plt>\nmov    $0x20,%edx\nlea    0x1(%rbp),%eax\nmov    %dx,(%rbx,%rbp,1)\ntest   %eax,%eax\njle    16f0 <func0+0x240>\nmov    %ebp,%ebp\nmovl   $0x0,0xc(%rsp)\n00\nxor    %r15d,%r15d\nlea    0x25(%rsp),%r14\nlea    0x1(%rbx,%rbp,1),%r12\nxor    %ebp,%ebp\njmp    1565 <func0+0xb5>\nxchg   %ax,%ax\nmov    %r14,%rdi\ncall   10c0 <strlen@plt>\ncmp    $0x2,%rax\nje     1558 <func0+0xa8>\nmov    %r13b,0x25(%rsp,%rax,1)\nmovb   $0x0,0x26(%rsp,%rax,1)\nadd    $0x1,%rbx\ncmp    %rbx,%r12\nje     1604 <func0+0x154>\nmovzbl (%rbx),%r13d\ncmp    $0x20,%r13b\njne    1540 <func0+0x90>\ncmpb   $0x6f,(%r14)\njne    1596 <func0+0xe6>\ncmpb   $0x0,0x1(%r14)\njne    1596 <func0+0xe6>\ncmp    0xc(%rsp),%r15d\nje     1640 <func0+0x190>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x4,0x0(%rbp,%rax,4)\n00\ncmpb   $0x6f,(%r14)\njne    15c4 <func0+0x114>\ncmpb   $0x7c,0x1(%r14)\njne    15c4 <func0+0x114>\ncmpb   $0x0,0x2(%r14)\njne    15c4 <func0+0x114>\ncmp    0xc(%rsp),%r15d\nje     1690 <func0+0x1e0>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x2,0x0(%rbp,%rax,4)\n00\ncmpb   $0x2e,(%r14)\njne    15f2 <func0+0x142>\ncmpb   $0x7c,0x1(%r14)\njne    15f2 <func0+0x142>\ncmpb   $0x0,0x2(%r14)\njne    15f2 <func0+0x142>\ncmp    0xc(%rsp),%r15d\nje     1668 <func0+0x1b8>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x1,0x0(%rbp,%rax,4)\n00\nadd    $0x1,%rbx\nmovb   $0x0,0x25(%rsp)\ncmp    %rbx,%r12\njne    1565 <func0+0xb5>\nmov    0x10(%rsp),%rdi\ncall   10b0 <free@plt>\nmov    0x18(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    16fa <func0+0x24a>\nadd    $0x38,%rsp\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\ntest   %r15d,%r15d\njle    16b8 <func0+0x208>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncall   1110 <realloc@plt>\nmov    %rax,%rbp\njmp    1587 <func0+0xd7>\nnopl   0x0(%rax)\ntest   %r15d,%r15d\njle    16e0 <func0+0x230>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncall   1110 <realloc@plt>\nmov    %rax,%rbp\njmp    15e3 <func0+0x133>\nnopl   0x0(%rax)\ntest   %r15d,%r15d\njle    16d0 <func0+0x220>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncall   1110 <realloc@plt>\nmov    %rax,%rbp\njmp    15b5 <func0+0x105>\nnopl   0x0(%rax)\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    1654 <func0+0x1a4>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    16a4 <func0+0x1f4>\nnop\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    167c <func0+0x1cc>\nnop\nxor    %r15d,%r15d\nxor    %ebp,%ebp\njmp    1604 <func0+0x154>\ncall   10d0 <__stack_chk_fail@plt>\nnop\n"
    },
    {
        "task_id": 17,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rsi,0x18(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmovb   $0x0,0x27(%rsp)\nmov    %ax,0x25(%rsp)\ncall   10c0 <strlen@plt>\nlea    0x2(%rax),%edi\nmov    %rax,%rbp\nmovslq %edi,%rdi\ncall   1100 <malloc@plt>\nmov    %rbp,%rdx\nmov    %r12,%rsi\nmov    %rax,%rdi\nmov    %rax,%rbx\nmov    %rax,0x10(%rsp)\ncall   10f0 <memcpy@plt>\nmov    $0x20,%edx\nlea    0x1(%rbp),%eax\nmov    %dx,(%rbx,%rbp,1)\ntest   %eax,%eax\njle    16d0 <func0+0x240>\nmov    %ebp,%ebp\nmovl   $0x0,0xc(%rsp)\n00\nxor    %r15d,%r15d\nlea    0x25(%rsp),%r14\nlea    0x1(%rbx,%rbp,1),%r12\nxor    %ebp,%ebp\njmp    1545 <func0+0xb5>\nxchg   %ax,%ax\nmov    %r14,%rdi\ncall   10c0 <strlen@plt>\ncmp    $0x2,%rax\nje     1538 <func0+0xa8>\nmov    %r13b,0x25(%rsp,%rax,1)\nmovb   $0x0,0x26(%rsp,%rax,1)\nadd    $0x1,%rbx\ncmp    %r12,%rbx\nje     15e4 <func0+0x154>\nmovzbl (%rbx),%r13d\ncmp    $0x20,%r13b\njne    1520 <func0+0x90>\ncmpb   $0x6f,(%r14)\njne    1576 <func0+0xe6>\ncmpb   $0x0,0x1(%r14)\njne    1576 <func0+0xe6>\ncmp    0xc(%rsp),%r15d\nje     1620 <func0+0x190>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x4,0x0(%rbp,%rax,4)\n00\ncmpb   $0x6f,(%r14)\njne    15a4 <func0+0x114>\ncmpb   $0x7c,0x1(%r14)\njne    15a4 <func0+0x114>\ncmpb   $0x0,0x2(%r14)\njne    15a4 <func0+0x114>\ncmp    0xc(%rsp),%r15d\nje     1670 <func0+0x1e0>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x2,0x0(%rbp,%rax,4)\n00\ncmpb   $0x2e,(%r14)\njne    15d2 <func0+0x142>\ncmpb   $0x7c,0x1(%r14)\njne    15d2 <func0+0x142>\ncmpb   $0x0,0x2(%r14)\njne    15d2 <func0+0x142>\ncmp    0xc(%rsp),%r15d\nje     1648 <func0+0x1b8>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x1,0x0(%rbp,%rax,4)\n00\nadd    $0x1,%rbx\nmovb   $0x0,0x25(%rsp)\ncmp    %r12,%rbx\njne    1545 <func0+0xb5>\nmov    0x10(%rsp),%rdi\ncall   10b0 <free@plt>\nmov    0x18(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    16da <func0+0x24a>\nadd    $0x38,%rsp\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\ntest   %r15d,%r15d\njle    1698 <func0+0x208>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncall   1110 <realloc@plt>\nmov    %rax,%rbp\njmp    1567 <func0+0xd7>\nnopl   0x0(%rax)\ntest   %r15d,%r15d\njle    16c0 <func0+0x230>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncall   1110 <realloc@plt>\nmov    %rax,%rbp\njmp    15c3 <func0+0x133>\nnopl   0x0(%rax)\ntest   %r15d,%r15d\njle    16b0 <func0+0x220>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncall   1110 <realloc@plt>\nmov    %rax,%rbp\njmp    1595 <func0+0x105>\nnopl   0x0(%rax)\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    1634 <func0+0x1a4>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    1684 <func0+0x1f4>\nnop\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    165c <func0+0x1cc>\nnop\nxor    %r15d,%r15d\nxor    %ebp,%ebp\njmp    15e4 <func0+0x154>\ncall   10d0 <__stack_chk_fail@plt>\nnop\n"
    },
    {
        "task_id": 18,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <strlen@plt>\nmov    %eax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <strlen@plt>\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njne    11cf <func0+0x46>\nmov    $0x0,%eax\njmp    1214 <func0+0x8b>\nmovl   $0x0,-0xc(%rbp)\njmp    1206 <func0+0x7d>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   1070 <strncmp@plt>\ntest   %eax,%eax\njne    1202 <func0+0x79>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0x8(%rbp),%eax\nsub    -0x4(%rbp),%eax\ncmp    %eax,-0xc(%rbp)\njle    11d8 <func0+0x4f>\nmov    -0x10(%rbp),%eax\nleave\nret\n"
    },
    {
        "task_id": 18,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r14\nmov    %rsi,%r12\ncall   1080 <strlen@plt>\nmov    %eax,%ebp\ntest   %eax,%eax\nje     11e3 <func0+0x5a>\nmov    %r12,%rdi\ncall   1080 <strlen@plt>\nmov    %ebp,%edx\nsub    %eax,%edx\njs     11ee <func0+0x65>\nmov    %r14,%rbx\nmov    %edx,%edx\nlea    0x1(%r14,%rdx,1),%r14\nmov    $0x0,%ebp\nmovslq %eax,%r13\nmov    %r13,%rdx\nmov    %r12,%rsi\nmov    %rbx,%rdi\ncall   1070 <strncmp@plt>\ncmp    $0x1,%eax\nadc    $0x0,%ebp\nadd    $0x1,%rbx\ncmp    %r14,%rbx\njne    11c6 <func0+0x3d>\nmov    %ebp,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    $0x0,%ebp\njmp    11e3 <func0+0x5a>\n"
    },
    {
        "task_id": 18,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\ncall   1080 <strlen@plt>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     12de <func0+0x5e>\nmov    %r13,%rdi\nmov    %rax,%r14\ncall   1080 <strlen@plt>\nsub    %eax,%r14d\njs     12f0 <func0+0x70>\nmovslq %r14d,%r14\nmovslq %eax,%rbp\nxor    %r12d,%r12d\nlea    0x1(%rbx,%r14,1),%r14\nnopl   0x0(%rax)\nmov    %rbx,%rdi\nmov    %rbp,%rdx\nmov    %r13,%rsi\ncall   1070 <strncmp@plt>\ncmp    $0x1,%eax\nadc    $0x0,%r12d\nadd    $0x1,%rbx\ncmp    %r14,%rbx\njne    12c0 <func0+0x40>\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\nxor    %r12d,%r12d\njmp    12de <func0+0x5e>\n"
    },
    {
        "task_id": 18,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\ncall   1080 <strlen@plt>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     12de <func0+0x5e>\nmov    %r13,%rdi\nmov    %rax,%r14\ncall   1080 <strlen@plt>\nsub    %eax,%r14d\njs     12f0 <func0+0x70>\nmovslq %r14d,%r14\nmovslq %eax,%rbp\nxor    %r12d,%r12d\nlea    0x1(%rbx,%r14,1),%r14\nnopl   0x0(%rax)\nmov    %rbx,%rdi\nmov    %rbp,%rdx\nmov    %r13,%rsi\ncall   1070 <strncmp@plt>\ncmp    $0x1,%eax\nadc    $0x0,%r12d\nadd    $0x1,%rbx\ncmp    %r14,%rbx\njne    12c0 <func0+0x40>\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\nxor    %r12d,%r12d\njmp    12de <func0+0x5e>\n"
    },
    {
        "task_id": 19,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x90(%rbp)\n00 00 00 00\nmovq   $0x0,-0x88(%rbp)\n00 00 00 00\nmovq   $0x0,-0x80(%rbp)\n00\nmovq   $0x0,-0x78(%rbp)\n00\nmovq   $0x0,-0x70(%rbp)\n00\nlea    0xe25(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0xe1f(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0xe18(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0xe11(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0xe0c(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0xe06(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0xe00(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0xdf9(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0xdf4(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0xdef(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0xa0(%rbp)\n00 00 00\nmov    -0xa8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1364 <func0+0x1db>\nmovl   $0x0,-0x9c(%rbp)\n00 00 00\njmp    129b <func0+0x112>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x9c(%rbp),%eax\ncltq\nmov    %dl,-0xe(%rbp,%rax,1)\naddl   $0x1,-0x9c(%rbp)\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     12cf <func0+0x146>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1272 <func0+0xe9>\nmov    -0x9c(%rbp),%eax\ncltq\nmovb   $0x0,-0xe(%rbp,%rax,1)\nmovl   $0x0,-0x98(%rbp)\n00 00 00\njmp    1332 <func0+0x1a9>\nmov    -0x98(%rbp),%eax\ncltq\nmov    -0x60(%rbp,%rax,8),%rdx\nlea    -0xe(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\njne    132b <func0+0x1a2>\nmov    -0x98(%rbp),%eax\ncltq\nmov    -0x90(%rbp,%rax,4),%eax\nlea    0x1(%rax),%edx\nmov    -0x98(%rbp),%eax\ncltq\nmov    %edx,-0x90(%rbp,%rax,4)\njmp    133b <func0+0x1b2>\naddl   $0x1,-0x98(%rbp)\ncmpl   $0x9,-0x98(%rbp)\njle    12e8 <func0+0x15f>\nmov    -0x9c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nadd    %rax,-0xa8(%rbp)\nmov    -0xa8(%rbp),%rax\nsub    $0x1,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1266 <func0+0xdd>\nmovl   $0x0,-0x9c(%rbp)\n00 00 00\njmp    142d <func0+0x2a4>\nmovl   $0x0,-0x98(%rbp)\n00 00 00\njmp    140b <func0+0x282>\nmovl   $0x0,-0x94(%rbp)\n00 00 00\njmp    13c9 <func0+0x240>\nmov    -0x9c(%rbp),%eax\ncltq\nmov    -0x60(%rbp,%rax,8),%rdx\nmov    -0x94(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xa0(%rbp),%eax\ncltq\nlea    0x2c88(%rip),%rcx\nmov    %dl,(%rax,%rcx,1)\naddl   $0x1,-0x94(%rbp)\naddl   $0x1,-0xa0(%rbp)\nmov    -0x9c(%rbp),%eax\ncltq\nmov    -0x60(%rbp,%rax,8),%rdx\nmov    -0x94(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    138e <func0+0x205>\nmov    -0xa0(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xa0(%rbp)\ncltq\nlea    0x2c40(%rip),%rdx\nmovb   $0x20,(%rax,%rdx,1)\naddl   $0x1,-0x98(%rbp)\nmov    -0x9c(%rbp),%eax\ncltq\nmov    -0x90(%rbp,%rax,4),%eax\ncmp    %eax,-0x98(%rbp)\njl     1382 <func0+0x1f9>\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0x9,-0x9c(%rbp)\njle    1373 <func0+0x1ea>\ncmpl   $0x0,-0xa0(%rbp)\njle    145b <func0+0x2d2>\nmov    -0xa0(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x2beb(%rip),%rdx\nmovb   $0x0,(%rax,%rdx,1)\njmp    1462 <func0+0x2d9>\nmovb   $0x0,0x2bde(%rip)\nlea    0x2bd7(%rip),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     147d <func0+0x2f4>\ncall   1070 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 19,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x98,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x88(%rsp)\n00\nxor    %eax,%eax\nmovq   $0x0,(%rsp)\n00\nmovq   $0x0,0x8(%rsp)\n00 00\nmovq   $0x0,0x10(%rsp)\n00 00\nmovq   $0x0,0x18(%rsp)\n00 00\nmovq   $0x0,0x20(%rsp)\n00 00\nlea    0xe20(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0xe19(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0xe11(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0xe09(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    0xe03(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0xdfc(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0xdf5(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0xded(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0xde7(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0xe20(%rip),%rax\nmov    %rax,0x78(%rsp)\ncmpb   $0x0,(%rdi)\nje     12e5 <func0+0x15c>\nmov    %rdi,%rbp\nlea    0x81(%rsp),%r15\n00\nlea    0x82(%rsp),%r14\n00\njmp    1293 <func0+0x10a>\nmov    $0x0,%ecx\nmov    $0x0,%r13d\njmp    12b8 <func0+0x12f>\nmovslq %ebx,%r12\naddl   $0x1,(%rsp,%r12,4)\nlea    0x1(%rbp,%r13,1),%rbp\ncmpb   $0x0,-0x1(%rbp)\nje     12e5 <func0+0x15c>\nmovzbl 0x0(%rbp),%edx\ntest   $0xdf,%dl\nje     1273 <func0+0xea>\nmov    $0x1,%eax\nmov    %dl,(%r15,%rax,1)\nmov    %eax,%ecx\nmovzbl 0x0(%rbp,%rax,1),%edx\nmov    %rax,%r13\nadd    $0x1,%rax\ntest   $0xdf,%dl\njne    12a1 <func0+0x118>\nmovslq %ecx,%rcx\nmovb   $0x0,0x82(%rsp,%rcx,1)\n00\nmov    $0x0,%ebx\nmov    0x30(%rsp,%rbx,8),%rsi\nmov    %r14,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1280 <func0+0xf7>\nadd    $0x1,%rbx\ncmp    $0xa,%rbx\njne    12c8 <func0+0x13f>\njmp    1288 <func0+0xff>\nmov    $0x0,%r12d\nmov    $0x0,%r8d\nlea    0x2d47(%rip),%rdi\nlea    0x1(%rdi),%rbp\njmp    134b <func0+0x1c2>\nmov    %dl,(%rax,%rdi,1)\nmov    %eax,%ecx\nadd    $0x1,%rax\nmovzbl -0x1(%rsi,%rax,1),%edx\ntest   %dl,%dl\njne    12fe <func0+0x175>\nlea    0x1(%rcx),%r8d\nmovslq %ecx,%rcx\nmovb   $0x20,0x0(%rbp,%rcx,1)\nadd    $0x1,%r9d\ncmp    %r11d,%r9d\nje     1341 <func0+0x1b8>\nlea    0x1(%r8),%eax\ncltq\nmov    %r10d,%edx\nmovslq %r8d,%rcx\nmov    %rbx,%rsi\nsub    %rcx,%rsi\nmov    %r8d,%ecx\ntest   %r10b,%r10b\njne    12fe <func0+0x175>\njmp    1310 <func0+0x187>\nadd    $0x1,%r12\ncmp    $0xa,%r12\nje     1365 <func0+0x1dc>\nmov    (%rsp,%r12,4),%r11d\ntest   %r11d,%r11d\njle    1341 <func0+0x1b8>\nmov    0x30(%rsp,%r12,8),%rbx\nmovzbl (%rbx),%r10d\nmov    $0x0,%r9d\njmp    1325 <func0+0x19c>\ntest   %r8d,%r8d\njle    13a7 <func0+0x21e>\nlea    -0x1(%r8),%eax\ncltq\nlea    0x2cc9(%rip),%rdx\nmovb   $0x0,(%rdx,%rax,1)\nmov    0x88(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    13b0 <func0+0x227>\nlea    0x2cab(%rip),%rax\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovb   $0x0,0x2c92(%rip)\njmp    137b <func0+0x1f2>\ncall   1070 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 19,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npxor   %xmm0,%xmm0\nxor    %r10d,%r10d\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x98,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x88(%rsp)\n00\nxor    %eax,%eax\nlea    0xcfe(%rip),%rax\nmovaps %xmm0,(%rsp)\nmov    %rax,0x30(%rsp)\nlea    0xcf3(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0xceb(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0xce3(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    0xcdd(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0xcd6(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0xccf(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0xcc7(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0xcc1(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0xcfa(%rip),%rax\nmov    %rax,0x78(%rsp)\nmovzbl (%rdi),%eax\nmovq   $0x0,0x20(%rsp)\n00 00\nmovaps %xmm0,0x10(%rsp)\ntest   %al,%al\nje     142a <func0+0x15a>\nmov    %rdi,%rbp\nlea    0x82(%rsp),%r13\n00\nmov    $0x1,%ebx\nlea    0x81(%rsp),%r14\n00\ntest   $0xdf,%al\nje     1414 <func0+0x144>\nmov    %al,(%r14,%rbx,1)\nmovzbl 0x0(%rbp,%rbx,1),%eax\nmovslq %ebx,%rdx\nadd    $0x1,%rbx\ntest   $0xdf,%al\njne    13b0 <func0+0xe0>\nmovb   $0x0,0x82(%rsp,%rdx,1)\n00\nxor    %r15d,%r15d\nlea    0xc2e(%rip),%rsi\njmp    13e5 <func0+0x115>\nnopl   0x0(%rax,%rax,1)\n00\nmov    0x30(%rsp,%r15,8),%rsi\nmov    %r13,%rdi\nmovslq %r15d,%r12\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1418 <func0+0x148>\nadd    $0x1,%r15\ncmp    $0xa,%r15\njne    13e0 <func0+0x110>\nadd    %rbx,%rbp\ncmpb   $0x0,-0x1(%rbp)\nje     1426 <func0+0x156>\nmovzbl 0x0(%rbp),%eax\nmov    $0x1,%ebx\ntest   $0xdf,%al\njne    13b0 <func0+0xe0>\nxor    %edx,%edx\njmp    13c4 <func0+0xf4>\nadd    %rbx,%rbp\naddl   $0x1,(%rsp,%r12,4)\ncmpb   $0x0,-0x1(%rbp)\njne    1407 <func0+0x137>\nmov    (%rsp),%r10d\nlea    0x2c0f(%rip),%r11\nxor    %ebp,%ebp\nxor    %esi,%esi\nlea    -0x1(%r11),%rdi\nnopl   0x0(%rax)\ntest   %r10d,%r10d\njle    149c <func0+0x1cc>\nmov    0x30(%rsp,%rbp,2),%rbx\nxor    %r8d,%r8d\nmovzbl (%rbx),%r9d\nnopl   0x0(%rax)\nmovslq %esi,%rcx\ntest   %r9b,%r9b\nje     148b <func0+0x1bb>\nlea    0x1(%rsi),%eax\nmovslq %esi,%rcx\nmov    %rbx,%rsi\nmov    %r9d,%edx\ncltq\nsub    %rcx,%rsi\nnopl   0x0(%rax)\nmov    %dl,(%rdi,%rax,1)\nmovslq %eax,%rcx\nadd    $0x1,%rax\nmovzbl -0x1(%rsi,%rax,1),%edx\ntest   %dl,%dl\njne    1478 <func0+0x1a8>\nadd    $0x1,%r8d\nmovb   $0x20,(%r11,%rcx,1)\nlea    0x1(%rcx),%esi\ncmp    %r10d,%r8d\njne    1458 <func0+0x188>\nadd    $0x4,%rbp\ncmp    $0x28,%rbp\nje     14ac <func0+0x1dc>\nmov    (%rsp,%rbp,1),%r10d\njmp    1440 <func0+0x170>\ntest   %esi,%esi\nje     14e2 <func0+0x212>\nlea    -0x1(%rsi),%eax\ncltq\nmovb   $0x0,(%r11,%rax,1)\nmov    0x88(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    14eb <func0+0x21b>\nadd    $0x98,%rsp\nmov    %r11,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovb   $0x0,0x2b57(%rip)\njmp    14ba <func0+0x1ea>\ncall   1070 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 19,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nlea    0xd30(%rip),%r15\npxor   %xmm0,%xmm0\npush   %r14\nlea    0xd27(%rip),%r14\nmovq   %r15,%xmm4\npush   %r13\nlea    0xd0c(%rip),%r13\nmovq   %r14,%xmm6\npush   %r12\nmovq   %r13,%xmm5\npunpcklqdq %xmm6,%xmm4\npush   %rbp\npush   %rbx\nsub    $0x98,%rsp\nmovq   0x2a6f(%rip),%xmm3\n00\nmovq   0x2a77(%rip),%xmm2\n00\nmovq   0x2a7f(%rip),%xmm1\n00\nmovhps 0x2a50(%rip),%xmm5\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x88(%rsp)\n00\nxor    %eax,%eax\nmovzbl (%rdi),%eax\nmovhps 0x2a43(%rip),%xmm3\nmovaps %xmm0,(%rsp)\nmovhps 0x2a48(%rip),%xmm2\nmovhps 0x2a51(%rip),%xmm1\nmovaps %xmm0,0x10(%rsp)\nmovq   $0x0,0x20(%rsp)\n00 00\nmovaps %xmm5,0x30(%rsp)\nmovaps %xmm4,0x40(%rsp)\nmovaps %xmm3,0x50(%rsp)\nmovaps %xmm2,0x60(%rsp)\nmovaps %xmm1,0x70(%rsp)\ntest   %al,%al\nje     152b <func0+0x25b>\nmov    %rdi,%rbp\nlea    0x82(%rsp),%rbx\n00\njmp    1502 <func0+0x232>\nmov    %al,0x82(%rsp)\nmovzbl 0x1(%rbp),%eax\ntest   $0xdf,%al\nje     15e8 <func0+0x318>\nmov    %al,0x83(%rsp)\nmovzbl 0x2(%rbp),%eax\ntest   $0xdf,%al\nje     15f8 <func0+0x328>\nmov    %al,0x84(%rsp)\nmovzbl 0x3(%rbp),%eax\ntest   $0xdf,%al\nje     1611 <func0+0x341>\nmov    %al,0x85(%rsp)\nmovzbl 0x4(%rbp),%eax\ntest   $0xdf,%al\nje     1621 <func0+0x351>\nmov    %al,0x86(%rsp)\nmovzbl 0x5(%rbp),%eax\ntest   $0xdf,%al\nje     1631 <func0+0x361>\nmov    %al,0x87(%rsp)\nmov    $0x6,%r12d\nmov    $0x6,%eax\nadd    $0x1,%r12\nmov    %r13,%rsi\nmov    %rbx,%rdi\nmovb   $0x0,0x82(%rsp,%rax,1)\n00\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     151c <func0+0x24c>\nlea    0xbd4(%rip),%rsi\nmov    %rbx,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1517 <func0+0x247>\nmov    %r15,%rsi\nmov    %rbx,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1651 <func0+0x381>\nmov    %r14,%rsi\nmov    %rbx,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1641 <func0+0x371>\nlea    0xba5(%rip),%rsi\nmov    %rbx,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1671 <func0+0x3a1>\nlea    0xb93(%rip),%rsi\nmov    %rbx,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1661 <func0+0x391>\nlea    0xb81(%rip),%rsi\nmov    %rbx,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1691 <func0+0x3c1>\nlea    0xb6e(%rip),%rsi\nmov    %rbx,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     16a1 <func0+0x3d1>\nlea    0xb5d(%rip),%rsi\nmov    %rbx,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     16b1 <func0+0x3e1>\nlea    0xb8b(%rip),%rsi\nmov    %rbx,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1681 <func0+0x3b1>\nadd    %r12,%rbp\ncmpb   $0x0,-0x1(%rbp)\nje     152b <func0+0x25b>\nmovzbl 0x0(%rbp),%eax\ntest   $0xdf,%al\njne    139e <func0+0xce>\nmov    $0x1,%r12d\nxor    %eax,%eax\njmp    1413 <func0+0x143>\nmov    $0x1,%eax\ncltq\naddl   $0x1,(%rsp,%rax,4)\nadd    %r12,%rbp\ncmpb   $0x0,-0x1(%rbp)\njne    14fe <func0+0x22e>\nlea    0x2b0e(%rip),%r12\nxor    %ebx,%ebx\nxor    %esi,%esi\nmov    %rsp,%rbp\nlea    -0x1(%r12),%rdi\nxchg   %ax,%ax\nmov    0x0(%rbp,%rbx,4),%r10d\ntest   %r10d,%r10d\njle    15a4 <func0+0x2d4>\nmov    0x30(%rsp,%rbx,8),%r11\nxor    %r8d,%r8d\nmovzbl (%r11),%r9d\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovslq %esi,%rcx\ntest   %r9b,%r9b\nje     1593 <func0+0x2c3>\nlea    0x1(%rsi),%eax\nmovslq %esi,%rcx\nmov    %r11,%rsi\nmov    %r9d,%edx\ncltq\nsub    %rcx,%rsi\nnopl   0x0(%rax)\nmov    %dl,(%rdi,%rax,1)\nmovslq %eax,%rcx\nadd    $0x1,%rax\nmovzbl -0x1(%rsi,%rax,1),%edx\ntest   %dl,%dl\njne    1580 <func0+0x2b0>\nadd    $0x1,%r8d\nmovb   $0x20,(%r12,%rcx,1)\nlea    0x1(%rcx),%esi\ncmp    %r8d,%r10d\njne    1560 <func0+0x290>\nadd    $0x1,%rbx\ncmp    $0xa,%rbx\njne    1540 <func0+0x270>\ntest   %esi,%esi\nje     1608 <func0+0x338>\nlea    -0x1(%rsi),%eax\ncltq\nmovb   $0x0,(%r12,%rax,1)\nmov    0x88(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    16c1 <func0+0x3f1>\nadd    $0x98,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x1,%eax\nmov    $0x1,%r12d\njmp    140f <func0+0x13f>\nmov    $0x2,%eax\nmov    $0x2,%r12d\njmp    140f <func0+0x13f>\nmovb   $0x0,0x2a31(%rip)\njmp    15bc <func0+0x2ec>\nmov    $0x3,%eax\nmov    $0x3,%r12d\njmp    140f <func0+0x13f>\nmov    $0x4,%eax\nmov    $0x4,%r12d\njmp    140f <func0+0x13f>\nmov    $0x5,%eax\nmov    $0x5,%r12d\njmp    140f <func0+0x13f>\nmov    $0x3,%eax\ncltq\naddl   $0x1,(%rsp,%rax,4)\njmp    1522 <func0+0x252>\nmov    $0x2,%eax\ncltq\naddl   $0x1,(%rsp,%rax,4)\njmp    1522 <func0+0x252>\nmov    $0x5,%eax\ncltq\naddl   $0x1,(%rsp,%rax,4)\njmp    1522 <func0+0x252>\nmov    $0x4,%eax\ncltq\naddl   $0x1,(%rsp,%rax,4)\njmp    1522 <func0+0x252>\nmov    $0x9,%eax\ncltq\naddl   $0x1,(%rsp,%rax,4)\njmp    1522 <func0+0x252>\nmov    $0x6,%eax\ncltq\naddl   $0x1,(%rsp,%rax,4)\njmp    1522 <func0+0x252>\nmov    $0x7,%eax\ncltq\naddl   $0x1,(%rsp,%rax,4)\njmp    1522 <func0+0x252>\nmov    $0x8,%eax\ncltq\naddl   $0x1,(%rsp,%rax,4)\njmp    1522 <func0+0x252>\ncall   1070 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 20,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovss  0xf3c(%rip),%xmm0\n00\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x38(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x28(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmovl   $0x0,-0x10(%rbp)\njmp    1279 <func0+0x110>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    1269 <func0+0x100>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmovss  0xecc(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x14(%rbp),%xmm0\ncomiss -0x4(%rbp),%xmm0\njbe    1265 <func0+0xfc>\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11c8 <func0+0x5f>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11ba <func0+0x51>\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\nja     12a0 <func0+0x137>\njmp    12cf <func0+0x166>\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0x8(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 20,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdx,%rcx\nmovss  (%rdi),%xmm0\nmovss  %xmm0,(%rdx)\nmovss  0x4(%rdi),%xmm0\nmovss  %xmm0,0x4(%rdx)\ntest   %esi,%esi\njle    11fd <func0+0x94>\nlea    0x4(%rdi),%rdx\nlea    -0x1(%rsi),%r10d\nmov    %esi,%r9d\nmov    $0x1,%r8d\nmovss  0xf15(%rip),%xmm2\n00\nadd    $0x8,%rdi\nmovss  0xf35(%rip),%xmm3\n00\njmp    11e4 <func0+0x7b>\nadd    $0x4,%rax\ncmp    %rsi,%rax\nje     11dc <func0+0x73>\nmovss  -0x4(%rdx),%xmm1\nmovaps %xmm1,%xmm0\nsubss  (%rax),%xmm0\nandps  %xmm3,%xmm0\ncomiss %xmm0,%xmm2\njbe    11ad <func0+0x44>\nmovss  %xmm1,(%rcx)\nmovss  (%rax),%xmm1\nmovss  %xmm1,0x4(%rcx)\nmovaps %xmm0,%xmm2\njmp    11ad <func0+0x44>\nadd    $0x1,%r8\nadd    $0x4,%rdx\ncmp    %r9,%r8\nje     11fd <func0+0x94>\nmov    %r10d,%eax\nsub    %r8d,%eax\nlea    -0x1(%r8,%rax,1),%rax\nlea    (%rdi,%rax,4),%rsi\nmov    %rdx,%rax\njmp    11b6 <func0+0x4d>\nmovss  (%rcx),%xmm0\nmovss  0x4(%rcx),%xmm1\ncomiss %xmm1,%xmm0\njbe    1214 <func0+0xab>\nmovss  %xmm1,(%rcx)\nmovss  %xmm0,0x4(%rcx)\nret\n"
    },
    {
        "task_id": 20,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm0\nmov    %rdx,%rcx\nmovss  %xmm0,(%rdx)\nmovss  0x4(%rdi),%xmm1\nmovss  %xmm1,0x4(%rdx)\ntest   %esi,%esi\njle    14db <func0+0xab>\nmov    %esi,%r9d\nlea    0x4(%rdi),%rdx\nlea    -0x1(%rsi),%r10d\nmov    $0x1,%r8d\nmovss  0xc4a(%rip),%xmm2\n00\nadd    $0x8,%rdi\nmovss  0xc4a(%rip),%xmm3\n00\ncmp    %r9,%r8\nje     14d2 <func0+0xa2>\nnopl   0x0(%rax,%rax,1)\nmov    %r10d,%eax\nsub    %r8d,%eax\nlea    -0x1(%r8,%rax,1),%rax\nlea    (%rdi,%rax,4),%rsi\nmov    %rdx,%rax\nnopw   0x0(%rax,%rax,1)\nmovss  -0x4(%rdx),%xmm1\nmovaps %xmm1,%xmm0\nsubss  (%rax),%xmm0\nandps  %xmm3,%xmm0\ncomiss %xmm0,%xmm2\njbe    14bc <func0+0x8c>\nmovss  %xmm1,(%rcx)\nmovss  (%rax),%xmm1\nmovaps %xmm0,%xmm2\nmovss  %xmm1,0x4(%rcx)\nadd    $0x4,%rax\ncmp    %rsi,%rax\njne    1498 <func0+0x68>\nadd    $0x1,%r8\nadd    $0x4,%rdx\ncmp    %r9,%r8\njne    1480 <func0+0x50>\nmovss  (%rcx),%xmm0\nmovss  0x4(%rcx),%xmm1\ncomiss %xmm1,%xmm0\njbe    14e9 <func0+0xb9>\nmovss  %xmm1,(%rcx)\nmovss  %xmm0,0x4(%rcx)\nret\nnopw   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 20,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm0\nmovss  %xmm0,(%rdx)\nmovss  0x4(%rdi),%xmm1\nmovss  %xmm1,0x4(%rdx)\ntest   %esi,%esi\njle    14cb <func0+0x8b>\ncmp    $0x1,%esi\nje     14c2 <func0+0x82>\nmovss  0xc4d(%rip),%xmm2\n00\nmov    %rdi,%rcx\nmovslq %esi,%r9\nmov    $0x1,%r8d\nmovss  0xc45(%rip),%xmm3\n00\nnopl   0x0(%rax,%rax,1)\nmov    %r8,%rax\nnopl   0x0(%rax,%rax,1)\nmovss  (%rcx),%xmm1\nmovaps %xmm1,%xmm0\nsubss  (%rdi,%rax,4),%xmm0\nandps  %xmm3,%xmm0\ncomiss %xmm0,%xmm2\njbe    14ad <func0+0x6d>\nmovss  %xmm1,(%rdx)\nmovss  (%rdi,%rax,4),%xmm1\nmovaps %xmm0,%xmm2\nmovss  %xmm1,0x4(%rdx)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     1488 <func0+0x48>\nadd    $0x1,%r8\nadd    $0x4,%rcx\ncmp    %r8,%r9\njne    1480 <func0+0x40>\nmovss  (%rdx),%xmm0\nmovss  0x4(%rdx),%xmm1\ncomiss %xmm1,%xmm0\njbe    14d9 <func0+0x99>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,0x4(%rdx)\nret\nnopw   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 21,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovl   $0x1,-0x8(%rbp)\njmp    1219 <func0+0xb0>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmovss  -0x10(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njbe    11da <func0+0x71>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncomiss -0xc(%rbp),%xmm0\njbe    1215 <func0+0xac>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     119b <func0+0x32>\nmovl   $0x0,-0x4(%rbp)\njmp    1275 <func0+0x10c>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nsubss  -0x10(%rbp),%xmm0\nmovss  -0xc(%rbp),%xmm1\nsubss  -0x10(%rbp),%xmm1\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     122e <func0+0xc5>\nnop\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 21,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm1\ncmp    $0x1,%esi\njle    11c7 <func0+0x5e>\nlea    0x4(%rdi),%rax\nlea    -0x2(%rsi),%edx\nlea    0x8(%rdi,%rdx,4),%rdx\nmovaps %xmm1,%xmm0\nmovss  (%rax),%xmm2\nmovaps %xmm2,%xmm3\nminss  %xmm1,%xmm3\nmovaps %xmm3,%xmm1\nmaxss  %xmm0,%xmm2\nmovaps %xmm2,%xmm0\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    1185 <func0+0x1c>\nmov    $0x0,%eax\nsubss  %xmm3,%xmm2\nmovss  (%rdi,%rax,4),%xmm0\nsubss  %xmm1,%xmm0\ndivss  %xmm2,%xmm0\nmovss  %xmm0,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     11ac <func0+0x43>\nret\nje     11ca <func0+0x61>\nret\nmovss  (%rdi),%xmm0\nsubss  %xmm1,%xmm0\nsubss  %xmm1,%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rdi)\njmp    11c9 <func0+0x60>\n"
    },
    {
        "task_id": 21,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm0\ncmp    $0x1,%esi\njle    14a0 <func0+0x70>\nlea    -0x2(%rsi),%edx\nlea    0x4(%rdi),%rax\nmovaps %xmm0,%xmm1\nlea    0x8(%rdi,%rdx,4),%rdx\nmovaps %xmm0,%xmm2\nnop\nmovss  (%rax),%xmm3\nadd    $0x4,%rax\nmovaps %xmm3,%xmm4\nmaxss  %xmm1,%xmm3\nminss  %xmm2,%xmm4\nmovaps %xmm3,%xmm1\nmovaps %xmm4,%xmm2\ncmp    %rax,%rdx\njne    1450 <func0+0x20>\nsubss  %xmm2,%xmm1\nxor    %eax,%eax\njmp    1485 <func0+0x55>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovss  (%rdi,%rax,4),%xmm0\nsubss  %xmm2,%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     1480 <func0+0x50>\nret\nnopl   0x0(%rax,%rax,1)\njne    149a <func0+0x6a>\nmovaps %xmm0,%xmm1\nmovaps %xmm0,%xmm2\njmp    146e <func0+0x3e>\nnopw   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 21,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm3\nmov    %rdi,%rdx\nmovaps %xmm3,%xmm2\ncmp    $0x1,%esi\njle    15e8 <func0+0x108>\nlea    -0x2(%rsi),%ecx\nlea    0x4(%rdi),%rax\nmovaps %xmm3,%xmm1\nlea    0x8(%rdi,%rcx,4),%rcx\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovss  (%rax),%xmm0\nadd    $0x4,%rax\nmovaps %xmm0,%xmm5\nmaxss  %xmm1,%xmm0\nminss  %xmm2,%xmm5\nmovaps %xmm0,%xmm1\nmovaps %xmm5,%xmm2\ncmp    %rcx,%rax\njne    1510 <func0+0x30>\ntest   %esi,%esi\nmov    $0x1,%edi\nsubss  %xmm5,%xmm1\ncmovg  %esi,%edi\ncmp    $0x3,%esi\njle    15eb <func0+0x10b>\nmov    %edi,%ecx\nmovaps %xmm5,%xmm4\nmov    %rdx,%rax\nshr    $0x2,%ecx\nmovaps %xmm1,%xmm3\nshufps $0x0,%xmm4,%xmm4\nsub    $0x1,%ecx\nshufps $0x0,%xmm3,%xmm3\nshl    $0x4,%rcx\nlea    0x10(%rdx,%rcx,1),%rcx\nnopw   0x0(%rax,%rax,1)\n00 00\nmovups (%rax),%xmm0\nadd    $0x10,%rax\nsubps  %xmm4,%xmm0\ndivps  %xmm3,%xmm0\nmovups %xmm0,-0x10(%rax)\ncmp    %rcx,%rax\njne    1570 <func0+0x90>\nmov    %edi,%eax\nand    $0xfffffffc,%eax\nand    $0x3,%edi\nje     15ea <func0+0x10a>\nmovslq %eax,%rcx\nadd    $0x1,%eax\nshl    $0x2,%rcx\nlea    (%rdx,%rcx,1),%rdi\nmovss  (%rdi),%xmm0\nsubss  %xmm2,%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rdi)\ncmp    %esi,%eax\njge    15ea <func0+0x10a>\nlea    0x4(%rdx,%rcx,1),%rdi\nadd    $0x1,%eax\nmovss  (%rdi),%xmm0\nsubss  %xmm2,%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rdi)\ncmp    %esi,%eax\njge    15ea <func0+0x10a>\nlea    0x8(%rdx,%rcx,1),%rax\nmovss  (%rax),%xmm0\nsubss  %xmm2,%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\nret\nnopl   0x0(%rax)\nje     1600 <func0+0x120>\nret\nsubss  %xmm5,%xmm3\nmov    $0x1,%eax\nxor    %ecx,%ecx\ndivss  %xmm1,%xmm3\nmovss  %xmm3,(%rdx)\njmp    15b2 <func0+0xd2>\nsubss  %xmm3,%xmm3\ndivss  %xmm3,%xmm3\nmovss  %xmm3,(%rdi)\nret\nnopl   (%rax)\n"
    },
    {
        "task_id": 22,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x10(%rbp)\njmp    12d9 <func0+0x110>\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1243 <func0+0x7a>\ncall   10d0 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x800,%eax\ntest   %eax,%eax\njne    1243 <func0+0x7a>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\njne    1200 <func0+0x37>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     12ea <func0+0x121>\nlea    -0x18(%rbp),%rcx\nmov    -0x10(%rbp),%rax\nmov    $0xa,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   10c0 <strtol@plt>\nmov    %eax,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    %rax,-0x10(%rbp)\nje     12bb <func0+0xf2>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\nje     128d <func0+0xc4>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    12bb <func0+0xf2>\nmov    -0x20(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x20(%rbp)\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nlea    0x2d99(%rip),%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\njmp    12d1 <func0+0x108>\nmov    -0x18(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     12d1 <func0+0x108>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\njne    12af <func0+0xe6>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1205 <func0+0x3c>\njmp    12eb <func0+0x122>\nnop\nmov    -0x30(%rbp),%rax\nmov    -0x20(%rbp),%edx\nmov    %edx,(%rax)\nlea    0x2d45(%rip),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     130f <func0+0x146>\ncall   10a0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 22,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,%r15\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmovzbl (%rdi),%ebx\nmov    $0x0,%r13d\ntest   %bl,%bl\nje     1277 <func0+0xae>\nmov    %rdi,%rbp\ncall   10d0 <__ctype_b_loc@plt>\nmov    %rax,%r12\nmov    $0x0,%r13d\nlea    0x2e2d(%rip),%r14\njmp    1257 <func0+0x8e>\ntest   %bl,%bl\nje     1277 <func0+0xae>\nmov    %rsp,%rsi\nmov    $0xa,%edx\nmov    %rbp,%rdi\ncall   10c0 <strtol@plt>\nmov    (%rsp),%rdx\ncmp    %rbp,%rdx\nje     12a0 <func0+0xd7>\nmovzbl (%rdx),%ecx\ncmp    $0x2c,%cl\nje     123e <func0+0x75>\ntest   %cl,%cl\njne    12ac <func0+0xe3>\nmovslq %r13d,%rdx\nmov    %eax,(%r14,%rdx,4)\nlea    0x1(%r13),%r13d\nmov    (%rsp),%rax\nmovzbl (%rax),%ebx\ntest   %bl,%bl\nje     1277 <func0+0xae>\nmov    %rax,%rbp\nmovsbq %bl,%rax\nmov    (%r12),%rdx\ntestb  $0x8,0x1(%rdx,%rax,2)\njne    1215 <func0+0x4c>\ncmp    $0x2d,%bl\nje     1215 <func0+0x4c>\nlea    0x1(%rbp),%rax\nmovzbl 0x1(%rbp),%ebx\ntest   %bl,%bl\njne    1254 <func0+0x8b>\nmov    %r13d,(%r15)\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    12c6 <func0+0xfd>\nlea    0x2daf(%rip),%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovzbl 0x0(%rbp),%eax\ntest   %al,%al\nje     1249 <func0+0x80>\ncmp    $0x2c,%al\nje     1249 <func0+0x80>\nlea    0x1(%rdx),%rax\nmov    %rax,(%rsp)\nmovzbl (%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\nje     1249 <func0+0x80>\ncmp    $0x2c,%dl\njne    12b0 <func0+0xe7>\njmp    1249 <func0+0x80>\ncall   10a0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 22,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nxor    %r15d,%r15d\npush   %r14\nlea    0x2cce(%rip),%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovzbl (%rdi),%ebx\nmov    %rsi,0x8(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ntest   %bl,%bl\nje     1450 <func0+0xf0>\nmov    %rdi,%rbp\nxor    %r15d,%r15d\nlea    0x10(%rsp),%r13\ncall   10d0 <__ctype_b_loc@plt>\nlea    0x2c8d(%rip),%r14\nmov    (%rax),%rcx\nmov    %rax,%r12\njmp    13d4 <func0+0x74>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x2d,%bl\nje     13df <func0+0x7f>\nmovzbl 0x1(%rbp),%ebx\nlea    0x1(%rbp),%rdx\ntest   %bl,%bl\nje     1450 <func0+0xf0>\nmov    %rdx,%rbp\nmovsbq %bl,%rax\ntestb  $0x8,0x1(%rcx,%rax,2)\nje     13c0 <func0+0x60>\nmov    $0xa,%edx\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncall   10c0 <strtol@plt>\nmov    0x10(%rsp),%rdx\ncmp    %rbp,%rdx\nje     1420 <func0+0xc0>\nmovzbl (%rdx),%ecx\ncmp    $0x2c,%cl\nje     1405 <func0+0xa5>\ntest   %cl,%cl\njne    142d <func0+0xcd>\nmovslq %r15d,%rcx\nadd    $0x1,%r15d\nmov    %eax,(%r14,%rcx,4)\nmovzbl (%rdx),%ebx\ntest   %bl,%bl\nje     1450 <func0+0xf0>\nmov    (%r12),%rcx\njmp    13d1 <func0+0x71>\nnopl   (%rax)\nmovzbl 0x0(%rbp),%ebx\ncmp    $0x2c,%bl\nje     147a <func0+0x11a>\ntest   %bl,%bl\nje     147a <func0+0x11a>\nlea    0x1(%rdx),%rax\njmp    143d <func0+0xdd>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x2c,%bl\nje     1413 <func0+0xb3>\nmov    %rax,0x10(%rsp)\nmovzbl (%rax),%ebx\nmov    %rax,%rdx\nadd    $0x1,%rax\ntest   %bl,%bl\njne    1438 <func0+0xd8>\nmov    0x8(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    147f <func0+0x11f>\nadd    $0x28,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rbp,%rdx\njmp    1413 <func0+0xb3>\ncall   10a0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnop\n"
    },
    {
        "task_id": 22,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nxor    %r15d,%r15d\npush   %r14\nlea    0x2cce(%rip),%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovzbl (%rdi),%ebx\nmov    %rsi,0x8(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ntest   %bl,%bl\nje     1450 <func0+0xf0>\nmov    %rdi,%rbp\nxor    %r15d,%r15d\nlea    0x10(%rsp),%r13\ncall   10d0 <__ctype_b_loc@plt>\nlea    0x2c8d(%rip),%r14\nmov    (%rax),%rcx\nmov    %rax,%r12\njmp    13d4 <func0+0x74>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x2d,%bl\nje     13df <func0+0x7f>\nmovzbl 0x1(%rbp),%ebx\nlea    0x1(%rbp),%rdx\ntest   %bl,%bl\nje     1450 <func0+0xf0>\nmov    %rdx,%rbp\nmovsbq %bl,%rax\ntestb  $0x8,0x1(%rcx,%rax,2)\nje     13c0 <func0+0x60>\nmov    $0xa,%edx\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncall   10c0 <strtol@plt>\nmov    0x10(%rsp),%rdx\ncmp    %rbp,%rdx\nje     1420 <func0+0xc0>\nmovzbl (%rdx),%ecx\ncmp    $0x2c,%cl\nje     1405 <func0+0xa5>\ntest   %cl,%cl\njne    142d <func0+0xcd>\nmovslq %r15d,%rcx\nadd    $0x1,%r15d\nmov    %eax,(%r14,%rcx,4)\nmovzbl (%rdx),%ebx\ntest   %bl,%bl\nje     1450 <func0+0xf0>\nmov    (%r12),%rcx\njmp    13d1 <func0+0x71>\nnopl   (%rax)\nmovzbl 0x0(%rbp),%ebx\ncmp    $0x2c,%bl\nje     147a <func0+0x11a>\ntest   %bl,%bl\nje     147a <func0+0x11a>\nlea    0x1(%rdx),%rax\njmp    143d <func0+0xdd>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x2c,%bl\nje     1413 <func0+0xb3>\nmov    %rax,0x10(%rsp)\nmovzbl (%rax),%ebx\nmov    %rax,%rdx\nadd    $0x1,%rax\ntest   %bl,%bl\njne    1438 <func0+0xd8>\nmov    0x8(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    147f <func0+0x11f>\nadd    $0x28,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rbp,%rdx\njmp    1413 <func0+0xb3>\ncall   10a0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnop\n"
    },
    {
        "task_id": 23,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1162 <func0+0x19>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    115e <func0+0x15>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 23,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmpb   $0x0,(%rdi)\nje     1167 <func0+0x1e>\nmov    $0x1,%eax\nmov    %eax,%edx\nadd    $0x1,%rax\ncmpb   $0x0,-0x1(%rdi,%rax,1)\njne    1157 <func0+0xe>\nmov    %edx,%eax\nret\nmov    $0x0,%edx\njmp    1164 <func0+0x1b>\n"
    },
    {
        "task_id": 23,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmpb   $0x0,(%rdi)\nje     11c8 <func0+0x28>\nmov    $0x1,%eax\nxchg   %ax,%ax\nmov    %eax,%r8d\nadd    $0x1,%rax\ncmpb   $0x0,-0x1(%rdi,%rax,1)\njne    11b0 <func0+0x10>\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 23,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmpb   $0x0,(%rdi)\nje     11c8 <func0+0x28>\nmov    $0x1,%eax\nxchg   %ax,%ax\nmov    %eax,%r8d\nadd    $0x1,%rax\ncmpb   $0x0,-0x1(%rdi,%rax,1)\njne    11b0 <func0+0x10>\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 24,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    1177 <func0+0x2e>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    1173 <func0+0x2a>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\njmp    1187 <func0+0x3e>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    115d <func0+0x14>\nmov    $0x1,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 24,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x3,%edi\njle    1185 <func0+0x3c>\ntest   $0x1,%dil\nje     1178 <func0+0x2f>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     117f <func0+0x36>\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    115d <func0+0x14>\nmov    %edi,%eax\ncltd\nidiv   %ecx\nret\nmov    $0x2,%ecx\njmp    1172 <func0+0x29>\nmov    $0x1,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 24,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x3,%edi\njle    1175 <func0+0x35>\nmov    $0x2,%ecx\ntest   $0x1,%dil\njne    1169 <func0+0x29>\njmp    1180 <func0+0x40>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1180 <func0+0x40>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    1160 <func0+0x20>\nmov    $0x1,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %ecx\nret\n"
    },
    {
        "task_id": 24,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x3,%edi\njle    1175 <func0+0x35>\nmov    $0x2,%ecx\ntest   $0x1,%dil\njne    1169 <func0+0x29>\njmp    1180 <func0+0x40>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1180 <func0+0x40>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    1160 <func0+0x20>\nmov    $0x1,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %ecx\nret\n"
    },
    {
        "task_id": 25,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    $0x100,%edi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x2,-0xc(%rbp)\njmp    121d <func0+0x74>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %eax,-0x14(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x20(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\nje     11dd <func0+0x34>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    120c <func0+0x63>\ncmpl   $0x1,-0x14(%rbp)\njle    1253 <func0+0xaa>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x20(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 25,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%ebx\nmov    %rsi,%rbp\nmov    $0x100,%edi\ncall   10b0 <malloc@plt>\nmov    %rax,%r10\nmovl   $0x0,0x0(%rbp)\nmov    $0x2,%ecx\ncmp    $0x3,%ebx\njg     122e <func0+0x85>\ncmp    $0x1,%ebx\njle    11ea <func0+0x41>\nmov    0x0(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x0(%rbp)\ncltq\nmov    %ebx,(%r10,%rax,4)\nmov    %r10,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nmov    0x0(%rbp),%eax\nlea    0x1(%rax),%edi\nmovslq %edi,%rdi\ncltq\nlea    (%r10,%rax,4),%rsi\nmov    %ebx,%eax\ncltd\nidiv   %ecx\nmov    %eax,%ebx\nmov    %edi,%r9d\nmov    %ecx,(%rsi)\nadd    $0x1,%rdi\nadd    $0x4,%rsi\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1203 <func0+0x5a>\nmov    %r9d,0x0(%rbp)\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njg     11d6 <func0+0x2d>\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     11f4 <func0+0x4b>\njmp    1222 <func0+0x79>\n"
    },
    {
        "task_id": 25,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x100,%edi\nsub    $0x8,%rsp\ncall   10b0 <malloc@plt>\nmovl   $0x0,0x0(%rbp)\nmov    $0x2,%ecx\nmov    %rax,%r8\ncmp    $0x3,%ebx\njle    15e0 <func0+0x70>\nnopl   (%rax)\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    15d4 <func0+0x64>\nmov    0x0(%rbp),%eax\nlea    0x1(%rax),%esi\nmovslq %esi,%rsi\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%eax\nmov    %ecx,-0x4(%r8,%rsi,4)\nmov    %esi,%edi\nadd    $0x1,%rsi\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%ebx\nidiv   %ecx\ntest   %edx,%edx\nje     15b8 <func0+0x48>\nmov    %edi,0x0(%rbp)\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njle    15a0 <func0+0x30>\ncmp    $0x1,%ebx\njle    15f3 <func0+0x83>\nmovslq 0x0(%rbp),%rax\nlea    0x1(%rax),%edx\nmov    %ebx,(%r8,%rax,4)\nmov    %edx,0x0(%rbp)\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\n"
    },
    {
        "task_id": 25,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x100,%edi\nsub    $0x8,%rsp\ncall   10b0 <malloc@plt>\nmovl   $0x0,0x0(%rbp)\nmov    $0x2,%ecx\nmov    %rax,%r8\ncmp    $0x3,%ebx\njle    15b0 <func0+0x70>\nnopl   (%rax)\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    15a4 <func0+0x64>\nmov    0x0(%rbp),%eax\nlea    0x1(%rax),%esi\nmovslq %esi,%rsi\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%eax\nmov    %ecx,-0x4(%r8,%rsi,4)\nmov    %esi,%edi\nadd    $0x1,%rsi\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%ebx\nidiv   %ecx\ntest   %edx,%edx\nje     1588 <func0+0x48>\nmov    %edi,0x0(%rbp)\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njle    1570 <func0+0x30>\ncmp    $0x1,%ebx\njle    15c3 <func0+0x83>\nmovslq 0x0(%rbp),%rax\nlea    0x1(%rax),%edx\nmov    %ebx,(%r8,%rax,4)\nmov    %edx,0x0(%rbp)\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\n"
    },
    {
        "task_id": 26,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %esi,-0x5c(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x5c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x5c(%rbp),%eax\ncltq\nmov    $0x4,%esi\nmov    %rax,%rdi\ncall   10c0 <calloc@plt>\nmov    %rax,-0x10(%rbp)\nmov    -0x5c(%rbp),%eax\ncltq\nmov    $0x4,%esi\nmov    %rax,%rdi\ncall   10c0 <calloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x4c(%rbp)\nmovl   $0x0,-0x48(%rbp)\nmovl   $0x0,-0x44(%rbp)\nmovl   $0x0,-0x40(%rbp)\njmp    1332 <func0+0x169>\nmov    -0x40(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x1c(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    1293 <func0+0xca>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njne    128f <func0+0xc6>\nmovl   $0x1,-0x3c(%rbp)\njmp    129b <func0+0xd2>\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x48(%rbp),%eax\njl     126b <func0+0xa2>\ncmpl   $0x0,-0x3c(%rbp)\njne    132d <func0+0x164>\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x30(%rbp)\njmp    12dd <func0+0x114>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njne    12d9 <func0+0x110>\nmovl   $0x1,-0x34(%rbp)\njmp    12e5 <func0+0x11c>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njl     12b5 <func0+0xec>\ncmpl   $0x0,-0x34(%rbp)\nje     130c <func0+0x143>\nmov    -0x48(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x48(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,(%rdx)\njmp    132e <func0+0x165>\nmov    -0x4c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x4c(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,(%rdx)\njmp    132e <func0+0x165>\nnop\naddl   $0x1,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x5c(%rbp),%eax\njl     1242 <func0+0x79>\nmovl   $0x0,-0x2c(%rbp)\njmp    13cc <func0+0x203>\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x20(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    139b <func0+0x1d2>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x20(%rbp)\njne    1397 <func0+0x1ce>\nmovl   $0x1,-0x28(%rbp)\njmp    13a3 <func0+0x1da>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x48(%rbp),%eax\njl     1373 <func0+0x1aa>\ncmpl   $0x0,-0x28(%rbp)\njne    13c8 <func0+0x1ff>\nmov    -0x44(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x44(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x5c(%rbp),%eax\njl     134a <func0+0x181>\nmov    -0x68(%rbp),%rax\nmov    -0x44(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   1090 <free@plt>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1090 <free@plt>\nmov    -0x18(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 26,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r14\nmov    %esi,%r15d\nmov    %rdx,%r13\nmovslq %esi,%rbx\nlea    0x0(,%rbx,4),%rdi\n00\ncall   10d0 <malloc@plt>\nmov    %rax,%r12\nmov    $0x4,%esi\nmov    %rbx,%rdi\ncall   10c0 <calloc@plt>\nmov    %rax,%rbp\nmov    $0x4,%esi\nmov    %rbx,%rdi\ncall   10c0 <calloc@plt>\nmov    %rax,%rbx\ntest   %r15d,%r15d\njle    124f <func0+0x86>\nmov    %r14,%rsi\nlea    -0x1(%r15),%eax\nlea    0x4(%r14,%rax,4),%rdi\nmov    $0x0,%r8d\nmov    $0x0,%r9d\nlea    0x4(%rbp),%r11\nlea    0x4(%rbx),%r10\njmp    12bb <func0+0xf2>\nlea    -0x1(%r8),%eax\nlea    0x4(%rbx,%rax,4),%rcx\nmov    $0x0,%r9d\njmp    128f <func0+0xc6>\nmov    $0x0,%r9d\nmov    %r9d,0x0(%r13)\nmov    %rbp,%rdi\ncall   1090 <free@plt>\nmov    %rbx,%rdi\ncall   1090 <free@plt>\nmov    %r12,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovslq %r9d,%rax\nmov    %edx,(%r12,%rax,4)\nlea    0x1(%r9),%r9d\nadd    $0x4,%rsi\ncmp    %rdi,%rsi\nje     1255 <func0+0x8c>\nmov    (%rsi),%edx\ntest   %r8d,%r8d\njle    127b <func0+0xb2>\nmov    %rbx,%rax\ncmp    %edx,(%rax)\nje     1286 <func0+0xbd>\nadd    $0x4,%rax\ncmp    %rax,%rcx\njne    1299 <func0+0xd0>\njmp    127b <func0+0xb2>\nmovslq %r8d,%rax\nmov    %edx,(%rbx,%rax,4)\nlea    0x1(%r8),%r8d\nadd    $0x4,%r14\ncmp    %rdi,%r14\nje     123e <func0+0x75>\nmov    (%r14),%edx\ntest   %r8d,%r8d\njle    12db <func0+0x112>\nmov    %rbx,%rax\nlea    -0x1(%r8),%ecx\nlea    (%r10,%rcx,4),%rcx\ncmp    %edx,(%rax)\nje     12b2 <func0+0xe9>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    12ce <func0+0x105>\ntest   %r9d,%r9d\njle    12f8 <func0+0x12f>\nmov    %rbp,%rax\nlea    -0x1(%r9),%ecx\nlea    (%r11,%rcx,4),%rcx\ncmp    %edx,(%rax)\nje     12a8 <func0+0xdf>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    12eb <func0+0x122>\nmovslq %r9d,%rax\nmov    %edx,0x0(%rbp,%rax,4)\nlea    0x1(%r9),%r9d\njmp    12b2 <func0+0xe9>\n"
    },
    {
        "task_id": 26,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\nmovslq %esi,%r13\npush   %r12\nlea    0x0(,%r13,4),%rdi\n00\nmov    %r13,%r14\npush   %rbp\npush   %rbx\nmov    %rdx,%rbx\nsub    $0x8,%rsp\ncall   10d0 <malloc@plt>\nmov    %r13,%rdi\nmov    $0x4,%esi\nmov    %rax,%r12\ncall   10c0 <calloc@plt>\nmov    %r13,%rdi\nmov    $0x4,%esi\nmov    %rax,%rbp\ncall   10c0 <calloc@plt>\nmov    %rax,%r13\ntest   %r14d,%r14d\njle    1545 <func0+0x185>\nlea    -0x1(%r14),%eax\nmov    %r15,%rsi\nmov    %r15,%rdi\nxor    %r8d,%r8d\nlea    0x4(%r15,%rax,4),%r9\nxor    %r10d,%r10d\nlea    0x4(%r13),%r11\nlea    0x4(%rbp),%r14\nnopl   0x0(%rax)\nmov    (%rdi),%edx\ntest   %r8d,%r8d\nje     14c0 <func0+0x100>\nlea    -0x1(%r8),%ecx\nmov    %r13,%rax\nlea    (%r11,%rcx,4),%rcx\njmp    1459 <func0+0x99>\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     14c0 <func0+0x100>\ncmp    %edx,(%rax)\njne    1450 <func0+0x90>\nadd    $0x4,%rdi\ncmp    %r9,%rdi\njne    1438 <func0+0x78>\nlea    -0x1(%r8),%eax\nxor    %edi,%edi\nlea    (%r11,%rax,4),%rcx\nmov    (%rsi),%edx\ntest   %r8d,%r8d\nje     1508 <func0+0x148>\nmov    %r13,%rax\njmp    1489 <func0+0xc9>\nadd    $0x4,%rax\ncmp    %rax,%rcx\nje     1508 <func0+0x148>\ncmp    %edx,(%rax)\njne    1480 <func0+0xc0>\nadd    $0x4,%rsi\ncmp    %r9,%rsi\njne    1470 <func0+0xb0>\nmov    %edi,(%rbx)\nmov    %rbp,%rdi\ncall   1090 <free@plt>\nmov    %r13,%rdi\ncall   1090 <free@plt>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\ntest   %r10d,%r10d\nje     1528 <func0+0x168>\nlea    -0x1(%r10),%ecx\nmov    %rbp,%rax\nlea    (%r14,%rcx,4),%rcx\njmp    14e1 <func0+0x121>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     1528 <func0+0x168>\ncmp    %edx,(%rax)\njne    14d8 <func0+0x118>\nmovslq %r8d,%rax\nadd    $0x4,%rdi\nadd    $0x1,%r8d\nmov    %edx,0x0(%r13,%rax,4)\ncmp    %r9,%rdi\njne    1438 <func0+0x78>\njmp    1466 <func0+0xa6>\nnopl   0x0(%rax,%rax,1)\nmovslq %edi,%rax\nadd    $0x4,%rsi\nadd    $0x1,%edi\nmov    %edx,(%r12,%rax,4)\ncmp    %r9,%rsi\njne    1470 <func0+0xb0>\njmp    1496 <func0+0xd6>\nnopl   0x0(%rax)\nmovslq %r10d,%rax\nadd    $0x4,%rdi\nadd    $0x1,%r10d\nmov    %edx,0x0(%rbp,%rax,4)\ncmp    %r9,%rdi\njne    1438 <func0+0x78>\njmp    1466 <func0+0xa6>\nxor    %edi,%edi\njmp    1496 <func0+0xd6>\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 26,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\nmovslq %esi,%r13\npush   %r12\nlea    0x0(,%r13,4),%rdi\n00\nmov    %r13,%r14\npush   %rbp\npush   %rbx\nmov    %rdx,%rbx\nsub    $0x8,%rsp\ncall   10d0 <malloc@plt>\nmov    %r13,%rdi\nmov    $0x4,%esi\nmov    %rax,%r12\ncall   10c0 <calloc@plt>\nmov    %r13,%rdi\nmov    $0x4,%esi\nmov    %rax,%rbp\ncall   10c0 <calloc@plt>\nmov    %rax,%r13\ntest   %r14d,%r14d\njle    1525 <func0+0x185>\nlea    -0x1(%r14),%eax\nmov    %r15,%rsi\nmov    %r15,%rdi\nxor    %r8d,%r8d\nlea    0x4(%r15,%rax,4),%r9\nxor    %r10d,%r10d\nlea    0x4(%r13),%r11\nlea    0x4(%rbp),%r14\nnopl   0x0(%rax)\nmov    (%rdi),%edx\ntest   %r8d,%r8d\nje     14a0 <func0+0x100>\nlea    -0x1(%r8),%ecx\nmov    %r13,%rax\nlea    (%r11,%rcx,4),%rcx\njmp    1439 <func0+0x99>\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     14a0 <func0+0x100>\ncmp    %edx,(%rax)\njne    1430 <func0+0x90>\nadd    $0x4,%rdi\ncmp    %r9,%rdi\njne    1418 <func0+0x78>\nlea    -0x1(%r8),%eax\nxor    %edi,%edi\nlea    (%r11,%rax,4),%rcx\nmov    (%rsi),%edx\ntest   %r8d,%r8d\nje     14e8 <func0+0x148>\nmov    %r13,%rax\njmp    1469 <func0+0xc9>\nadd    $0x4,%rax\ncmp    %rax,%rcx\nje     14e8 <func0+0x148>\ncmp    %edx,(%rax)\njne    1460 <func0+0xc0>\nadd    $0x4,%rsi\ncmp    %r9,%rsi\njne    1450 <func0+0xb0>\nmov    %edi,(%rbx)\nmov    %rbp,%rdi\ncall   1090 <free@plt>\nmov    %r13,%rdi\ncall   1090 <free@plt>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\ntest   %r10d,%r10d\nje     1508 <func0+0x168>\nlea    -0x1(%r10),%ecx\nmov    %rbp,%rax\nlea    (%r14,%rcx,4),%rcx\njmp    14c1 <func0+0x121>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     1508 <func0+0x168>\ncmp    %edx,(%rax)\njne    14b8 <func0+0x118>\nmovslq %r8d,%rax\nadd    $0x4,%rdi\nadd    $0x1,%r8d\nmov    %edx,0x0(%r13,%rax,4)\ncmp    %r9,%rdi\njne    1418 <func0+0x78>\njmp    1446 <func0+0xa6>\nnopl   0x0(%rax,%rax,1)\nmovslq %edi,%rax\nadd    $0x4,%rsi\nadd    $0x1,%edi\nmov    %edx,(%r12,%rax,4)\ncmp    %r9,%rsi\njne    1450 <func0+0xb0>\njmp    1476 <func0+0xd6>\nnopl   0x0(%rax)\nmovslq %r10d,%rax\nadd    $0x4,%rdi\nadd    $0x1,%r10d\nmov    %edx,0x0(%rbp,%rax,4)\ncmp    %r9,%rdi\njne    1418 <func0+0x78>\njmp    1446 <func0+0xa6>\nxor    %edi,%edi\njmp    1476 <func0+0xd6>\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 27,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <strlen@plt>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    122d <func0+0x84>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x9(%rbp)\ncmpb   $0x60,-0x9(%rbp)\njle    1200 <func0+0x57>\ncmpb   $0x7a,-0x9(%rbp)\njg     1200 <func0+0x57>\nmovzbl -0x9(%rbp),%eax\nsub    $0x20,%eax\nmov    %al,-0x9(%rbp)\njmp    1216 <func0+0x6d>\ncmpb   $0x40,-0x9(%rbp)\njle    1216 <func0+0x6d>\ncmpb   $0x5a,-0x9(%rbp)\njg     1216 <func0+0x6d>\nmovzbl -0x9(%rbp),%eax\nadd    $0x20,%eax\nmov    %al,-0x9(%rbp)\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x9(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     11d5 <func0+0x2c>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nleave\nret\n"
    },
    {
        "task_id": 27,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %rsi,%rbx\ncall   1080 <strlen@plt>\ntest   %eax,%eax\njle    11fe <func0+0x55>\nlea    -0x1(%rax),%r8d\nmov    $0x0,%ecx\njmp    11e9 <func0+0x40>\nlea    -0x41(%rdx),%edi\nadd    $0x20,%esi\ncmp    $0x1a,%dil\ncmovb  %esi,%edx\nmov    %dl,(%rbx,%rcx,1)\nlea    0x1(%rcx),%rdx\ncmp    %r8,%rcx\nje     11fe <func0+0x55>\nmov    %rdx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edx\nmov    %edx,%esi\nlea    -0x61(%rdx),%edi\ncmp    $0x19,%dil\nja     11cd <func0+0x24>\nsub    $0x20,%edx\njmp    11da <func0+0x31>\ncltq\nmovb   $0x0,(%rbx,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 27,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\ntest   %eax,%eax\njle    133b <func0+0x5b>\nlea    -0x1(%rax),%esi\nxor    %ecx,%ecx\njmp    1312 <func0+0x32>\nsub    $0x20,%edx\nmov    %dl,(%rbx,%rcx,1)\nlea    0x1(%rcx),%rdx\ncmp    %rcx,%rsi\nje     133b <func0+0x5b>\nmov    %rdx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edx\nlea    -0x61(%rdx),%r8d\ncmp    $0x19,%r8b\njbe    1300 <func0+0x20>\nlea    -0x41(%rdx),%r8d\nlea    0x20(%rdx),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%edx\nmov    %dl,(%rbx,%rcx,1)\nlea    0x1(%rcx),%rdx\ncmp    %rcx,%rsi\njne    130f <func0+0x2f>\ncltq\nmovb   $0x0,(%rbx,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 27,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\nmov    %rax,%rdx\ntest   %eax,%eax\njle    164b <func0+0x36b>\nlea    0x1(%rbp),%rsi\nmov    %rbx,%rcx\nlea    -0x1(%rax),%eax\nsub    %rsi,%rcx\ncmp    $0xe,%rcx\njbe    1660 <func0+0x380>\ncmp    $0xe,%eax\njbe    1660 <func0+0x380>\nmov    %edx,%ecx\nmovdqa 0xe06(%rip),%xmm5\n00\nxor    %eax,%eax\npxor   %xmm4,%xmm4\nshr    $0x4,%ecx\nmovdqa 0xe05(%rip),%xmm7\n00\nmovdqa 0xdcc(%rip),%xmm9\n00 00\nmovdqa 0xdd3(%rip),%xmm8\n00 00\nmovdqa 0xdfb(%rip),%xmm6\n00\nshl    $0x4,%rcx\nnopl   0x0(%rax)\nmovdqu 0x0(%rbp,%rax,1),%xmm3\nmovdqa %xmm3,%xmm0\nmovdqa %xmm3,%xmm1\npaddb  %xmm8,%xmm0\npaddb  %xmm9,%xmm1\nmovdqa %xmm0,%xmm2\npsubusb %xmm5,%xmm1\npminub %xmm5,%xmm2\npcmpeqb %xmm4,%xmm1\npcmpeqb %xmm0,%xmm2\npsubusb %xmm5,%xmm0\npcmpeqb %xmm4,%xmm0\nmovdqa %xmm1,%xmm10\npcmpeqb %xmm4,%xmm10\npcmpeqb %xmm4,%xmm0\npand   %xmm10,%xmm2\npand   %xmm10,%xmm0\nmovdqa %xmm3,%xmm10\npaddb  %xmm7,%xmm10\npand   %xmm1,%xmm10\npandn  %xmm3,%xmm1\npor    %xmm10,%xmm1\nmovdqa %xmm3,%xmm10\npaddb  %xmm6,%xmm3\npand   %xmm0,%xmm10\npandn  %xmm1,%xmm0\npand   %xmm2,%xmm3\npor    %xmm10,%xmm0\npandn  %xmm0,%xmm2\npor    %xmm3,%xmm2\nmovups %xmm2,(%rbx,%rax,1)\nadd    $0x10,%rax\ncmp    %rcx,%rax\njne    1360 <func0+0x80>\nmov    %edx,%eax\nand    $0xfffffff0,%eax\ntest   $0xf,%dl\nje     164b <func0+0x36b>\nmovslq %eax,%rsi\nmovzbl 0x0(%rbp,%rsi,1),%ecx\nlea    -0x61(%rcx),%edi\ncmp    $0x19,%dil\njbe    16a0 <func0+0x3c0>\nlea    -0x41(%rcx),%r8d\nlea    0x20(%rcx),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%ecx\nmov    %cl,(%rbx,%rsi,1)\nlea    0x1(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     16b0 <func0+0x3d0>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x2(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     16c8 <func0+0x3e8>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x3(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     16e0 <func0+0x400>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x4(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     16f8 <func0+0x418>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x5(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     1710 <func0+0x430>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x6(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     1728 <func0+0x448>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x7(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\njbe    1740 <func0+0x460>\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x8(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     1750 <func0+0x470>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x9(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     1768 <func0+0x488>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0xa(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     1780 <func0+0x4a0>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0xb(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     1798 <func0+0x4b8>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0xc(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     17b0 <func0+0x4d0>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0xd(%rax),%ecx\ncmp    %ecx,%edx\njle    164b <func0+0x36b>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     17c8 <func0+0x4e8>\nsub    $0x20,%esi\nadd    $0xe,%eax\nmov    %sil,(%rbx,%rcx,1)\ncmp    %eax,%edx\njle    164b <func0+0x36b>\ncltq\nmovzbl 0x0(%rbp,%rax,1),%ecx\nlea    -0x61(%rcx),%esi\ncmp    $0x19,%sil\nja     17db <func0+0x4fb>\nsub    $0x20,%ecx\nmov    %cl,(%rbx,%rax,1)\nmovslq %edx,%rdx\nmovb   $0x0,(%rbx,%rdx,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   0x0(%rax)\nmov    %eax,%esi\nxor    %ecx,%ecx\njmp    1682 <func0+0x3a2>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nsub    $0x20,%eax\nmov    %al,(%rbx,%rcx,1)\nlea    0x1(%rcx),%rax\ncmp    %rsi,%rcx\nje     164b <func0+0x36b>\nmov    %rax,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%eax\nlea    -0x61(%rax),%edi\ncmp    $0x19,%dil\njbe    1670 <func0+0x390>\nlea    -0x41(%rax),%r8d\nlea    0x20(%rax),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%eax\njmp    1673 <func0+0x393>\nsub    $0x20,%ecx\njmp    1429 <func0+0x149>\nnopl   0x0(%rax,%rax,1)\n00\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    144f <func0+0x16f>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    1476 <func0+0x196>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    149d <func0+0x1bd>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    14c4 <func0+0x1e4>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    14eb <func0+0x20b>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    1512 <func0+0x232>\nnopl   0x0(%rax,%rax,1)\nsub    $0x20,%esi\njmp    1544 <func0+0x264>\nnopl   0x0(%rax,%rax,1)\n00\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    156b <func0+0x28b>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    1592 <func0+0x2b2>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    15b9 <func0+0x2d9>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    15e0 <func0+0x300>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    1603 <func0+0x323>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmp    1626 <func0+0x346>\nlea    -0x41(%rcx),%edi\nlea    0x20(%rcx),%esi\ncmp    $0x1a,%dil\ncmovb  %esi,%ecx\njmp    1648 <func0+0x368>\n"
    },
    {
        "task_id": 28,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1259 <func0+0x50>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   10c0 <strlen@plt>\nmov    %eax,%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     122c <func0+0x23>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   1100 <malloc@plt>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1283 <func0+0x7a>\nmov    $0x0,%eax\njmp    12c9 <func0+0xc0>\nmov    -0x8(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0xc(%rbp)\njmp    12bd <func0+0xb4>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1110 <strcat@plt>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1293 <func0+0x8a>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 28,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    1280 <func0+0x77>\nmov    %rdi,%r13\nmov    %esi,%r12d\nmov    %rdi,%rbx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r14\nmov    $0x0,%ebp\nmov    (%rbx),%rdi\ncall   10c0 <strlen@plt>\nadd    %eax,%ebp\nadd    $0x8,%rbx\ncmp    %r14,%rbx\njne    122f <func0+0x26>\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\ncall   1100 <malloc@plt>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1274 <func0+0x6b>\nmovb   $0x0,0x0(%rbp)\nmov    $0x0,%ebx\nmov    0x0(%r13,%rbx,8),%rsi\nmov    %rbp,%rdi\ncall   1110 <strcat@plt>\nadd    $0x1,%rbx\ncmp    %ebx,%r12d\njg     125e <func0+0x55>\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    $0x1,%edi\ncall   1100 <malloc@plt>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1274 <func0+0x6b>\nmovb   $0x0,(%rax)\njmp    1274 <func0+0x6b>\n"
    },
    {
        "task_id": 28,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    1408 <func0+0x88>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nmov    %rdi,%rbp\nxor    %r12d,%r12d\nlea    0x8(%rdi,%rax,8),%r13\nnopl   0x0(%rax,%rax,1)\nmov    0x0(%rbp),%rdi\nadd    $0x8,%rbp\ncall   10c0 <strlen@plt>\nadd    %eax,%r12d\ncmp    %r13,%rbp\njne    13a8 <func0+0x28>\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\ncall   1100 <malloc@plt>\nmov    %rax,%r8\ntest   %rax,%rax\nje     142b <func0+0xab>\nmovb   $0x0,(%r8)\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    (%rbx),%rsi\nmov    %r8,%rdi\nadd    $0x8,%rbx\ncall   1110 <strcat@plt>\nmov    %rax,%r8\ncmp    %r13,%rbx\njne    13e0 <func0+0x60>\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\nmov    $0x1,%edi\ncall   1100 <malloc@plt>\nmov    %rax,%r8\ntest   %rax,%rax\nje     142b <func0+0xab>\nmovb   $0x0,(%rax)\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nxor    %r8d,%r8d\njmp    13f7 <func0+0x77>\n"
    },
    {
        "task_id": 28,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    1418 <func0+0x88>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nmov    %rdi,%rbp\nxor    %r12d,%r12d\nlea    0x8(%rdi,%rax,8),%r13\nnopl   0x0(%rax,%rax,1)\nmov    0x0(%rbp),%rdi\nadd    $0x8,%rbp\ncall   10c0 <strlen@plt>\nadd    %eax,%r12d\ncmp    %rbp,%r13\njne    13b8 <func0+0x28>\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\ncall   1100 <malloc@plt>\nmov    %rax,%r8\ntest   %rax,%rax\nje     143b <func0+0xab>\nmovb   $0x0,(%r8)\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    (%rbx),%rsi\nmov    %r8,%rdi\nadd    $0x8,%rbx\ncall   1110 <strcat@plt>\nmov    %rax,%r8\ncmp    %rbx,%r13\njne    13f0 <func0+0x60>\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\nmov    $0x1,%edi\ncall   1100 <malloc@plt>\nmov    %rax,%r8\ntest   %rax,%rax\nje     143b <func0+0xab>\nmovb   $0x0,(%rax)\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nxor    %r8d,%r8d\njmp    1407 <func0+0x77>\n"
    },
    {
        "task_id": 29,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10d0 <strlen@plt>\nmov    %eax,-0x4(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1110 <malloc@plt>\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,(%rax)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    12c7 <func0+0xbe>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    -0x28(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   10c0 <strncmp@plt>\ntest   %eax,%eax\njne    12c3 <func0+0xba>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x30(%rbp),%rax\nmov    (%rax),%rsi\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nshl    $0x3,%rax\nlea    (%rsi,%rax,1),%rdx\nmov    (%rcx),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     125e <func0+0x55>\nmov    -0xc(%rbp),%eax\nleave\nret\n"
    },
    {
        "task_id": 29,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r12\nmov    %esi,%ebp\nmov    %rdx,%rdi\nmov    %rdx,0x8(%rsp)\nmov    %rcx,%r15\ncall   10d0 <strlen@plt>\nmov    %eax,%r13d\nmovslq %ebp,%rdi\nshl    $0x3,%rdi\ncall   1110 <malloc@plt>\nmov    %rax,(%r15)\ntest   %ebp,%ebp\njle    128d <func0+0x84>\nmov    %r12,%rbx\nlea    -0x1(%rbp),%eax\nlea    0x8(%r12,%rax,8),%r14\nmov    $0x0,%r12d\nmovslq %r13d,%r13\njmp    1265 <func0+0x5c>\nadd    $0x8,%rbx\ncmp    %r14,%rbx\nje     1293 <func0+0x8a>\nmov    (%rbx),%rbp\nmov    %r13,%rdx\nmov    0x8(%rsp),%rsi\nmov    %rbp,%rdi\ncall   10c0 <strncmp@plt>\ntest   %eax,%eax\njne    125c <func0+0x53>\nmovslq %r12d,%rdx\nmov    (%r15),%rax\nmov    %rbp,(%rax,%rdx,8)\nlea    0x1(%r12),%r12d\njmp    125c <func0+0x53>\nmov    $0x0,%r12d\nmov    %r12d,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 29,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rcx,%r15\npush   %r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\nmov    %esi,%r12d\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rdx,%rdi\nsub    $0x18,%rsp\ncall   10d0 <strlen@plt>\nmovslq %r12d,%rdi\nshl    $0x3,%rdi\nmov    %rax,%rbp\ncall   1110 <malloc@plt>\nmov    %rax,0x8(%rsp)\nmov    %rax,(%r15)\ntest   %r12d,%r12d\njle    1470 <func0+0xa0>\nlea    -0x1(%r12),%eax\nmovslq %ebp,%rbp\nxor    %r12d,%r12d\nlea    0x8(%rbx,%rax,8),%r15\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%r14\nmov    %rbp,%rdx\nmov    %r13,%rsi\nmov    %r14,%rdi\ncall   10c0 <strncmp@plt>\ntest   %eax,%eax\njne    144d <func0+0x7d>\nmov    0x8(%rsp),%rcx\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmov    %r14,(%rcx,%rax,8)\nadd    $0x8,%rbx\ncmp    %r15,%rbx\njne    1428 <func0+0x58>\nadd    $0x18,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\n00\nxor    %r12d,%r12d\njmp    1456 <func0+0x86>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\n"
    },
    {
        "task_id": 29,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rcx,%r15\npush   %r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\nmov    %esi,%r12d\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rdx,%rdi\nsub    $0x18,%rsp\ncall   10d0 <strlen@plt>\nmovslq %r12d,%rdi\nshl    $0x3,%rdi\nmov    %rax,%rbp\ncall   1110 <malloc@plt>\nmov    %rax,0x8(%rsp)\nmov    %rax,(%r15)\ntest   %r12d,%r12d\njle    14d0 <func0+0xa0>\nlea    -0x1(%r12),%eax\nmovslq %ebp,%rbp\nxor    %r12d,%r12d\nlea    0x8(%rbx,%rax,8),%r15\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%r14\nmov    %rbp,%rdx\nmov    %r13,%rsi\nmov    %r14,%rdi\ncall   10c0 <strncmp@plt>\ntest   %eax,%eax\njne    14ad <func0+0x7d>\nmov    0x8(%rsp),%rcx\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmov    %r14,(%rcx,%rax,8)\nadd    $0x8,%rbx\ncmp    %r15,%rbx\njne    1488 <func0+0x58>\nadd    $0x18,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\n00\nxor    %r12d,%r12d\njmp    14b6 <func0+0x86>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\n"
    },
    {
        "task_id": 30,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0xc(%rbp)\njmp    124a <func0+0xa1>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\ncomiss %xmm1,%xmm0\njbe    1246 <func0+0x9d>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x28(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rsi),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     11e8 <func0+0x3f>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 30,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    %esi,%ebp\nmov    %rdx,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmovl   $0x0,(%rbx)\ntest   %ebp,%ebp\njle    1207 <func0+0x5e>\nmov    %r12,%rdx\nlea    -0x1(%rbp),%ecx\nlea    0x4(%r12,%rcx,4),%rdi\npxor   %xmm1,%xmm1\njmp    11fc <func0+0x53>\nmov    (%rbx),%ecx\nlea    0x1(%rcx),%esi\nmov    %esi,(%rbx)\nmovslq %ecx,%rcx\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax,%rcx,4)\nadd    $0x4,%rdx\ncmp    %rdi,%rdx\nje     1207 <func0+0x5e>\nmovss  (%rdx),%xmm0\ncomiss %xmm1,%xmm0\nja     11e0 <func0+0x37>\njmp    11f3 <func0+0x4a>\npop    %rbx\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 30,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    14d1 <func0+0x61>\nlea    -0x1(%r12),%ecx\nmov    %rbx,%rdx\npxor   %xmm1,%xmm1\nlea    0x4(%rbx,%rcx,4),%rdi\nnopw   0x0(%rax,%rax,1)\nmovss  (%rdx),%xmm0\ncomiss %xmm1,%xmm0\njbe    14c8 <func0+0x58>\nmovslq 0x0(%rbp),%rcx\nlea    0x1(%rcx),%esi\nmovss  %xmm0,(%rax,%rcx,4)\nmov    %esi,0x0(%rbp)\nadd    $0x4,%rdx\ncmp    %rdi,%rdx\njne    14b0 <func0+0x40>\npop    %rbx\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\n"
    },
    {
        "task_id": 30,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    14a1 <func0+0x61>\nlea    -0x1(%r12),%ecx\nmov    %rbx,%rdx\npxor   %xmm1,%xmm1\nlea    0x4(%rbx,%rcx,4),%rdi\nnopw   0x0(%rax,%rax,1)\nmovss  (%rdx),%xmm0\ncomiss %xmm1,%xmm0\njbe    1498 <func0+0x58>\nmovslq 0x0(%rbp),%rcx\nlea    0x1(%rcx),%esi\nmovss  %xmm0,(%rax,%rcx,4)\nmov    %esi,0x0(%rbp)\nadd    $0x4,%rdx\ncmp    %rdi,%rdx\njne    1480 <func0+0x40>\npop    %rbx\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\n"
    },
    {
        "task_id": 31,
        "type": "O0",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\ncmpq   $0x1,-0x18(%rbp)\njg     1163 <func0+0x1a>\nmov    $0x0,%eax\njmp    119e <func0+0x55>\nmovq   $0x2,-0x8(%rbp)\n00\njmp    118b <func0+0x42>\nmov    -0x18(%rbp),%rax\ncqto\nidivq  -0x8(%rbp)\nmov    %rdx,%rax\ntest   %rax,%rax\njne    1186 <func0+0x3d>\nmov    $0x0,%eax\njmp    119e <func0+0x55>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nimul   %rax,%rax\ncmp    %rax,-0x18(%rbp)\njge    116d <func0+0x24>\nmov    $0x1,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 31,
        "type": "O1",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%eax\ncmp    $0x1,%rdi\njle    118b <func0+0x42>\ncmp    $0x3,%rdi\njle    1192 <func0+0x49>\ntest   $0x1,%dil\nje     1198 <func0+0x4f>\nmov    $0x2,%ecx\nadd    $0x1,%rcx\nmov    %rcx,%rax\nimul   %rcx,%rax\ncmp    %rdi,%rax\njg     118c <func0+0x43>\nmov    %rdi,%rax\ncqto\nidiv   %rcx\ntest   %rdx,%rdx\njne    1169 <func0+0x20>\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\nmov    $0x1,%eax\nret\nmov    $0x0,%eax\nret\n"
    },
    {
        "task_id": 31,
        "type": "O2",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ncmp    $0x1,%rdi\njle    141a <func0+0x4a>\ncmp    $0x3,%rdi\njle    140d <func0+0x3d>\ntest   $0x1,%dil\nje     141a <func0+0x4a>\nmov    $0x2,%ecx\njmp    13fd <func0+0x2d>\nnop\nmov    %rdi,%rax\ncqto\nidiv   %rcx\ntest   %rdx,%rdx\nje     1418 <func0+0x48>\nadd    $0x1,%rcx\nmov    %rcx,%rax\nimul   %rcx,%rax\ncmp    %rax,%rdi\njge    13f0 <func0+0x20>\nmov    $0x1,%eax\nret\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 31,
        "type": "O3",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ncmp    $0x1,%rdi\njle    141a <func0+0x4a>\ncmp    $0x3,%rdi\njle    140d <func0+0x3d>\ntest   $0x1,%dil\nje     141a <func0+0x4a>\nmov    $0x2,%ecx\njmp    13fd <func0+0x2d>\nnop\nmov    %rdi,%rax\ncqto\nidiv   %rcx\ntest   %rdx,%rdx\nje     1418 <func0+0x48>\nadd    $0x1,%rcx\nmov    %rcx,%rax\nimul   %rcx,%rax\ncmp    %rax,%rdi\njge    13f0 <func0+0x20>\nmov    $0x1,%eax\nret\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 32,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovl   $0x1,-0x30(%rbp)\njmp    1217 <func0+0x8e>\nmovsd  0xeb1(%rip),%xmm0\n00\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    11e0 <func0+0x57>\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     11cd <func0+0x44>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  -0x18(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     11b7 <func0+0x2e>\njmp    1345 <func0+0x1bc>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovl   $0x1,-0x30(%rbp)\njmp    12a3 <func0+0x11a>\nmovsd  0xe32(%rip),%xmm0\n00\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x1,-0x28(%rbp)\njmp    125f <func0+0xd6>\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     124c <func0+0xc3>\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x30(%rbp),%xmm1\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  -0x10(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     1236 <func0+0xad>\nmovsd  -0x18(%rbp),%xmm0\nmovapd %xmm0,%xmm1\ndivsd  -0x10(%rbp),%xmm1\nmovsd  -0x20(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovl   $0x1,-0x30(%rbp)\njmp    133d <func0+0x1b4>\nmovsd  0xd8b(%rip),%xmm0\n00\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    1306 <func0+0x17d>\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     12f3 <func0+0x16a>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  -0x18(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     12dd <func0+0x154>\nmovsd  -0x18(%rbp),%xmm0\nmovq   0xd2e(%rip),%xmm1\n00\nandpd  %xmm1,%xmm0\ncomisd 0xd32(%rip),%xmm0\n00\nja     1224 <func0+0x9b>\nmovsd  -0x20(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 32,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r8\nmov    %esi,%r9d\nmovsd  (%rdi),%xmm5\ncmp    $0x1,%esi\njle    11e0 <func0+0x57>\nmov    %esi,%esi\nmovapd %xmm5,%xmm3\nmov    $0x1,%ecx\npxor   %xmm1,%xmm1\njmp    11cb <func0+0x42>\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    11ad <func0+0x24>\nmulsd  (%r8,%rcx,8),%xmm0\naddsd  %xmm0,%xmm3\nadd    $0x1,%rcx\ncmp    %rsi,%rcx\nje     11e4 <func0+0x5b>\nmov    %ecx,%edx\nmov    $0x0,%eax\nmovsd  0xe86(%rip),%xmm0\n00\ntest   %ecx,%ecx\njg     11ad <func0+0x24>\njmp    11b8 <func0+0x2f>\nmovapd %xmm5,%xmm3\nmovapd %xmm3,%xmm0\nandpd  0xe90(%rip),%xmm0\n00\npxor   %xmm1,%xmm1\ncomisd 0xe6c(%rip),%xmm0\n00\njbe    1219 <func0+0x90>\nmov    $0x1,%r10d\nmovq   0xe74(%rip),%xmm7\n00\nmovsd  0xe54(%rip),%xmm6\n00\njmp    12c6 <func0+0x13d>\npxor   %xmm1,%xmm1\nmovapd %xmm1,%xmm0\nret\nmov    $0x1,%eax\nmovsd  0xe31(%rip),%xmm0\n00\nmulsd  %xmm1,%xmm0\nmov    %eax,%edx\nadd    $0x1,%eax\ncmp    %edx,%ecx\njne    122f <func0+0xa6>\nadd    $0x8,%rdi\nmov    %esi,%ecx\npxor   %xmm2,%xmm2\ncvtsi2sd %ecx,%xmm2\nmulsd  (%rdi),%xmm2\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm4\nlea    0x1(%rcx),%esi\ncmp    %esi,%r9d\nje     12e4 <func0+0x15b>\ncmp    $0x1,%esi\njg     1222 <func0+0x99>\nmovsd  0xdf1(%rip),%xmm0\n00\njmp    123c <func0+0xb3>\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %eax,%edx\njne    1271 <func0+0xe8>\nmulsd  (%r8,%rcx,8),%xmm0\naddsd  %xmm0,%xmm3\nadd    $0x1,%rcx\ncmp    %rcx,%rsi\nje     12b4 <func0+0x12b>\nmov    %ecx,%edx\nmov    $0x0,%eax\nmovsd  0xdc2(%rip),%xmm0\n00\ntest   %ecx,%ecx\njg     1271 <func0+0xe8>\njmp    127c <func0+0xf3>\ndivsd  0xddc(%rip),%xmm3\n00\nsubsd  %xmm3,%xmm1\nmovapd %xmm5,%xmm3\nmovapd %xmm3,%xmm0\nandpd  %xmm7,%xmm0\ncomisd %xmm6,%xmm0\njbe    121d <func0+0x94>\ncmp    $0x1,%r9d\njle    12a4 <func0+0x11b>\nlea    0x8(%r8),%rdi\nmov    %r10d,%ecx\npxor   %xmm4,%xmm4\nmovsd  0xd81(%rip),%xmm0\n00\njmp    1242 <func0+0xb9>\ndivsd  %xmm4,%xmm3\nsubsd  %xmm3,%xmm1\nlea    0x1(%rcx),%esi\nmovapd %xmm5,%xmm3\nmov    $0x1,%ecx\njmp    128f <func0+0x106>\n"
    },
    {
        "task_id": 32,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsd  (%rdi),%xmm7\nmov    %rdi,%r8\nmov    %esi,%r9d\ncmp    $0x1,%esi\njle    14b9 <func0+0x179>\nmovslq %esi,%rcx\nmovapd %xmm7,%xmm3\npxor   %xmm6,%xmm6\nmov    $0x1,%edx\nmovsd  0xcf1(%rip),%xmm1\n00\nnop\nxor    %eax,%eax\nmovapd %xmm1,%xmm0\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmulsd  %xmm6,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    1380 <func0+0x40>\nmulsd  (%r8,%rdx,8),%xmm0\nadd    $0x1,%rdx\naddsd  %xmm0,%xmm3\ncmp    %rdx,%rcx\njne    1370 <func0+0x30>\nmovq   0xcd9(%rip),%xmm9\n00 00\nmovapd %xmm3,%xmm0\nmovapd %xmm6,%xmm1\nmovsd  0xcb0(%rip),%xmm8\n00 00\nmovsd  0xca0(%rip),%xmm5\n00\nmovslq %r9d,%r10\nandpd  %xmm9,%xmm0\ncomisd %xmm8,%xmm0\njbe    1492 <func0+0x152>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x1,%r9d\njle    1497 <func0+0x157>\nlea    0x8(%r8),%rdi\nmovapd %xmm6,%xmm4\nmov    $0x1,%ecx\nmovapd %xmm5,%xmm0\nnopl   0x0(%rax,%rax,1)\npxor   %xmm2,%xmm2\nlea    0x1(%rcx),%esi\ncvtsi2sd %ecx,%xmm2\nmulsd  (%rdi),%xmm2\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm4\ncmp    %esi,%r9d\nje     1438 <func0+0xf8>\nmov    $0x1,%eax\nmovapd %xmm5,%xmm0\nnopl   (%rax)\nmulsd  %xmm1,%xmm0\nmov    %eax,%edx\nadd    $0x1,%eax\ncmp    %ecx,%edx\njne    1420 <func0+0xe0>\nadd    $0x8,%rdi\nmov    %esi,%ecx\njmp    13f8 <func0+0xb8>\nnopl   (%rax)\ndivsd  %xmm4,%xmm3\nmov    $0x1,%edx\nsubsd  %xmm3,%xmm1\nmovapd %xmm7,%xmm3\nnopl   0x0(%rax)\nxor    %eax,%eax\nmovapd %xmm5,%xmm0\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    1460 <func0+0x120>\nmulsd  (%r8,%rdx,8),%xmm0\nadd    $0x1,%rdx\naddsd  %xmm0,%xmm3\ncmp    %rdx,%r10\njne    1450 <func0+0x110>\nmovapd %xmm3,%xmm0\nandpd  %xmm9,%xmm0\ncomisd %xmm8,%xmm0\nja     13d8 <func0+0x98>\nmovapd %xmm1,%xmm0\nret\ndivsd  %xmm6,%xmm3\nsubsd  %xmm3,%xmm1\nmovapd %xmm7,%xmm3\nmovapd %xmm3,%xmm0\nandpd  %xmm9,%xmm0\ncomisd %xmm8,%xmm0\nja     13d8 <func0+0x98>\njmp    1492 <func0+0x152>\nmovapd %xmm7,%xmm3\npxor   %xmm6,%xmm6\njmp    139e <func0+0x5e>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\n"
    },
    {
        "task_id": 32,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsd  (%rdi),%xmm10\nmov    %esi,%r9d\ncmp    $0x1,%esi\njle    1579 <func0+0x179>\nmovsd  0xc43(%rip),%xmm5\n00\nmovslq %esi,%r8\nmovapd %xmm10,%xmm3\nmov    $0x1,%edx\npxor   %xmm7,%xmm7\nxchg   %ax,%ax\nxor    %eax,%eax\nmovapd %xmm5,%xmm0\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmulsd  %xmm7,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    1440 <func0+0x40>\nmulsd  (%rdi,%rdx,8),%xmm0\nadd    $0x1,%rdx\naddsd  %xmm0,%xmm3\ncmp    %rdx,%r8\njne    1430 <func0+0x30>\nmovq   0xc1a(%rip),%xmm9\n00 00\nmovapd %xmm3,%xmm0\nmovapd %xmm7,%xmm1\nmovsd  0xbf1(%rip),%xmm8\n00 00\nmovsd  0xbe1(%rip),%xmm6\n00\nmovslq %r9d,%r10\nandpd  %xmm9,%xmm0\ncomisd %xmm8,%xmm0\njbe    1551 <func0+0x151>\nnopw   0x0(%rax,%rax,1)\ncmp    $0x1,%r9d\njle    1556 <func0+0x156>\nmovsd  0x8(%rdi),%xmm4\nmov    $0x2,%r8d\nmovapd %xmm6,%xmm5\naddsd  %xmm7,%xmm4\ncmp    $0x2,%r9d\nje     1501 <func0+0x101>\nmov    %r10,%r8\nmov    $0x2,%ecx\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%esi\nmov    %ecx,%edx\nmovapd %xmm6,%xmm0\nmov    $0x1,%eax\nnopl   (%rax)\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    14d8 <func0+0xd8>\npxor   %xmm2,%xmm2\ncvtsi2sd %esi,%xmm2\nmulsd  (%rdi,%rcx,8),%xmm2\nadd    $0x1,%rcx\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm4\ncmp    %rcx,%r10\njne    14c8 <func0+0xc8>\ndivsd  %xmm4,%xmm3\nmov    $0x1,%edx\nsubsd  %xmm3,%xmm1\nmovapd %xmm10,%xmm3\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nmovapd %xmm5,%xmm0\nxchg   %ax,%ax\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    1520 <func0+0x120>\nmulsd  (%rdi,%rdx,8),%xmm0\nadd    $0x1,%rdx\naddsd  %xmm0,%xmm3\ncmp    %r8,%rdx\njne    1518 <func0+0x118>\nmovapd %xmm3,%xmm0\nandpd  %xmm9,%xmm0\ncomisd %xmm8,%xmm0\nja     1498 <func0+0x98>\nmovapd %xmm1,%xmm0\nret\ndivsd  %xmm7,%xmm3\nsubsd  %xmm3,%xmm1\nmovapd %xmm10,%xmm3\nmovapd %xmm3,%xmm0\nandpd  %xmm9,%xmm0\ncomisd %xmm8,%xmm0\nja     1498 <func0+0x98>\njmp    1551 <func0+0x151>\nmovapd %xmm10,%xmm3\npxor   %xmm7,%xmm7\njmp    145d <func0+0x5d>\nnopw   0x0(%rax,%rax,1)\n00 00\n"
    },
    {
        "task_id": 33,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nadd    $0x1,%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    1261 <func0+0x98>\nmov    -0x1c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncmp    %eax,-0x2c(%rbp)\njg     1226 <func0+0x5d>\nmovl   $0x0,-0x1c(%rbp)\njmp    1339 <func0+0x170>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    12c6 <func0+0xfd>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    12c2 <func0+0xf9>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x10(%rbp)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     128c <func0+0xc3>\nmov    -0x10(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\nje     1335 <func0+0x16c>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x1c(%rbp)\njl     127b <func0+0xb2>\nmovl   $0x0,-0x1c(%rbp)\njmp    13f1 <func0+0x228>\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\njne    13c0 <func0+0x1f7>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x38(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\njmp    13ed <func0+0x224>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x38(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1354 <func0+0x18b>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1090 <free@plt>\nnop\nleave\nret\n"
    },
    {
        "task_id": 33,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %esi,%ebx\nmov    %rdx,%r12\nmovslq %esi,%rdi\nimul   $0x55555556,%rdi,%rdi\nshr    $0x20,%rdi\nmov    %esi,%eax\nsar    $0x1f,%eax\nsub    %eax,%edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,%rdi\ntest   %ebx,%ebx\njle    12e4 <func0+0x11b>\nmov    $0x0,%edx\nmov    $0x0,%eax\nmov    %eax,%r10d\nmov    0x0(%rbp,%rdx,4),%ecx\nmov    %ecx,(%rdi,%rax,4)\nadd    $0x1,%rax\nadd    $0x3,%rdx\ncmp    %edx,%ebx\njg     1218 <func0+0x4f>\ntest   %r10d,%r10d\njle    12f4 <func0+0x12b>\nlea    -0x1(%r10),%r13d\nmov    %r10d,%r9d\nmov    $0x0,%esi\njmp    1252 <func0+0x89>\nadd    $0x1,%rsi\ncmp    %r9,%rsi\nje     12f4 <func0+0x12b>\nmov    %esi,%edx\nmov    %esi,%r11d\ncmp    %r10d,%esi\njge    1245 <func0+0x7c>\nlea    0x1(%rsi),%rax\nmov    %r13d,%ecx\nsub    %esi,%ecx\nlea    0x2(%rsi,%rcx,1),%r8\nmovslq %edx,%rcx\nmov    (%rdi,%rcx,4),%ecx\ncmp    %ecx,(%rdi,%rax,4)\ncmovl  %eax,%edx\nadd    $0x1,%rax\ncmp    %r8,%rax\njne    126a <func0+0xa1>\ncmp    %r11d,%edx\nje     1245 <func0+0x7c>\nmov    (%rdi,%rsi,4),%ecx\nmovslq %edx,%rdx\nlea    (%rdi,%rdx,4),%rax\nmov    (%rax),%edx\nmov    %edx,(%rdi,%rsi,4)\nmov    %ecx,(%rax)\njmp    1245 <func0+0x7c>\nmov    0x0(%rbp,%rdx,4),%eax\nmov    %eax,(%r12,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rbx\nje     12e4 <func0+0x11b>\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nlea    (%rax,%rax,2),%eax\ncmp    %edx,%eax\njne    1297 <func0+0xce>\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\ncltq\nmov    (%rdi,%rax,4),%eax\nmov    %eax,(%r12,%rdx,4)\njmp    129f <func0+0xd6>\ncall   1090 <free@plt>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    %ebx,%ebx\nmov    $0x0,%edx\njmp    12a8 <func0+0xdf>\n"
    },
    {
        "task_id": 33,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nmovslq %esi,%r12\npush   %rbp\nmov    %r12d,%eax\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nimul   $0x55555556,%r12,%rdi\nsar    $0x1f,%eax\nshr    $0x20,%rdi\nsub    %eax,%edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,%rdi\ntest   %r12d,%r12d\njle    1780 <func0+0x110>\nmov    %r12,%r13\nxor    %edx,%edx\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx,%rdx,4),%ecx\nmov    %rax,%r9\nadd    $0x3,%rdx\nmov    %eax,%r11d\nmov    %ecx,(%rdi,%rax,4)\nlea    0x1(%r9),%rax\ncmp    %edx,%r13d\njg     16c0 <func0+0x50>\ntest   %r11d,%r11d\nje     173b <func0+0xcb>\nlea    -0x1(%r11),%r13d\nxor    %esi,%esi\nnopl   0x0(%rax)\nmov    %esi,%edx\nmov    %esi,%r14d\nlea    0x1(%rsi),%r10\ncmp    %r11d,%esi\njge    1733 <func0+0xc3>\nmov    %r13d,%ecx\nmov    %r10,%rax\nsub    %esi,%ecx\nlea    0x2(%rsi,%rcx,1),%r8\nnopl   0x0(%rax,%rax,1)\nmovslq %edx,%rcx\nmov    (%rdi,%rcx,4),%ecx\ncmp    %ecx,(%rdi,%rax,4)\ncmovl  %eax,%edx\nadd    $0x1,%rax\ncmp    %rax,%r8\njne    1708 <func0+0x98>\ncmp    %edx,%r14d\nje     1733 <func0+0xc3>\nmovslq %edx,%rdx\nmov    (%rdi,%rsi,4),%ecx\nlea    (%rdi,%rdx,4),%rax\nmov    (%rax),%edx\nmov    %edx,(%rdi,%rsi,4)\nmov    %ecx,(%rax)\nmov    %r10,%rsi\ncmp    %r9,%r10\njne    16e8 <func0+0x78>\nxor    %eax,%eax\nmov    $0xaaaaaaab,%ecx\njmp    1762 <func0+0xf2>\nnopl   0x0(%rax)\nmov    %eax,%edx\nimul   %rcx,%rdx\nshr    $0x21,%rdx\nmov    (%rdi,%rdx,4),%edx\nmov    %edx,0x0(%rbp,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%r12\nje     1780 <func0+0x110>\nimul   $0xaaaaaaab,%eax,%edx\ncmp    $0x55555555,%edx\njbe    1748 <func0+0xd8>\nmov    (%rbx,%rax,4),%edx\nmov    %edx,0x0(%rbp,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%r12\njne    1762 <func0+0xf2>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmp    1090 <free@plt>\nnopl   (%rax)\n"
    },
    {
        "task_id": 33,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmovslq %esi,%r13\npush   %r12\nmov    %r13d,%eax\nmov    %rdx,%r12\npush   %rbp\nmov    %rdi,%rbp\nimul   $0x55555556,%r13,%rdi\nsar    $0x1f,%eax\npush   %rbx\nshr    $0x20,%rdi\nsub    %eax,%edi\nsub    $0x8,%rsp\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,%r10\ntest   %r13d,%r13d\njle    1799 <func0+0x1d9>\nlea    -0x1(%r13),%esi\nmov    $0xaaaaaaab,%edx\nmov    %r13,%rbx\nmov    %rsi,%rax\nimul   %rdx,%rsi\nshr    $0x21,%rsi\nadd    $0x1,%esi\ncmp    $0x8,%eax\njbe    17d8 <func0+0x218>\nmov    %esi,%ecx\nmovdqa 0xa7a(%rip),%xmm2\n00\nmov    %rbp,%rax\nmov    %r10,%rdx\nshr    $0x2,%ecx\nmovdqa 0xa79(%rip),%xmm4\n00\nshl    $0x4,%rcx\nadd    %r10,%rcx\nxchg   %ax,%ax\nmovd   (%rax),%xmm0\nadd    $0x10,%rdx\nmovdqa %xmm2,%xmm3\nadd    $0x30,%rax\nmovd   -0x18(%rax),%xmm1\nmovd   -0xc(%rax),%xmm5\npaddd  %xmm4,%xmm2\nmovd   -0x24(%rax),%xmm6\npunpckldq %xmm5,%xmm1\npunpckldq %xmm6,%xmm0\npunpcklqdq %xmm1,%xmm0\nmovups %xmm0,-0x10(%rdx)\ncmp    %rcx,%rdx\njne    1650 <func0+0x90>\nmov    %esi,%eax\npshufd $0xff,%xmm3,%xmm3\nand    $0xfffffffc,%eax\nmovd   %xmm3,%r8d\nlea    (%rax,%rax,2),%edx\ncmp    %eax,%esi\nje     17c6 <func0+0x206>\nmovslq %edx,%rdx\nmovslq %eax,%rcx\nmov    0x0(%rbp,%rdx,4),%edx\nlea    0x0(,%rcx,4),%rsi\n00\nmov    %edx,(%r10,%rcx,4)\nlea    0x1(%rax),%ecx\nlea    (%rcx,%rcx,2),%edx\ncmp    %edx,%ebx\njle    17c3 <func0+0x203>\nmovslq %edx,%rdi\nadd    $0x3,%edx\nlea    0x2(%rax),%r8d\nlea    0x0(,%rdi,4),%r9\n00\nmov    0x0(%rbp,%rdi,4),%edi\nmov    %edi,0x4(%r10,%rsi,1)\ncmp    %ebx,%edx\njge    17e1 <func0+0x221>\nmov    0xc(%rbp,%r9,1),%eax\nmov    %eax,0x8(%r10,%rsi,1)\nlea    0x4(%r10),%rbx\nxor    %r11d,%r11d\nnopw   0x0(%rax,%rax,1)\nmov    -0x4(%rbx),%r15d\nmov    %r11d,%r14d\nadd    $0x1,%r11d\nmov    %rbx,%rax\nmov    %r14d,%r9d\nmov    %r11d,%edx\nmov    %r15d,%esi\njmp    1735 <func0+0x175>\nnopl   0x0(%rax)\nmovslq %r9d,%rcx\nadd    $0x4,%rax\nlea    (%r10,%rcx,4),%rdi\nlea    0x1(%rdx),%ecx\ncmp    %r8d,%edx\njge    174f <func0+0x18f>\nmov    %ecx,%edx\nmov    (%rax),%ecx\nmov    %rax,%rdi\ncmp    %esi,%ecx\njge    1720 <func0+0x160>\nmov    %ecx,%esi\nmov    %edx,%r9d\nlea    0x1(%rdx),%ecx\nadd    $0x4,%rax\ncmp    %r8d,%edx\njl     1733 <func0+0x173>\ncmp    %r14d,%r9d\nje     175a <func0+0x19a>\nmov    %esi,-0x4(%rbx)\nmov    %r15d,(%rdi)\nadd    $0x4,%rbx\ncmp    %r8d,%r11d\njne    1700 <func0+0x140>\nxor    %eax,%eax\nmov    $0xaaaaaaab,%ecx\nnopw   0x0(%rax,%rax,1)\nimul   $0xaaaaaaab,%eax,%edx\ncmp    $0x55555555,%edx\nja     17b0 <func0+0x1f0>\nmov    %eax,%edx\nimul   %rcx,%rdx\nshr    $0x21,%rdx\nmov    (%r10,%rdx,4),%edx\nmov    %edx,(%r12,%rax,4)\nadd    $0x1,%rax\ncmp    %r13,%rax\njne    1770 <func0+0x1b0>\nadd    $0x8,%rsp\nmov    %r10,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    1090 <free@plt>\nnop\nmov    0x0(%rbp,%rax,4),%edx\nmov    %edx,(%r12,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%r13\njne    1770 <func0+0x1b0>\njmp    1799 <func0+0x1d9>\nmov    %eax,%r8d\ntest   %r8d,%r8d\njg     16f3 <func0+0x133>\njmp    1763 <func0+0x1a3>\nnopl   0x0(%rax)\nxor    %eax,%eax\nxor    %edx,%edx\njmp    16a2 <func0+0xe2>\nmov    %ecx,%r8d\njmp    16f3 <func0+0x133>\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 34,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    129a <func0+0xd1>\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1255 <func0+0x8c>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    1251 <func0+0x88>\nmovl   $0x1,-0x1c(%rbp)\njmp    125d <func0+0x94>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     1218 <func0+0x4f>\ncmpl   $0x0,-0x1c(%rbp)\njne    1296 <func0+0xcd>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1208 <func0+0x3f>\nmovl   $0x0,-0x14(%rbp)\njmp    1363 <func0+0x19a>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    1353 <func0+0x18a>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    134f <func0+0x186>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     12c0 <func0+0xf7>\naddl   $0x1,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x14(%rbp)\njl     12b2 <func0+0xe9>\nmov    -0x38(%rbp),%rax\nmov    -0x18(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 34,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    %esi,%ebp\nmov    %rdx,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,%r10\ntest   %ebp,%ebp\njle    1268 <func0+0x9f>\nmov    %r12,%rsi\nlea    -0x1(%rbp),%eax\nlea    0x4(%r12,%rax,4),%rdi\nmov    $0x0,%r9d\nlea    0x4(%r10),%r8\njmp    1293 <func0+0xca>\ncmp    $0x1,%r9d\njle    126e <func0+0xa5>\nlea    0x4(%r10),%rsi\nlea    -0x2(%r9),%r11d\nadd    $0x2,%r11\nmov    $0x1,%r8d\nlea    -0x1(%r9),%r12d\nlea    0x8(%r10),%rbp\njmp    124e <func0+0x85>\nadd    $0x4,%rax\ncmp    %rdi,%rax\nje     1241 <func0+0x78>\nmov    -0x4(%rsi),%edx\nmov    (%rax),%ecx\ncmp    %ecx,%edx\njle    1228 <func0+0x5f>\nmov    %ecx,-0x4(%rsi)\nmov    %edx,(%rax)\njmp    1228 <func0+0x5f>\nadd    $0x1,%r8\nadd    $0x4,%rsi\ncmp    %r11,%r8\nje     126e <func0+0xa5>\ncmp    %r8d,%r9d\njle    1241 <func0+0x78>\nmov    %r12d,%eax\nsub    %r8d,%eax\nlea    -0x1(%r8,%rax,1),%rax\nlea    0x0(%rbp,%rax,4),%rdi\nmov    %rsi,%rax\njmp    1231 <func0+0x68>\nmov    $0x0,%r9d\nmov    %r9d,(%rbx)\nmov    %r10,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\nmovslq %r9d,%rax\nmov    (%rsi),%edx\nmov    %edx,(%r10,%rax,4)\nlea    0x1(%r9),%r9d\nadd    $0x4,%rsi\ncmp    %rdi,%rsi\nje     1206 <func0+0x3d>\ntest   %r9d,%r9d\njle    1279 <func0+0xb0>\nmov    (%rsi),%edx\nmov    %r10,%rax\nlea    -0x1(%r9),%ecx\nlea    (%r8,%rcx,4),%rcx\ncmp    (%rax),%edx\nje     1286 <func0+0xbd>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    12a5 <func0+0xdc>\njmp    1279 <func0+0xb0>\n"
    },
    {
        "task_id": 34,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,%r10\ntest   %r12d,%r12d\njle    13fd <func0+0x10d>\nlea    -0x1(%r12),%eax\nmov    %rbx,%rdi\nlea    0x4(%r10),%r8\nxor    %r9d,%r9d\nlea    0x4(%rbx,%rax,4),%rsi\nnopl   (%rax)\nmov    (%rdi),%edx\ntest   %r9d,%r9d\nje     13e0 <func0+0xf0>\nlea    -0x1(%r9),%ecx\nmov    %r10,%rax\nlea    (%r8,%rcx,4),%rcx\njmp    135d <func0+0x6d>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     13e0 <func0+0xf0>\ncmp    %edx,(%rax)\njne    1350 <func0+0x60>\nadd    $0x4,%rdi\ncmp    %rsi,%rdi\njne    1330 <func0+0x40>\ncmp    $0x1,%r9d\nje     13d4 <func0+0xe4>\nlea    -0x2(%r9),%r11d\nlea    0x4(%r10),%rsi\nmov    $0x1,%r8d\nadd    $0x2,%r11\nlea    -0x1(%r9),%r12d\nlea    0x8(%r10),%rbx\nnopw   0x0(%rax,%rax,1)\ncmp    %r8d,%r9d\njle    13c7 <func0+0xd7>\nmov    %r12d,%eax\nsub    %r8d,%eax\nlea    -0x1(%r8,%rax,1),%rax\nlea    (%rbx,%rax,4),%rdi\nmov    %rsi,%rax\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    -0x4(%rsi),%edx\nmov    (%rax),%ecx\ncmp    %ecx,%edx\njle    13be <func0+0xce>\nmov    %ecx,-0x4(%rsi)\nmov    %edx,(%rax)\nadd    $0x4,%rax\ncmp    %rax,%rdi\njne    13b0 <func0+0xc0>\nadd    $0x1,%r8\nadd    $0x4,%rsi\ncmp    %r11,%r8\njne    1390 <func0+0xa0>\npop    %rbx\nmov    %r9d,0x0(%rbp)\nmov    %r10,%rax\npop    %rbp\npop    %r12\nret\nmovslq %r9d,%rax\nadd    $0x4,%rdi\nadd    $0x1,%r9d\nmov    %edx,(%r10,%rax,4)\ncmp    %rsi,%rdi\njne    1330 <func0+0x40>\njmp    136a <func0+0x7a>\nxor    %r9d,%r9d\npop    %rbx\nmov    %r10,%rax\nmov    %r9d,0x0(%rbp)\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 34,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,%r10\ntest   %r12d,%r12d\njle    13cd <func0+0x10d>\nlea    -0x1(%r12),%eax\nmov    %rbx,%rdi\nlea    0x4(%r10),%r8\nxor    %r9d,%r9d\nlea    0x4(%rbx,%rax,4),%rsi\nnopl   (%rax)\nmov    (%rdi),%edx\ntest   %r9d,%r9d\nje     13b0 <func0+0xf0>\nlea    -0x1(%r9),%ecx\nmov    %r10,%rax\nlea    (%r8,%rcx,4),%rcx\njmp    132d <func0+0x6d>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     13b0 <func0+0xf0>\ncmp    %edx,(%rax)\njne    1320 <func0+0x60>\nadd    $0x4,%rdi\ncmp    %rsi,%rdi\njne    1300 <func0+0x40>\ncmp    $0x1,%r9d\nje     13a4 <func0+0xe4>\nlea    -0x2(%r9),%r11d\nlea    0x4(%r10),%rsi\nmov    $0x1,%r8d\nadd    $0x2,%r11\nlea    -0x1(%r9),%r12d\nlea    0x8(%r10),%rbx\nnopw   0x0(%rax,%rax,1)\ncmp    %r8d,%r9d\njle    1397 <func0+0xd7>\nmov    %r12d,%eax\nsub    %r8d,%eax\nlea    -0x1(%r8,%rax,1),%rax\nlea    (%rbx,%rax,4),%rdi\nmov    %rsi,%rax\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    -0x4(%rsi),%edx\nmov    (%rax),%ecx\ncmp    %ecx,%edx\njle    138e <func0+0xce>\nmov    %ecx,-0x4(%rsi)\nmov    %edx,(%rax)\nadd    $0x4,%rax\ncmp    %rax,%rdi\njne    1380 <func0+0xc0>\nadd    $0x1,%r8\nadd    $0x4,%rsi\ncmp    %r8,%r11\njne    1360 <func0+0xa0>\npop    %rbx\nmov    %r9d,0x0(%rbp)\nmov    %r10,%rax\npop    %rbp\npop    %r12\nret\nmovslq %r9d,%rax\nadd    $0x4,%rdi\nadd    $0x1,%r9d\nmov    %edx,(%r10,%rax,4)\ncmp    %rsi,%rdi\njne    1300 <func0+0x40>\njmp    133a <func0+0x7a>\nxor    %r9d,%r9d\npop    %rbx\nmov    %r10,%rax\nmov    %r9d,0x0(%rbp)\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 35,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovss  0xf04(%rip),%xmm0\n00\nmovss  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11cd <func0+0x64>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncomiss -0x8(%rbp),%xmm0\njbe    11c9 <func0+0x60>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     118e <func0+0x25>\nmovss  -0x8(%rbp),%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 35,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1199 <func0+0x30>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdx\nmovss  0xef0(%rip),%xmm0\n00\nmovss  (%rax),%xmm1\nmaxss  %xmm0,%xmm1\nmovaps %xmm1,%xmm0\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    1184 <func0+0x1b>\nret\nmovss  0xed3(%rip),%xmm0\n00\nret\n"
    },
    {
        "task_id": 35,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1298 <func0+0x38>\nlea    -0x1(%rsi),%eax\nmovss  0xdd9(%rip),%xmm0\n00\nlea    0x4(%rdi,%rax,4),%rax\nnopl   0x0(%rax,%rax,1)\n00\nmovss  (%rdi),%xmm1\nadd    $0x4,%rdi\nmaxss  %xmm0,%xmm1\nmovaps %xmm1,%xmm0\ncmp    %rax,%rdi\njne    1280 <func0+0x20>\nret\nnopl   (%rax)\nmovss  0xdac(%rip),%xmm0\n00\nret\n"
    },
    {
        "task_id": 35,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1178 <func0+0x38>\nlea    -0x1(%rsi),%eax\nmovss  0xeb1(%rip),%xmm0\n00\nlea    0x4(%rdi,%rax,4),%rax\nnopl   0x0(%rax,%rax,1)\n00\nmovss  (%rdi),%xmm1\nadd    $0x4,%rdi\nmaxss  %xmm0,%xmm1\nmovaps %xmm1,%xmm0\ncmp    %rax,%rdi\njne    1160 <func0+0x20>\nret\nnopl   (%rax)\nmovss  0xe84(%rip),%xmm0\n00\nret\n"
    },
    {
        "task_id": 36,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    122b <func0+0xe2>\nmov    -0x8(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x2e8ba2e9,%rax,%rax\nshr    $0x20,%rax\nsar    %eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     11c6 <func0+0x7d>\nmov    -0x8(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\njne    1227 <func0+0xde>\nmov    -0x8(%rbp),%eax\nmov    %eax,-0x4(%rbp)\njmp    1221 <func0+0xd8>\nmov    -0x4(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ncmp    $0x7,%edx\njne    1201 <func0+0xb8>\naddl   $0x1,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njg     11ce <func0+0x85>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     1167 <func0+0x1e>\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 36,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    11ff <func0+0xb6>\nmov    $0x0,%ecx\nmov    $0x0,%esi\njmp    11b6 <func0+0x6d>\nmov    %eax,%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%eax\nlea    (%rax,%rax,4),%eax\nadd    %eax,%eax\nmov    %edx,%r8d\nsub    %eax,%r8d\ncmp    $0x7,%r8d\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%esi\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%eax\ncmp    $0x9,%edx\njg     1161 <func0+0x18>\nadd    $0x1,%ecx\ncmp    %ecx,%edi\nje     1204 <func0+0xbb>\nmovslq %ecx,%rax\nimul   $0x2e8ba2e9,%rax,%rax\nsar    $0x21,%rax\nmov    %ecx,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,4),%edx\nlea    (%rax,%rdx,2),%eax\ncmp    %eax,%ecx\nje     11f4 <func0+0xab>\nmovslq %ecx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x22,%rax\nmov    %ecx,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,2),%edx\nlea    (%rax,%rdx,4),%eax\ncmp    %eax,%ecx\njne    11af <func0+0x66>\ntest   %ecx,%ecx\njle    11af <func0+0x66>\nmov    %ecx,%edx\njmp    1163 <func0+0x1a>\nmov    $0x0,%esi\nmov    %esi,%eax\nret\n"
    },
    {
        "task_id": 36,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    135e <func0+0x6e>\nxor    %esi,%esi\nxor    %r8d,%r8d\nmov    $0xcccccccd,%r9d\njmp    131c <func0+0x2c>\nnopl   (%rax)\nimul   $0xc4ec4ec5,%esi,%eax\ncmp    $0x13b13b13,%eax\njbe    1329 <func0+0x39>\nadd    $0x1,%esi\ncmp    %esi,%edi\nje     135a <func0+0x6a>\nimul   $0xba2e8ba3,%esi,%eax\ncmp    $0x1745d174,%eax\nja     1308 <func0+0x18>\nmov    %esi,%edx\ntest   %esi,%esi\nje     1315 <func0+0x25>\nnop\nmov    %edx,%eax\nimul   %r9,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%edx\ncmp    $0x7,%edx\nsete   %dl\nmovzbl %dl,%edx\nadd    %edx,%r8d\nmov    %eax,%edx\ntest   %eax,%eax\njne    1330 <func0+0x40>\nadd    $0x1,%esi\ncmp    %esi,%edi\njne    131c <func0+0x2c>\nmov    %r8d,%eax\nret\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 36,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    16de <func0+0x6e>\nxor    %esi,%esi\nxor    %r8d,%r8d\nmov    $0xcccccccd,%r9d\njmp    169c <func0+0x2c>\nnopl   (%rax)\nimul   $0xc4ec4ec5,%esi,%eax\ncmp    $0x13b13b13,%eax\njbe    16a9 <func0+0x39>\nadd    $0x1,%esi\ncmp    %esi,%edi\nje     16da <func0+0x6a>\nimul   $0xba2e8ba3,%esi,%eax\ncmp    $0x1745d174,%eax\nja     1688 <func0+0x18>\nmov    %esi,%edx\ntest   %esi,%esi\nje     1695 <func0+0x25>\nnop\nmov    %edx,%eax\nimul   %r9,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%edx\ncmp    $0x7,%edx\nsete   %dl\nmovzbl %dl,%edx\nadd    %edx,%r8d\nmov    %eax,%edx\ntest   %eax,%eax\njne    16b0 <func0+0x40>\nadd    $0x1,%esi\ncmp    %esi,%edi\njne    169c <func0+0x2c>\nmov    %r8d,%eax\nret\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 37,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nadd    $0x1,%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    122c <func0+0x83>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rcx),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x2,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11f1 <func0+0x48>\nmovl   $0x0,-0x18(%rbp)\njmp    1311 <func0+0x168>\nmovl   $0x0,-0x14(%rbp)\njmp    12fb <func0+0x152>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    12f7 <func0+0x14e>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nsub    -0x18(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x14(%rbp)\njl     124c <func0+0xa3>\naddl   $0x1,-0x18(%rbp)\nmov    -0x10(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x18(%rbp)\njl     1240 <func0+0x97>\nmovl   $0x0,-0x18(%rbp)\njmp    13a2 <func0+0x1f9>\nmov    -0x18(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    136e <func0+0x1c5>\nmov    -0x18(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\njmp    139e <func0+0x1f5>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1329 <func0+0x180>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <free@plt>\nnop\nleave\nret\n"
    },
    {
        "task_id": 37,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbp\nmov    %esi,%ebx\nmov    %rdx,%r12\nmov    %esi,%edi\nshr    $0x1f,%edi\nadd    %esi,%edi\nsar    %edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%rdi\ntest   %ebx,%ebx\njle    126a <func0+0xc1>\nmov    $0x0,%eax\nmovss  0x0(%rbp,%rax,4),%xmm0\nmovss  %xmm0,(%rdi,%rax,2)\nadd    $0x2,%rax\ncmp    %eax,%ebx\njg     11e1 <func0+0x38>\nlea    -0x1(%rbx),%ecx\nshr    %ecx\nje     1274 <func0+0xcb>\nlea    0x4(%rdi),%rsi\njmp    1228 <func0+0x7f>\nadd    $0x4,%rax\ncmp    %rdx,%rax\nje     1223 <func0+0x7a>\nmovss  (%rax),%xmm0\nmovss  0x4(%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    1201 <func0+0x58>\nmovss  %xmm1,(%rax)\nmovss  %xmm0,0x4(%rax)\njmp    1201 <func0+0x58>\nsub    $0x1,%ecx\nje     1274 <func0+0xcb>\ntest   %ecx,%ecx\njle    1223 <func0+0x7a>\nmov    %rdi,%rax\nlea    -0x1(%rcx),%edx\nlea    (%rsi,%rdx,4),%rdx\njmp    120a <func0+0x61>\nmovss  0x0(%rbp,%rax,4),%xmm0\nmovss  %xmm0,(%r12,%rax,4)\nadd    $0x1,%rax\ncmp    %rbx,%rax\nje     126a <func0+0xc1>\ntest   $0x1,%al\njne    1238 <func0+0x8f>\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %eax,%edx\nsar    %edx\nmovslq %edx,%rdx\nmovss  (%rdi,%rdx,4),%xmm0\nmovss  %xmm0,(%r12,%rax,4)\njmp    1244 <func0+0x9b>\ncall   1080 <free@plt>\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    %ebx,%ebx\nmov    $0x0,%eax\njmp    124d <func0+0xa4>\n"
    },
    {
        "task_id": 37,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmovslq %esi,%rbx\nmov    %ebx,%edi\nshr    $0x1f,%edi\nadd    %ebx,%edi\nsar    %edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%rdi\ntest   %ebx,%ebx\njle    1544 <func0+0xd4>\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovss  0x0(%rbp,%rax,4),%xmm0\nmovss  %xmm0,(%rdi,%rax,2)\nadd    $0x2,%rax\ncmp    %eax,%ebx\njg     14b0 <func0+0x40>\nlea    -0x1(%rbx),%edx\nshr    %edx\nje     1506 <func0+0x96>\nlea    0x4(%rdi),%rsi\nxchg   %ax,%ax\nsub    $0x1,%edx\nmov    %rdi,%rax\nmov    %rdx,%rcx\nlea    (%rsi,%rdx,4),%rdx\nnopl   (%rax)\nmovss  (%rax),%xmm0\nmovss  0x4(%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    14f7 <func0+0x87>\nmovss  %xmm1,(%rax)\nmovss  %xmm0,0x4(%rax)\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    14e0 <func0+0x70>\nmov    %ecx,%edx\ntest   %ecx,%ecx\njne    14d0 <func0+0x60>\nxor    %eax,%eax\njmp    152b <func0+0xbb>\nnopw   0x0(%rax,%rax,1)\nmov    %eax,%edx\nsar    %edx\nmovslq %edx,%rdx\nmovss  (%rdi,%rdx,4),%xmm0\nmovss  %xmm0,(%r12,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rbx\nje     1544 <func0+0xd4>\ntest   $0x1,%al\nje     1510 <func0+0xa0>\nmovss  0x0(%rbp,%rax,4),%xmm0\nmovss  %xmm0,(%r12,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rbx\njne    152b <func0+0xbb>\npop    %rbx\npop    %rbp\npop    %r12\njmp    1080 <free@plt>\nnopl   (%rax)\n"
    },
    {
        "task_id": 37,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %rdi,%rbx\nmov    %esi,%edi\nshr    $0x1f,%edi\nadd    %esi,%edi\nsar    %edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%rdi\ntest   %ebp,%ebp\njle    177f <func0+0x14f>\nlea    -0x1(%rbp),%eax\nmov    %eax,%edx\nshr    %edx\ncmp    $0x7,%eax\njbe    17ad <func0+0x17d>\nshr    $0x3,%eax\nmov    %eax,%esi\nxor    %eax,%eax\nmov    %rsi,%rcx\nshl    $0x4,%rsi\nnopl   0x0(%rax)\nmovups (%rbx,%rax,2),%xmm0\nmovups 0x10(%rbx,%rax,2),%xmm4\nshufps $0x88,%xmm4,%xmm0\nmovups %xmm0,(%rdi,%rax,1)\nadd    $0x10,%rax\ncmp    %rax,%rsi\njne    1688 <func0+0x58>\nlea    0x0(,%rcx,4),%esi\nlea    0x0(,%rcx,8),%eax\nmovslq %eax,%r9\nmovslq %esi,%rcx\nmovss  (%rbx,%r9,4),%xmm0\nlea    0x0(,%rcx,4),%rsi\n00\nlea    0x0(,%r9,4),%r8\n00\nmovss  %xmm0,(%rdi,%rcx,4)\nlea    0x2(%rax),%ecx\ncmp    %ecx,%ebp\njle    170d <func0+0xdd>\nmovss  0x8(%rbx,%r8,1),%xmm0\nlea    0x4(%rax),%ecx\nmovss  %xmm0,0x4(%rdi,%rsi,1)\ncmp    %ecx,%ebp\njle    170d <func0+0xdd>\nmovss  0x10(%rbx,%r8,1),%xmm0\nadd    $0x6,%eax\nmovss  %xmm0,0x8(%rdi,%rsi,1)\ncmp    %eax,%ebp\njle    170d <func0+0xdd>\nmovss  0x18(%rbx,%r8,1),%xmm0\nmovss  %xmm0,0xc(%rdi,%rsi,1)\ntest   %edx,%edx\nje     1751 <func0+0x121>\nlea    0x4(%rdi),%rsi\nnopl   (%rax)\nsub    $0x1,%edx\nmov    %rdi,%rax\nmov    %rdx,%rcx\nlea    (%rsi,%rdx,4),%rdx\nnopl   (%rax)\nmovq   (%rax),%xmm0\nmovaps %xmm0,%xmm3\nmovaps %xmm0,%xmm2\nshufps $0xe5,%xmm3,%xmm3\ncomiss %xmm3,%xmm0\nshufps $0xe1,%xmm2,%xmm2\njbe    1742 <func0+0x112>\nmovlps %xmm2,(%rax)\nadd    $0x4,%rax\ncmp    %rax,%rdx\njne    1728 <func0+0xf8>\nmov    %ecx,%edx\ntest   %ecx,%ecx\njne    1718 <func0+0xe8>\nmovslq %ebp,%rdx\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\ntest   $0x1,%al\njne    1790 <func0+0x160>\nmov    %eax,%ecx\nsar    %ecx\nmovslq %ecx,%rcx\nmovss  (%rdi,%rcx,4),%xmm0\nmovss  %xmm0,(%r12,%rax,4)\nadd    $0x1,%rax\ncmp    %rdx,%rax\njne    1760 <func0+0x130>\npop    %rbx\npop    %rbp\npop    %r12\njmp    1080 <free@plt>\nnopl   0x0(%rax,%rax,1)\n00\nmovss  (%rbx,%rax,4),%xmm0\nmovss  %xmm0,(%r12,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rdx\njne    1760 <func0+0x130>\npop    %rbx\npop    %rbp\npop    %r12\njmp    1080 <free@plt>\nxor    %esi,%esi\nxor    %eax,%eax\njmp    16b0 <func0+0x80>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\n"
    },
    {
        "task_id": 38,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10f0 <strlen@plt>\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nadd    $0x2,%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    1374 <func0+0x12b>\nmov    -0x1c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncmp    %eax,-0x18(%rbp)\njge    12c8 <func0+0x7f>\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshl    $0x2,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\njmp    12cd <func0+0x84>\nmov    $0x3,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rcx\nlea    -0xc(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   10d0 <strncpy@plt>\nmov    -0x10(%rbp),%eax\ncltq\nmovb   $0x0,-0xc(%rbp,%rax,1)\ncmpl   $0x3,-0x10(%rbp)\njne    1348 <func0+0xff>\ncmpl   $0x0,-0x2c(%rbp)\nje     132c <func0+0xe3>\nmovzbl -0xa(%rbp),%eax\nmov    %al,-0x1d(%rbp)\nmovzbl -0xb(%rbp),%eax\nmov    %al,-0xa(%rbp)\nmovzbl -0xc(%rbp),%eax\nmov    %al,-0xb(%rbp)\nmovzbl -0x1d(%rbp),%eax\nmov    %al,-0xc(%rbp)\njmp    1348 <func0+0xff>\nmovzbl -0xc(%rbp),%eax\nmov    %al,-0x1e(%rbp)\nmovzbl -0xb(%rbp),%eax\nmov    %al,-0xc(%rbp)\nmovzbl -0xa(%rbp),%eax\nmov    %al,-0xb(%rbp)\nmovzbl -0x1e(%rbp),%eax\nmov    %al,-0xa(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%ecx\nmov    %ecx,%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rcx\nlea    -0xc(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   10d0 <strncpy@plt>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     12a6 <func0+0x5d>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n00 00\nje     1395 <func0+0x14c>\ncall   1100 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 38,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%rbp\nmov    %esi,0xc(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncall   10f0 <strlen@plt>\nmov    %rax,%r12\nmov    %eax,0x8(%rsp)\nlea    0x2(%rax),%eax\nmovslq %eax,%r15\nimul   $0x55555556,%r15,%r15\nshr    $0x20,%r15\nsar    $0x1f,%eax\nsub    %eax,%r15d\ntest   %r12d,%r12d\njle    137b <func0+0x112>\nmov    $0x0,%ebx\nlea    0x14(%rsp),%r14\njmp    130c <func0+0xa3>\nmovslq %r12d,%r13\nmov    %rbp,(%rsp)\nmov    $0x4,%ecx\nmov    %r13,%rdx\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncall   1150 <__strncpy_chk@plt>\nmovb   $0x0,0x14(%rsp,%r13,1)\ncmp    $0x3,%r12d\nje     1337 <func0+0xce>\nmov    %r13,%rdx\nmov    %r14,%rsi\nmov    (%rsp),%rdi\ncall   10e0 <strncpy@plt>\nadd    $0x3,%rbp\nsub    $0x3,%r12d\ncmp    %r15d,%ebx\njge    137b <func0+0x112>\nadd    $0x1,%ebx\nlea    (%rbx,%rbx,2),%eax\ncmp    %eax,0x8(%rsp)\njl     12ca <func0+0x61>\nmov    %rbp,(%rsp)\nmov    $0x3,%edx\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncall   10e0 <strncpy@plt>\nmovb   $0x0,0x17(%rsp)\nmov    $0x3,%r13d\ncmpl   $0x0,0xc(%rsp)\nje     135b <func0+0xf2>\nmovzbl 0x16(%rsp),%eax\nmovzbl 0x15(%rsp),%edx\nmov    %dl,0x16(%rsp)\nmovzbl 0x14(%rsp),%edx\nmov    %dl,0x15(%rsp)\nmov    %al,0x14(%rsp)\njmp    12f0 <func0+0x87>\nmovzbl 0x14(%rsp),%eax\nmovzbl 0x15(%rsp),%edx\nmov    %dl,0x14(%rsp)\nmovzbl 0x16(%rsp),%edx\nmov    %dl,0x15(%rsp)\nmov    %al,0x16(%rsp)\njmp    12f0 <func0+0x87>\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    139a <func0+0x131>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   1100 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 38,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %esi,0xc(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncall   10f0 <strlen@plt>\nmov    %rax,%rbp\nmov    %eax,%r14d\nadd    $0x2,%eax\nmovslq %eax,%r13\nsar    $0x1f,%eax\nimul   $0x55555556,%r13,%r13\nshr    $0x20,%r13\nsub    %eax,%r13d\ntest   %ebp,%ebp\njle    14d8 <func0+0x108>\nxor    %ebx,%ebx\nlea    0x14(%rsp),%r12\njmp    1487 <func0+0xb7>\nnopl   0x0(%rax)\nmov    $0x3,%edx\nmov    %r15,%rsi\nmov    %r12,%rdi\ncall   10e0 <strncpy@plt>\nmovb   $0x0,0x17(%rsp)\nmov    0xc(%rsp),%esi\nmovzbl 0x15(%rsp),%ecx\nmovzbl 0x16(%rsp),%edx\nmovzbl 0x14(%rsp),%eax\ntest   %esi,%esi\nje     14c0 <func0+0xf0>\nmov    %cl,0x16(%rsp)\nmov    %al,0x15(%rsp)\nmov    %dl,0x14(%rsp)\nmov    $0x3,%edx\nnopl   (%rax)\nmov    %r15,%rdi\nmov    %r12,%rsi\nadd    $0x3,%r15\nsub    $0x3,%ebp\ncall   10e0 <strncpy@plt>\ncmp    %r13d,%ebx\njge    14d8 <func0+0x108>\nadd    $0x1,%ebx\nlea    (%rbx,%rbx,2),%eax\ncmp    %r14d,%eax\njle    1430 <func0+0x60>\nmovslq %ebp,%rdx\nmov    $0x4,%ecx\nmov    %r15,%rsi\nmov    %r12,%rdi\nmov    %rdx,(%rsp)\ncall   1150 <__strncpy_chk@plt>\nmov    (%rsp),%rdx\nmovb   $0x0,0x14(%rsp,%rdx,1)\ncmp    $0x3,%ebp\njne    1470 <func0+0xa0>\njmp    1445 <func0+0x75>\nnopl   0x0(%rax)\nmov    %dl,0x15(%rsp)\nmov    $0x3,%edx\nmov    %cl,0x14(%rsp)\nmov    %al,0x16(%rsp)\njmp    1470 <func0+0xa0>\nnopl   0x0(%rax,%rax,1)\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    14f7 <func0+0x127>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   1100 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 38,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %esi,%r15d\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncall   10f0 <strlen@plt>\nmov    %rax,%rbp\nmov    %eax,%r13d\nadd    $0x2,%eax\nmovslq %eax,%r12\nsar    $0x1f,%eax\nimul   $0x55555556,%r12,%r12\nshr    $0x20,%r12\nsub    %eax,%r12d\ntest   %ebp,%ebp\njle    1688 <func0+0xe8>\ntest   %r15d,%r15d\njne    16b0 <func0+0x110>\nlea    0x14(%rsp),%r14\njmp    164c <func0+0xac>\nnopw   0x0(%rax,%rax,1)\nmov    $0x3,%edx\nmov    %rbx,%rsi\nmov    %r14,%rdi\ncall   10e0 <strncpy@plt>\nmovb   $0x0,0x17(%rsp)\nmovzbl 0x14(%rsp),%eax\nmovzwl 0x15(%rsp),%edx\nmov    %al,0x16(%rsp)\nmov    %dx,0x14(%rsp)\nmov    $0x3,%edx\nmov    %rbx,%rdi\nmov    %r14,%rsi\nadd    $0x3,%rbx\nsub    $0x3,%ebp\ncall   10e0 <strncpy@plt>\ncmp    %r15d,%r12d\njle    1688 <func0+0xe8>\nadd    $0x1,%r15d\nlea    (%r15,%r15,2),%eax\ncmp    %eax,%r13d\njge    1608 <func0+0x68>\nmovslq %ebp,%rdx\nmov    $0x4,%ecx\nmov    %rbx,%rsi\nmov    %r14,%rdi\nmov    %rdx,0x8(%rsp)\ncall   1160 <__strncpy_chk@plt>\nmov    0x8(%rsp),%rdx\nmovb   $0x0,0x14(%rsp,%rdx,1)\ncmp    $0x3,%ebp\njne    1635 <func0+0x95>\njmp    161d <func0+0x7d>\nnopw   0x0(%rax,%rax,1)\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1743 <func0+0x1a3>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nxor    %r15d,%r15d\nlea    0x14(%rsp),%r14\njmp    170d <func0+0x16d>\nnopw   0x0(%rax,%rax,1)\nmov    $0x3,%edx\nmov    %rbx,%rsi\nmov    %r14,%rdi\ncall   10e0 <strncpy@plt>\nmovb   $0x0,0x17(%rsp)\nxor    %eax,%eax\nmov    0x16(%rsp),%al\nmov    0x14(%rsp),%ah\nmovzbl 0x15(%rsp),%edx\nmov    %ax,0x14(%rsp)\nmov    %dl,0x16(%rsp)\nmov    $0x3,%edx\nmov    %rbx,%rdi\nmov    %r14,%rsi\nadd    $0x3,%rbx\nsub    $0x3,%ebp\ncall   10e0 <strncpy@plt>\ncmp    %r12d,%r15d\njge    1688 <func0+0xe8>\nadd    $0x1,%r15d\nlea    (%r15,%r15,2),%eax\ncmp    %eax,%r13d\njge    16c0 <func0+0x120>\nmovslq %ebp,%rdx\nmov    $0x4,%ecx\nmov    %rbx,%rsi\nmov    %r14,%rdi\nmov    %rdx,0x8(%rsp)\ncall   1160 <__strncpy_chk@plt>\nmov    0x8(%rsp),%rdx\nmovb   $0x0,0x14(%rsp,%rdx,1)\ncmp    $0x3,%ebp\njne    16f2 <func0+0x152>\njmp    16d5 <func0+0x135>\ncall   1100 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 39,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmovl   $0x1,-0x18(%rbp)\nmovl   $0x2,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    11cf <func0+0x86>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x2,-0x8(%rbp)\njmp    11ad <func0+0x64>\nmov    -0x18(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    11a9 <func0+0x60>\nmovl   $0x0,-0xc(%rbp)\njmp    11b8 <func0+0x6f>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x18(%rbp)\njge    1193 <func0+0x4a>\ncmpl   $0x0,-0xc(%rbp)\nje     11c2 <func0+0x79>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njne    11cf <func0+0x86>\nmov    -0x18(%rbp),%eax\njmp    11dc <func0+0x93>\nmov    -0x10(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     116b <func0+0x22>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 39,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%r8d\nmov    $0x2,%esi\nmov    $0x1,%eax\njmp    1175 <func0+0x2c>\nmov    $0x0,%esi\nmov    %esi,%eax\nret\nadd    $0x1,%r8d\ncmp    %r8d,%edi\nje     1164 <func0+0x1b>\nmov    %esi,%eax\nmov    %r9d,%esi\ncmp    %edi,%r8d\njge    115f <func0+0x16>\nlea    (%rax,%rsi,1),%r9d\ncmp    $0x3,%esi\njle    1167 <func0+0x1e>\ntest   $0x1,%sil\nje     1170 <func0+0x27>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njg     1167 <func0+0x1e>\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    118e <func0+0x45>\njmp    1170 <func0+0x27>\n"
    },
    {
        "task_id": 39,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    13b8 <func0+0x58>\nxor    %r9d,%r9d\nmov    $0x2,%esi\nmov    $0x1,%eax\nnopl   (%rax)\nmov    %esi,%r8d\nadd    %eax,%esi\ncmp    $0x3,%r8d\njle    13a7 <func0+0x47>\ntest   $0x1,%r8b\nje     13b0 <func0+0x50>\nmov    $0x2,%ecx\njmp    139a <func0+0x3a>\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     13b0 <func0+0x50>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    1390 <func0+0x30>\nadd    $0x1,%r9d\ncmp    %r9d,%edi\nje     13bb <func0+0x5b>\nmov    %r8d,%eax\ncmp    %r9d,%edi\njg     1378 <func0+0x18>\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 39,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    1628 <func0+0x58>\nxor    %r9d,%r9d\nmov    $0x2,%esi\nmov    $0x1,%eax\nnopl   (%rax)\nmov    %esi,%r8d\nadd    %eax,%esi\ncmp    $0x3,%r8d\njle    1617 <func0+0x47>\ntest   $0x1,%r8b\nje     1620 <func0+0x50>\nmov    $0x2,%ecx\njmp    160a <func0+0x3a>\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1620 <func0+0x50>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    1600 <func0+0x30>\nadd    $0x1,%r9d\ncmp    %r9d,%edi\nje     162b <func0+0x5b>\nmov    %r8d,%eax\ncmp    %r9d,%edi\njg     15e8 <func0+0x18>\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 40,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1207 <func0+0x9e>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmp    11fb <func0+0x92>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    11ef <func0+0x86>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %edx,%eax\ntest   %eax,%eax\njne    11eb <func0+0x82>\nmov    $0x1,%eax\njmp    1218 <func0+0xaf>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     119a <func0+0x31>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     118f <func0+0x26>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1184 <func0+0x1b>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 40,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11aa <func0+0x41>\nlea    0x1(%rsi),%r10d\nmov    $0x2,%r9d\ncmp    %r10,%r9\nje     11b0 <func0+0x47>\nmov    %r9,%r8\ncmp    %r8d,%esi\njle    11bc <func0+0x53>\nmov    -0x4(%rdi,%r8,4),%edx\nadd    -0x8(%rdi,%r9,4),%edx\nmov    %r8,%rax\nmov    %edx,%ecx\nadd    (%rdi,%rax,4),%ecx\nje     11b6 <func0+0x4d>\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     1195 <func0+0x2c>\nadd    $0x1,%r8\njmp    1183 <func0+0x1a>\nmov    $0x0,%eax\nret\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\nadd    $0x1,%r9\njmp    117b <func0+0x12>\n"
    },
    {
        "task_id": 40,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    14c7 <func0+0x57>\nlea    0x1(%rsi),%r10d\nmov    $0x2,%r9d\ncmp    %r9,%r10\nje     14c7 <func0+0x57>\nmov    %r9,%r8\ncmp    %r8d,%esi\njle    14c1 <func0+0x51>\nmov    -0x4(%rdi,%r8,4),%edx\nmov    %r8,%rax\nadd    -0x8(%rdi,%r9,4),%edx\njmp    14a8 <func0+0x38>\nxchg   %ax,%ax\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    14b8 <func0+0x48>\nmov    %edx,%ecx\nadd    (%rdi,%rax,4),%ecx\njne    14a0 <func0+0x30>\nmov    $0x1,%eax\nret\nnopl   (%rax)\nadd    $0x1,%r8\ncmp    %r8d,%esi\njg     148f <func0+0x1f>\nadd    $0x1,%r9\njmp    1482 <func0+0x12>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 40,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1477 <func0+0x57>\nlea    0x1(%rsi),%r10d\nmov    $0x2,%r9d\ncmp    %r9,%r10\nje     1477 <func0+0x57>\nmov    %r9,%r8\ncmp    %r8d,%esi\njle    1471 <func0+0x51>\nmov    -0x4(%rdi,%r8,4),%edx\nmov    %r8,%rax\nadd    -0x8(%rdi,%r9,4),%edx\njmp    1458 <func0+0x38>\nxchg   %ax,%ax\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    1468 <func0+0x48>\nmov    %edx,%ecx\nadd    (%rdi,%rax,4),%ecx\njne    1450 <func0+0x30>\nmov    $0x1,%eax\nret\nnopl   (%rax)\nadd    $0x1,%r8\ncmp    %r8d,%esi\njg     143f <func0+0x1f>\nadd    $0x1,%r9\njmp    1432 <func0+0x12>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 41,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 41,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nimul   %edi,%edi\nmov    %edi,%eax\nret\n"
    },
    {
        "task_id": 41,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nimul   %edi,%eax\nret\n"
    },
    {
        "task_id": 41,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nimul   %edi,%eax\nret\n"
    },
    {
        "task_id": 42,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11b4 <func0+0x4b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nadd    $0x1,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1181 <func0+0x18>\nnop\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 42,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1188 <func0+0x1f>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdx\naddl   $0x1,(%rax)\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    117c <func0+0x13>\nret\n"
    },
    {
        "task_id": 42,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    134c <func0+0x1c>\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rax\naddl   $0x1,(%rdi)\nadd    $0x4,%rdi\ncmp    %rax,%rdi\njne    1340 <func0+0x10>\nret\nnopl   (%rax)\n"
    },
    {
        "task_id": 42,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1363 <func0+0x73>\nlea    -0x1(%rsi),%eax\ncmp    $0x2,%eax\njbe    1369 <func0+0x79>\nmov    %esi,%edx\nmovdqa 0xd76(%rip),%xmm1\n00\nmov    %rdi,%rax\nshr    $0x2,%edx\nsub    $0x1,%edx\nshl    $0x4,%rdx\nlea    0x10(%rdi,%rdx,1),%rdx\nnopl   0x0(%rax)\nmovdqu (%rax),%xmm0\nadd    $0x10,%rax\npaddd  %xmm1,%xmm0\nmovups %xmm0,-0x10(%rax)\ncmp    %rdx,%rax\njne    1320 <func0+0x30>\nmov    %esi,%edx\nand    $0xfffffffc,%edx\ntest   $0x3,%sil\nje     1368 <func0+0x78>\nmovslq %edx,%rax\nlea    0x1(%rdx),%ecx\nshl    $0x2,%rax\naddl   $0x1,(%rdi,%rax,1)\ncmp    %ecx,%esi\njle    1363 <func0+0x73>\nadd    $0x2,%edx\naddl   $0x1,0x4(%rdi,%rax,1)\ncmp    %edx,%esi\njle    1363 <func0+0x73>\naddl   $0x1,0x8(%rdi,%rax,1)\nret\nnopl   0x0(%rax)\nret\nxor    %edx,%edx\njmp    1340 <func0+0x50>\nnopl   (%rax)\n"
    },
    {
        "task_id": 43,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    11d5 <func0+0x6c>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    11c9 <func0+0x60>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %edx,%eax\ntest   %eax,%eax\njne    11c5 <func0+0x5c>\nmov    $0x1,%eax\njmp    11e2 <func0+0x79>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     118c <func0+0x23>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1181 <func0+0x18>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 43,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    119c <func0+0x33>\nmov    %esi,%r9d\nmov    $0x1,%r8d\ncmp    %r9,%r8\nje     11a2 <func0+0x39>\nmov    -0x4(%rdi,%r8,4),%edx\nmov    %r8,%rax\nmov    %edx,%ecx\nadd    (%rdi,%rax,4),%ecx\nje     11a8 <func0+0x3f>\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     1187 <func0+0x1e>\nadd    $0x1,%r8\njmp    117a <func0+0x11>\nmov    $0x0,%eax\nret\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 43,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    14f1 <func0+0x41>\nmovslq %esi,%r9\nmov    $0x1,%r8d\ncmp    %r9,%r8\nje     14f1 <func0+0x41>\nmov    -0x4(%rdi,%r8,4),%edx\nmov    %r8,%rax\njmp    14d8 <func0+0x28>\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    14e8 <func0+0x38>\nmov    %edx,%ecx\nadd    (%rdi,%rax,4),%ecx\njne    14d0 <func0+0x20>\nmov    $0x1,%eax\nret\nnopl   (%rax)\nadd    $0x1,%r8\ncmp    %r9,%r8\njne    14c6 <func0+0x16>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 43,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1181 <func0+0x41>\nmovslq %esi,%r9\nmov    $0x1,%r8d\ncmp    %r8,%r9\nje     1181 <func0+0x41>\nmov    -0x4(%rdi,%r8,4),%edx\nmov    %r8,%rax\njmp    1168 <func0+0x28>\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    1178 <func0+0x38>\nmov    %edx,%ecx\nadd    (%rdi,%rax,4),%ecx\njne    1160 <func0+0x20>\nmov    $0x1,%eax\nret\nnopl   (%rax)\nadd    $0x1,%r8\ncmp    %r8,%r9\njne    1156 <func0+0x16>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 44,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %esi,-0x48(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x38(%rbp)\njmp    11fe <func0+0x55>\nmov    -0x44(%rbp),%eax\ncltd\nidivl  -0x48(%rbp)\nmov    %edx,%eax\nlea    0x30(%rax),%ecx\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\nmov    %ecx,%edx\ncltq\nmov    %dl,-0x30(%rbp,%rax,1)\nmov    -0x44(%rbp),%eax\ncltd\nidivl  -0x48(%rbp)\nmov    %eax,-0x44(%rbp)\ncmpl   $0x0,-0x44(%rbp)\njg     11d7 <func0+0x2e>\nmovl   $0x0,-0x34(%rbp)\njmp    1230 <func0+0x87>\nsubl   $0x1,-0x38(%rbp)\nmov    -0x34(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x34(%rbp)\nmovslq %eax,%rdx\nmov    -0x50(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\ncmpl   $0x0,-0x38(%rbp)\njg     120d <func0+0x64>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n00 00\nje     125b <func0+0xb2>\ncall   1080 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 44,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x38,%rsp\nmov    %rdx,%r9\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\ntest   %edi,%edi\njle    1236 <func0+0x8d>\nmov    $0x1,%ecx\nlea    -0x1(%rsp),%r11\nmov    %ecx,%r8d\nmov    %edi,%eax\ncltd\nidiv   %esi\nadd    $0x30,%edx\nmov    %dl,(%r11,%rcx,1)\nmov    %eax,%edi\nadd    $0x1,%rcx\ntest   %eax,%eax\njg     11d2 <func0+0x29>\ntest   %r8d,%r8d\njle    123e <func0+0x95>\nmovslq %r8d,%rcx\nlea    (%rsp,%rcx,1),%rax\nmov    %r9,%rdx\nlea    -0x1(%rsp,%rcx,1),%rsi\nlea    -0x1(%r8),%ecx\nsub    %rcx,%rsi\nmovzbl -0x1(%rax),%ecx\nmov    %cl,(%rdx)\nsub    $0x1,%rax\nadd    $0x1,%rdx\ncmp    %rsi,%rax\njne    1206 <func0+0x5d>\nmovslq %r8d,%r8\nmovb   $0x0,(%r9,%r8,1)\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1246 <func0+0x9d>\nadd    $0x38,%rsp\nret\nmov    $0x0,%r8d\njmp    1219 <func0+0x70>\nmov    $0x0,%r8d\njmp    1219 <func0+0x70>\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 44,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x38,%rsp\nmov    %rdx,%r9\nmov    %fs:0x28,%rdx\n00 00\nmov    %rdx,0x28(%rsp)\nxor    %edx,%edx\ntest   %edi,%edi\njle    14e6 <func0+0x76>\nmov    %edi,%eax\nmov    $0x1,%ecx\nlea    -0x1(%rsp),%r8\nnopl   0x0(%rax,%rax,1)\ncltd\nmov    %ecx,%edi\nidiv   %esi\nadd    $0x30,%edx\nmov    %dl,(%r8,%rcx,1)\nadd    $0x1,%rcx\ntest   %eax,%eax\njg     14a0 <func0+0x30>\nmovslq %edi,%r8\nlea    -0x1(%rdi),%esi\nmov    %r9,%rax\nlea    (%rsp,%r8,1),%rcx\nadd    %r9,%rsi\njmp    14d8 <func0+0x68>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovzbl -0x1(%rcx),%edx\nadd    $0x1,%rax\nmov    %dl,(%rax)\nsub    $0x1,%rcx\ncmp    %rsi,%rax\njne    14d0 <func0+0x60>\nadd    %r8,%r9\nmovb   $0x0,(%r9)\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    14ff <func0+0x8f>\nadd    $0x38,%rsp\nret\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 44,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x38,%rsp\nmov    %rdx,%r9\nmov    %fs:0x28,%rdx\n00 00\nmov    %rdx,0x28(%rsp)\nxor    %edx,%edx\ntest   %edi,%edi\njle    1416 <func0+0x76>\nmov    %edi,%eax\nmov    $0x1,%ecx\nlea    -0x1(%rsp),%r8\nnopl   0x0(%rax,%rax,1)\ncltd\nmov    %ecx,%edi\nidiv   %esi\nadd    $0x30,%edx\nmov    %dl,(%r8,%rcx,1)\nadd    $0x1,%rcx\ntest   %eax,%eax\njg     13d0 <func0+0x30>\nmov    %rsp,%rax\nmovslq %edi,%r8\nlea    -0x1(%rdi),%ecx\nlea    -0x1(%rax,%r8,1),%rdx\nlea    0x1(%r9,%rcx,1),%rsi\nmov    %r9,%rax\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rdx),%ecx\nadd    $0x1,%rax\nsub    $0x1,%rdx\nmov    %cl,-0x1(%rax)\ncmp    %rax,%rsi\njne    1400 <func0+0x60>\nadd    %r8,%r9\nmovb   $0x0,(%r9)\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    142f <func0+0x8f>\nadd    $0x38,%rsp\nret\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 45,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  0xf28(%rip),%xmm0\n00\nmulss  %xmm1,%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 45,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmulss  %xmm1,%xmm0\nmulss  0xecb(%rip),%xmm0\n00\nret\n"
    },
    {
        "task_id": 45,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmulss  %xmm1,%xmm0\nmulss  0xeb4(%rip),%xmm0\n00\nret\n"
    },
    {
        "task_id": 45,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmulss  %xmm1,%xmm0\nmulss  0xeb4(%rip),%xmm0\n00\nret\n"
    },
    {
        "task_id": 46,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x1c0,%rsp\nmov    %edi,-0x1b4(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x1a0(%rbp)\n00 00 00\nmovl   $0x0,-0x19c(%rbp)\n00 00 00\nmovl   $0x2,-0x198(%rbp)\n00 00 00\nmovl   $0x0,-0x194(%rbp)\n00 00 00\nmovl   $0x4,-0x1a4(%rbp)\n00 00 00\njmp    1225 <func0+0xbc>\nmov    -0x1a4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x2,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x3,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x4,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\ncltq\nmov    %edx,-0x1a0(%rbp,%rax,4)\naddl   $0x1,-0x1a4(%rbp)\nmov    -0x1a4(%rbp),%eax\ncmp    -0x1b4(%rbp),%eax\njle    11c1 <func0+0x58>\nmov    -0x1b4(%rbp),%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     1256 <func0+0xed>\ncall   1060 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 46,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmovl   $0x0,(%rsp)\nmovl   $0x0,0x4(%rsp)\n00\nmovl   $0x2,0x8(%rsp)\n00\nmovl   $0x0,0xc(%rsp)\n00\ncmp    $0x3,%edi\njle    11cd <func0+0x64>\nmov    %rsp,%rax\nlea    -0x4(%rdi),%edx\nlea    0x4(%rsp,%rdx,4),%rcx\nmov    0x8(%rax),%edx\nadd    0xc(%rax),%edx\nadd    0x4(%rax),%edx\nadd    (%rax),%edx\nmov    %edx,0x10(%rax)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    11b6 <func0+0x4d>\nmovslq %edi,%rdi\nmov    (%rsp,%rdi,4),%eax\nmov    0x198(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    11ee <func0+0x85>\nadd    $0x1a8,%rsp\nret\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 46,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmovq   $0x0,(%rsp)\n00\nmovq   $0x2,0x8(%rsp)\n00 00\ncmp    $0x3,%edi\njle    12af <func0+0x6f>\nlea    -0x4(%rdi),%eax\nlea    0x4(%rsp),%rdx\nxor    %r8d,%r8d\nxor    %esi,%esi\nlea    0x8(%rsp,%rax,4),%r9\nmov    $0x2,%ecx\nxor    %eax,%eax\njmp    129c <func0+0x5c>\nnop\nmov    0x8(%rdx),%eax\nmov    0x4(%rdx),%ecx\nmov    (%rdx),%esi\nmov    -0x4(%rdx),%r8d\nadd    %ecx,%eax\nadd    $0x4,%rdx\nadd    %esi,%eax\nadd    %r8d,%eax\nmov    %eax,0x8(%rdx)\ncmp    %rdx,%r9\njne    1290 <func0+0x50>\nmovslq %edi,%rdi\nmov    (%rsp,%rdi,4),%eax\nmov    0x198(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    12d0 <func0+0x90>\nadd    $0x1a8,%rsp\nret\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 46,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmovdqa 0xe1d(%rip),%xmm0\n00\nmovslq %edi,%rsi\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmovaps %xmm0,(%rsp)\ncmp    $0x3,%esi\njle    12fa <func0+0xba>\nlea    -0x1(%rsi),%r11d\ncmp    $0x6,%esi\njle    1318 <func0+0xd8>\nmov    %rsp,%r10\nxor    %r8d,%r8d\nmov    $0x2,%edi\nxor    %edx,%edx\nmov    %r10,%rax\nmov    $0x4,%ecx\nlea    (%rdi,%r8,1),%r9d\nadd    $0xc,%rax\nadd    %r9d,%edx\nadd    -0xc(%rax),%edx\nlea    (%rdx,%r8,1),%r9d\nmov    %edx,0x4(%rax)\nadd    %r9d,%edi\nadd    -0x8(%rax),%edi\nlea    (%rdx,%rdi,1),%r9d\nmov    %edi,0x8(%rax)\nadd    %r9d,%r8d\nmov    %ecx,%r9d\nadd    -0x4(%rax),%r8d\nadd    $0x3,%ecx\nadd    $0x4,%r9d\nmov    %r8d,0xc(%rax)\ncmp    %r9d,%r11d\njg     1298 <func0+0x58>\nmovslq %ecx,%rax\nlea    (%r10,%rax,4),%rdx\nnopl   0x0(%rax,%rax,1)\nmov    -0x4(%rdx),%eax\nadd    $0x1,%ecx\nadd    -0x8(%rdx),%eax\nadd    $0x4,%rdx\nadd    -0x10(%rdx),%eax\nadd    -0x14(%rdx),%eax\nmov    %eax,-0x4(%rdx)\ncmp    %ecx,%esi\njge    12e0 <func0+0xa0>\nmov    (%rsp,%rsi,4),%eax\nmov    0x198(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    1322 <func0+0xe2>\nadd    $0x1a8,%rsp\nret\nmov    $0x4,%ecx\nmov    %rsp,%r10\njmp    12d4 <func0+0x94>\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 47,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1245 <func0+0xdc>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmp    1235 <func0+0xcc>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    1231 <func0+0xc8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1192 <func0+0x29>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1184 <func0+0x1b>\nmov    -0x1c(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    1287 <func0+0x11e>\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\njmp    12d9 <func0+0x170>\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\naddss  %xmm0,%xmm1\nmovss  0xe23(%rip),%xmm0\n00\nmulss  %xmm1,%xmm0\npop    %rbp\nret\n"
    },
    {
        "task_id": 47,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r11\nmov    %esi,%edi\ntest   %esi,%esi\njle    11ce <func0+0x65>\nlea    0x4(%r11),%rdx\nlea    -0x1(%rsi),%r10d\nmov    %esi,%r8d\nmov    $0x1,%esi\nlea    0x8(%r11),%r9\njmp    11b6 <func0+0x4d>\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     11ae <func0+0x45>\nmovss  -0x4(%rdx),%xmm0\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    118c <func0+0x23>\nmovss  %xmm1,-0x4(%rdx)\nmovss  %xmm0,(%rax)\njmp    118c <func0+0x23>\nadd    $0x1,%rsi\nadd    $0x4,%rdx\ncmp    %r8,%rsi\nje     11ce <func0+0x65>\nmov    %r10d,%eax\nsub    %esi,%eax\nlea    -0x1(%rsi,%rax,1),%rax\nlea    (%r9,%rax,4),%rcx\nmov    %rdx,%rax\njmp    1195 <func0+0x2c>\nmov    %edi,%edx\nshr    $0x1f,%edx\nlea    (%rdi,%rdx,1),%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nje     1201 <func0+0x98>\nmov    %edi,%eax\nshr    $0x1f,%eax\nadd    %edi,%eax\nsar    %eax\ncltq\nmovss  -0x4(%r11,%rax,4),%xmm0\naddss  (%r11,%rax,4),%xmm0\nmulss  0xee8(%rip),%xmm0\n00\nret\nmov    %edx,%eax\nadd    %edi,%eax\nsar    %eax\ncltq\nmovss  (%r11,%rax,4),%xmm0\nret\n"
    },
    {
        "task_id": 47,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r11\nmov    %esi,%edi\ntest   %esi,%esi\njle    1445 <func0+0x75>\nlea    -0x1(%rsi),%r10d\nmov    %esi,%r8d\nmov    $0x1,%esi\nlea    0x4(%r11),%rdx\nlea    0x8(%r11),%r9\ncmp    %r8,%rsi\nje     1445 <func0+0x75>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    %r10d,%eax\nsub    %esi,%eax\nlea    -0x1(%rsi,%rax,1),%rax\nlea    (%r9,%rax,4),%rcx\nmov    %rdx,%rax\nnopl   0x0(%rax)\nmovss  -0x4(%rdx),%xmm0\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    142f <func0+0x5f>\nmovss  %xmm1,-0x4(%rdx)\nmovss  %xmm0,(%rax)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    1418 <func0+0x48>\nadd    $0x1,%rsi\nadd    $0x4,%rdx\ncmp    %r8,%rsi\njne    1400 <func0+0x30>\nmov    %edi,%edx\nshr    $0x1f,%edx\nlea    (%rdi,%rdx,1),%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nje     1478 <func0+0xa8>\nmov    %edi,%eax\nshr    $0x1f,%eax\nadd    %edi,%eax\nsar    %eax\ncltq\nmovss  -0x4(%r11,%rax,4),%xmm0\naddss  (%r11,%rax,4),%xmm0\nmulss  0xc71(%rip),%xmm0\n00\nret\nsar    %edi\nmovslq %edi,%rax\nmovss  (%r11,%rax,4),%xmm0\nret\n"
    },
    {
        "task_id": 47,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rcx\ncmp    $0x1,%esi\njle    1454 <func0+0x54>\nmov    %rdi,%rdx\nmovslq %esi,%r8\nmov    $0x1,%edi\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %rdi,%rax\nnopl   0x0(%rax,%rax,1)\nmovss  (%rdx),%xmm0\nmovss  (%rcx,%rax,4),%xmm1\ncomiss %xmm1,%xmm0\njbe    143f <func0+0x3f>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,(%rcx,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     1428 <func0+0x28>\nadd    $0x1,%rdi\nadd    $0x4,%rdx\ncmp    %r8,%rdi\njne    1420 <func0+0x20>\nmov    %esi,%edx\nshr    $0x1f,%edx\nlea    (%rsi,%rdx,1),%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nje     1485 <func0+0x85>\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %esi,%eax\nsar    %eax\ncltq\nmovss  -0x4(%rcx,%rax,4),%xmm0\naddss  (%rcx,%rax,4),%xmm0\nmulss  0xc3c(%rip),%xmm0\n00\nret\nsar    %esi\nmovslq %esi,%rax\nmovss  (%rcx,%rax,4),%xmm0\nret\n"
    },
    {
        "task_id": 48,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1060 <strlen@plt>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    11c6 <func0+0x5d>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x8(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     11c2 <func0+0x59>\nmov    $0x0,%eax\njmp    11dc <func0+0x73>\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x8(%rbp)\njl     1191 <func0+0x28>\nmov    $0x1,%eax\nleave\nret\n"
    },
    {
        "task_id": 48,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    $0x1,%eax\njle    11ac <func0+0x43>\ncltq\nlea    -0x1(%rbx,%rax,1),%rdx\nmov    $0x0,%eax\nmovzbl (%rdx),%esi\ncmp    %sil,(%rbx,%rax,1)\njne    11b3 <func0+0x4a>\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%ecx\njg     1190 <func0+0x27>\nmov    $0x1,%eax\njmp    11b8 <func0+0x4f>\nmov    $0x1,%eax\njmp    11b8 <func0+0x4f>\nmov    $0x0,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 48,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    $0x1,%eax\njle    1330 <func0+0x50>\nsub    $0x1,%eax\nxor    %edx,%edx\ncltq\nadd    %rbx,%rax\njmp    131c <func0+0x3c>\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%rdx\nsub    $0x1,%rax\ncmp    %edx,%ecx\njle    1330 <func0+0x50>\nmovzbl (%rax),%esi\ncmp    %sil,(%rbx,%rdx,1)\nje     1310 <func0+0x30>\nxor    %eax,%eax\npop    %rbx\nret\nnopl   0x0(%rax)\nmov    $0x1,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 48,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    $0x1,%eax\njle    1330 <func0+0x50>\nsub    $0x1,%eax\nxor    %edx,%edx\ncltq\nadd    %rbx,%rax\njmp    131c <func0+0x3c>\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%rdx\nsub    $0x1,%rax\ncmp    %edx,%ecx\njle    1330 <func0+0x50>\nmovzbl (%rax),%esi\ncmp    %sil,(%rbx,%rdx,1)\nje     1310 <func0+0x30>\nxor    %eax,%eax\npop    %rbx\nret\nnopl   0x0(%rax)\nmov    $0x1,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 49,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1197 <func0+0x2e>\nmov    -0x8(%rbp),%eax\nadd    %eax,%eax\ncltd\nidivl  -0x18(%rbp)\nmov    %edx,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     1187 <func0+0x1e>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 49,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    118b <func0+0x22>\nmov    $0x0,%ecx\nmov    $0x1,%edx\nlea    (%rdx,%rdx,1),%eax\ncltd\nidiv   %esi\nadd    $0x1,%ecx\ncmp    %ecx,%edi\njne    117b <func0+0x12>\nmov    %edx,%eax\nret\nmov    $0x1,%edx\njmp    1188 <func0+0x1f>\n"
    },
    {
        "task_id": 49,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    1310 <func0+0x20>\nxor    %ecx,%ecx\nmov    $0x1,%edx\nnop\nlea    (%rdx,%rdx,1),%eax\nadd    $0x1,%ecx\ncltd\nidiv   %esi\ncmp    %ecx,%edi\njne    1300 <func0+0x10>\nmov    %edx,%eax\nret\nmov    $0x1,%edx\nmov    %edx,%eax\nret\n"
    },
    {
        "task_id": 49,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    1310 <func0+0x20>\nxor    %ecx,%ecx\nmov    $0x1,%edx\nnop\nlea    (%rdx,%rdx,1),%eax\nadd    $0x1,%ecx\ncltd\nidiv   %esi\ncmp    %ecx,%edi\njne    1300 <func0+0x10>\nmov    %edx,%eax\nret\nmov    $0x1,%edx\nmov    %edx,%eax\nret\n"
    },
    {
        "task_id": 50,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nje     1269 <func0+0x20>\nmov    $0x5,%eax\njmp    126e <func0+0x25>\nmov    $0x15,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10f0 <strlen@plt>\nmov    %rax,-0x8(%rbp)\nmovq   $0x0,-0x10(%rbp)\n00\njmp    12de <func0+0x95>\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nlea    -0x61(%rax),%edx\nmov    -0x18(%rbp),%eax\nadd    %eax,%edx\nmovslq %edx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nsar    $0x3,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nimul   $0x1a,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nadd    $0x61,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x14(%rbp),%edx\nmov    %dl,(%rax)\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njb     128b <func0+0x42>\nnop\nnop\nleave\nret\n"
    },
    {
        "task_id": 50,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\ncmp    $0x1,%esi\nsbb    %ebx,%ebx\nand    $0x10,%ebx\nadd    $0x5,%ebx\ncall   10f0 <strlen@plt>\ntest   %rax,%rax\nje     12a2 <func0+0x59>\nmov    %rbp,%rcx\nlea    0x0(%rbp,%rax,1),%rdi\nmovsbl (%rcx),%eax\nlea    -0x61(%rbx,%rax,1),%edx\nmovslq %edx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x23,%rax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%edx\nadd    $0x61,%edx\nmov    %dl,(%rcx)\nadd    $0x1,%rcx\ncmp    %rdi,%rcx\njne    1273 <func0+0x2a>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 50,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\ncmp    $0x1,%esi\nsbb    %ebp,%ebp\nand    $0x10,%ebp\nadd    $0x5,%ebp\ncall   10f0 <strlen@plt>\ntest   %rax,%rax\nje     1460 <func0+0x60>\nmov    %rbx,%rdi\nadd    %rbx,%rax\nnopl   0x0(%rax,%rax,1)\n00\nmovsbl (%rdi),%edx\nadd    $0x1,%rdi\nlea    -0x61(%rbp,%rdx,1),%ecx\nmovslq %ecx,%rdx\nmov    %ecx,%esi\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%esi\nsar    $0x23,%rdx\nsub    %esi,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%ecx\nadd    $0x61,%ecx\nmov    %cl,-0x1(%rdi)\ncmp    %rdi,%rax\njne    1430 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 50,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\ncmp    $0x1,%esi\nsbb    %ebp,%ebp\nand    $0x10,%ebp\nadd    $0x5,%ebp\ncall   10f0 <strlen@plt>\ntest   %rax,%rax\nje     2118 <func0+0x4c8>\nmov    %rax,%rdx\nlea    -0x1(%rax),%rax\ncmp    $0xe,%rax\njbe    211f <func0+0x4cf>\nmovd   %ebp,%xmm2\nmov    %rdx,%rcx\nmovdqa 0x13aa(%rip),%xmm5\n00\nmovdqa 0x13b2(%rip),%xmm4\n00\npunpcklwd %xmm2,%xmm2\nand    $0xfffffffffffffff0,%rcx\npxor   %xmm6,%xmm6\nmov    %rbx,%rax\nmovdqa 0x13ab(%rip),%xmm3\n00\nmovdqa 0x13b3(%rip),%xmm7\n00\npshufd $0x0,%xmm2,%xmm2\nadd    %rbx,%rcx\nnopl   (%rax)\nmovdqu (%rax),%xmm1\nmovdqa %xmm6,%xmm9\nadd    $0x10,%rax\npcmpgtb %xmm1,%xmm9\nmovdqa %xmm1,%xmm8\nmovdqa %xmm1,%xmm0\npunpcklbw %xmm9,%xmm8\npunpckhbw %xmm9,%xmm0\npaddw  %xmm5,%xmm8\npaddw  %xmm5,%xmm0\npaddw  %xmm2,%xmm8\npaddw  %xmm2,%xmm0\nmovdqa %xmm8,%xmm9\nmovdqa %xmm8,%xmm1\npmulhw %xmm4,%xmm9\npsraw  $0xf,%xmm1\npsraw  $0x3,%xmm9\npsubw  %xmm1,%xmm9\nmovdqa %xmm9,%xmm1\npsllw  $0x1,%xmm1\npaddw  %xmm9,%xmm1\npsllw  $0x2,%xmm1\npaddw  %xmm9,%xmm1\nmovdqa %xmm0,%xmm9\npmulhw %xmm4,%xmm9\npsllw  $0x1,%xmm1\npsubw  %xmm1,%xmm8\nmovdqa %xmm0,%xmm1\npsraw  $0xf,%xmm1\npsraw  $0x3,%xmm9\npsubw  %xmm1,%xmm9\nmovdqa %xmm9,%xmm1\npsllw  $0x1,%xmm1\npaddw  %xmm9,%xmm1\npsllw  $0x2,%xmm1\npaddw  %xmm9,%xmm1\npsllw  $0x1,%xmm1\npsubw  %xmm1,%xmm0\nmovdqa %xmm0,%xmm9\nmovdqa %xmm8,%xmm0\nmovdqa %xmm9,%xmm1\npand   %xmm3,%xmm0\npand   %xmm3,%xmm1\npackuswb %xmm1,%xmm0\npaddb  %xmm7,%xmm0\nmovups %xmm0,-0x10(%rax)\ncmp    %rax,%rcx\njne    1cc8 <func0+0x78>\nmov    %rdx,%rcx\nand    $0xfffffffffffffff0,%rcx\ntest   $0xf,%dl\nje     2118 <func0+0x4c8>\nlea    (%rbx,%rcx,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0x1(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0x2(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0x3(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0x4(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0x5(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0x6(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0x7(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0x8(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0x9(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0xa(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0xb(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0xc(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nlea    0xd(%rcx),%rax\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rax,%rdx\njbe    2118 <func0+0x4c8>\nlea    (%rbx,%rax,1),%rdi\nadd    $0xe,%rcx\nmovsbl (%rdi),%eax\nlea    -0x61(%rbp,%rax,1),%esi\nmovslq %esi,%rax\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%r8d\nsar    $0x23,%rax\nsub    %r8d,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%esi\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rcx,%rdx\njbe    2118 <func0+0x4c8>\nadd    %rcx,%rbx\nmovsbl (%rbx),%eax\nlea    -0x61(%rbp,%rax,1),%edx\nmovslq %edx,%rax\nmov    %edx,%ecx\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%ecx\nsar    $0x23,%rax\nsub    %ecx,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%edx\nadd    $0x61,%edx\nmov    %dl,(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nxor    %ecx,%ecx\njmp    1dbd <func0+0x16d>\n"
    },
    {
        "task_id": 51,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0xe48(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\njmp    1205 <func0+0x5c>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\njne    1200 <func0+0x57>\nmov    -0x10(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x10(%rbp)\nmov    -0x18(%rbp),%rdx\nmovzbl (%rdx),%edx\nmov    %dl,(%rax)\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    11ce <func0+0x25>\nmov    -0x10(%rbp),%rax\nmovb   $0x0,(%rax)\nnop\nleave\nret\n"
    },
    {
        "task_id": 51,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmovzbl (%rdi),%ebp\ntest   %bpl,%bpl\nje     11f6 <func0+0x4d>\nmov    %rdi,%r12\nlea    0xe38(%rip),%r13\njmp    11da <func0+0x31>\nadd    $0x1,%rbx\nmovzbl (%rbx),%ebp\ntest   %bpl,%bpl\nje     11f9 <func0+0x50>\nmovsbl %bpl,%esi\nmov    %r13,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\njne    11ce <func0+0x25>\nmov    %bpl,(%r12)\nlea    0x1(%r12),%r12\njmp    11ce <func0+0x25>\nmov    %rdi,%r12\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 51,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     1478 <func0+0x58>\nmov    %rdi,%rbp\nlea    0xbc2(%rip),%r13\njmp    1454 <func0+0x34>\nnopl   0x0(%rax)\nmovzbl 0x1(%rbp),%ebx\nadd    $0x1,%rbp\ntest   %bl,%bl\nje     1478 <func0+0x58>\nmovsbl %bl,%esi\nmov    %r13,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\njne    1448 <func0+0x28>\nadd    $0x1,%rbp\nmov    %bl,(%r12)\nadd    $0x1,%r12\nmovzbl 0x0(%rbp),%ebx\ntest   %bl,%bl\njne    1454 <func0+0x34>\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 51,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebp\ntest   %bpl,%bpl\nje     1466 <func0+0x46>\nlea    0xbc1(%rip),%r13\nnopl   0x0(%rax,%rax,1)\nmovsbl %bpl,%esi\nmov    %r13,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\nje     1480 <func0+0x60>\nmovzbl 0x1(%rbx),%ebp\nadd    $0x1,%rbx\ntest   %bpl,%bpl\njne    1448 <func0+0x28>\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nadd    $0x1,%rbx\nmov    %bpl,(%r12)\nlea    0x1(%r12),%rax\nmovzbl (%rbx),%ebp\nmov    %rax,%r12\ntest   %bpl,%bpl\njne    1448 <func0+0x28>\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 52,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11aa <func0+0x41>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x20(%rbp)\njg     11a6 <func0+0x3d>\nmov    $0x0,%eax\njmp    11b7 <func0+0x4e>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1184 <func0+0x1b>\nmov    $0x1,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 52,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    118f <func0+0x26>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%ecx\nlea    0x4(%rdi,%rcx,4),%rcx\ncmp    %edx,(%rax)\njge    1195 <func0+0x2c>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    117c <func0+0x13>\nmov    $0x1,%eax\nret\nmov    $0x1,%eax\nret\nmov    $0x0,%eax\nret\n"
    },
    {
        "task_id": 52,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1170 <func0+0x30>\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rax\njmp    1161 <func0+0x21>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rdi\ncmp    %rax,%rdi\nje     1170 <func0+0x30>\ncmp    %edx,(%rdi)\njl     1158 <func0+0x18>\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\n00\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 52,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1170 <func0+0x30>\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rax\njmp    1161 <func0+0x21>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rdi\ncmp    %rax,%rdi\nje     1170 <func0+0x30>\ncmp    %edx,(%rdi)\njl     1158 <func0+0x18>\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\n00\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 53,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 53,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    (%rdi,%rsi,1),%eax\nret\n"
    },
    {
        "task_id": 53,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    (%rdi,%rsi,1),%eax\nret\n"
    },
    {
        "task_id": 53,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    (%rdi,%rsi,1),%eax\nret\n"
    },
    {
        "task_id": 54,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1060 <strlen@plt>\nmov    %eax,-0x8(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1060 <strlen@plt>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    11fd <func0+0x94>\nmovb   $0x0,-0x1a(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    11df <func0+0x76>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    11db <func0+0x72>\nmovb   $0x1,-0x1a(%rbp)\njmp    11e7 <func0+0x7e>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     11b1 <func0+0x48>\nmovzbl -0x1a(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     11f9 <func0+0x90>\nmov    $0x0,%eax\njmp    1274 <func0+0x10b>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njl     11a4 <func0+0x3b>\nmovl   $0x0,-0x10(%rbp)\njmp    1267 <func0+0xfe>\nmovb   $0x0,-0x19(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1249 <func0+0xe0>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    1245 <func0+0xdc>\nmovb   $0x1,-0x19(%rbp)\njmp    1251 <func0+0xe8>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njl     121b <func0+0xb2>\nmovzbl -0x19(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     1263 <func0+0xfa>\nmov    $0x0,%eax\njmp    1274 <func0+0x10b>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     120e <func0+0xa5>\nmov    $0x1,%eax\nleave\nret\n"
    },
    {
        "task_id": 54,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %rsi,%rbx\ncall   1060 <strlen@plt>\nmov    %rax,%r13\nmov    %eax,%r12d\nmov    %rbx,%rdi\ncall   1060 <strlen@plt>\ntest   %r13d,%r13d\njle    11b5 <func0+0x4c>\nmov    %eax,%r8d\nmov    %rbp,%rdi\nlea    -0x1(%r13),%edx\nlea    0x1(%rbp,%rdx,1),%r9\nlea    -0x1(%rax),%edx\nlea    0x1(%rbx,%rdx,1),%rsi\njmp    1215 <func0+0xac>\nmov    $0x0,%eax\njmp    1232 <func0+0xc9>\ntest   %eax,%eax\njg     11c0 <func0+0x57>\nmov    $0x1,%eax\njmp    1232 <func0+0xc9>\nmov    %rbx,%rsi\nlea    -0x1(%rax),%eax\nlea    0x1(%rbx,%rax,1),%rdi\nlea    -0x1(%r13),%eax\nlea    0x1(%rbp,%rax,1),%rcx\njmp    11e6 <func0+0x7d>\nmov    $0x0,%eax\njmp    1232 <func0+0xc9>\nadd    $0x1,%rsi\ncmp    %rdi,%rsi\nje     1205 <func0+0x9c>\ntest   %r12d,%r12d\njle    11d6 <func0+0x6d>\nmovzbl (%rsi),%edx\nmov    %rbp,%rax\ncmp    (%rax),%dl\nje     11dd <func0+0x74>\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    11f1 <func0+0x88>\nmov    $0x0,%eax\njmp    1232 <func0+0xc9>\nmov    $0x1,%eax\njmp    1232 <func0+0xc9>\nadd    $0x1,%rdi\ncmp    %r9,%rdi\nje     11c0 <func0+0x57>\ntest   %r8d,%r8d\njle    11ae <func0+0x45>\nmovzbl (%rdi),%ecx\nmov    %rbx,%rdx\ncmp    (%rdx),%cl\nje     120c <func0+0xa3>\nadd    $0x1,%rdx\ncmp    %rsi,%rdx\njne    1220 <func0+0xb7>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 54,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\ncall   1060 <strlen@plt>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncall   1060 <strlen@plt>\ntest   %r12d,%r12d\njle    13c7 <func0+0xb7>\nlea    -0x1(%r12),%r9d\nmov    %eax,%r8d\nlea    0x1(%rbp),%rsi\nsub    $0x1,%eax\nmov    %r9,%r12\nmov    %rbp,%rdi\nlea    0x1(%rbx,%rax,1),%rcx\nadd    %rsi,%r9\nnopl   0x0(%rax)\ntest   %r8d,%r8d\njle    13c0 <func0+0xb0>\nmovzbl (%rdi),%edx\nmov    %rbx,%rax\njmp    1371 <func0+0x61>\nnopl   (%rax)\nadd    $0x1,%rax\ncmp    %rcx,%rax\nje     13c0 <func0+0xb0>\ncmp    (%rax),%dl\njne    1368 <func0+0x58>\nadd    $0x1,%rdi\ncmp    %r9,%rdi\njne    1358 <func0+0x48>\nxor    %edi,%edi\nlea    (%rsi,%r12,1),%rcx\nnopl   0x0(%rax)\nmovzbl (%rbx,%rdi,1),%edx\nmov    %rbp,%rax\njmp    13a1 <func0+0x91>\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    %rcx,%rax\nje     13c0 <func0+0xb0>\ncmp    (%rax),%dl\njne    1398 <func0+0x88>\nadd    $0x1,%rdi\ncmp    %edi,%r8d\njg     1388 <func0+0x78>\npop    %rbx\nmov    $0x1,%eax\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\n00\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\ntest   %eax,%eax\nsetle  %al\njmp    13c2 <func0+0xb2>\n"
    },
    {
        "task_id": 54,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\ncall   1060 <strlen@plt>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncall   1060 <strlen@plt>\ntest   %r12d,%r12d\njle    13c7 <func0+0xb7>\nlea    -0x1(%r12),%r9d\nmov    %eax,%r8d\nlea    0x1(%rbp),%rsi\nsub    $0x1,%eax\nmov    %r9,%r12\nmov    %rbp,%rdi\nlea    0x1(%rbx,%rax,1),%rcx\nadd    %rsi,%r9\nnopl   0x0(%rax)\ntest   %r8d,%r8d\njle    13c0 <func0+0xb0>\nmovzbl (%rdi),%edx\nmov    %rbx,%rax\njmp    1371 <func0+0x61>\nnopl   (%rax)\nadd    $0x1,%rax\ncmp    %rcx,%rax\nje     13c0 <func0+0xb0>\ncmp    (%rax),%dl\njne    1368 <func0+0x58>\nadd    $0x1,%rdi\ncmp    %r9,%rdi\njne    1358 <func0+0x48>\nxor    %edi,%edi\nlea    (%rsi,%r12,1),%rcx\nnopl   0x0(%rax)\nmovzbl (%rbx,%rdi,1),%edx\nmov    %rbp,%rax\njmp    13a1 <func0+0x91>\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    %rax,%rcx\nje     13c0 <func0+0xb0>\ncmp    (%rax),%dl\njne    1398 <func0+0x88>\nadd    $0x1,%rdi\ncmp    %edi,%r8d\njg     1388 <func0+0x78>\npop    %rbx\nmov    $0x1,%eax\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\n00\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\ntest   %eax,%eax\nsetle  %al\njmp    13c2 <func0+0xb2>\n"
    },
    {
        "task_id": 55,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xfd0,%rsp\nmov    %edi,-0xfc4(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xfb0(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x1f4,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0xfb0(%rbp)\n00 00 00\nmovl   $0x1,-0xfac(%rbp)\n00 00 00\nmovl   $0x2,-0xfb4(%rbp)\n00 00 00\njmp    1200 <func0+0x97>\nmov    -0xfb4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0xfb0(%rbp,%rax,4),%edx\nmov    -0xfb4(%rbp),%eax\nsub    $0x2,%eax\ncltq\nmov    -0xfb0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0xfb4(%rbp),%eax\ncltq\nmov    %edx,-0xfb0(%rbp,%rax,4)\naddl   $0x1,-0xfb4(%rbp)\nmov    -0xfb4(%rbp),%eax\ncmp    -0xfc4(%rbp),%eax\njle    11c4 <func0+0x5b>\nmov    -0xfc4(%rbp),%eax\ncltq\nmov    -0xfb0(%rbp,%rax,4),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     1231 <func0+0xc8>\ncall   1060 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 55,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0xfb8,%rsp\nmov    %edi,%esi\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xfa8(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0x1f4,%ecx\nrep stos %rax,%es:(%rdi)\nmovl   $0x1,0x4(%rsp)\n00\ncmp    $0x1,%esi\njle    11bd <func0+0x54>\nmov    %rsp,%rax\nlea    -0x2(%rsi),%edx\nlea    0x4(%rsp,%rdx,4),%rcx\nmov    (%rax),%edx\nadd    0x4(%rax),%edx\nmov    %edx,0x8(%rax)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    11ac <func0+0x43>\nmovslq %esi,%rsi\nmov    (%rsp,%rsi,4),%eax\nmov    0xfa8(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    11de <func0+0x75>\nadd    $0xfb8,%rsp\nret\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 55,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0xfb8,%rsp\nmovslq %edi,%r8\nmov    $0x1f4,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xfa8(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x1,0x4(%rsp)\n00\ncmp    $0x1,%r8d\njle    12d0 <func0+0x60>\nlea    -0x2(%r8),%edx\nlea    0x8(%rsp),%rax\nlea    (%rax,%rdx,4),%rsi\nmov    $0x1,%edx\njmp    12c7 <func0+0x57>\nxchg   %ax,%ax\nmov    -0x4(%rax),%ecx\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\ncmp    %rsi,%rax\njne    12c0 <func0+0x50>\nmov    (%rsp,%r8,4),%eax\nmov    0xfa8(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    12ef <func0+0x7f>\nadd    $0xfb8,%rsp\nret\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 55,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0xfb8,%rsp\nmovslq %edi,%rsi\nmov    $0x1f4,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xfa8(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x1,0x4(%rsp)\n00\ncmp    $0x1,%esi\njle    130c <func0+0x9c>\ncmp    $0x3,%esi\njle    132a <func0+0xba>\nlea    -0x4(%rsi),%eax\nmov    $0x1,%r8d\nxor    %edi,%edi\nshr    %eax\nlea    0x3(%rax),%r9d\nmov    $0x4,%eax\nadd    %r9,%r9\nadd    %r8d,%edi\nmov    %eax,%ecx\nadd    %edi,%r8d\nmovd   %edi,%xmm0\nmovd   %r8d,%xmm1\npunpckldq %xmm1,%xmm0\nmovq   %xmm0,-0x8(%rdx,%rax,4)\nadd    $0x2,%rax\ncmp    %rax,%r9\njne    12ca <func0+0x5a>\nmovslq %ecx,%rax\nlea    (%rdx,%rax,4),%rax\nnopl   (%rax)\nmov    -0x4(%rax),%edx\nadd    $0x1,%ecx\nadd    -0x8(%rax),%edx\nadd    $0x4,%rax\nmov    %edx,-0x4(%rax)\ncmp    %ecx,%esi\njge    12f8 <func0+0x88>\nmov    (%rsp,%rsi,4),%eax\nmov    0xfa8(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    1331 <func0+0xc1>\nadd    $0xfb8,%rsp\nret\nmov    $0x2,%ecx\njmp    12ee <func0+0x7e>\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 56,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11a6 <func0+0x5d>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x3c,%al\njne    117d <func0+0x34>\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x3e,%al\njne    1195 <func0+0x4c>\nsubl   $0x1,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njns    11a2 <func0+0x59>\nmov    $0x0,%eax\njmp    11cc <func0+0x83>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1165 <func0+0x1c>\ncmpl   $0x0,-0x8(%rbp)\nje     11c7 <func0+0x7e>\nmov    $0x0,%eax\njmp    11cc <func0+0x83>\nmov    $0x1,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 56,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     1182 <func0+0x39>\nadd    $0x1,%rdi\nmov    $0x0,%edx\njmp    1172 <func0+0x29>\nadd    $0x1,%edx\ntest   %edx,%edx\njs     118d <func0+0x44>\nadd    $0x1,%rdi\nmovzbl -0x1(%rdi),%eax\ntest   %al,%al\nje     1187 <func0+0x3e>\ncmp    $0x3c,%al\nje     115f <func0+0x16>\ncmp    $0x3e,%al\nsete   %al\nmovzbl %al,%eax\nsub    %eax,%edx\njmp    1162 <func0+0x19>\nmov    $0x0,%edx\ntest   %edx,%edx\nsete   %al\nret\nmov    $0x0,%eax\nret\n"
    },
    {
        "task_id": 56,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     140b <func0+0x4b>\nadd    $0x1,%rdi\nxor    %edx,%edx\njmp    13ec <func0+0x2c>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x3e,%al\njne    13e1 <func0+0x21>\nsub    $0x1,%edx\njb     1408 <func0+0x48>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\nje     13fe <func0+0x3e>\ncmp    $0x3c,%al\njne    13d8 <func0+0x18>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\nadd    $0x1,%edx\ntest   %al,%al\njne    13ec <func0+0x2c>\ntest   %edx,%edx\nsete   %al\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 56,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     14bb <func0+0x4b>\nadd    $0x1,%rdi\nxor    %edx,%edx\njmp    149c <func0+0x2c>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x3e,%al\njne    1491 <func0+0x21>\nsub    $0x1,%edx\njb     14b8 <func0+0x48>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\nje     14ae <func0+0x3e>\ncmp    $0x3c,%al\njne    1488 <func0+0x18>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\nadd    $0x1,%edx\ntest   %al,%al\njne    149c <func0+0x2c>\ntest   %edx,%edx\nsete   %al\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 57,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x1,-0x4(%rbp)\njmp    120a <func0+0xa1>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    11ca <func0+0x61>\nmovl   $0x1,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncomiss %xmm1,%xmm0\njbe    1206 <func0+0x9d>\nmovl   $0x1,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     118e <func0+0x25>\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\ncmp    $0x2,%eax\njne    122a <func0+0xc1>\nmov    $0x0,%eax\njmp    122f <func0+0xc6>\nmov    $0x1,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 57,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    11b3 <func0+0x4a>\nmov    %rdi,%rax\nlea    -0x2(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdi\nmov    $0x0,%ecx\nmov    $0x0,%edx\nmov    $0x1,%esi\nmovss  0x4(%rax),%xmm0\nmovss  (%rax),%xmm1\nucomiss %xmm1,%xmm0\ncmova  %esi,%edx\nucomiss %xmm0,%xmm1\ncmova  %esi,%ecx\nadd    $0x4,%rax\ncmp    %rdi,%rax\njne    118c <func0+0x23>\nadd    %ecx,%edx\ncmp    $0x2,%edx\nsetne  %al\nret\nmov    $0x0,%ecx\nmov    $0x0,%edx\njmp    11aa <func0+0x41>\n"
    },
    {
        "task_id": 57,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    1470 <func0+0x50>\nlea    -0x2(%rsi),%eax\nxor    %edx,%edx\nmov    $0x1,%ecx\nlea    0x4(%rdi,%rax,4),%rsi\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovss  0x4(%rdi),%xmm0\nmovss  (%rdi),%xmm1\nucomiss %xmm1,%xmm0\ncmova  %ecx,%eax\nucomiss %xmm0,%xmm1\ncmova  %ecx,%edx\nadd    $0x4,%rdi\ncmp    %rdi,%rsi\njne    1440 <func0+0x20>\nadd    %edx,%eax\ncmp    $0x2,%eax\nsetne  %al\nret\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 57,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    1550 <func0+0x270>\nlea    -0x2(%rsi),%eax\nmov    %rdi,%rcx\nlea    -0x1(%rsi),%r8d\ncmp    $0x2,%eax\njbe    1556 <func0+0x276>\nmov    %r8d,%edx\npxor   %xmm1,%xmm1\nmovdqa 0xd61(%rip),%xmm2\n00\nmov    %rdi,%rax\nshr    $0x2,%edx\nmovdqa %xmm1,%xmm4\nsub    $0x1,%edx\nshl    $0x4,%rdx\nlea    0x10(%rdi,%rdx,1),%rdx\nnopl   (%rax)\nmovups 0x4(%rax),%xmm5\nmovups (%rax),%xmm0\nmovdqa %xmm2,%xmm3\nadd    $0x10,%rax\nmovups -0x10(%rax),%xmm6\ncmpltps %xmm5,%xmm0\npand   %xmm0,%xmm3\npandn  %xmm4,%xmm0\nmovdqa %xmm0,%xmm4\nmovaps %xmm5,%xmm0\ncmpltps %xmm6,%xmm0\npor    %xmm3,%xmm4\nmovdqa %xmm2,%xmm3\npand   %xmm0,%xmm3\npandn  %xmm1,%xmm0\nmovdqa %xmm0,%xmm1\npor    %xmm3,%xmm1\ncmp    %rdx,%rax\njne    1328 <func0+0x48>\nmovdqa %xmm1,%xmm2\nmov    %r8d,%r9d\npsrldq $0x8,%xmm2\nand    $0xfffffffc,%r9d\nmovdqa %xmm2,%xmm0\nlea    0x1(%r9),%edi\npcmpgtd %xmm1,%xmm0\npand   %xmm0,%xmm2\npandn  %xmm1,%xmm0\npor    %xmm2,%xmm0\nmovdqa %xmm0,%xmm2\npsrldq $0x4,%xmm2\nmovdqa %xmm2,%xmm1\npcmpgtd %xmm0,%xmm1\npand   %xmm1,%xmm2\npandn  %xmm0,%xmm1\npor    %xmm2,%xmm1\nmovd   %xmm1,%edx\nmovdqa %xmm4,%xmm1\npsrldq $0x8,%xmm1\nmovdqa %xmm1,%xmm0\npcmpgtd %xmm4,%xmm0\npand   %xmm0,%xmm1\npandn  %xmm4,%xmm0\npor    %xmm1,%xmm0\nmovdqa %xmm0,%xmm2\npsrldq $0x4,%xmm2\nmovdqa %xmm2,%xmm1\npcmpgtd %xmm0,%xmm1\npand   %xmm1,%xmm2\npandn  %xmm0,%xmm1\npor    %xmm2,%xmm1\nmovd   %xmm1,%eax\ncmp    %r9d,%r8d\nje     1540 <func0+0x260>\nmovslq %edi,%r10\nlea    0x1(%rdi),%r11d\npush   %rbx\nshl    $0x2,%r10\nlea    (%rcx,%r10,1),%r9\ncmp    %r11d,%r8d\njle    1564 <func0+0x284>\ncmp    %edi,%esi\njle    1564 <func0+0x284>\nmovss  (%r9),%xmm0\nmovss  -0x4(%r9),%xmm1\nlea    0x3(%rdi),%ebx\nlea    0x2(%rdi),%r11d\nmov    $0x1,%r9d\nucomiss %xmm1,%xmm0\ncmova  %r9d,%eax\nucomiss %xmm0,%xmm1\nmovss  0x4(%rcx,%r10,1),%xmm1\ncmova  %r9d,%edx\nucomiss %xmm0,%xmm1\ncmova  %r9d,%eax\nucomiss %xmm1,%xmm0\ncmova  %r9d,%edx\ncmp    %ebx,%r8d\njg     14d0 <func0+0x1f0>\nmovslq %r11d,%rdi\nlea    0x1(%r11),%r9d\nlea    0x0(,%rdi,4),%r8\n00\nmovss  (%rcx,%rdi,4),%xmm0\nmov    $0x1,%edi\nmovss  -0x4(%rcx,%r8,1),%xmm1\nucomiss %xmm1,%xmm0\ncmova  %edi,%eax\nucomiss %xmm0,%xmm1\ncmova  %edi,%edx\ncmp    %r9d,%esi\njle    14c0 <func0+0x1e0>\nmovss  0x4(%rcx,%r8,1),%xmm1\nucomiss %xmm0,%xmm1\ncmova  %edi,%eax\nucomiss %xmm1,%xmm0\ncmova  %edi,%edx\nadd    $0x2,%r11d\ncmp    %r11d,%esi\njle    14c0 <func0+0x1e0>\nmovss  0x8(%rcx,%r8,1),%xmm0\nucomiss %xmm1,%xmm0\ncmova  %edi,%eax\nucomiss %xmm0,%xmm1\ncmova  %edi,%edx\nadd    %edx,%eax\npop    %rbx\ncmp    $0x2,%eax\nsetne  %al\nret\nnopw   0x0(%rax,%rax,1)\nmovss  0x8(%rcx,%r10,1),%xmm0\nlea    0x5(%rdi),%ebx\nlea    0x4(%rdi),%r11d\nucomiss %xmm1,%xmm0\ncmova  %r9d,%eax\nucomiss %xmm0,%xmm1\nmovss  0xc(%rcx,%r10,1),%xmm1\ncmova  %r9d,%edx\nucomiss %xmm0,%xmm1\ncmova  %r9d,%eax\nucomiss %xmm1,%xmm0\ncmova  %r9d,%edx\ncmp    %ebx,%r8d\njle    1460 <func0+0x180>\nmovss  0x10(%rcx,%r10,1),%xmm0\nlea    0x6(%rdi),%r11d\nucomiss %xmm1,%xmm0\ncmova  %r9d,%eax\nucomiss %xmm0,%xmm1\nmovss  0x14(%rcx,%r10,1),%xmm1\ncmova  %r9d,%edx\nucomiss %xmm0,%xmm1\ncmova  %r9d,%eax\nucomiss %xmm1,%xmm0\ncmova  %r9d,%edx\njmp    1460 <func0+0x180>\nnopl   (%rax)\nadd    %edx,%eax\ncmp    $0x2,%eax\nsetne  %al\nret\nnopl   0x0(%rax)\nmov    $0x1,%eax\nret\nmov    $0x1,%edi\nxor    %edx,%edx\nxor    %eax,%eax\njmp    13ff <func0+0x11f>\nmov    %edi,%r11d\njmp    1460 <func0+0x180>\n"
    },
    {
        "task_id": 58,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %ecx,-0x30(%rbp)\nmov    %r8,-0x40(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    12c8 <func0+0x11f>\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    123c <func0+0x93>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    1238 <func0+0x8f>\nmovl   $0x1,-0x10(%rbp)\njmp    1244 <func0+0x9b>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     11ff <func0+0x56>\ncmpl   $0x0,-0x10(%rbp)\njne    12c4 <func0+0x11b>\nmovl   $0x0,-0x18(%rbp)\njmp    12bc <func0+0x113>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    12b8 <func0+0x10f>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x20(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x20(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\njmp    12c4 <func0+0x11b>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     1253 <func0+0xaa>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11ef <func0+0x46>\nmovl   $0x0,-0x1c(%rbp)\njmp    13a1 <func0+0x1f8>\nmovl   $0x0,-0x18(%rbp)\njmp    138b <func0+0x1e2>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    1387 <func0+0x1de>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x18(%rbp)\njl     12ec <func0+0x143>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x20(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x1c(%rbp)\njl     12e0 <func0+0x137>\nmov    -0x40(%rbp),%rax\nmov    -0x20(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 58,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r14\nmov    %esi,%r13d\nmov    %rdx,%r12\nmov    %ecx,%ebp\nmov    %r8,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%r9\ntest   %r13d,%r13d\njle    1282 <func0+0xd9>\nmov    %r14,%rsi\nlea    -0x1(%r13),%eax\nlea    0x4(%r14,%rax,4),%r10\nlea    -0x1(%rbp),%eax\nlea    0x4(%r12,%rax,4),%rdi\nmov    $0x0,%r8d\nlea    0x4(%r9),%r11\njmp    120f <func0+0x66>\nmovslq %r8d,%rax\nmov    %edx,(%r9,%rax,4)\nlea    0x1(%r8),%r8d\nadd    $0x4,%rsi\ncmp    %r10,%rsi\nje     1246 <func0+0x9d>\ntest   %r8d,%r8d\njle    122e <func0+0x85>\nmov    (%rsi),%edx\nmov    %r9,%rax\nlea    -0x1(%r8),%ecx\nlea    (%r11,%rcx,4),%rcx\ncmp    %edx,(%rax)\nje     1206 <func0+0x5d>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    1221 <func0+0x78>\ntest   %ebp,%ebp\njle    1206 <func0+0x5d>\nmov    (%rsi),%edx\nmov    %r12,%rax\ncmp    (%rax),%edx\nje     11fb <func0+0x52>\nadd    $0x4,%rax\ncmp    %rdi,%rax\njne    1237 <func0+0x8e>\njmp    1206 <func0+0x5d>\nlea    -0x1(%r8),%edi\ntest   %edi,%edi\njle    1288 <func0+0xdf>\nlea    0x4(%r9),%r10\njmp    1272 <func0+0xc9>\nadd    $0x4,%rax\ncmp    %rax,%rsi\nje     126d <func0+0xc4>\nmov    (%rax),%edx\nmov    0x4(%rax),%ecx\ncmp    %ecx,%edx\njle    1254 <func0+0xab>\nmov    %ecx,(%rax)\nmov    %edx,0x4(%rax)\njmp    1254 <func0+0xab>\nsub    $0x1,%edi\nje     1288 <func0+0xdf>\ntest   %edi,%edi\njle    126d <func0+0xc4>\nmov    %r9,%rax\nlea    -0x1(%rdi),%edx\nlea    (%r10,%rdx,4),%rsi\njmp    125d <func0+0xb4>\nmov    $0x0,%r8d\nmov    %r8d,(%rbx)\nmov    %r9,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n"
    },
    {
        "task_id": 58,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    %rdi,%r14\nmovslq %esi,%rdi\npush   %r13\nmov    %rdi,%r13\nshl    $0x2,%rdi\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %r8,%rbx\ncall   10b0 <malloc@plt>\nmov    %rax,%r8\ntest   %r13d,%r13d\njle    15aa <func0+0x10a>\nlea    -0x1(%r13),%eax\nmov    %r14,%rsi\nlea    0x4(%r8),%r11\nxor    %r9d,%r9d\nlea    0x4(%r14,%rax,4),%r10\nlea    -0x1(%r12),%eax\nlea    0x4(%rbp,%rax,4),%rdi\ntest   %r9d,%r9d\nje     1570 <func0+0xd0>\nlea    -0x1(%r9),%ecx\nmov    (%rsi),%edx\nmov    %r8,%rax\nlea    (%r11,%rcx,4),%rcx\njmp    1511 <func0+0x71>\nnopl   0x0(%rax)\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     1570 <func0+0xd0>\ncmp    %edx,(%rax)\njne    1508 <func0+0x68>\nadd    $0x4,%rsi\ncmp    %r10,%rsi\njne    14f0 <func0+0x50>\nlea    -0x1(%r9),%edx\ntest   %edx,%edx\njle    155d <func0+0xbd>\nlea    0x4(%r8),%r10\nnopw   0x0(%rax,%rax,1)\nsub    $0x1,%edx\nmov    %r8,%rax\nmov    %rdx,%rdi\nlea    (%r10,%rdx,4),%rsi\nnopl   (%rax)\nmov    (%rax),%edx\nmov    0x4(%rax),%ecx\ncmp    %ecx,%edx\njle    154e <func0+0xae>\nmov    %ecx,(%rax)\nmov    %edx,0x4(%rax)\nadd    $0x4,%rax\ncmp    %rax,%rsi\njne    1540 <func0+0xa0>\nmov    %edi,%edx\ntest   %edi,%edi\njne    1530 <func0+0x90>\nmov    %r9d,(%rbx)\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\ntest   %r12d,%r12d\njle    1515 <func0+0x75>\nmov    (%rsi),%edx\nmov    %rbp,%rax\njmp    1589 <func0+0xe9>\nnopl   0x0(%rax)\nadd    $0x4,%rax\ncmp    %rdi,%rax\nje     1515 <func0+0x75>\ncmp    (%rax),%edx\njne    1580 <func0+0xe0>\nmovslq %r9d,%rax\nadd    $0x4,%rsi\nadd    $0x1,%r9d\nmov    %edx,(%r8,%rax,4)\ncmp    %r10,%rsi\njne    14f0 <func0+0x50>\njmp    151e <func0+0x7e>\nxor    %r9d,%r9d\nmov    %r8,%rax\nmov    %r9d,(%rbx)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n"
    },
    {
        "task_id": 58,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    %rdi,%r14\nmovslq %esi,%rdi\npush   %r13\nmov    %rdi,%r13\nshl    $0x2,%rdi\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %r8,%rbx\ncall   10b0 <malloc@plt>\nmov    %rax,%r8\ntest   %r13d,%r13d\njle    1536 <func0+0x126>\nlea    -0x1(%r13),%eax\nmov    %r14,%rsi\nlea    0x4(%r8),%r11\nxor    %r9d,%r9d\nlea    0x4(%r14,%rax,4),%r10\nlea    -0x1(%r12),%eax\nlea    0x4(%rbp,%rax,4),%rdi\ntest   %r9d,%r9d\nje     14f8 <func0+0xe8>\nlea    -0x1(%r9),%ecx\nmov    (%rsi),%edx\nmov    %r8,%rax\nlea    (%r11,%rcx,4),%rcx\njmp    1489 <func0+0x79>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     14f8 <func0+0xe8>\ncmp    %edx,(%rax)\njne    1480 <func0+0x70>\nadd    $0x4,%rsi\ncmp    %r10,%rsi\njne    1460 <func0+0x50>\nlea    -0x1(%r9),%eax\ntest   %eax,%eax\njle    14e5 <func0+0xd5>\nlea    0x4(%r8),%r10\nnopw   0x0(%rax,%rax,1)\nsub    $0x1,%eax\nmov    %r8,%rdx\nmov    %rax,%rdi\nlea    (%r10,%rax,4),%rsi\nnopl   (%rax)\nmovq   (%rdx),%xmm0\npshufd $0xe5,%xmm0,%xmm2\nmovd   %xmm0,%ecx\nmovd   %xmm2,%eax\npshufd $0xe1,%xmm0,%xmm1\ncmp    %eax,%ecx\njle    14d6 <func0+0xc6>\nmovq   %xmm1,(%rdx)\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\njne    14b8 <func0+0xa8>\nmov    %edi,%eax\ntest   %edi,%edi\njne    14a8 <func0+0x98>\nmov    %r9d,(%rbx)\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\ntest   %r12d,%r12d\njle    148d <func0+0x7d>\nmov    (%rsi),%edx\nmov    %rbp,%rax\njmp    1515 <func0+0x105>\nnopl   0x0(%rax)\nadd    $0x4,%rax\ncmp    %rdi,%rax\nje     148d <func0+0x7d>\ncmp    (%rax),%edx\njne    1508 <func0+0xf8>\nmovslq %r9d,%rax\nadd    $0x4,%rsi\nadd    $0x1,%r9d\nmov    %edx,(%r8,%rax,4)\ncmp    %r10,%rsi\njne    1460 <func0+0x50>\njmp    1496 <func0+0x86>\nxor    %r9d,%r9d\nmov    %r8,%rax\nmov    %r9d,(%rbx)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n"
    },
    {
        "task_id": 59,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    1180 <func0+0x37>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    117c <func0+0x33>\nmov    -0x14(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     115d <func0+0x14>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    1167 <func0+0x1e>\nmov    -0x14(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 59,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x2,%ecx\ncmp    $0x3,%edi\njg     1166 <func0+0x1d>\nmov    %edi,%eax\nret\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     1157 <func0+0xe>\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    115a <func0+0x11>\ncmp    %ecx,%edi\njle    115a <func0+0x11>\nmov    %edi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%esi\nmov    %eax,%edi\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    115a <func0+0x11>\ncmp    %ecx,%esi\njg     1173 <func0+0x2a>\njmp    115a <func0+0x11>\n"
    },
    {
        "task_id": 59,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%r8d\nmov    $0x2,%ecx\ncmp    $0x3,%edi\njle    129a <func0+0x4a>\nnopl   0x0(%rax)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1288 <func0+0x38>\njmp    128d <func0+0x3d>\nnopl   0x0(%rax)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%r8d\nidiv   %ecx\ntest   %edx,%edx\njne    128d <func0+0x3d>\ncmp    %ecx,%r8d\njg     1278 <func0+0x28>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    1268 <func0+0x18>\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 59,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%r8d\nmov    $0x2,%ecx\ncmp    $0x3,%edi\njle    133a <func0+0x4a>\nnopl   0x0(%rax)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1328 <func0+0x38>\njmp    132d <func0+0x3d>\nnopl   0x0(%rax)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%r8d\nidiv   %ecx\ntest   %edx,%edx\njne    132d <func0+0x3d>\ncmp    %ecx,%r8d\njg     1318 <func0+0x28>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    1308 <func0+0x18>\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 60,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\nimul   -0x4(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 60,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    0x1(%rdi),%edx\nimul   %edi,%edx\nmov    %edx,%eax\nshr    $0x1f,%eax\nadd    %edx,%eax\nsar    %eax\nret\n"
    },
    {
        "task_id": 60,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    0x1(%rdi),%edx\nimul   %edi,%edx\nmov    %edx,%eax\nshr    $0x1f,%eax\nadd    %edx,%eax\nsar    %eax\nret\n"
    },
    {
        "task_id": 60,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    0x1(%rdi),%edx\nimul   %edi,%edx\nmov    %edx,%eax\nshr    $0x1f,%eax\nadd    %edx,%eax\nsar    %eax\nret\n"
    },
    {
        "task_id": 61,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    11cb <func0+0x62>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    11a2 <func0+0x39>\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    11ba <func0+0x51>\nsubl   $0x1,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njns    11c7 <func0+0x5e>\nmov    $0x0,%eax\njmp    11e9 <func0+0x80>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1060 <strlen@plt>\ncmp    %rax,%rbx\njb     118a <func0+0x21>\ncmpl   $0x0,-0x18(%rbp)\nsete   %al\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 61,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    %rax,%rdi\nmov    %rbx,%rax\nadd    %rbx,%rdi\nmov    $0x0,%edx\njmp    1191 <func0+0x28>\nadd    $0x1,%edx\nadd    $0x1,%rax\ntest   %edx,%edx\njs     11b2 <func0+0x49>\ncmp    %rdi,%rax\nje     11ab <func0+0x42>\nmovzbl (%rax),%ecx\ncmp    $0x28,%cl\nje     1186 <func0+0x1d>\ncmp    $0x29,%cl\nsete   %cl\nmovzbl %cl,%ecx\nsub    %ecx,%edx\njmp    1189 <func0+0x20>\ntest   %edx,%edx\nsete   %al\npop    %rbx\nret\nmov    $0x0,%eax\njmp    11b0 <func0+0x47>\n"
    },
    {
        "task_id": 61,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    %rbx,%rdi\nxor    %ecx,%ecx\nadd    %rbx,%rax\njmp    140e <func0+0x2e>\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x29,%dl\njne    140a <func0+0x2a>\nsub    $0x1,%ecx\njb     1430 <func0+0x50>\nadd    $0x1,%rdi\ncmp    %rax,%rdi\nje     1420 <func0+0x40>\nmovzbl (%rdi),%edx\ncmp    $0x28,%dl\njne    1400 <func0+0x20>\nadd    $0x1,%ecx\njmp    140a <func0+0x2a>\ntest   %ecx,%ecx\npop    %rbx\nsete   %al\nret\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 61,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    %rbx,%rdi\nxor    %ecx,%ecx\nadd    %rbx,%rax\njmp    140e <func0+0x2e>\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x29,%dl\njne    140a <func0+0x2a>\nsub    $0x1,%ecx\njb     1430 <func0+0x50>\nadd    $0x1,%rdi\ncmp    %rax,%rdi\nje     1420 <func0+0x40>\nmovzbl (%rdi),%edx\ncmp    $0x28,%dl\njne    1400 <func0+0x20>\nadd    $0x1,%ecx\njmp    140a <func0+0x2a>\ntest   %ecx,%ecx\npop    %rbx\nsete   %al\nret\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 62,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x1,-0x4(%rbp)\njmp    11c6 <func0+0x5d>\npxor   %xmm1,%xmm1\ncvtsi2ssl -0x4(%rbp),%xmm1\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1185 <func0+0x1c>\nnop\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 62,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    1195 <func0+0x2c>\nmov    %esi,%esi\nmov    $0x1,%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmulss  (%rdi,%rax,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rsi,%rax\njne    1179 <func0+0x10>\nret\n"
    },
    {
        "task_id": 62,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    1474 <func0+0x34>\nmovslq %esi,%rsi\nmov    $0x1,%eax\nnopl   0x0(%rax)\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmulss  (%rdi,%rax,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    1458 <func0+0x18>\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\n"
    },
    {
        "task_id": 62,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rcx\ncmp    $0x1,%esi\njle    1428 <func0+0xe8>\nlea    0x8(%rdi),%rdi\nmov    %rdx,%rax\nsub    %rdi,%rax\ncmp    $0x8,%rax\njbe    1430 <func0+0xf0>\ncmp    $0x2,%esi\nje     1430 <func0+0xf0>\nlea    -0x2(%rsi),%eax\nlea    -0x1(%rsi),%r8d\ncmp    $0x2,%eax\njbe    145d <func0+0x11d>\nmov    %r8d,%edi\nmovdqa 0xd48(%rip),%xmm1\n00\nmovdqa 0xd50(%rip),%xmm2\n00\nxor    %eax,%eax\nshr    $0x2,%edi\nshl    $0x4,%rdi\nnopl   0x0(%rax)\nmovups 0x4(%rcx,%rax,1),%xmm3\nmovdqa %xmm1,%xmm0\npaddd  %xmm2,%xmm1\ncvtdq2ps %xmm0,%xmm0\nmulps  %xmm3,%xmm0\nmovups %xmm0,(%rdx,%rax,1)\nadd    $0x10,%rax\ncmp    %rax,%rdi\njne    13a0 <func0+0x60>\nmov    %r8d,%r9d\nand    $0xfffffffc,%r9d\nlea    0x1(%r9),%edi\nmov    %edi,%eax\ncmp    %r9d,%r8d\nje     1428 <func0+0xe8>\nsub    %r9d,%esi\nlea    -0x1(%rsi),%r8d\ncmp    $0x2,%esi\nje     140c <func0+0xcc>\nmov    %edi,%esi\nlea    0x1(%rax),%edi\nmovd   %eax,%xmm0\nmovq   (%rcx,%rsi,4),%xmm1\nmovd   %edi,%xmm4\npunpckldq %xmm4,%xmm0\ncvtdq2ps %xmm0,%xmm0\nmulps  %xmm1,%xmm0\nmovlps %xmm0,-0x4(%rdx,%rsi,4)\nmov    %r8d,%esi\nand    $0xfffffffe,%esi\nadd    %esi,%eax\ncmp    %esi,%r8d\nje     1428 <func0+0xe8>\nmovslq %eax,%rsi\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmulss  (%rcx,%rsi,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rsi,4)\nret\nnopl   0x0(%rax,%rax,1)\nret\nnopl   0x0(%rax)\nmovslq %esi,%rsi\nmov    $0x1,%eax\nnopl   0x0(%rax,%rax,1)\n00\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmulss  (%rcx,%rax,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    1440 <func0+0x100>\nret\nmov    $0x1,%eax\nmov    $0x1,%edi\njmp    13de <func0+0x9e>\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 63,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x1c0,%rsp\nmov    %edi,-0x1b4(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x1a0(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x32,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0x19c(%rbp)\n00 00 00\nmovl   $0x1,-0x198(%rbp)\n00 00 00\nmovl   $0x3,-0x1a4(%rbp)\n00 00 00\njmp    1214 <func0+0xab>\nmov    -0x1a4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x2,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x3,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\ncltq\nmov    %edx,-0x1a0(%rbp,%rax,4)\naddl   $0x1,-0x1a4(%rbp)\nmov    -0x1a4(%rbp),%eax\ncmp    -0x1b4(%rbp),%eax\njle    11c4 <func0+0x5b>\nmov    -0x1b4(%rbp),%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     1245 <func0+0xdc>\ncall   1060 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 63,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmov    %edi,%esi\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0x32,%ecx\nrep stos %rax,%es:(%rdi)\nmovl   $0x1,0x8(%rsp)\n00\ncmp    $0x2,%esi\njle    11c0 <func0+0x57>\nmov    %rsp,%rax\nlea    -0x3(%rsi),%edx\nlea    0x4(%rsp,%rdx,4),%rcx\nmov    0x4(%rax),%edx\nadd    0x8(%rax),%edx\nadd    (%rax),%edx\nmov    %edx,0xc(%rax)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    11ac <func0+0x43>\nmovslq %esi,%rsi\nmov    (%rsp,%rsi,4),%eax\nmov    0x198(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    11e1 <func0+0x78>\nadd    $0x1a8,%rsp\nret\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 63,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmovslq %edi,%r8\nmov    $0x32,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x1,0x8(%rsp)\n00\ncmp    $0x2,%r8d\njle    1350 <func0+0x70>\nlea    -0x3(%r8),%edx\nlea    0x4(%rsp),%rax\nxor    %esi,%esi\nlea    0x8(%rsp,%rdx,4),%rdi\nmov    $0x1,%edx\njmp    1340 <func0+0x60>\nnopl   0x0(%rax)\nmov    0x4(%rax),%edx\nmov    (%rax),%ecx\nmov    -0x4(%rax),%esi\nadd    %ecx,%edx\nadd    $0x4,%rax\nadd    %esi,%edx\nmov    %edx,0x4(%rax)\ncmp    %rdi,%rax\njne    1338 <func0+0x58>\nmov    (%rsp,%r8,4),%eax\nmov    0x198(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    136f <func0+0x8f>\nadd    $0x1a8,%rsp\nret\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 63,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmovslq %edi,%rsi\nmov    $0x32,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%r9\nmov    %r9,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x1,0x8(%rsp)\n00\ncmp    $0x2,%esi\njle    1397 <func0+0xb7>\nlea    -0x1(%rsi),%r11d\ncmp    $0x5,%esi\njle    13b5 <func0+0xd5>\nlea    0xc(%rsp),%r8\nmov    $0x1,%edi\nxor    %edx,%edx\nmov    $0x3,%ecx\nlea    (%rdx,%rdi,1),%r10d\nadd    $0xc,%r8\nadd    %r10d,%eax\nlea    (%rax,%rdi,1),%r10d\nmovd   %eax,%xmm0\nadd    %r10d,%edx\nlea    (%rax,%rdx,1),%r10d\nmovd   %edx,%xmm1\nadd    %r10d,%edi\nmov    %ecx,%r10d\npunpckldq %xmm1,%xmm0\nadd    $0x3,%ecx\nadd    $0x4,%r10d\nmovq   %xmm0,-0xc(%r8)\nmov    %edi,-0x4(%r8)\ncmp    %r10d,%r11d\njg     133a <func0+0x5a>\nmovslq %ecx,%rax\nlea    (%r9,%rax,4),%rax\nnop\nmov    -0x4(%rax),%edx\nadd    $0x1,%ecx\nadd    -0x8(%rax),%edx\nadd    $0x4,%rax\nadd    -0x10(%rax),%edx\nmov    %edx,-0x4(%rax)\ncmp    %ecx,%esi\njge    1380 <func0+0xa0>\nmov    (%rsp,%rsi,4),%eax\nmov    0x198(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    13bc <func0+0xdc>\nadd    $0x1a8,%rsp\nret\nmov    $0x3,%ecx\njmp    1378 <func0+0x98>\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 64,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nlea    0xe64(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1070 <strlen@plt>\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    11f1 <func0+0x68>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1080 <strchr@plt>\ntest   %rax,%rax\nje     11ed <func0+0x64>\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     11c3 <func0+0x3a>\ncmpl   $0x0,-0xc(%rbp)\njle    1231 <func0+0xa8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x79,%al\nje     122d <func0+0xa4>\nmov    -0xc(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x59,%al\njne    1231 <func0+0xa8>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nleave\nret\n"
    },
    {
        "task_id": 64,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r15\ncall   1070 <strlen@plt>\ntest   %eax,%eax\njle    1203 <func0+0x7a>\nmov    %rax,%r14\nmov    %r15,%rbx\nlea    -0x1(%rax),%eax\nlea    0x1(%r15,%rax,1),%r13\nmov    $0x0,%ebp\nlea    0xe43(%rip),%r12\nmovsbl (%rbx),%esi\nmov    %r12,%rdi\ncall   1080 <strchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x1,%rbx\ncmp    %r13,%rbx\njne    11c1 <func0+0x38>\nmovslq %r14d,%r14\nmovzbl -0x1(%r15,%r14,1),%eax\nand    $0xffffffdf,%eax\ncmp    $0x59,%al\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebp\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x0,%ebp\njmp    11f2 <func0+0x69>\n"
    },
    {
        "task_id": 64,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\ntest   %eax,%eax\njle    1388 <func0+0x88>\nmov    %rax,%r14\nlea    -0x1(%rax),%eax\nmov    %r15,%rbx\nxor    %r12d,%r12d\nlea    0x1(%r15,%rax,1),%r13\nlea    0xcce(%rip),%rbp\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovsbl (%rbx),%esi\nmov    %rbp,%rdi\ncall   1080 <strchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmp    %r13,%rbx\njne    1340 <func0+0x40>\nmovslq %r14d,%r14\nmovzbl -0x1(%r15,%r14,1),%eax\nand    $0xffffffdf,%eax\ncmp    $0x59,%al\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nxor    %r12d,%r12d\njmp    1373 <func0+0x73>\n"
    },
    {
        "task_id": 64,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\ntest   %eax,%eax\njle    1388 <func0+0x88>\nmov    %rax,%r14\nlea    -0x1(%rax),%eax\nmov    %r15,%rbx\nxor    %r12d,%r12d\nlea    0x1(%r15,%rax,1),%r13\nlea    0xcce(%rip),%rbp\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovsbl (%rbx),%esi\nmov    %rbp,%rdi\ncall   1080 <strchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmp    %r13,%rbx\njne    1340 <func0+0x40>\nmovslq %r14d,%r14\nmovzbl -0x1(%r15,%r14,1),%eax\nand    $0xffffffdf,%eax\ncmp    $0x59,%al\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nxor    %r12d,%r12d\njmp    1373 <func0+0x73>\n"
    },
    {
        "task_id": 65,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %edi,-0x54(%rbp)\nmov    %esi,-0x58(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x54(%rbp),%eax\nmov    %eax,%edx\nlea    0xdd2(%rip),%rax\nmov    %rax,%rsi\nlea    0x2e00(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   1110 <sprintf@plt>\nlea    0x2dec(%rip),%rax\nmov    %rax,%rdi\ncall   10c0 <strlen@plt>\nmov    %eax,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x58(%rbp),%eax\njge    12d8 <func0+0xcf>\nmovl   $0x0,-0x48(%rbp)\njmp    12c5 <func0+0xbc>\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x2dc4(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmov    %al,-0x49(%rbp)\nmov    -0x44(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x48(%rbp),%eax\ncltq\nlea    0x2dab(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x2d9b(%rip),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x44(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x48(%rbp),%eax\ncltq\nlea    0x2d86(%rip),%rcx\nmovzbl -0x49(%rbp),%edx\nmov    %dl,(%rax,%rcx,1)\naddl   $0x1,-0x48(%rbp)\nmov    -0x44(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x48(%rbp)\njl     1270 <func0+0x67>\njmp    1342 <func0+0x139>\nmov    -0x44(%rbp),%eax\ncltq\nmov    -0x58(%rbp),%edx\nmovslq %edx,%rdx\nsub    %rdx,%rax\nmov    %rax,%rcx\nlea    0x2d50(%rip),%rax\nlea    (%rcx,%rax,1),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10b0 <strcpy@plt>\nmov    -0x58(%rbp),%eax\ncltq\nmovb   $0x0,-0x40(%rbp,%rax,1)\nmov    -0x44(%rbp),%eax\nsub    -0x58(%rbp),%eax\nmovslq %eax,%rdx\nlea    -0x40(%rbp),%rax\nlea    0x2d1f(%rip),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   10f0 <strncat@plt>\nlea    -0x40(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2d06(%rip),%rax\nmov    %rax,%rdi\ncall   10b0 <strcpy@plt>\nlea    0x2cf7(%rip),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     135d <func0+0x154>\ncall   10d0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 65,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %edi,%r8d\nmov    %esi,%ebp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nlea    0xdd1(%rip),%rcx\nmov    $0x32,%edx\nmov    $0x1,%esi\nlea    0x2dfc(%rip),%rbx\nmov    %rbx,%rdi\ncall   1110 <__sprintf_chk@plt>\nmov    %rbx,%rdi\ncall   10b0 <strlen@plt>\ncmp    %ebp,%eax\njge    12b6 <func0+0xad>\nmov    %eax,%r8d\nshr    $0x1f,%r8d\nadd    %eax,%r8d\nsar    %r8d\ncmp    $0x1,%eax\njle    1294 <func0+0x8b>\ncltq\nadd    %rbx,%rax\nmov    $0x0,%edx\nmov    %rbx,%rcx\nmovzbl (%rcx,%rdx,1),%esi\nmovzbl -0x1(%rax),%edi\nmov    %dil,(%rcx,%rdx,1)\nmov    %sil,-0x1(%rax)\nadd    $0x1,%rdx\nsub    $0x1,%rax\ncmp    %edx,%r8d\njg     1277 <func0+0x6e>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1303 <func0+0xfa>\nlea    0x2d95(%rip),%rax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmovslq %eax,%rbx\nmovslq %ebp,%rbp\nsub    %rbp,%rbx\nlea    0x2d7a(%rip),%r12\nlea    (%rbx,%r12,1),%rsi\nmov    %rsp,%r13\nmov    $0x32,%edx\nmov    %r13,%rdi\ncall   10f0 <__strcpy_chk@plt>\nmovb   $0x0,(%rsp,%rbp,1)\nmov    $0x32,%ecx\nmov    %rbx,%rdx\nmov    %r12,%rsi\nmov    %r13,%rdi\ncall   1100 <__strncat_chk@plt>\nmov    $0x32,%edx\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   10f0 <__strcpy_chk@plt>\njmp    1294 <func0+0x8b>\ncall   10c0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 65,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nlea    0x2cd3(%rip),%r13\nmov    %edi,%r8d\nlea    0xc8d(%rip),%rcx\npush   %r12\nmov    %r13,%rdi\nmov    $0x32,%edx\npush   %rbx\nmovslq %esi,%rbx\nmov    $0x1,%esi\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncall   1110 <__sprintf_chk@plt>\nmov    %r13,%rdi\ncall   10b0 <strlen@plt>\ncmp    %ebx,%eax\njge    1410 <func0+0xb0>\nmov    %eax,%ecx\nsar    %ecx\nje     13ea <func0+0x8a>\nlea    -0x1(%rcx),%edi\ncltq\nlea    0x1(%r13),%rcx\nmov    %r13,%rdx\nlea    -0x1(%r13,%rax,1),%rax\nadd    %rcx,%rdi\nnopl   0x0(%rax)\nmovzbl (%rax),%esi\nmovzbl (%rdx),%ecx\nadd    $0x1,%rdx\nsub    $0x1,%rax\nmov    %sil,-0x1(%rdx)\nmov    %cl,0x1(%rax)\ncmp    %rdi,%rdx\njne    13d0 <func0+0x70>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1454 <func0+0xf4>\nadd    $0x40,%rsp\nmov    %r13,%rax\npop    %rbx\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\n00 00\nsub    %rbx,%rax\nmov    %rsp,%r8\nmov    $0x32,%edx\nmov    %r8,%rdi\nlea    0x0(%r13,%rax,1),%rsi\nmov    %rax,%r12\ncall   10f0 <__strcpy_chk@plt>\nmov    %r12,%rdx\nmov    %r13,%rsi\nmov    $0x32,%ecx\nmov    %rax,%rdi\nmovb   $0x0,(%rsp,%rbx,1)\ncall   1100 <__strncat_chk@plt>\nmov    $0x32,%edx\nmov    %r13,%rdi\nmov    %rax,%rsi\ncall   10f0 <__strcpy_chk@plt>\njmp    13ea <func0+0x8a>\ncall   10c0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 65,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nlea    0x2cd3(%rip),%r13\nmov    %edi,%r8d\nlea    0xc8d(%rip),%rcx\npush   %r12\nmov    %r13,%rdi\nmov    $0x32,%edx\npush   %rbx\nmovslq %esi,%rbx\nmov    $0x1,%esi\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncall   1110 <__sprintf_chk@plt>\nmov    %r13,%rdi\ncall   10b0 <strlen@plt>\ncmp    %ebx,%eax\njge    1410 <func0+0xb0>\nmov    %eax,%ecx\nsar    %ecx\nje     13ea <func0+0x8a>\nlea    -0x1(%rcx),%edi\ncltq\nlea    0x1(%r13),%rcx\nmov    %r13,%rdx\nlea    -0x1(%r13,%rax,1),%rax\nadd    %rcx,%rdi\nnopl   0x0(%rax)\nmovzbl (%rax),%esi\nmovzbl (%rdx),%ecx\nadd    $0x1,%rdx\nsub    $0x1,%rax\nmov    %sil,-0x1(%rdx)\nmov    %cl,0x1(%rax)\ncmp    %rdi,%rdx\njne    13d0 <func0+0x70>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1454 <func0+0xf4>\nadd    $0x40,%rsp\nmov    %r13,%rax\npop    %rbx\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\n00 00\nsub    %rbx,%rax\nmov    %rsp,%r8\nmov    $0x32,%edx\nmov    %r8,%rdi\nlea    0x0(%r13,%rax,1),%rsi\nmov    %rax,%r12\ncall   10f0 <__strcpy_chk@plt>\nmov    %r12,%rdx\nmov    %r13,%rsi\nmov    $0x32,%ecx\nmov    %rax,%rdi\nmovb   $0x0,(%rsp,%rbx,1)\ncall   1100 <__strncat_chk@plt>\nmov    $0x32,%edx\nmov    %r13,%rdi\nmov    %rax,%rsi\ncall   10f0 <__strcpy_chk@plt>\njmp    13ea <func0+0x8a>\ncall   10c0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 66,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11a7 <func0+0x5e>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x40,%al\njle    11a3 <func0+0x5a>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5a,%al\njg     11a3 <func0+0x5a>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1165 <func0+0x1c>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 66,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     117a <func0+0x31>\nadd    $0x1,%rdi\nmov    $0x0,%edx\nlea    -0x41(%rax),%ecx\nmovsbl %al,%eax\nadd    %edx,%eax\ncmp    $0x1a,%cl\ncmovb  %eax,%edx\nadd    $0x1,%rdi\nmovzbl -0x1(%rdi),%eax\ntest   %al,%al\njne    115d <func0+0x14>\nmov    %edx,%eax\nret\nmov    $0x0,%edx\njmp    1177 <func0+0x2e>\n"
    },
    {
        "task_id": 66,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsbl (%rdi),%eax\ntest   %al,%al\nje     13c8 <func0+0x38>\nadd    $0x1,%rdi\nxor    %r8d,%r8d\nnopw   0x0(%rax,%rax,1)\nlea    -0x41(%rax),%edx\nadd    %r8d,%eax\ncmp    $0x1a,%dl\ncmovb  %eax,%r8d\nmovsbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\njne    13a8 <func0+0x18>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 66,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsbl (%rdi),%eax\ntest   %al,%al\nje     13e8 <func0+0x38>\nadd    $0x1,%rdi\nxor    %r8d,%r8d\nnopw   0x0(%rax,%rax,1)\nlea    -0x41(%rax),%edx\nadd    %r8d,%eax\ncmp    $0x1a,%dl\ncmovb  %eax,%r8d\nmovsbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\njne    13c8 <func0+0x18>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 67,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %esi,-0x4c(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x2c(%rbp)\n00\nmovw   $0x0,-0x24(%rbp)\nmovq   $0x0,-0x22(%rbp)\n00\nmovw   $0x0,-0x1a(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x30(%rbp)\njmp    129b <func0+0xf2>\ncall   10b0 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x48(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x800,%eax\ntest   %eax,%eax\nje     127d <func0+0xd4>\ncmpl   $0x0,-0x38(%rbp)\njne    125b <func0+0xb2>\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x34(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x34(%rbp)\nmovzbl (%rcx),%edx\ncltq\nmov    %dl,-0x2c(%rbp,%rax,1)\njmp    1297 <func0+0xee>\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x34(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x34(%rbp)\nmovzbl (%rcx),%edx\ncltq\nmov    %dl,-0x22(%rbp,%rax,1)\njmp    1297 <func0+0xee>\ncmpl   $0x0,-0x38(%rbp)\njne    1297 <func0+0xee>\ncmpl   $0x0,-0x34(%rbp)\njle    1297 <func0+0xee>\nmovl   $0x1,-0x38(%rbp)\nmovl   $0x0,-0x34(%rbp)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1202 <func0+0x59>\nlea    -0x2c(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <atoi@plt>\nmov    %eax,%edx\nmov    -0x4c(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,%ebx\nlea    -0x22(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <atoi@plt>\nmov    %eax,%edx\nmov    %ebx,%eax\nsub    %edx,%eax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     12ee <func0+0x145>\ncall   1080 <__stack_chk_fail@plt>\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 67,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmov    %esi,%r12d\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmovq   $0x0,0x4(%rsp)\n00 00\nmovw   $0x0,0xc(%rsp)\nmovq   $0x0,0xe(%rsp)\n00 00\nmovw   $0x0,0x16(%rsp)\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     125e <func0+0xb5>\nmov    %rdi,%rbp\ncall   10b0 <__ctype_b_loc@plt>\nmov    (%rax),%rdi\nlea    0x1(%rbp),%rdx\nmov    $0x0,%ecx\nmov    $0x0,%eax\nmov    $0x0,%r9d\nmov    $0x1,%r8d\njmp    1243 <func0+0x9a>\nmovslq %ecx,%rsi\nmov    %bl,0xe(%rsp,%rsi,1)\nlea    0x1(%rcx),%ecx\njmp    1237 <func0+0x8e>\ntest   %eax,%eax\njne    1237 <func0+0x8e>\ntest   %ecx,%ecx\nsetg   %sil\ntest   %sil,%sil\ncmovne %r9d,%ecx\ncmovne %r8d,%eax\nadd    $0x1,%rdx\nmovzbl -0x1(%rdx),%ebx\ntest   %bl,%bl\nje     125e <func0+0xb5>\nmovsbq %bl,%rsi\ntestb  $0x8,0x1(%rdi,%rsi,2)\nje     1222 <func0+0x79>\ntest   %eax,%eax\njne    1216 <func0+0x6d>\nmovslq %ecx,%rsi\nmov    %bl,0x4(%rsp,%rsi,1)\nlea    0x1(%rcx),%ecx\njmp    1237 <func0+0x8e>\nlea    0x4(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncall   10a0 <strtol@plt>\nsub    %eax,%r12d\nlea    0xe(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncall   10a0 <strtol@plt>\nsub    %eax,%r12d\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    12a8 <func0+0xff>\nmov    %r12d,%eax\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 67,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nxor    %edx,%edx\nmov    %esi,%r12d\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmovzbl (%rdi),%ebx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmov    %dx,0x16(%rsp)\nmovq   $0x0,0x4(%rsp)\n00 00\nmov    %ax,0xc(%rsp)\nmovq   $0x0,0xe(%rsp)\n00 00\ntest   %bl,%bl\nje     13ee <func0+0xae>\nmov    %rdi,%rbp\ncall   10b0 <__ctype_b_loc@plt>\nlea    0x1(%rbp),%rdi\nxor    %edx,%edx\nxor    %r9d,%r9d\nmov    (%rax),%rsi\nmov    $0x1,%r8d\nxor    %eax,%eax\njmp    13c5 <func0+0x85>\nnopl   0x0(%rax)\nmovslq %edx,%rcx\ntest   %eax,%eax\njne    1438 <func0+0xf8>\nmov    %bl,0x4(%rsp,%rcx,1)\nadd    $0x1,%edx\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\nje     13ee <func0+0xae>\nmovsbq %bl,%rcx\ntestb  $0x8,0x1(%rsi,%rcx,2)\njne    13a8 <func0+0x68>\ntest   %eax,%eax\njne    13ba <func0+0x7a>\ntest   %edx,%edx\nsetg   %cl\ntest   %cl,%cl\ncmovne %r9d,%edx\ncmovne %r8d,%eax\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    13c5 <func0+0x85>\nlea    0x4(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\ncall   10a0 <strtol@plt>\nlea    0xe(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nsub    %eax,%r12d\ncall   10a0 <strtol@plt>\nsub    %eax,%r12d\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1444 <func0+0x104>\nadd    $0x20,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmov    %bl,0xe(%rsp,%rcx,1)\nadd    $0x1,%edx\njmp    13ba <func0+0x7a>\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 67,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nxor    %edx,%edx\nmov    %esi,%r12d\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmovzbl (%rdi),%ebx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmov    %dx,0x16(%rsp)\nmovq   $0x0,0x4(%rsp)\n00 00\nmov    %ax,0xc(%rsp)\nmovq   $0x0,0xe(%rsp)\n00 00\ntest   %bl,%bl\nje     13ee <func0+0xae>\nmov    %rdi,%rbp\ncall   10b0 <__ctype_b_loc@plt>\nlea    0x1(%rbp),%rdi\nxor    %edx,%edx\nxor    %r9d,%r9d\nmov    (%rax),%rsi\nmov    $0x1,%r8d\nxor    %eax,%eax\njmp    13c5 <func0+0x85>\nnopl   0x0(%rax)\nmovslq %edx,%rcx\ntest   %eax,%eax\njne    1438 <func0+0xf8>\nmov    %bl,0x4(%rsp,%rcx,1)\nadd    $0x1,%edx\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\nje     13ee <func0+0xae>\nmovsbq %bl,%rcx\ntestb  $0x8,0x1(%rsi,%rcx,2)\njne    13a8 <func0+0x68>\ntest   %eax,%eax\njne    13ba <func0+0x7a>\ntest   %edx,%edx\nsetg   %cl\ntest   %cl,%cl\ncmovne %r9d,%edx\ncmovne %r8d,%eax\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    13c5 <func0+0x85>\nlea    0x4(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\ncall   10a0 <strtol@plt>\nlea    0xe(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nsub    %eax,%r12d\ncall   10a0 <strtol@plt>\nsub    %eax,%r12d\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1444 <func0+0x104>\nadd    $0x20,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmov    %bl,0xe(%rsp,%rcx,1)\nadd    $0x1,%edx\njmp    13ba <func0+0x7a>\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 68,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x7fffffff,-0xc(%rbp)\nmovl   $0xffffffff,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11f4 <func0+0x8b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    11f0 <func0+0x87>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njg     11d1 <func0+0x68>\ncmpl   $0xffffffff,-0x8(%rbp)\njne    11f0 <func0+0x87>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1193 <func0+0x2a>\ncmpl   $0xffffffff,-0x8(%rbp)\njne    1209 <func0+0xa0>\nmov    $0x0,%eax\njmp    1223 <func0+0xba>\nmov    -0x28(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x28(%rbp),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 68,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11be <func0+0x55>\nmov    %esi,%esi\nmov    $0x0,%ecx\nmov    $0xffffffff,%r10d\nmov    $0x7fffffff,%eax\njmp    1194 <func0+0x2b>\nmov    %r9d,%r10d\nmov    %r8d,%eax\nadd    $0x1,%rcx\ncmp    %rsi,%rcx\nje     11ae <func0+0x45>\nmov    %ecx,%r9d\nmov    (%rdi,%rcx,4),%r8d\ntest   $0x1,%r8b\njne    118b <func0+0x22>\ncmp    $0xffffffff,%r10d\nje     1185 <func0+0x1c>\ncmp    %eax,%r8d\njl     1185 <func0+0x1c>\njmp    118b <func0+0x22>\ncmp    $0xffffffff,%r10d\nje     11c4 <func0+0x5b>\nmov    %eax,(%rdx)\nmov    %r10d,0x4(%rdx)\nmov    %rdx,%rax\nret\nmov    $0x0,%eax\nret\nmov    $0x0,%eax\nret\n"
    },
    {
        "task_id": 68,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    15a0 <func0+0x60>\nmovslq %esi,%rsi\nxor    %ecx,%ecx\nmov    $0xffffffff,%r10d\nmov    $0x7fffffff,%eax\nnopl   0x0(%rax,%rax,1)\n00\nmov    (%rdi,%rcx,4),%r8d\nmov    %ecx,%r9d\ntest   $0x1,%r8b\njne    157e <func0+0x3e>\ncmp    $0xffffffff,%r10d\nje     1578 <func0+0x38>\ncmp    %eax,%r8d\njge    157e <func0+0x3e>\nmov    %r9d,%r10d\nmov    %r8d,%eax\nadd    $0x1,%rcx\ncmp    %rsi,%rcx\njne    1560 <func0+0x20>\ncmp    $0xffffffff,%r10d\nje     15a0 <func0+0x60>\nmov    %eax,(%rdx)\nmov    %rdx,%rax\nmov    %r10d,0x4(%rdx)\nret\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nxchg   %ax,%ax\n"
    },
    {
        "task_id": 68,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    13e0 <func0+0x60>\nmovslq %esi,%rsi\nxor    %ecx,%ecx\nmov    $0xffffffff,%r10d\nmov    $0x7fffffff,%eax\nnopl   0x0(%rax,%rax,1)\n00\nmov    (%rdi,%rcx,4),%r8d\nmov    %ecx,%r9d\ntest   $0x1,%r8b\njne    13be <func0+0x3e>\ncmp    $0xffffffff,%r10d\nje     13b8 <func0+0x38>\ncmp    %r8d,%eax\njle    13be <func0+0x3e>\nmov    %r9d,%r10d\nmov    %r8d,%eax\nadd    $0x1,%rcx\ncmp    %rcx,%rsi\njne    13a0 <func0+0x20>\ncmp    $0xffffffff,%r10d\nje     13e0 <func0+0x60>\nmov    %eax,(%rdx)\nmov    %rdx,%rax\nmov    %r10d,0x4(%rdx)\nret\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nxchg   %ax,%ax\n"
    },
    {
        "task_id": 69,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    $0x4,%esi\nmov    %rax,%rdi\ncall   1090 <calloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0xffffffff,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1271 <func0+0xe8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nadd    $0x1,%edx\nmov    %edx,(%rax)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njl     126d <func0+0xe4>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    126d <func0+0xe4>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     11c8 <func0+0x3f>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1070 <free@plt>\nmov    -0x10(%rbp),%eax\nleave\nret\n"
    },
    {
        "task_id": 69,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %esi,%ebx\nlea    0x1(%rsi),%edi\nmovslq %edi,%rdi\nmov    $0x4,%esi\ncall   1070 <calloc@plt>\nmov    %rax,%rdi\ntest   %ebx,%ebx\njle    11d7 <func0+0x6e>\nmov    %rbp,%rsi\nlea    -0x1(%rbx),%eax\nlea    0x4(%rbp,%rax,4),%rax\nmov    $0xffffffff,%ebx\nmov    (%rsi),%ecx\nmovslq %ecx,%rdx\nlea    (%rdi,%rdx,4),%r8\nmov    (%r8),%edx\nadd    $0x1,%edx\nmov    %edx,(%r8)\ncmp    %ecx,%ebx\nmov    %ecx,%r8d\ncmovge %ebx,%r8d\ncmp    %edx,%ecx\ncmovle %r8d,%ebx\nadd    $0x4,%rsi\ncmp    %rax,%rsi\njne    119f <func0+0x36>\ncall   1060 <free@plt>\nmov    %ebx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nmov    $0xffffffff,%ebx\njmp    11c9 <func0+0x60>\n"
    },
    {
        "task_id": 69,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %esi,%r12d\npush   %rbx\nmov    %rdi,%rbx\nlea    0x1(%rsi),%edi\nmov    $0x4,%esi\nmovslq %edi,%rdi\nsub    $0x8,%rsp\ncall   1070 <calloc@plt>\nmov    %rax,%rdi\ntest   %r12d,%r12d\njle    1200 <func0+0x80>\nlea    -0x1(%r12),%eax\nmov    %rbx,%rsi\nmov    $0xffffffff,%r12d\nlea    0x4(%rbx,%rax,4),%rax\nnopl   0x0(%rax)\nmovslq (%rsi),%rdx\nlea    (%rdi,%rdx,4),%r8\nmov    %rdx,%rcx\nmov    (%r8),%ebx\ncmp    %ecx,%r12d\nlea    0x1(%rbx),%edx\nmov    %edx,(%r8)\nmov    %ecx,%r8d\ncmovge %r12d,%r8d\ncmp    %edx,%ecx\ncmovle %r8d,%r12d\nadd    $0x4,%rsi\ncmp    %rsi,%rax\njne    11c0 <func0+0x40>\ncall   1060 <free@plt>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nret\nnopl   0x0(%rax)\ncall   1060 <free@plt>\nmov    $0xffffffff,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nret\n"
    },
    {
        "task_id": 69,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %esi,%r12d\npush   %rbx\nmov    %rdi,%rbx\nlea    0x1(%rsi),%edi\nmov    $0x4,%esi\nmovslq %edi,%rdi\nsub    $0x8,%rsp\ncall   1070 <calloc@plt>\nmov    %rax,%rdi\ntest   %r12d,%r12d\njle    1200 <func0+0x80>\nlea    -0x1(%r12),%eax\nmov    %rbx,%rsi\nmov    $0xffffffff,%r12d\nlea    0x4(%rbx,%rax,4),%rax\nnopl   0x0(%rax)\nmovslq (%rsi),%rdx\nlea    (%rdi,%rdx,4),%r8\nmov    %rdx,%rcx\nmov    (%r8),%ebx\ncmp    %ecx,%r12d\nlea    0x1(%rbx),%edx\nmov    %edx,(%r8)\nmov    %ecx,%r8d\ncmovge %r12d,%r8d\ncmp    %edx,%ecx\ncmovle %r8d,%r12d\nadd    $0x4,%rsi\ncmp    %rsi,%rax\njne    11c0 <func0+0x40>\ncall   1060 <free@plt>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nret\nnopl   0x0(%rax)\ncall   1060 <free@plt>\nmov    $0xffffffff,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nret\n"
    },
    {
        "task_id": 70,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    1239 <func0+0xd0>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1229 <func0+0xc0>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    1225 <func0+0xbc>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1196 <func0+0x2d>\naddl   $0x1,-0x18(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x18(%rbp)\njl     1188 <func0+0x1f>\nmovl   $0x0,-0x10(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1319 <func0+0x1b0>\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njne    12a7 <func0+0x13e>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x8(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\njmp    1319 <func0+0x1b0>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x8(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0xc(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x8(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njle    1264 <func0+0xfb>\nnop\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 70,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r10\nmov    %rdx,%r11\nlea    -0x1(%rsi),%r9d\ntest   %r9d,%r9d\njle    11dd <func0+0x74>\nmov    %esi,%ebx\nlea    0x4(%rdi),%rsi\nlea    -0x2(%rbx),%ebp\nadd    $0x2,%rbp\nmov    $0x1,%r8d\nmov    %r9d,%r13d\nlea    0x8(%rdi),%r12\njmp    11c4 <func0+0x5b>\nadd    $0x4,%rax\ncmp    %rdi,%rax\nje     11b7 <func0+0x4e>\nmov    -0x4(%rsi),%edx\nmov    (%rax),%ecx\ncmp    %ecx,%edx\njle    119e <func0+0x35>\nmov    %ecx,-0x4(%rsi)\nmov    %edx,(%rax)\njmp    119e <func0+0x35>\nadd    $0x1,%r8\nadd    $0x4,%rsi\ncmp    %rbp,%r8\nje     11df <func0+0x76>\ncmp    %r8d,%ebx\njle    11b7 <func0+0x4e>\nmov    %r13d,%eax\nsub    %r8d,%eax\nlea    -0x1(%r8,%rax,1),%rax\nlea    (%r12,%rax,4),%rdi\nmov    %rsi,%rax\njmp    11a7 <func0+0x3e>\njne    121b <func0+0xb2>\nmovslq %r9d,%rdx\nmov    $0x0,%eax\njmp    1206 <func0+0x9d>\nmov    (%r10,%rax,4),%ecx\nmov    %ecx,(%r11,%rax,8)\nmov    (%r10,%rdx,4),%ecx\nmov    %ecx,0x4(%r11,%rax,8)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %edx,%eax\njg     121b <func0+0xb2>\nlea    (%rax,%rax,1),%ecx\ncmp    %eax,%edx\njne    11e9 <func0+0x80>\nmovslq %eax,%rsi\nmov    (%r10,%rsi,4),%eax\nmovslq %ecx,%rcx\nmov    %eax,(%r11,%rcx,4)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 70,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rdi,%r10\nmov    %rdx,%r11\npush   %r12\nlea    -0x1(%rsi),%r12d\npush   %rbp\nmov    %r12d,%r9d\npush   %rbx\ntest   %r12d,%r12d\njle    17f9 <func0+0xd9>\nmov    %esi,%ebx\nlea    0x8(%rdi),%r13\nlea    0x4(%rdi),%rsi\nmov    $0x1,%r8d\nlea    -0x2(%rbx),%ebp\nadd    $0x2,%rbp\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    %r8d,%ebx\njle    1797 <func0+0x77>\nmov    %r12d,%eax\nsub    %r8d,%eax\nlea    -0x1(%r8,%rax,1),%rax\nlea    0x0(%r13,%rax,4),%rdi\nmov    %rsi,%rax\nnopl   0x0(%rax,%rax,1)\n00\nmov    -0x4(%rsi),%edx\nmov    (%rax),%ecx\ncmp    %ecx,%edx\njle    178e <func0+0x6e>\nmov    %ecx,-0x4(%rsi)\nmov    %edx,(%rax)\nadd    $0x4,%rax\ncmp    %rax,%rdi\njne    1780 <func0+0x60>\nadd    $0x1,%r8\nadd    $0x4,%rsi\ncmp    %rbp,%r8\njne    1760 <func0+0x40>\nxor    %eax,%eax\nxor    %ecx,%ecx\njmp    17cc <func0+0xac>\nnopw   0x0(%rax,%rax,1)\nmovslq %r9d,%rsi\nadd    $0x1,%rax\nsub    $0x1,%r9d\nadd    $0x2,%ecx\nmov    (%r10,%rsi,4),%esi\nmov    %esi,0x4(%r11,%rdx,1)\ncmp    %eax,%r9d\njl     17f2 <func0+0xd2>\nmovslq %ecx,%rdx\nmov    (%r10,%rax,4),%edi\nlea    0x1(%rcx),%r8d\nshl    $0x2,%rdx\nlea    (%r11,%rdx,1),%rsi\nmov    %edi,(%rsi)\ncmp    %eax,%r9d\njne    17b0 <func0+0x90>\nadd    $0x1,%rax\nmov    %r8d,%ecx\ncmp    %eax,%r9d\njge    17cc <func0+0xac>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ntest   %r12d,%r12d\nje     17a4 <func0+0x84>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\n"
    },
    {
        "task_id": 70,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rdi,%r10\nmov    %rdx,%r11\npush   %r12\nlea    -0x1(%rsi),%r12d\npush   %rbp\nmovslq %r12d,%r9\npush   %rbx\ntest   %r12d,%r12d\njle    16ee <func0+0xde>\nmov    %esi,%ebx\nlea    0x8(%rdi),%r13\nlea    0x4(%rdi),%rsi\nmov    $0x1,%r8d\nlea    -0x2(%rbx),%ebp\nadd    $0x2,%rbp\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    %r8d,%ebx\njle    1687 <func0+0x77>\nmov    %r12d,%eax\nsub    %r8d,%eax\nlea    -0x1(%r8,%rax,1),%rax\nlea    0x0(%r13,%rax,4),%rdi\nmov    %rsi,%rax\nnopl   0x0(%rax,%rax,1)\n00\nmov    -0x4(%rsi),%edx\nmov    (%rax),%ecx\ncmp    %ecx,%edx\njle    167e <func0+0x6e>\nmov    %ecx,-0x4(%rsi)\nmov    %edx,(%rax)\nadd    $0x4,%rax\ncmp    %rax,%rdi\njne    1670 <func0+0x60>\nadd    $0x1,%r8\nadd    $0x4,%rsi\ncmp    %r8,%rbp\njne    1650 <func0+0x40>\nxor    %eax,%eax\nxor    %ecx,%ecx\nnopl   0x0(%rax,%rax,1)\n00\nmovslq %ecx,%rdx\nmov    (%r10,%rax,4),%edi\nlea    0x1(%rcx),%r8d\nshl    $0x2,%rdx\nlea    (%r11,%rdx,1),%rsi\nmov    %edi,(%rsi)\ncmp    %eax,%r9d\nje     16e0 <func0+0xd0>\nmov    (%r10,%r9,4),%edi\nlea    -0x1(%r9),%esi\nadd    $0x1,%rax\nadd    $0x2,%ecx\nmov    %edi,0x4(%r11,%rdx,1)\ncmp    %eax,%esi\njl     16f3 <func0+0xe3>\nmovslq %esi,%r9\njmp    16a0 <func0+0x90>\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%rax\ncmp    %eax,%r9d\njl     16f3 <func0+0xe3>\nmov    %r8d,%ecx\njmp    16a0 <func0+0x90>\ntest   %r9d,%r9d\nje     1694 <func0+0x84>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 71,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovss  %xmm0,-0x14(%rbp)\nmovss  %xmm1,-0x18(%rbp)\nmovss  %xmm2,-0x1c(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\naddss  -0x18(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njae    11e9 <func0+0x60>\nmovss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\naddss  -0x1c(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njae    11e9 <func0+0x60>\nmovss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\naddss  -0x1c(%rbp),%xmm1\nmovss  -0x14(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njb     11f6 <func0+0x6d>\nmovss  0xf97(%rip),%xmm0\n00\njmp    128a <func0+0x101>\nmovss  -0x14(%rbp),%xmm0\naddss  -0x18(%rbp),%xmm0\naddss  -0x1c(%rbp),%xmm0\nmovss  0xf7f(%rip),%xmm1\n00\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x8(%rbp),%xmm0\nsubss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nsubss  -0x18(%rbp),%xmm0\nmulss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\nsubss  -0x1c(%rbp),%xmm0\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   1090 <sqrtf@plt>\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm1\nmovss  0xf2b(%rip),%xmm0\n00\nmulss  %xmm0,%xmm1\nmovd   %xmm1,%eax\nmovd   %eax,%xmm0\ncall   1070 <roundf@plt>\nmovd   %xmm0,%eax\nmovss  0xf0e(%rip),%xmm1\n00\nmovd   %eax,%xmm0\ndivss  %xmm1,%xmm0\nleave\nret\n"
    },
    {
        "task_id": 71,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovaps %xmm0,%xmm4\naddss  %xmm1,%xmm4\ncomiss %xmm4,%xmm2\njae    121d <func0+0x94>\nmovaps %xmm0,%xmm3\nmovss  0xfd0(%rip),%xmm0\n00\nmovaps %xmm3,%xmm5\naddss  %xmm2,%xmm5\ncomiss %xmm5,%xmm1\njae    11c0 <func0+0x37>\nmovaps %xmm1,%xmm5\naddss  %xmm2,%xmm5\ncomiss %xmm5,%xmm3\njb     11c1 <func0+0x38>\nret\nsub    $0x8,%rsp\naddss  %xmm2,%xmm4\nmulss  0xfab(%rip),%xmm4\n00\nmovaps %xmm4,%xmm0\nsubss  %xmm3,%xmm0\nmulss  %xmm4,%xmm0\nmovaps %xmm4,%xmm3\nsubss  %xmm1,%xmm3\nmulss  %xmm3,%xmm0\nsubss  %xmm2,%xmm4\nmulss  %xmm4,%xmm0\npxor   %xmm1,%xmm1\nucomiss %xmm0,%xmm1\nja     1216 <func0+0x8d>\nsqrtss %xmm0,%xmm0\nmulss  0xf7c(%rip),%xmm0\n00\ncall   1070 <roundf@plt>\ndivss  0xf6f(%rip),%xmm0\n00\nadd    $0x8,%rsp\nret\ncall   1090 <sqrtf@plt>\njmp    11fc <func0+0x73>\nmovss  0xf53(%rip),%xmm0\n00\nret\n"
    },
    {
        "task_id": 71,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovaps %xmm0,%xmm4\naddss  %xmm1,%xmm4\ncomiss %xmm4,%xmm2\njae    1588 <func0+0x98>\nmovaps %xmm0,%xmm3\nmovss  0xc69(%rip),%xmm0\n00\nmovaps %xmm3,%xmm5\naddss  %xmm2,%xmm5\ncomiss %xmm5,%xmm1\njae    1580 <func0+0x90>\nmovaps %xmm1,%xmm5\naddss  %xmm2,%xmm5\ncomiss %xmm5,%xmm3\njae    1580 <func0+0x90>\nsub    $0x8,%rsp\naddss  %xmm2,%xmm4\nmulss  0xc45(%rip),%xmm4\n00\nmovaps %xmm4,%xmm0\nsubss  %xmm3,%xmm0\nmovaps %xmm4,%xmm3\nsubss  %xmm1,%xmm3\npxor   %xmm1,%xmm1\nmulss  %xmm4,%xmm0\nsubss  %xmm2,%xmm4\nmulss  %xmm3,%xmm0\nmulss  %xmm4,%xmm0\nucomiss %xmm0,%xmm1\nja     1591 <func0+0xa1>\nsqrtss %xmm0,%xmm0\nmulss  0xc16(%rip),%xmm0\n00\ncall   1070 <roundf@plt>\ndivss  0xc09(%rip),%xmm0\n00\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\nret\nnopl   0x0(%rax)\nmovss  0xbe8(%rip),%xmm0\n00\nret\ncall   1090 <sqrtf@plt>\njmp    1562 <func0+0x72>\n"
    },
    {
        "task_id": 71,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovaps %xmm0,%xmm4\naddss  %xmm1,%xmm4\ncomiss %xmm4,%xmm2\njae    1218 <func0+0x98>\nmovaps %xmm0,%xmm3\nmovss  0xe65(%rip),%xmm0\n00\nmovaps %xmm3,%xmm5\naddss  %xmm2,%xmm5\ncomiss %xmm5,%xmm1\njae    1210 <func0+0x90>\nmovaps %xmm1,%xmm5\naddss  %xmm2,%xmm5\ncomiss %xmm5,%xmm3\njae    1210 <func0+0x90>\nsub    $0x8,%rsp\naddss  %xmm2,%xmm4\nmulss  0xe41(%rip),%xmm4\n00\nmovaps %xmm4,%xmm0\nsubss  %xmm3,%xmm0\nmovaps %xmm4,%xmm3\nsubss  %xmm1,%xmm3\npxor   %xmm1,%xmm1\nmulss  %xmm4,%xmm0\nsubss  %xmm2,%xmm4\nmulss  %xmm3,%xmm0\nmulss  %xmm4,%xmm0\nucomiss %xmm0,%xmm1\nja     1221 <func0+0xa1>\nsqrtss %xmm0,%xmm0\nmulss  0xe12(%rip),%xmm0\n00\ncall   1060 <roundf@plt>\ndivss  0xe05(%rip),%xmm0\n00\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\nret\nnopl   0x0(%rax)\nmovss  0xde4(%rip),%xmm0\n00\nret\ncall   1070 <sqrtf@plt>\njmp    11f2 <func0+0x72>\n"
    },
    {
        "task_id": 72,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1226 <func0+0x9d>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\nje     11eb <func0+0x62>\nmov    $0x0,%eax\njmp    1279 <func0+0xf0>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %edx,%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x4(%rbp)\njl     11ab <func0+0x22>\nmov    -0x1c(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    1270 <func0+0xe7>\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x20(%rbp),%eax\nsetle  %al\npop    %rbp\nret\n"
    },
    {
        "task_id": 72,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r9\nmov    %esi,%r10d\nmov    %edx,%r11d\nmov    %esi,%r8d\nshr    $0x1f,%r8d\nadd    %esi,%r8d\nsar    %r8d\ncmp    $0x1,%esi\njle    11f2 <func0+0x69>\nmovslq %esi,%rax\nlea    (%rdi,%rax,4),%rcx\nmov    $0x0,%edx\nmov    $0x0,%edi\nmov    (%r9,%rdx,4),%eax\nmov    -0x4(%rcx),%esi\ncmp    %esi,%eax\njne    1202 <func0+0x79>\nadd    %esi,%eax\nadd    %eax,%edi\nadd    $0x1,%rdx\nsub    $0x4,%rcx\ncmp    %edx,%r8d\njg     11b9 <func0+0x30>\nmov    %r10d,%eax\nshr    $0x1f,%eax\nadd    %eax,%r10d\nand    $0x1,%r10d\nsub    %eax,%r10d\ncmp    $0x1,%r10d\nje     11f9 <func0+0x70>\ncmp    %r11d,%edi\nsetle  %al\nret\nmov    $0x0,%edi\njmp    11d5 <func0+0x4c>\nmovslq %r8d,%r8\nadd    (%r9,%r8,4),%edi\njmp    11eb <func0+0x62>\nmov    $0x0,%eax\nret\n"
    },
    {
        "task_id": 72,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%r8d\nmov    %rdi,%r9\nmov    %edx,%r10d\nshr    $0x1f,%r8d\nadd    %esi,%r8d\nsar    %r8d\ncmp    $0x1,%esi\njle    13cb <func0+0x4b>\nlea    -0x1(%rsi),%eax\ncltq\nlea    (%rdi,%rax,4),%rdx\nxor    %eax,%eax\nxor    %edi,%edi\njmp    13c0 <func0+0x40>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rax\nlea    (%rdi,%rcx,2),%edi\nsub    $0x4,%rdx\ncmp    %eax,%r8d\njle    13d0 <func0+0x50>\nmov    (%r9,%rax,4),%ecx\ncmp    (%rdx),%ecx\nje     13b0 <func0+0x30>\nxor    %eax,%eax\nret\nxor    %edi,%edi\nnopl   (%rax)\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %eax,%esi\nand    $0x1,%esi\nsub    %eax,%esi\ncmp    $0x1,%esi\nje     13f0 <func0+0x70>\ncmp    %r10d,%edi\nsetle  %al\nret\nnopl   0x0(%rax,%rax,1)\n00\nmovslq %r8d,%r8\nadd    (%r9,%r8,4),%edi\ncmp    %r10d,%edi\nsetle  %al\nret\n"
    },
    {
        "task_id": 72,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%r8d\nmov    %rdi,%r9\nmov    %edx,%r10d\nshr    $0x1f,%r8d\nadd    %esi,%r8d\nsar    %r8d\ncmp    $0x1,%esi\njle    11bb <func0+0x4b>\nlea    -0x1(%rsi),%eax\ncltq\nlea    (%rdi,%rax,4),%rdx\nxor    %eax,%eax\nxor    %edi,%edi\njmp    11b0 <func0+0x40>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rax\nlea    (%rdi,%rcx,2),%edi\nsub    $0x4,%rdx\ncmp    %eax,%r8d\njle    11c0 <func0+0x50>\nmov    (%r9,%rax,4),%ecx\ncmp    (%rdx),%ecx\nje     11a0 <func0+0x30>\nxor    %eax,%eax\nret\nxor    %edi,%edi\nnopl   (%rax)\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %eax,%esi\nand    $0x1,%esi\nsub    %eax,%esi\ncmp    $0x1,%esi\nje     11e0 <func0+0x70>\ncmp    %r10d,%edi\nsetle  %al\nret\nnopl   0x0(%rax,%rax,1)\n00\nmovslq %r8d,%r8\nadd    (%r9,%r8,4),%edi\ncmp    %r10d,%edi\nsetle  %al\nret\n"
    },
    {
        "task_id": 73,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11c6 <func0+0x5d>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\nje     11c2 <func0+0x59>\naddl   $0x1,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x4(%rbp)\njl     1188 <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 73,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%r8d\nshr    $0x1f,%r8d\nadd    %esi,%r8d\nsar    %r8d\ncmp    $0x1,%esi\njle    11b0 <func0+0x47>\nmovslq %esi,%rsi\nlea    (%rdi,%rsi,4),%rdx\nmov    $0x0,%eax\nmov    $0x0,%ecx\nmov    -0x4(%rdx),%esi\ncmp    %esi,(%rdi,%rax,4)\nsetne  %sil\nmovzbl %sil,%esi\nadd    %esi,%ecx\nadd    $0x1,%rax\nsub    $0x4,%rdx\ncmp    %eax,%r8d\njg     1190 <func0+0x27>\nmov    %ecx,%eax\nret\nmov    $0x0,%ecx\njmp    11ad <func0+0x44>\n"
    },
    {
        "task_id": 73,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%r9d\nshr    $0x1f,%r9d\nadd    %esi,%r9d\nsar    %r9d\ncmp    $0x1,%esi\njle    14a0 <func0+0x50>\nsub    $0x1,%esi\nxor    %eax,%eax\nxor    %r8d,%r8d\nmovslq %esi,%rsi\nlea    (%rdi,%rsi,4),%rdx\nnopl   (%rax)\nmov    (%rdx),%esi\nxor    %ecx,%ecx\ncmp    %esi,(%rdi,%rax,4)\nsetne  %cl\nadd    $0x1,%rax\nsub    $0x4,%rdx\nadd    %ecx,%r8d\ncmp    %eax,%r9d\njg     1478 <func0+0x28>\nmov    %r8d,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 73,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rcx\nmov    %esi,%edi\nshr    $0x1f,%edi\nadd    %esi,%edi\nsar    %edi\ncmp    $0x1,%esi\njle    1240 <func0+0x100>\nlea    -0x1(%rsi),%r8d\ncmp    $0x7,%esi\njle    1249 <func0+0x109>\nmovslq %esi,%rsi\npxor   %xmm1,%xmm1\nmov    %rcx,%rax\nlea    -0x10(%rcx,%rsi,4),%rdx\nmov    %edi,%esi\nmovdqa %xmm1,%xmm2\nshr    $0x2,%esi\nsub    $0x1,%esi\nshl    $0x4,%rsi\nlea    0x10(%rcx,%rsi,1),%rsi\nnopw   0x0(%rax,%rax,1)\nmovdqu (%rdx),%xmm3\nmovdqu (%rax),%xmm4\nadd    $0x10,%rax\nsub    $0x10,%rdx\npshufd $0x1b,%xmm3,%xmm0\npcmpeqd %xmm4,%xmm0\npcmpeqd %xmm2,%xmm0\npsubd  %xmm0,%xmm1\ncmp    %rax,%rsi\njne    1190 <func0+0x50>\nmovdqa %xmm1,%xmm0\nmov    %edi,%edx\npsrldq $0x8,%xmm0\nand    $0xfffffffc,%edx\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ntest   $0x3,%dil\nje     1248 <func0+0x108>\nmov    %r8d,%esi\nmovslq %edx,%r9\nsub    %edx,%esi\nlea    0x0(,%r9,4),%r10\n00\nmovslq %esi,%rsi\nmov    (%rcx,%rsi,4),%esi\ncmp    %esi,(%rcx,%r9,4)\nje     11fe <func0+0xbe>\nadd    $0x1,%eax\nlea    0x1(%rdx),%r9d\ncmp    %edi,%r9d\njge    1242 <func0+0x102>\nmov    %r8d,%esi\nmov    0x4(%rcx,%r10,1),%r11d\nsub    %r9d,%esi\nmovslq %esi,%rsi\ncmp    %r11d,(%rcx,%rsi,4)\nje     121e <func0+0xde>\nadd    $0x1,%eax\nadd    $0x2,%edx\ncmp    %edi,%edx\njge    1242 <func0+0x102>\nsub    %edx,%r8d\nmovslq %r8d,%r8\nmov    (%rcx,%r8,4),%edi\ncmp    %edi,0x8(%rcx,%r10,1)\nje     1242 <func0+0x102>\nadd    $0x1,%eax\nret\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\nret\nxor    %edx,%edx\nxor    %eax,%eax\njmp    11df <func0+0x9f>\n"
    },
    {
        "task_id": 74,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    11e7 <func0+0x5e>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   1070 <strlen@plt>\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     11ba <func0+0x31>\nmovl   $0x0,-0xc(%rbp)\njmp    1225 <func0+0x9c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   1070 <strlen@plt>\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     11f8 <func0+0x6f>\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    123b <func0+0xb2>\nmov    -0x18(%rbp),%rax\njmp    124d <func0+0xc4>\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njle    1249 <func0+0xc0>\nmov    -0x28(%rbp),%rax\njmp    124d <func0+0xc4>\nmov    -0x18(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 74,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r14\nmov    %rdx,%r12\nmov    %ecx,%r13d\ntest   %esi,%esi\njle    11f1 <func0+0x88>\nmov    %rdi,%rbx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r15\nmov    $0x0,%ebp\nmov    (%rbx),%rdi\ncall   1060 <strlen@plt>\nadd    %eax,%ebp\nadd    $0x8,%rbx\ncmp    %r15,%rbx\njne    1198 <func0+0x2f>\ntest   %r13d,%r13d\njle    11e9 <func0+0x80>\nmov    $0x0,%ebx\nmov    $0x0,%r15d\nmov    (%r12,%rbx,8),%rdi\ncall   1060 <strlen@plt>\nadd    %eax,%r15d\nadd    $0x1,%rbx\ncmp    %ebx,%r13d\njg     11bb <func0+0x52>\ncmp    %r15d,%ebp\ncmovle %r14,%r12\nmov    %r12,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x0,%r15d\njmp    11d0 <func0+0x67>\nmov    $0x0,%ebp\ntest   %ecx,%ecx\njg     11b0 <func0+0x47>\nmov    %rdi,%r12\njmp    11d7 <func0+0x6e>\n"
    },
    {
        "task_id": 74,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    1200 <func0+0x80>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nlea    0x8(%rdi,%rax,8),%r15\nnopl   0x0(%rax)\nmov    (%rbx),%rdi\nadd    $0x8,%rbx\ncall   1060 <strlen@plt>\nadd    %eax,%ebp\ncmp    %rbx,%r15\njne    11b0 <func0+0x30>\ntest   %r12d,%r12d\njle    1210 <func0+0x90>\nxor    %ebx,%ebx\nxor    %r15d,%r15d\nnopl   (%rax)\nmov    0x0(%r13,%rbx,8),%rdi\nadd    $0x1,%rbx\ncall   1060 <strlen@plt>\nadd    %eax,%r15d\ncmp    %ebx,%r12d\njg     11d0 <func0+0x50>\ncmp    %r15d,%ebp\nmov    %r13,%rax\ncmovle %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnop\nxor    %ebp,%ebp\ntest   %ecx,%ecx\njg     11c8 <func0+0x48>\nmov    %rdi,%rax\njmp    11f0 <func0+0x70>\nnopl   0x0(%rax,%rax,1)\nxor    %r15d,%r15d\njmp    11e6 <func0+0x66>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\n"
    },
    {
        "task_id": 74,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    1200 <func0+0x80>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nlea    0x8(%rdi,%rax,8),%r15\nnopl   0x0(%rax)\nmov    (%rbx),%rdi\nadd    $0x8,%rbx\ncall   1060 <strlen@plt>\nadd    %eax,%ebp\ncmp    %rbx,%r15\njne    11b0 <func0+0x30>\ntest   %r12d,%r12d\njle    1210 <func0+0x90>\nxor    %ebx,%ebx\nxor    %r15d,%r15d\nnopl   (%rax)\nmov    0x0(%r13,%rbx,8),%rdi\nadd    $0x1,%rbx\ncall   1060 <strlen@plt>\nadd    %eax,%r15d\ncmp    %ebx,%r12d\njg     11d0 <func0+0x50>\ncmp    %r15d,%ebp\nmov    %r13,%rax\ncmovle %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnop\nxor    %ebp,%ebp\ntest   %ecx,%ecx\njg     11c8 <func0+0x48>\nmov    %rdi,%rax\njmp    11f0 <func0+0x70>\nnopl   0x0(%rax,%rax,1)\nxor    %r15d,%r15d\njmp    11e6 <func0+0x66>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\n"
    },
    {
        "task_id": 75,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njg     1181 <func0+0x18>\nmov    $0x0,%eax\njmp    11cf <func0+0x66>\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    11b0 <func0+0x47>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\nje     1191 <func0+0x28>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    119f <func0+0x36>\ncmpl   $0x1,-0x14(%rbp)\njle    11c5 <func0+0x5c>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\nsete   %al\nmovzbl %al,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 75,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%eax\ncmp    $0x1,%edi\njle    11c1 <func0+0x58>\nmov    $0x2,%ecx\nmov    $0x0,%esi\ncmp    $0x3,%edi\njg     11a5 <func0+0x3c>\njmp    11b5 <func0+0x4c>\nmov    %edi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%edi\nadd    $0x1,%esi\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1188 <func0+0x1f>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     11b0 <func0+0x47>\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1188 <func0+0x1f>\njmp    1199 <func0+0x30>\ncmp    $0x1,%edi\njle    11b8 <func0+0x4f>\nadd    $0x1,%esi\ncmp    $0x3,%esi\nsete   %al\nmovzbl %al,%eax\nret\n"
    },
    {
        "task_id": 75,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ncmp    $0x1,%edi\njle    142a <func0+0x5a>\nxor    %esi,%esi\nmov    $0x2,%ecx\ncmp    $0x3,%edi\njle    1434 <func0+0x64>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    1411 <func0+0x41>\nnopl   0x0(%rax)\nmov    %edi,%eax\nadd    $0x1,%esi\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%edi\nidiv   %ecx\ntest   %edx,%edx\nje     1400 <func0+0x30>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %eax,%edi\njge    13f0 <func0+0x20>\ncmp    $0x1,%edi\njle    142b <func0+0x5b>\nxor    %eax,%eax\ncmp    $0x2,%esi\nsete   %al\nret\nxor    %eax,%eax\ncmp    $0x3,%esi\nsete   %al\nret\nret\n"
    },
    {
        "task_id": 75,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ncmp    $0x1,%edi\njle    142a <func0+0x5a>\nxor    %esi,%esi\nmov    $0x2,%ecx\ncmp    $0x3,%edi\njle    1434 <func0+0x64>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    1411 <func0+0x41>\nnopl   0x0(%rax)\nmov    %edi,%eax\nadd    $0x1,%esi\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%edi\nidiv   %ecx\ntest   %edx,%edx\nje     1400 <func0+0x30>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %eax,%edi\njge    13f0 <func0+0x20>\ncmp    $0x1,%edi\njle    142b <func0+0x5b>\nxor    %eax,%eax\ncmp    $0x2,%esi\nsete   %al\nret\nxor    %eax,%eax\ncmp    $0x3,%esi\nsete   %al\nret\nret\n"
    },
    {
        "task_id": 76,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1184 <func0+0x3b>\nmov    -0x8(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njne    1176 <func0+0x2d>\nmov    $0x1,%eax\njmp    1197 <func0+0x4e>\nmov    -0x8(%rbp),%eax\nimul   -0x18(%rbp),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njg     1192 <func0+0x49>\ncmpl   $0x63,-0x4(%rbp)\njle    1167 <func0+0x1e>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 76,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    117f <func0+0x36>\ncmp    $0x1,%edi\nje     1185 <func0+0x3c>\nmov    $0x0,%ecx\nmov    $0x1,%edx\nimul   %esi,%edx\nadd    $0x1,%ecx\ncmp    %edx,%edi\njl     1179 <func0+0x30>\ncmp    $0x63,%ecx\njg     1179 <func0+0x30>\ncmp    %edx,%edi\njne    1160 <func0+0x17>\nmov    $0x1,%eax\nret\nmov    $0x0,%eax\nret\nmov    $0x0,%eax\nret\nmov    %edi,%eax\nret\n"
    },
    {
        "task_id": 76,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    1238 <func0+0x38>\ncmp    $0x1,%edi\nje     122b <func0+0x2b>\nxor    %edx,%edx\nmov    $0x1,%eax\nnopl   0x0(%rax)\nimul   %esi,%eax\nadd    $0x1,%edx\ncmp    %eax,%edi\njl     1238 <func0+0x38>\ncmp    $0x63,%edx\njg     1238 <func0+0x38>\ncmp    %eax,%edi\njne    1218 <func0+0x18>\nmov    $0x1,%eax\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 76,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    1238 <func0+0x38>\ncmp    $0x1,%edi\nje     122b <func0+0x2b>\nxor    %edx,%edx\nmov    $0x1,%eax\nnopl   0x0(%rax)\nimul   %esi,%eax\nadd    $0x1,%edx\ncmp    %eax,%edi\njl     1238 <func0+0x38>\ncmp    $0x63,%edx\njg     1238 <func0+0x38>\ncmp    %eax,%edi\njne    1218 <func0+0x18>\nmov    $0x1,%eax\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 77,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11a2 <func0+0x39>\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\nimul   -0x4(%rbp),%eax\nmov    %eax,%edx\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nneg    %ecx\ncmovns %ecx,%eax\ncmp    %eax,%edx\njne    119e <func0+0x35>\nmov    $0x1,%eax\njmp    11c1 <func0+0x58>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\nimul   -0x4(%rbp),%eax\nmov    %eax,%edx\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nneg    %ecx\ncmovns %ecx,%eax\ncmp    %eax,%edx\njle    117d <func0+0x14>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 77,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%ecx\nneg    %ecx\ncmovs  %edi,%ecx\ntest   %edi,%edi\nje     119b <func0+0x32>\nmov    $0x1,%edx\nmov    $0x1,%eax\ncmp    %eax,%ecx\nje     11a1 <func0+0x38>\nadd    $0x1,%edx\nmov    %edx,%eax\nimul   %edx,%eax\nimul   %edx,%eax\ncmp    %ecx,%eax\njle    1182 <func0+0x19>\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 77,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%ecx\nneg    %ecx\ncmovs  %edi,%ecx\ntest   %edi,%edi\nje     12d0 <func0+0x40>\nmov    $0x1,%edx\nmov    $0x1,%eax\nnopl   0x0(%rax)\ncmp    %eax,%ecx\nje     12d0 <func0+0x40>\nadd    $0x1,%edx\nmov    %edx,%eax\nimul   %edx,%eax\nimul   %edx,%eax\ncmp    %ecx,%eax\njle    12b0 <func0+0x20>\nxor    %eax,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 77,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%ecx\nneg    %ecx\ncmovs  %edi,%ecx\ntest   %edi,%edi\nje     12d0 <func0+0x40>\nmov    $0x1,%edx\nmov    $0x1,%eax\nnopl   0x0(%rax)\ncmp    %eax,%ecx\nje     12d0 <func0+0x40>\nadd    $0x1,%edx\nmov    %edx,%eax\nimul   %edx,%eax\nimul   %edx,%eax\ncmp    %ecx,%eax\njle    12b0 <func0+0x20>\nxor    %eax,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 78,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nlea    0xe67(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    11e3 <func0+0x5a>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1080 <strchr@plt>\ntest   %rax,%rax\nje     11df <func0+0x56>\naddl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1070 <strlen@plt>\ncmp    %rax,%rbx\njb     11b5 <func0+0x2c>\nmov    -0x20(%rbp),%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 78,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r12\ncall   1070 <strlen@plt>\nmov    %r12,%rbx\nadd    %rax,%r12\nmov    $0x0,%ebp\nlea    0xe53(%rip),%r13\njmp    11c9 <func0+0x40>\nmovsbl (%rbx),%esi\nmov    %r13,%rdi\ncall   1080 <strchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x1,%rbx\ncmp    %r12,%rbx\njne    11b3 <func0+0x2a>\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 78,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nlea    0xcf7(%rip),%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\nlea    (%rbx,%rax,1),%rbp\njmp    1347 <func0+0x47>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovsbl (%rbx),%esi\nmov    %r13,%rdi\ncall   1080 <strchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\njne    1330 <func0+0x30>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 78,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\ntest   %rax,%rax\nje     1360 <func0+0x60>\nlea    (%rbx,%rax,1),%rbp\nxor    %r12d,%r12d\nlea    0xcdb(%rip),%r13\nnopl   0x0(%rax)\nmovsbl (%rbx),%esi\nmov    %r13,%rdi\ncall   1080 <strchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\njne    1330 <func0+0x30>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\nadd    $0x8,%rsp\nxor    %r12d,%r12d\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 79,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    $0x40,%edi\ncall   10f0 <malloc@plt>\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    1217 <func0+0x2e>\nmov    $0x0,%eax\njmp    133d <func0+0x154>\nmovl   $0x3e,-0x1c(%rbp)\nmov    -0x10(%rbp),%rax\nadd    $0x3f,%rax\nmovb   $0x0,(%rax)\ncmpl   $0x0,-0x24(%rbp)\njne    127e <func0+0x95>\nmov    -0x1c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\njmp    1284 <func0+0x9b>\nmov    -0x24(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nlea    0x30(%rax),%ecx\nmov    -0x1c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x24(%rbp)\ncmpl   $0x0,-0x24(%rbp)\njg     1247 <func0+0x5e>\nmov    -0x1c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x62,(%rax)\nmov    -0x1c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x64,(%rax)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\nmov    $0x3e,%eax\nsub    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x3,%eax\ncltq\nmov    %rax,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    12f2 <func0+0x109>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmov    $0x0,%eax\njmp    133d <func0+0x154>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10b0 <strcpy@plt>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   10c0 <strlen@plt>\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovw   $0x6264,(%rax)\nmovb   $0x0,0x2(%rax)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 79,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x40,%edi\ncall   10f0 <malloc@plt>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     12ba <func0+0xd1>\nmovb   $0x0,0x3f(%rax)\ntest   %ebx,%ebx\nje     124b <func0+0x62>\nmov    $0x3d,%edx\nmov    $0x3e,%esi\njle    1254 <func0+0x6b>\nmov    %edx,%esi\nmov    %ebx,%ecx\nshr    $0x1f,%ecx\nlea    (%rbx,%rcx,1),%eax\nand    $0x1,%eax\nsub    %ecx,%eax\nadd    $0x30,%eax\nmov    %al,0x1(%rbp,%rdx,1)\nmov    %ebx,%ecx\nmov    %ebx,%eax\nshr    $0x1f,%eax\nadd    %ebx,%eax\nsar    %eax\nmov    %eax,%ebx\nsub    $0x1,%rdx\ncmp    $0x1,%ecx\njg     121d <func0+0x34>\njmp    1254 <func0+0x6b>\nmovb   $0x30,0x3e(%rax)\nmov    $0x3d,%esi\nlea    -0x1(%rsi),%eax\nmovslq %esi,%rsi\nmovb   $0x62,0x0(%rbp,%rsi,1)\nmovslq %eax,%r12\nadd    %rbp,%r12\nmovb   $0x64,(%r12)\nmov    $0x41,%edi\nsub    %eax,%edi\nmovslq %edi,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     12b0 <func0+0xc7>\nmov    %r12,%rsi\nmov    %rax,%rdi\ncall   10b0 <strcpy@plt>\nmov    %rbx,%rdi\ncall   10c0 <strlen@plt>\nadd    %rbx,%rax\nmovw   $0x6264,(%rax)\nmovb   $0x0,0x2(%rax)\nmov    %rbp,%rdi\ncall   10a0 <free@plt>\nmov    %rbx,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    %rbp,%rdi\ncall   10a0 <free@plt>\njmp    12a8 <func0+0xbf>\nmov    %rax,%rbx\njmp    12a8 <func0+0xbf>\n"
    },
    {
        "task_id": 79,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x40,%edi\nsub    $0x8,%rsp\ncall   10d0 <malloc@plt>\ntest   %rax,%rax\nje     13e5 <func0+0xe5>\nmovb   $0x0,0x3f(%rax)\nmov    %rax,%rbp\ntest   %ebx,%ebx\njne    1390 <func0+0x90>\nmovb   $0x30,0x3e(%rax)\nmov    $0x5,%edi\nmov    $0x3c,%r13d\nmov    $0x3d,%eax\nadd    %rbp,%r13\nmovb   $0x62,0x0(%rbp,%rax,1)\nmovb   $0x64,0x0(%r13)\ncall   10d0 <malloc@plt>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1373 <func0+0x73>\nmov    %r13,%rsi\nmov    %rax,%rdi\ncall   10a0 <stpcpy@plt>\nmov    $0x6264,%edx\nmov    %dx,(%rax)\nmovb   $0x0,0x2(%rax)\nmov    %rbp,%rdi\ncall   1090 <free@plt>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmov    $0x3d,%eax\njle    13d0 <func0+0xd0>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %ebx,%edx\nmov    %eax,%ecx\nand    $0x1,%edx\nadd    $0x30,%edx\nmov    %dl,0x1(%rbp,%rax,1)\nsub    $0x1,%rax\nsar    %ebx\njne    13a0 <func0+0xa0>\nmovslq %ecx,%rax\nmov    $0x41,%edi\nsub    $0x1,%ecx\nsub    %ecx,%edi\nmovslq %ecx,%r13\nmovslq %edi,%rdi\njmp    1342 <func0+0x42>\nxchg   %ax,%ax\nmov    $0x4,%edi\nmov    $0x3d,%r13d\nmov    $0x3e,%eax\njmp    1342 <func0+0x42>\nxor    %r12d,%r12d\njmp    137b <func0+0x7b>\n"
    },
    {
        "task_id": 79,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x40,%edi\nsub    $0x8,%rsp\ncall   10d0 <malloc@plt>\ntest   %rax,%rax\nje     13e5 <func0+0xe5>\nmovb   $0x0,0x3f(%rax)\nmov    %rax,%rbp\ntest   %ebx,%ebx\njne    1390 <func0+0x90>\nmovb   $0x30,0x3e(%rax)\nmov    $0x5,%edi\nmov    $0x3c,%r13d\nmov    $0x3d,%eax\nadd    %rbp,%r13\nmovb   $0x62,0x0(%rbp,%rax,1)\nmovb   $0x64,0x0(%r13)\ncall   10d0 <malloc@plt>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1373 <func0+0x73>\nmov    %r13,%rsi\nmov    %rax,%rdi\ncall   10a0 <stpcpy@plt>\nmov    $0x6264,%edx\nmov    %dx,(%rax)\nmovb   $0x0,0x2(%rax)\nmov    %rbp,%rdi\ncall   1090 <free@plt>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmov    $0x3d,%eax\njle    13d0 <func0+0xd0>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %ebx,%edx\nmov    %eax,%ecx\nand    $0x1,%edx\nadd    $0x30,%edx\nmov    %dl,0x1(%rbp,%rax,1)\nsub    $0x1,%rax\nsar    %ebx\njne    13a0 <func0+0xa0>\nmovslq %ecx,%rax\nmov    $0x41,%edi\nsub    $0x1,%ecx\nsub    %ecx,%edi\nmovslq %ecx,%r13\nmovslq %edi,%rdi\njmp    1342 <func0+0x42>\nxchg   %ax,%ax\nmov    $0x4,%edi\nmov    $0x3d,%r13d\nmov    $0x3e,%eax\njmp    1342 <func0+0x42>\nxor    %r12d,%r12d\njmp    137b <func0+0x7b>\n"
    },
    {
        "task_id": 80,
        "type": "O0",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1060 <strlen@plt>\ncmp    $0x2,%rax\nja     1193 <func0+0x2a>\nmov    $0x0,%eax\njmp    1211 <func0+0xa8>\nmovl   $0x2,-0x14(%rbp)\njmp    11f5 <func0+0x8c>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     11ea <func0+0x81>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\ncltq\nlea    -0x2(%rax),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    11f1 <func0+0x88>\nmov    $0x0,%eax\njmp    1211 <func0+0xa8>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1060 <strlen@plt>\ncmp    %rax,%rbx\njb     119c <func0+0x33>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 80,
        "type": "O1",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    $0x0,%edx\ncmp    $0x2,%rax\njbe    11ab <func0+0x42>\nmov    %rbx,%rdx\nlea    -0x2(%rbx,%rax,1),%rcx\nmovzbl 0x2(%rdx),%eax\ncmp    0x1(%rdx),%al\nje     11a6 <func0+0x3d>\ncmp    (%rdx),%al\nje     11af <func0+0x46>\nadd    $0x1,%rdx\ncmp    %rcx,%rdx\njne    1189 <func0+0x20>\nmov    $0x1,%edx\njmp    11ab <func0+0x42>\nmov    $0x0,%edx\nmov    %edx,%eax\npop    %rbx\nret\nmov    $0x0,%edx\njmp    11ab <func0+0x42>\n"
    },
    {
        "task_id": 80,
        "type": "O2",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nxor    %r8d,%r8d\ncmp    $0x2,%rax\njbe    1349 <func0+0x39>\nmov    %rbx,%rdi\nlea    -0x2(%rbx,%rax,1),%rdx\njmp    133d <func0+0x2d>\ncmp    (%rdi),%al\nje     1346 <func0+0x36>\nadd    $0x1,%rdi\ncmp    %rdx,%rdi\nje     1350 <func0+0x40>\nmovzbl 0x2(%rdi),%eax\ncmp    0x1(%rdi),%al\njne    1330 <func0+0x20>\nxor    %r8d,%r8d\nmov    %r8d,%eax\npop    %rbx\nret\nxchg   %ax,%ax\nmov    $0x1,%r8d\npop    %rbx\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 80,
        "type": "O3",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nxor    %r8d,%r8d\ncmp    $0x2,%rax\njbe    1349 <func0+0x39>\nmov    %rbx,%rdi\nlea    -0x2(%rbx,%rax,1),%rdx\njmp    133d <func0+0x2d>\ncmp    (%rdi),%al\nje     1346 <func0+0x36>\nadd    $0x1,%rdi\ncmp    %rdx,%rdi\nje     1350 <func0+0x40>\nmovzbl 0x2(%rdi),%eax\ncmp    0x1(%rdi),%al\njne    1330 <func0+0x20>\nxor    %r8d,%r8d\nmov    %r8d,%eax\npop    %rbx\nret\nxchg   %ax,%ax\nmov    $0x1,%r8d\npop    %rbx\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 81,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1585 <func0+0x3bc>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xedf(%rip),%xmm0\n00\njb     1246 <func0+0x7d>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xdca(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xe9e(%rip),%xmm0\n00\njbe    128f <func0+0xc6>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xd84(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xe5d(%rip),%xmm0\n00\njbe    12d8 <func0+0x10f>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xd3d(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xe1c(%rip),%xmm0\n00\njbe    1321 <func0+0x158>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xcf7(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xddb(%rip),%xmm0\n00\njbe    136a <func0+0x1a1>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xcb1(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xd9a(%rip),%xmm0\n00\njbe    13b3 <func0+0x1ea>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xc6a(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xd59(%rip),%xmm0\n00\njbe    13fc <func0+0x233>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xc24(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xd18(%rip),%xmm0\n00\njbe    1445 <func0+0x27c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xbde(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xcd7(%rip),%xmm0\n00\njbe    148e <func0+0x2c5>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xb97(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xc96(%rip),%xmm0\n00\njbe    14d7 <func0+0x30e>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xb51(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xc55(%rip),%xmm0\n00\njbe    151d <func0+0x354>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xb0b(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0xc17(%rip),%xmm0\n00\njbe    1563 <func0+0x39a>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xac7(%rip),%rdx\nmov    %rdx,(%rax)\njmp    1581 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0xaaa(%rip),%rdx\nmov    %rdx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     11fd <func0+0x34>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 81,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    %esi,%ebp\nmovslq %esi,%rdi\nshl    $0x3,%rdi\ncall   10d0 <malloc@plt>\ntest   %ebp,%ebp\njle    1346 <func0+0x17d>\nmov    %rbx,%rcx\nmov    %rax,%rdx\nmov    %ebp,%ebp\nlea    (%rax,%rbp,8),%rsi\nmovsd  0xef8(%rip),%xmm1\n00\nmovsd  0xef8(%rip),%xmm2\n00\nmovsd  0xef8(%rip),%xmm3\n00\njmp    1233 <func0+0x6a>\ncomisd %xmm2,%xmm0\njbe    124d <func0+0x84>\nlea    0xde8(%rip),%rdi\nmov    %rdi,(%rdx)\nadd    $0x4,%rcx\nadd    $0x8,%rdx\ncmp    %rsi,%rdx\nje     1346 <func0+0x17d>\npxor   %xmm0,%xmm0\ncvtss2sd (%rcx),%xmm0\ncomisd %xmm1,%xmm0\njb     1212 <func0+0x49>\nlea    0xdbc(%rip),%rbx\nmov    %rbx,(%rdx)\njmp    1222 <func0+0x59>\ncomisd %xmm3,%xmm0\njbe    125f <func0+0x96>\nlea    0xdaf(%rip),%rbx\nmov    %rbx,(%rdx)\njmp    1222 <func0+0x59>\ncomisd 0xea9(%rip),%xmm0\n00\njbe    1275 <func0+0xac>\nlea    0xd9c(%rip),%rbx\nmov    %rbx,(%rdx)\njmp    1222 <func0+0x59>\ncomisd 0xe9b(%rip),%xmm0\n00\njbe    128b <func0+0xc2>\nlea    0xd89(%rip),%rdi\nmov    %rdi,(%rdx)\njmp    1222 <func0+0x59>\ncomisd 0xe8d(%rip),%xmm0\n00\njbe    12a1 <func0+0xd8>\nlea    0xd75(%rip),%rdi\nmov    %rdi,(%rdx)\njmp    1222 <func0+0x59>\ncomisd 0xe7f(%rip),%xmm0\n00\njbe    12ba <func0+0xf1>\nlea    0xd62(%rip),%rdi\nmov    %rdi,(%rdx)\njmp    1222 <func0+0x59>\ncomisd 0xe6e(%rip),%xmm0\n00\njbe    12d3 <func0+0x10a>\nlea    0xd4c(%rip),%rdi\nmov    %rdi,(%rdx)\njmp    1222 <func0+0x59>\ncomisd 0xe5d(%rip),%xmm0\n00\njbe    12ec <func0+0x123>\nlea    0xd35(%rip),%rdi\nmov    %rdi,(%rdx)\njmp    1222 <func0+0x59>\ncomisd 0xe4c(%rip),%xmm0\n00\njbe    1305 <func0+0x13c>\nlea    0xd1f(%rip),%rdi\nmov    %rdi,(%rdx)\njmp    1222 <func0+0x59>\ncomisd 0xe3b(%rip),%xmm0\n00\njbe    131e <func0+0x155>\nlea    0xd09(%rip),%rdi\nmov    %rdi,(%rdx)\njmp    1222 <func0+0x59>\ncomisd 0xe2a(%rip),%xmm0\n00\njbe    1337 <func0+0x16e>\nlea    0xcf2(%rip),%rbx\nmov    %rbx,(%rdx)\njmp    1222 <func0+0x59>\nlea    0xce6(%rip),%rdi\nmov    %rdi,(%rdx)\njmp    1222 <func0+0x59>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 81,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmovslq %esi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nlea    0x0(,%rbp,8),%rdi\n00\ncall   10d0 <malloc@plt>\nmovsd  0xb95(%rip),%xmm1\n00\ntest   %ebp,%ebp\njle    15ed <func0+0xad>\nxor    %edx,%edx\nmovsd  0xb8b(%rip),%xmm2\n00\nmovsd  0xb8b(%rip),%xmm3\n00\nlea    0xa80(%rip),%rsi\nlea    0xa7c(%rip),%rdi\nlea    0xa77(%rip),%r8\nlea    0xa73(%rip),%r9\nlea    0xa6f(%rip),%r10\npxor   %xmm0,%xmm0\nmov    %rsi,%rcx\ncvtss2sd (%rbx,%rdx,4),%xmm0\ncomisd %xmm1,%xmm0\njae    15e0 <func0+0xa0>\ncomisd %xmm2,%xmm0\nmov    %rdi,%rcx\nja     15e0 <func0+0xa0>\ncomisd %xmm3,%xmm0\nmov    %r8,%rcx\nja     15e0 <func0+0xa0>\ncomisd 0xb44(%rip),%xmm0\n00\nmov    %r9,%rcx\nja     15e0 <func0+0xa0>\ncomisd 0xb3f(%rip),%xmm0\n00\nmov    %r10,%rcx\njbe    15f8 <func0+0xb8>\nxchg   %ax,%ax\nmov    %rcx,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rbp,%rdx\njne    15a0 <func0+0x60>\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\ncomisd 0xb20(%rip),%xmm0\n00\nlea    0xa0a(%rip),%rcx\nja     15e0 <func0+0xa0>\ncomisd 0xb17(%rip),%xmm0\n00\nlea    0x9fc(%rip),%rcx\nja     15e0 <func0+0xa0>\ncomisd 0xb0e(%rip),%xmm0\n00\nlea    0x9ee(%rip),%rcx\nja     15e0 <func0+0xa0>\ncomisd 0xb05(%rip),%xmm0\n00\nlea    0x9df(%rip),%rcx\nja     15e0 <func0+0xa0>\ncomisd 0xafc(%rip),%xmm0\n00\nlea    0x9d1(%rip),%rcx\nja     15e0 <func0+0xa0>\ncomisd 0xaf3(%rip),%xmm0\n00\nlea    0x9c3(%rip),%rcx\nja     15e0 <func0+0xa0>\ncomisd 0xaea(%rip),%xmm0\n00\nlea    0x9b4(%rip),%rcx\nlea    0x9b0(%rip),%r11\ncmovbe %r11,%rcx\njmp    15e0 <func0+0xa0>\nnopl   (%rax)\n"
    },
    {
        "task_id": 81,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmovslq %esi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nlea    0x0(,%rbp,8),%rdi\n00\ncall   10d0 <malloc@plt>\nmovsd  0xb85(%rip),%xmm1\n00\ntest   %ebp,%ebp\njle    15fd <func0+0xad>\nxor    %edx,%edx\nmovsd  0xb7b(%rip),%xmm2\n00\nmovsd  0xb7b(%rip),%xmm3\n00\nlea    0xa70(%rip),%rsi\nlea    0xa6c(%rip),%rdi\nlea    0xa67(%rip),%r8\nlea    0xa63(%rip),%r9\nlea    0xa5f(%rip),%r10\npxor   %xmm0,%xmm0\nmov    %rsi,%rcx\ncvtss2sd (%rbx,%rdx,4),%xmm0\ncomisd %xmm1,%xmm0\njae    15f0 <func0+0xa0>\ncomisd %xmm2,%xmm0\nmov    %rdi,%rcx\nja     15f0 <func0+0xa0>\ncomisd %xmm3,%xmm0\nmov    %r8,%rcx\nja     15f0 <func0+0xa0>\ncomisd 0xb34(%rip),%xmm0\n00\nmov    %r9,%rcx\nja     15f0 <func0+0xa0>\ncomisd 0xb2f(%rip),%xmm0\n00\nmov    %r10,%rcx\njbe    1608 <func0+0xb8>\nxchg   %ax,%ax\nmov    %rcx,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rbp,%rdx\njne    15b0 <func0+0x60>\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\ncomisd 0xb10(%rip),%xmm0\n00\nlea    0x9fa(%rip),%rcx\nja     15f0 <func0+0xa0>\ncomisd 0xb07(%rip),%xmm0\n00\nlea    0x9ec(%rip),%rcx\nja     15f0 <func0+0xa0>\ncomisd 0xafe(%rip),%xmm0\n00\nlea    0x9de(%rip),%rcx\nja     15f0 <func0+0xa0>\ncomisd 0xaf5(%rip),%xmm0\n00\nlea    0x9cf(%rip),%rcx\nja     15f0 <func0+0xa0>\ncomisd 0xaec(%rip),%xmm0\n00\nlea    0x9c1(%rip),%rcx\nja     15f0 <func0+0xa0>\ncomisd 0xae3(%rip),%xmm0\n00\nlea    0x9b3(%rip),%rcx\nja     15f0 <func0+0xa0>\ncomisd 0xada(%rip),%xmm0\n00\nlea    0x9a4(%rip),%rcx\nlea    0x9a0(%rip),%r11\ncmovbe %r11,%rcx\njmp    15f0 <func0+0xa0>\nnopl   (%rax)\n"
    },
    {
        "task_id": 82,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1060 <strlen@plt>\nmov    %eax,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njg     1195 <func0+0x2c>\nmov    $0x0,%eax\njmp    11c6 <func0+0x5d>\nmovl   $0x2,-0x8(%rbp)\njmp    11b6 <func0+0x4d>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    11b2 <func0+0x49>\nmov    $0x0,%eax\njmp    11c6 <func0+0x5d>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x4(%rbp)\njge    119e <func0+0x35>\nmov    $0x1,%eax\nleave\nret\n"
    },
    {
        "task_id": 82,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\ncall   1060 <strlen@plt>\nmov    $0x0,%edx\ncmp    $0x1,%eax\njle    11b1 <func0+0x48>\nmov    %eax,%esi\ncmp    $0x3,%eax\njle    11b8 <func0+0x4f>\ntest   $0x1,%al\nje     11bf <func0+0x56>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njg     11ac <func0+0x43>\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    1190 <func0+0x27>\nmov    $0x0,%edx\njmp    11b1 <func0+0x48>\nmov    $0x1,%edx\nmov    %edx,%eax\nadd    $0x8,%rsp\nret\nmov    $0x1,%edx\njmp    11b1 <func0+0x48>\nmov    $0x0,%edx\njmp    11b1 <func0+0x48>\n"
    },
    {
        "task_id": 82,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\ncall   1060 <strlen@plt>\nxor    %r8d,%r8d\ncmp    $0x1,%eax\njle    14fb <func0+0x4b>\ncmp    $0x3,%eax\njle    14f5 <func0+0x45>\ntest   $0x1,%al\nje     14fb <func0+0x4b>\nmov    %eax,%esi\nmov    $0x2,%ecx\njmp    14e9 <func0+0x39>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1508 <func0+0x58>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njle    14e0 <func0+0x30>\nmov    $0x1,%r8d\nmov    %r8d,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nadd    $0x8,%rsp\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 82,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\ncall   1060 <strlen@plt>\nxor    %r8d,%r8d\ncmp    $0x1,%eax\njle    14fb <func0+0x4b>\ncmp    $0x3,%eax\njle    14f5 <func0+0x45>\ntest   $0x1,%al\nje     14fb <func0+0x4b>\nmov    %eax,%esi\nmov    $0x2,%ecx\njmp    14e9 <func0+0x39>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1508 <func0+0x58>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njle    14e0 <func0+0x30>\nmov    $0x1,%r8d\nmov    %r8d,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nadd    $0x8,%rsp\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 83,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     1161 <func0+0x18>\nmov    $0x0,%eax\njmp    119c <func0+0x53>\ncmpl   $0x1,-0x14(%rbp)\njne    116e <func0+0x25>\nmov    $0x1,%eax\njmp    119c <func0+0x53>\nmovl   $0x12,-0x8(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    1191 <func0+0x48>\nmov    -0x8(%rbp),%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     117e <func0+0x35>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 83,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%eax\ntest   %edi,%edi\njle    117e <func0+0x35>\nmov    %edi,%eax\ncmp    $0x1,%edi\nje     117e <func0+0x35>\ncmp    $0x2,%edi\njle    1179 <func0+0x30>\nmov    $0x2,%edx\nmov    $0x12,%eax\nlea    (%rax,%rax,4),%eax\nadd    %eax,%eax\nadd    $0x1,%edx\ncmp    %edx,%edi\njne    116c <func0+0x23>\nret\nmov    $0x12,%eax\nret\n"
    },
    {
        "task_id": 83,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ntest   %edi,%edi\njle    117d <func0+0x3d>\nmov    $0x1,%eax\ncmp    $0x1,%edi\nje     117d <func0+0x3d>\ncmp    $0x2,%edi\nje     1178 <func0+0x38>\nmov    $0x2,%edx\nmov    $0x12,%eax\nnopl   0x0(%rax,%rax,1)\nlea    (%rax,%rax,4),%eax\nadd    $0x1,%edx\nadd    %eax,%eax\ncmp    %edx,%edi\njne    1168 <func0+0x28>\nret\nnopl   (%rax)\nmov    $0x12,%eax\nret\n"
    },
    {
        "task_id": 83,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ntest   %edi,%edi\njle    11b5 <func0+0x75>\nmov    $0x1,%eax\ncmp    $0x1,%edi\nje     11b5 <func0+0x75>\ncmp    $0x2,%edi\nje     11b0 <func0+0x70>\nlea    -0x2(%rdi),%ecx\ncmp    $0x3,%edi\nje     11b6 <func0+0x76>\nmovq   0xe9f(%rip),%xmm0\n00\nmov    %ecx,%edx\nxor    %eax,%eax\nshr    %edx\nnop\nmovdqa %xmm0,%xmm1\nadd    $0x1,%eax\npslld  $0x2,%xmm1\npaddd  %xmm1,%xmm0\npslld  $0x1,%xmm0\ncmp    %eax,%edx\njne    1170 <func0+0x30>\nmovd   %xmm0,%edx\npshufd $0xe5,%xmm0,%xmm2\nmovd   %xmm2,%eax\nimul   %edx,%eax\nlea    (%rax,%rax,8),%eax\nadd    %eax,%eax\nand    $0x1,%ecx\nje     11c0 <func0+0x80>\nlea    (%rax,%rax,4),%eax\nadd    %eax,%eax\nret\nnopl   0x0(%rax)\nmov    $0x12,%eax\nret\nmov    $0x12,%eax\njmp    11a3 <func0+0x63>\nnopl   (%rax)\nret\n"
    },
    {
        "task_id": 84,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %edi,-0x34(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x34(%rbp),%edx\nlea    -0xe(%rbp),%rax\nlea    0xdef(%rip),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   10f0 <sprintf@plt>\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    124c <func0+0x63>\nmov    -0x24(%rbp),%eax\ncltq\nmovzbl -0xe(%rbp,%rax,1),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nadd    %eax,-0x28(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nmovzbl -0xe(%rbp,%rax,1),%eax\ntest   %al,%al\njne    1235 <func0+0x4c>\nmov    $0x21,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x20(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njne    12c4 <func0+0xdb>\nmov    -0x20(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x20(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\njmp    12ca <func0+0xe1>\nmov    -0x28(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nlea    0x30(%rax),%ecx\nmov    -0x20(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x20(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x28(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x28(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njg     128d <func0+0xa4>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x1c(%rbp)\njmp    1338 <func0+0x14f>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x29(%rbp)\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x29(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x1c(%rbp)\njl     12e3 <func0+0xfa>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     1361 <func0+0x178>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 84,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nsub    $0x10,%rsp\nmov    %edi,%r8d\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nlea    0x2(%rsp),%rdi\nlea    0xdf3(%rip),%rcx\nmov    $0x6,%edx\nmov    $0x1,%esi\ncall   10f0 <__sprintf_chk@plt>\nmovzbl 0x2(%rsp),%eax\ntest   %al,%al\nje     12f1 <func0+0x108>\nlea    0x2(%rsp),%rdx\nmov    $0x0,%ebx\nmovsbl %al,%eax\nlea    -0x30(%rbx,%rax,1),%ebx\nadd    $0x1,%rdx\nmovzbl (%rdx),%eax\ntest   %al,%al\njne    1237 <func0+0x4e>\nmov    $0x21,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%rcx\ntest   %ebx,%ebx\nje     12fe <func0+0x115>\nmov    $0x1,%edx\nmov    $0x0,%eax\njle    1306 <func0+0x11d>\nmov    %edx,%edi\nmov    %ebx,%esi\nshr    $0x1f,%esi\nlea    (%rbx,%rsi,1),%eax\nand    $0x1,%eax\nsub    %esi,%eax\nadd    $0x30,%eax\nmov    %al,-0x1(%rcx,%rdx,1)\nmov    %ebx,%esi\nmov    %ebx,%eax\nshr    $0x1f,%eax\nadd    %ebx,%eax\nsar    %eax\nmov    %eax,%ebx\nadd    $0x1,%rdx\ncmp    $0x1,%esi\njg     126e <func0+0x85>\nmovslq %edi,%rax\nmovb   $0x0,(%rcx,%rax,1)\nmov    %edi,%r8d\nshr    $0x1f,%r8d\nadd    %edi,%r8d\nsar    %r8d\ncmp    $0x1,%edi\njle    12d8 <func0+0xef>\nlea    -0x1(%rcx,%rax,1),%rdx\nmov    $0x0,%eax\nmovzbl (%rcx,%rax,1),%esi\nmovzbl (%rdx),%edi\nmov    %dil,(%rcx,%rax,1)\nmov    %sil,(%rdx)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%r8d\njg     12bd <func0+0xd4>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    130e <func0+0x125>\nmov    %rcx,%rax\nadd    $0x10,%rsp\npop    %rbx\nret\nmov    $0x21,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%rcx\nmovb   $0x30,(%rcx)\nmov    $0x1,%eax\ncltq\nmovb   $0x0,(%rcx,%rax,1)\njmp    12d8 <func0+0xef>\ncall   10b0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 84,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%r8d\nlea    0xc95(%rip),%rcx\nmov    $0x6,%edx\nmov    $0x1,%esi\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nlea    0x2(%rsp),%rbx\nmov    %rbx,%rdi\ncall   10f0 <__sprintf_chk@plt>\nmovsbl 0x2(%rsp),%eax\ntest   %al,%al\nje     1458 <func0+0xf8>\nmov    %rbx,%rdx\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nadd    $0x1,%rdx\nlea    -0x30(%rbx,%rax,1),%ebx\nmovsbl (%rdx),%eax\ntest   %al,%al\njne    13b0 <func0+0x50>\nmov    $0x21,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%r8\ntest   %ebx,%ebx\nje     1465 <func0+0x105>\nmov    $0x1,%eax\njle    1472 <func0+0x112>\nnop\nmov    %ebx,%edx\nmov    %eax,%ecx\nand    $0x1,%edx\nadd    $0x30,%edx\nmov    %dl,-0x1(%r8,%rax,1)\nadd    $0x1,%rax\nsar    %ebx\njne    13e0 <func0+0x80>\nmovslq %ecx,%rsi\nsar    %ecx\nmovb   $0x0,(%r8,%rsi,1)\nje     143a <func0+0xda>\nlea    -0x2(%r8,%rsi,1),%rdi\nsub    $0x1,%ecx\nlea    -0x1(%r8,%rsi,1),%rax\nmov    %r8,%rdx\nsub    %rcx,%rdi\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovzbl (%rdx),%ecx\nmovzbl (%rax),%esi\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %sil,-0x1(%rdx)\nmov    %cl,0x1(%rax)\ncmp    %rax,%rdi\njne    1420 <func0+0xc0>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1477 <func0+0x117>\nadd    $0x10,%rsp\nmov    %r8,%rax\npop    %rbx\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x21,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%r8\nmovb   $0x30,(%r8)\nlea    0x1(%r8),%rax\nmovb   $0x0,(%rax)\njmp    143a <func0+0xda>\nmov    %r8,%rax\njmp    146d <func0+0x10d>\ncall   10b0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 84,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%r8d\nlea    0xc95(%rip),%rcx\nmov    $0x6,%edx\nmov    $0x1,%esi\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nlea    0x2(%rsp),%rdi\ncall   10f0 <__sprintf_chk@plt>\nmovsbl 0x2(%rsp),%ebx\ntest   %bl,%bl\nje     1478 <func0+0x118>\nmovsbl 0x3(%rsp),%eax\nsub    $0x30,%ebx\ntest   %al,%al\nje     13db <func0+0x7b>\nlea    -0x30(%rbx,%rax,1),%ebx\nmovsbl 0x4(%rsp),%eax\ntest   %al,%al\nje     13db <func0+0x7b>\nlea    -0x30(%rbx,%rax,1),%ebx\nmovsbl 0x5(%rsp),%eax\ntest   %al,%al\nje     13db <func0+0x7b>\nlea    -0x30(%rbx,%rax,1),%ebx\nmovsbl 0x6(%rsp),%eax\ntest   %al,%al\nje     13db <func0+0x7b>\nlea    -0x30(%rbx,%rax,1),%ebx\nmov    $0x21,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%r8\ntest   %ebx,%ebx\nje     1485 <func0+0x125>\nmov    $0x1,%eax\njle    1492 <func0+0x132>\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%edx\nmov    %eax,%ecx\nand    $0x1,%edx\nadd    $0x30,%edx\nmov    %dl,-0x1(%r8,%rax,1)\nadd    $0x1,%rax\nsar    %ebx\njne    1400 <func0+0xa0>\nmovslq %ecx,%rsi\nsar    %ecx\nmovb   $0x0,(%r8,%rsi,1)\nje     145a <func0+0xfa>\nlea    -0x2(%r8,%rsi,1),%rdi\nsub    $0x1,%ecx\nlea    -0x1(%r8,%rsi,1),%rax\nmov    %r8,%rdx\nsub    %rcx,%rdi\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovzbl (%rdx),%ecx\nmovzbl (%rax),%esi\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %sil,-0x1(%rdx)\nmov    %cl,0x1(%rax)\ncmp    %rax,%rdi\njne    1440 <func0+0xe0>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1497 <func0+0x137>\nadd    $0x10,%rsp\nmov    %r8,%rax\npop    %rbx\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x21,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%r8\nmovb   $0x30,(%r8)\nlea    0x1(%r8),%rax\nmovb   $0x0,(%rax)\njmp    145a <func0+0xfa>\nmov    %r8,%rax\njmp    148d <func0+0x12d>\ncall   10b0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 85,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11ce <func0+0x65>\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    11ca <func0+0x61>\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\ncmp    %eax,-0x1c(%rbp)\njg     1188 <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 85,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    119e <func0+0x35>\nlea    0x4(%rdi),%rax\nsub    $0x2,%esi\nshr    %esi\nmov    %esi,%esi\nlea    0xc(%rdi,%rsi,8),%rdi\nmov    $0x0,%edx\nmov    (%rax),%ecx\nlea    (%rdx,%rcx,1),%esi\ntest   $0x1,%cl\ncmove  %esi,%edx\nadd    $0x8,%rax\ncmp    %rdi,%rax\njne    1187 <func0+0x1e>\nmov    %edx,%eax\nret\nmov    $0x0,%edx\njmp    119b <func0+0x32>\n"
    },
    {
        "task_id": 85,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    1330 <func0+0x40>\nsub    $0x2,%esi\nlea    0x4(%rdi),%rax\nxor    %r8d,%r8d\nshr    %esi\nlea    0xc(%rdi,%rsi,8),%rsi\nnopw   0x0(%rax,%rax,1)\nmov    (%rax),%edx\nlea    (%r8,%rdx,1),%ecx\nand    $0x1,%edx\ncmove  %ecx,%r8d\nadd    $0x8,%rax\ncmp    %rsi,%rax\njne    1310 <func0+0x20>\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 85,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rdx\nmov    %esi,%ecx\ncmp    $0x1,%esi\njle    1240 <func0+0x100>\nlea    -0x2(%rsi),%esi\ncmp    $0x7,%esi\njbe    1243 <func0+0x103>\nshr    $0x3,%esi\nlea    0x4(%rdi),%rax\npxor   %xmm2,%xmm2\nmovdqa 0xe9f(%rip),%xmm4\n00\nlea    -0x1(%rsi),%edi\nmovdqa %xmm2,%xmm3\nshl    $0x5,%rdi\nlea    0x24(%rdx,%rdi,1),%rdi\nnopl   0x0(%rax)\nmovdqu (%rax),%xmm1\nmovdqu 0x10(%rax),%xmm5\nadd    $0x20,%rax\nshufps $0x88,%xmm5,%xmm1\nmovdqa %xmm1,%xmm0\npand   %xmm4,%xmm0\npcmpeqd %xmm3,%xmm0\npand   %xmm1,%xmm0\npaddd  %xmm0,%xmm2\ncmp    %rax,%rdi\njne    1188 <func0+0x48>\nmovdqa %xmm2,%xmm0\nlea    0x0(,%rsi,4),%edi\nlea    0x1(,%rsi,8),%esi\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm2\nmovdqa %xmm2,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm2\nmovd   %xmm2,%eax\nmovslq %esi,%rsi\nmov    (%rdx,%rsi,4),%esi\nlea    (%rax,%rsi,1),%r8d\nand    $0x1,%esi\nlea    0x2(%rdi,%rdi,1),%esi\nlea    0x1(%rsi),%edi\ncmove  %r8d,%eax\ncmp    %edi,%ecx\njle    1242 <func0+0x102>\nmovslq %edi,%rdi\nmov    (%rdx,%rdi,4),%edi\nlea    (%rax,%rdi,1),%r8d\nand    $0x1,%edi\nlea    0x3(%rsi),%edi\ncmove  %r8d,%eax\ncmp    %edi,%ecx\njle    1242 <func0+0x102>\nmovslq %edi,%rdi\nmov    (%rdx,%rdi,4),%edi\nlea    (%rax,%rdi,1),%r8d\nand    $0x1,%edi\ncmove  %r8d,%eax\nadd    $0x5,%esi\ncmp    %esi,%ecx\njle    1242 <func0+0x102>\nmovslq %esi,%rsi\nmov    (%rdx,%rsi,4),%edx\nlea    (%rax,%rdx,1),%ecx\nand    $0x1,%edx\ncmove  %ecx,%eax\nret\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\nxor    %edi,%edi\nxor    %eax,%eax\nmov    $0x1,%esi\njmp    11de <func0+0x9e>\n"
    },
    {
        "task_id": 86,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x78(%rbp),%rax\nmov    %rax,%rdi\ncall   10b0 <strlen@plt>\nmov    %eax,-0x4c(%rbp)\nmov    -0x4c(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    %rax,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,-0x48(%rbp)\nmovl   $0x0,-0x64(%rbp)\nmovl   $0x0,-0x60(%rbp)\nmovl   $0x0,-0x5c(%rbp)\njmp    1362 <func0+0x179>\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     1271 <func0+0x88>\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    133e <func0+0x155>\nmovl   $0x0,-0x58(%rbp)\njmp    12da <func0+0xf1>\nmov    -0x58(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x54(%rbp)\njmp    12ce <func0+0xe5>\nmov    -0x58(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%edx\nmov    -0x54(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\ncmp    %al,%dl\njle    12ca <func0+0xe1>\nmov    -0x58(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\nmov    %al,-0x65(%rbp)\nmov    -0x54(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%edx\nmov    -0x58(%rbp),%eax\ncltq\nmov    %dl,-0x40(%rbp,%rax,1)\nmov    -0x54(%rbp),%eax\ncltq\nmovzbl -0x65(%rbp),%edx\nmov    %dl,-0x40(%rbp,%rax,1)\naddl   $0x1,-0x54(%rbp)\nmov    -0x54(%rbp),%eax\ncmp    -0x60(%rbp),%eax\njl     1285 <func0+0x9c>\naddl   $0x1,-0x58(%rbp)\nmov    -0x60(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x58(%rbp)\njl     127a <func0+0x91>\ncmpl   $0x0,-0x64(%rbp)\njle    1301 <func0+0x118>\nmov    -0x64(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x64(%rbp)\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x20,(%rax)\nmovl   $0x0,-0x50(%rbp)\njmp    132d <func0+0x144>\nmov    -0x64(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x64(%rbp)\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x50(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x50(%rbp)\nmov    -0x50(%rbp),%eax\ncmp    -0x60(%rbp),%eax\njl     130a <func0+0x121>\nmovl   $0x0,-0x60(%rbp)\njmp    135e <func0+0x175>\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x78(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x60(%rbp)\nmovzbl (%rcx),%edx\ncltq\nmov    %dl,-0x40(%rbp,%rax,1)\naddl   $0x1,-0x5c(%rbp)\nmov    -0x5c(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njle    1245 <func0+0x5c>\nmov    -0x64(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x48(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     1396 <func0+0x1ad>\ncall   10c0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 86,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x40,%rsp\nmov    %rdi,%rbp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncall   10b0 <strlen@plt>\nmov    %rax,%rbx\nlea    0x2(%rax),%edi\nmovslq %edi,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,%r11\ntest   %ebx,%ebx\njs     1304 <func0+0x11b>\nmov    %rbp,%r10\nmov    %ebx,%ebx\nlea    0x1(%rbp,%rbx,1),%rbp\nmov    $0x0,%r9d\nmov    $0x0,%ebx\nmov    $0x0,%r12d\nmov    %rsp,%r13\njmp    12e7 <func0+0xfe>\ncmp    $0x1,%r9d\njle    129f <func0+0xb6>\nmov    %rsp,%rsi\nlea    -0x1(%r9),%r14d\nmov    $0x0,%r8d\njmp    1286 <func0+0x9d>\nadd    $0x1,%rax\ncmp    %rdi,%rax\nje     127d <func0+0x94>\nmovzbl (%rsi),%edx\nmovzbl 0x1(%rax),%ecx\ncmp    %cl,%dl\njle    1262 <func0+0x79>\nmov    %cl,(%rsi)\nmov    %dl,0x1(%rax)\njmp    1262 <func0+0x79>\nadd    $0x1,%rsi\ncmp    %r14d,%r8d\nje     129f <func0+0xb6>\nadd    $0x1,%r8d\ncmp    %r9d,%r8d\njge    127d <func0+0x94>\nmov    %r14d,%eax\nsub    %r8d,%eax\nlea    0x1(%rsi,%rax,1),%rdi\nmov    %rsi,%rax\njmp    126b <func0+0x82>\ntest   %ebx,%ebx\njle    12ae <func0+0xc5>\nmovslq %ebx,%rax\nmovb   $0x20,(%r11,%rax,1)\nlea    0x1(%rbx),%ebx\ntest   %r9d,%r9d\njle    12ff <func0+0x116>\nmovslq %ebx,%rdx\nmov    %r9d,%edi\nmov    %r9d,%ecx\nadd    %rdx,%rcx\nmov    %rdx,%rax\nmov    %r13,%rsi\nsub    %rdx,%rsi\nmovzbl (%rsi,%rax,1),%edx\nmov    %dl,(%r11,%rax,1)\nadd    $0x1,%rax\ncmp    %rax,%rcx\njne    12c8 <func0+0xdf>\nadd    %edi,%ebx\nmov    %r12d,%r9d\nadd    $0x1,%r10\ncmp    %rbp,%r10\nje     1309 <func0+0x120>\nmovzbl (%r10),%eax\ntest   $0xdf,%al\nje     124d <func0+0x64>\nmovslq %r9d,%rdx\nmov    %al,(%rsp,%rdx,1)\nlea    0x1(%r9),%r9d\njmp    12de <func0+0xf5>\nmov    %r12d,%r9d\njmp    12de <func0+0xf5>\nmov    $0x0,%ebx\nmovslq %ebx,%rbx\nmovb   $0x0,(%r11,%rbx,1)\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1331 <func0+0x148>\nmov    %r11,%rax\nadd    $0x40,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10c0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 86,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncall   10c0 <strlen@plt>\nlea    0x2(%rax),%edi\nmov    %rax,%rbx\nmovslq %edi,%rdi\ncall   1110 <malloc@plt>\nmov    %rax,%r14\ntest   %ebx,%ebx\njs     1537 <func0+0x107>\nmov    %ebx,%ebx\nxor    %r12d,%r12d\nmov    %rsp,%r15\nlea    0x1(%rbp,%rbx,1),%r13\nxor    %ebx,%ebx\njmp    149e <func0+0x6e>\nnopl   0x0(%rax)\nmovslq %ebx,%rdx\nadd    $0x1,%ebx\nmov    %al,(%rsp,%rdx,1)\nadd    $0x1,%rbp\ncmp    %r13,%rbp\nje     1531 <func0+0x101>\nmovzbl 0x0(%rbp),%eax\ntest   $0xdf,%al\njne    1488 <func0+0x58>\nlea    -0x1(%rbx),%r10d\nmov    %r15,%rsi\nxor    %r8d,%r8d\ntest   %r10d,%r10d\njle    14f9 <func0+0xc9>\nnopl   (%rax)\nadd    $0x1,%r8d\ncmp    %ebx,%r8d\njge    1560 <func0+0x130>\nmov    %r10d,%edi\nlea    0x1(%rsi),%r9\nmov    %rsi,%rax\nsub    %r8d,%edi\nadd    %r9,%rdi\nnopl   (%rax)\nmovzbl (%rsi),%edx\nmovzbl 0x1(%rax),%ecx\ncmp    %cl,%dl\njle    14e8 <func0+0xb8>\nmov    %cl,(%rsi)\nmov    %dl,0x1(%rax)\nadd    $0x1,%rax\ncmp    %rax,%rdi\njne    14d8 <func0+0xa8>\nmov    %r9,%rsi\ncmp    %r10d,%r8d\njne    14b8 <func0+0x88>\ntest   %r12d,%r12d\nje     150a <func0+0xda>\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmovb   $0x20,(%r14,%rax,1)\ntest   %ebx,%ebx\nje     1491 <func0+0x61>\nmovslq %r12d,%rdi\nmovslq %ebx,%rdx\nmov    %r15,%rsi\nadd    $0x1,%rbp\nadd    %r14,%rdi\nadd    %ebx,%r12d\nxor    %ebx,%ebx\ncall   1100 <memcpy@plt>\ncmp    %r13,%rbp\njne    149e <func0+0x6e>\nmovslq %r12d,%rax\nadd    %r14,%rax\nmovb   $0x0,(%rax)\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1572 <func0+0x142>\nadd    $0x48,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nlea    0x1(%rsi),%r9\nmov    %r9,%rsi\ncmp    %r10d,%r8d\njne    14b8 <func0+0x88>\njmp    14f9 <func0+0xc9>\ncall   10d0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 86,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncall   10c0 <strlen@plt>\nlea    0x2(%rax),%edi\nmov    %rax,%rbx\nmovslq %edi,%rdi\ncall   1110 <malloc@plt>\nmov    %rax,%r14\ntest   %ebx,%ebx\njs     1537 <func0+0x107>\nmov    %ebx,%ebx\nxor    %r12d,%r12d\nmov    %rsp,%r15\nlea    0x1(%rbp,%rbx,1),%r13\nxor    %ebx,%ebx\njmp    149e <func0+0x6e>\nnopl   0x0(%rax)\nmovslq %ebx,%rdx\nadd    $0x1,%ebx\nmov    %al,(%rsp,%rdx,1)\nadd    $0x1,%rbp\ncmp    %r13,%rbp\nje     1531 <func0+0x101>\nmovzbl 0x0(%rbp),%eax\ntest   $0xdf,%al\njne    1488 <func0+0x58>\nlea    -0x1(%rbx),%r10d\nmov    %r15,%rsi\nxor    %r8d,%r8d\ntest   %r10d,%r10d\njle    14f9 <func0+0xc9>\nnopl   (%rax)\nadd    $0x1,%r8d\ncmp    %ebx,%r8d\njge    1560 <func0+0x130>\nmov    %r10d,%edi\nlea    0x1(%rsi),%r9\nmov    %rsi,%rax\nsub    %r8d,%edi\nadd    %r9,%rdi\nnopl   (%rax)\nmovzbl (%rsi),%edx\nmovzbl 0x1(%rax),%ecx\ncmp    %cl,%dl\njle    14e8 <func0+0xb8>\nmov    %cl,(%rsi)\nmov    %dl,0x1(%rax)\nadd    $0x1,%rax\ncmp    %rax,%rdi\njne    14d8 <func0+0xa8>\nmov    %r9,%rsi\ncmp    %r10d,%r8d\njne    14b8 <func0+0x88>\ntest   %r12d,%r12d\nje     150a <func0+0xda>\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmovb   $0x20,(%r14,%rax,1)\ntest   %ebx,%ebx\nje     1491 <func0+0x61>\nmovslq %r12d,%rdi\nmovslq %ebx,%rdx\nmov    %r15,%rsi\nadd    $0x1,%rbp\nadd    %r14,%rdi\nadd    %ebx,%r12d\nxor    %ebx,%ebx\ncall   1100 <memcpy@plt>\ncmp    %r13,%rbp\njne    149e <func0+0x6e>\nmovslq %r12d,%rax\nadd    %r14,%rax\nmovb   $0x0,(%rax)\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1572 <func0+0x142>\nadd    $0x48,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nlea    0x1(%rsi),%r9\nmov    %r9,%rsi\ncmp    %r10d,%r8d\njne    14b8 <func0+0x88>\njmp    14f9 <func0+0xc9>\ncall   10d0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 87,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %ecx,-0x40(%rbp)\nmov    %r8,-0x50(%rbp)\nmov    $0x320,%edi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    12a8 <func0+0xff>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nsub    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmp    129a <func0+0xf1>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x40(%rbp)\njne    1296 <func0+0xed>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    $0x8,%edi\ncall   10b0 <malloc@plt>\nmov    %rax,(%rbx)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x20(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4(%rax),%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x24(%rbp)\nsubl   $0x1,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njns    120a <func0+0x61>\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     11e9 <func0+0x40>\nmov    -0x50(%rbp),%rax\nmov    -0x24(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 87,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%r12\nmov    %esi,%ebx\nmov    %rdx,0x18(%rsp)\nmov    %ecx,%r13d\nmov    %r8,0x28(%rsp)\nmov    $0x320,%edi\ncall   10b0 <malloc@plt>\nmov    %rax,0x10(%rsp)\ntest   %ebx,%ebx\njle    1265 <func0+0xbc>\nmov    %ebx,%eax\nmov    %rax,0x20(%rsp)\nmov    $0x0,%r15d\nmov    $0x0,%r14d\njmp    1243 <func0+0x9a>\nmov    $0x8,%edi\ncall   10b0 <malloc@plt>\nmovslq %r14d,%rdx\nmov    0x10(%rsp),%rcx\nmov    %rax,(%rcx,%rdx,8)\nmov    0x8(%rsp),%esi\nmov    %esi,(%rax)\nmov    %ebx,0x4(%rax)\nadd    $0x1,%r14d\nsub    $0x1,%ebx\nsub    $0x4,%rbp\ncmp    $0xffffffff,%ebx\nje     1234 <func0+0x8b>\nmov    (%r12),%rax\ncmp    %r13d,(%rax,%rbp,1)\njne    121c <func0+0x73>\njmp    11f9 <func0+0x50>\nadd    $0x1,%r15\nadd    $0x8,%r12\ncmp    0x20(%rsp),%r15\nje     126b <func0+0xc2>\nmov    %r15d,0x8(%rsp)\nmov    0x18(%rsp),%rax\nmov    (%rax,%r15,4),%eax\nmov    %eax,0xc(%rsp)\nmov    %eax,%ebx\nsub    $0x1,%ebx\njs     1234 <func0+0x8b>\nmovslq %ebx,%rbp\nshl    $0x2,%rbp\njmp    1228 <func0+0x7f>\nmov    $0x0,%r14d\nmov    0x28(%rsp),%rax\nmov    %r14d,(%rax)\nmov    0x10(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 87,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %ecx,%r14d\npush   %r13\npush   %r12\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,0x20(%rsp)\nmov    $0x320,%edi\nmov    %rdx,0x10(%rsp)\nmov    %r8,0x28(%rsp)\ncall   10b0 <malloc@plt>\nmov    %rax,0x8(%rsp)\ntest   %ebp,%ebp\njle    146f <func0+0xdf>\nmovslq %ebp,%rax\nxor    %r15d,%r15d\nxor    %ebp,%ebp\nmov    %rax,0x18(%rsp)\nnopw   0x0(%rax,%rax,1)\nmov    0x10(%rsp),%rax\nmov    %ebp,%ebx\nmov    (%rax,%rbp,4),%eax\nmov    %eax,%edx\nmov    %eax,0x4(%rsp)\nsub    $0x1,%edx\njs     1448 <func0+0xb8>\nmov    0x20(%rsp),%rax\nmovslq %edx,%r12\nmov    (%rax,%rbp,8),%r13\njmp    1411 <func0+0x81>\nnopl   0x0(%rax,%rax,1)\nsub    $0x1,%r12\ntest   %r12d,%r12d\njs     1448 <func0+0xb8>\ncmp    %r14d,0x0(%r13,%r12,4)\njne    1408 <func0+0x78>\nmov    $0x8,%edi\ncall   10b0 <malloc@plt>\nmov    0x8(%rsp),%rcx\nmovslq %r15d,%rdi\nadd    $0x1,%r15d\nmov    %r12d,0x4(%rax)\nsub    $0x1,%r12\nmov    %rax,(%rcx,%rdi,8)\nmov    %ebx,(%rax)\ntest   %r12d,%r12d\njns    1411 <func0+0x81>\nnopl   0x0(%rax)\nadd    $0x1,%rbp\ncmp    0x18(%rsp),%rbp\njne    13e0 <func0+0x50>\nmov    0x28(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x8(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxor    %r15d,%r15d\njmp    1453 <func0+0xc3>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnop\n"
    },
    {
        "task_id": 87,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %ecx,%r14d\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,0x20(%rsp)\nmov    $0x320,%edi\nmov    %r8,0x28(%rsp)\ncall   10b0 <malloc@plt>\nmov    %rax,0x10(%rsp)\ntest   %ebp,%ebp\njle    140b <func0+0xfb>\nmovslq %ebp,%rax\nxor    %r15d,%r15d\nxor    %ebp,%ebp\nmov    %rax,0x18(%rsp)\nnopl   0x0(%rax,%rax,1)\n00\nmov    0x0(%r13,%rbp,4),%ebx\nmovd   %ebp,%xmm1\nsub    $0x1,%ebx\njs     13e0 <func0+0xd0>\nmov    0x20(%rsp),%rax\nmovslq %ebx,%rbx\nmov    (%rax,%rbp,8),%r12\njmp    1388 <func0+0x78>\nnopl   0x0(%rax)\nsub    $0x1,%rbx\ntest   %ebx,%ebx\njs     13e0 <func0+0xd0>\nmovdqa %xmm1,%xmm0\nmovd   %ebx,%xmm2\npunpckldq %xmm2,%xmm0\ncmp    %r14d,(%r12,%rbx,4)\njne    1380 <func0+0x70>\nmov    $0x8,%edi\nmovq   %xmm0,0x8(%rsp)\nsub    $0x1,%rbx\nmovd   %xmm1,0x4(%rsp)\ncall   10b0 <malloc@plt>\nmov    0x10(%rsp),%rdx\nmovslq %r15d,%rdi\nmovq   0x8(%rsp),%xmm0\nmovd   0x4(%rsp),%xmm1\nadd    $0x1,%r15d\nmov    %rax,(%rdx,%rdi,8)\nmovq   %xmm0,(%rax)\ntest   %ebx,%ebx\njns    1388 <func0+0x78>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%rbp\ncmp    %rbp,0x18(%rsp)\njne    1360 <func0+0x50>\nmov    0x28(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x10(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxor    %r15d,%r15d\njmp    13ef <func0+0xdf>\n"
    },
    {
        "task_id": 88,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmov    %edx,(%rax)\ncmpl   $0x0,-0x2c(%rbp)\njne    1203 <func0+0x3a>\nmov    -0x38(%rbp),%rax\nmovq   $0x0,(%rax)\njmp    140c <func0+0x243>\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10c0 <malloc@plt>\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    1234 <func0+0x6b>\nmov    $0x1,%edi\ncall   10d0 <exit@plt>\nmovl   $0x0,-0x18(%rbp)\njmp    126d <func0+0xa4>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     123d <func0+0x74>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %edx,%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    13fd <func0+0x234>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmp    13ed <func0+0x224>\ncmpl   $0x0,-0xc(%rbp)\nje     1360 <func0+0x197>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rcx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    13e9 <func0+0x220>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\njmp    13e9 <func0+0x220>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rcx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    13e9 <func0+0x220>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     12c4 <func0+0xfb>\naddl   $0x1,-0x14(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x14(%rbp)\njl     12b6 <func0+0xed>\nleave\nret\n"
    },
    {
        "task_id": 88,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdx,%rbx\nmov    %esi,(%rcx)\ntest   %esi,%esi\njne    11f2 <func0+0x29>\nmovq   $0x0,(%rdx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    %rdi,%r12\nmov    %esi,%ebp\nmovslq %esi,%r13\nshl    $0x2,%r13\nmov    %r13,%rdi\ncall   10c0 <malloc@plt>\nmov    %rax,(%rbx)\ntest   %rax,%rax\nje     1265 <func0+0x9c>\nmov    %ebp,%esi\nshl    $0x2,%rsi\nmov    $0x0,%eax\ntest   %ebp,%ebp\njle    1230 <func0+0x67>\nmov    (%r12,%rax,1),%ecx\nmov    (%rbx),%rdx\nmov    %ecx,(%rdx,%rax,1)\nadd    $0x4,%rax\ncmp    %rsi,%rax\njne    121d <func0+0x54>\nmov    (%r12),%eax\nadd    -0x4(%r12,%r13,1),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nlea    (%rax,%rdx,1),%r9d\nand    $0x1,%r9d\nsub    %edx,%r9d\ncmp    $0x1,%ebp\njle    11e7 <func0+0x1e>\nlea    -0x1(%rbp),%r12d\nmov    $0x0,%edi\nmov    $0x0,%r11d\nmov    $0x0,%r10d\njmp    12c1 <func0+0xf8>\nmov    $0x1,%edi\ncall   10d0 <exit@plt>\nmov    (%rbx),%rdx\nlea    (%rdx,%rdi,1),%rsi\nmov    (%rsi),%ecx\nmov    (%rdx,%rax,1),%edx\ncmp    %edx,%ecx\njle    1287 <func0+0xbe>\nmov    %edx,(%rsi)\nmov    (%rbx),%rdx\nmov    %ecx,(%rdx,%rax,1)\nadd    $0x4,%rax\ncmp    %r8,%rax\nje     12b0 <func0+0xe7>\ncmp    $0x1,%r9d\nje     126f <func0+0xa6>\nmov    (%rbx),%rdx\nlea    (%rdx,%rdi,1),%rsi\nmov    (%rsi),%ecx\nmov    (%rdx,%rax,1),%edx\ncmp    %edx,%ecx\njge    1287 <func0+0xbe>\nmov    %edx,(%rsi)\nmov    (%rbx),%rdx\nmov    %ecx,(%rdx,%rax,1)\njmp    1287 <func0+0xbe>\nadd    $0x1,%r11\nadd    $0x4,%rdi\ncmp    %r12d,%r10d\nje     11e7 <func0+0x1e>\nadd    $0x1,%r10d\ncmp    %r10d,%ebp\njle    12b0 <func0+0xe7>\nlea    0x4(%rdi),%rax\nmov    %r12d,%edx\nsub    %r10d,%edx\nlea    0x2(%r11,%rdx,1),%r8\nshl    $0x2,%r8\njmp    1290 <func0+0xc7>\n"
    },
    {
        "task_id": 88,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,(%rcx)\ntest   %esi,%esi\njne    1738 <func0+0x18>\nmovq   $0x0,(%rdx)\nret\nnopw   0x0(%rax,%rax,1)\njmp    15f0 <func0.part.0>\nnopl   (%rax)\n"
    },
    {
        "task_id": 88,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,(%rcx)\ntest   %esi,%esi\njne    16a8 <func0+0x18>\nmovq   $0x0,(%rdx)\nret\nnopw   0x0(%rax,%rax,1)\njmp    1560 <func0.part.0>\nnopl   (%rax)\n"
    },
    {
        "task_id": 89,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    11f3 <func0+0x6a>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nlea    -0x5d(%rax),%edx\nmovslq %edx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nsar    $0x3,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nimul   $0x1a,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nadd    $0x61,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x4(%rbp),%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    11a2 <func0+0x19>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 89,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r8\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     11d4 <func0+0x4b>\nmov    $0x0,%ecx\nmovsbl %al,%eax\nsub    $0x5d,%eax\nmovslq %eax,%rdx\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x23,%rdx\nmov    %eax,%edi\nsar    $0x1f,%edi\nsub    %edi,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%eax\nadd    $0x61,%eax\nmov    %al,(%rsi,%rcx,1)\nadd    $0x1,%rcx\nmovzbl (%r8,%rcx,1),%eax\ntest   %al,%al\njne    119c <func0+0x13>\nmovb   $0x0,(%rsi,%rcx,1)\nret\nmov    $0x0,%ecx\njmp    11cf <func0+0x46>\n"
    },
    {
        "task_id": 89,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsbl (%rdi),%eax\nmov    %rdi,%r8\ntest   %al,%al\nje     1433 <func0+0x43>\nxor    %ecx,%ecx\nsub    $0x5d,%eax\nmovslq %eax,%rdx\nmov    %eax,%edi\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%edi\nsar    $0x23,%rdx\nsub    %edi,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%eax\nadd    $0x61,%eax\nmov    %al,(%rsi,%rcx,1)\nadd    $0x1,%rcx\nmovsbl (%r8,%rcx,1),%eax\ntest   %al,%al\njne    1400 <func0+0x10>\nadd    %rcx,%rsi\nmovb   $0x0,(%rsi)\nret\n"
    },
    {
        "task_id": 89,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsbl (%rdi),%eax\nmov    %rdi,%r8\ntest   %al,%al\nje     1563 <func0+0x43>\nxor    %ecx,%ecx\nsub    $0x5d,%eax\nmovslq %eax,%rdx\nmov    %eax,%edi\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%edi\nsar    $0x23,%rdx\nsub    %edi,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%eax\nadd    $0x61,%eax\nmov    %al,(%rsi,%rcx,1)\nadd    $0x1,%rcx\nmovsbl (%r8,%rcx,1),%eax\ntest   %al,%al\njne    1530 <func0+0x10>\nadd    %rcx,%rsi\nmovb   $0x0,(%rsi)\nret\n"
    },
    {
        "task_id": 90,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x1,-0x1c(%rbp)\njg     1188 <func0+0x1f>\nmov    $0xffffffff,%eax\njmp    1250 <func0+0xe7>\nmovl   $0x7fffffff,-0xc(%rbp)\nmovl   $0x7fffffff,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1231 <func0+0xc8>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    11de <func0+0x75>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\njmp    122d <func0+0xc4>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x8(%rbp)\njle    122d <func0+0xc4>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\nje     122d <func0+0xc4>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     11a2 <func0+0x39>\ncmpl   $0x7fffffff,-0x8(%rbp)\njne    124d <func0+0xe4>\nmov    $0xffffffff,%eax\njmp    1250 <func0+0xe7>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 90,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    11ba <func0+0x51>\nmov    %rdi,%rcx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rdi\nmov    $0x7fffffff,%eax\nmov    $0x7fffffff,%esi\njmp    1196 <func0+0x2d>\nmov    %esi,%eax\nmov    %edx,%esi\nadd    $0x4,%rcx\ncmp    %rdi,%rcx\nje     11ac <func0+0x43>\nmov    (%rcx),%edx\ncmp    %esi,%edx\njl     1189 <func0+0x20>\nmov    %eax,%r8d\ncmp    %eax,%edx\ncmovle %edx,%eax\ncmp    %esi,%edx\ncmove  %r8d,%eax\njmp    118d <func0+0x24>\ncmp    $0x7fffffff,%eax\nje     11b4 <func0+0x4b>\nret\nmov    $0xffffffff,%eax\nret\nmov    $0xffffffff,%eax\njmp    11b3 <func0+0x4a>\n"
    },
    {
        "task_id": 90,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    1413 <func0+0x53>\nlea    -0x1(%rsi),%eax\nmov    $0x7fffffff,%r8d\nmov    $0x7fffffff,%edx\nlea    0x4(%rdi,%rax,4),%rcx\njmp    13f2 <func0+0x32>\nxchg   %ax,%ax\nje     13e9 <func0+0x29>\ncmp    %r8d,%eax\ncmovle %eax,%r8d\nadd    $0x4,%rdi\ncmp    %rdi,%rcx\nje     1406 <func0+0x46>\nmov    (%rdi),%eax\ncmp    %edx,%eax\njge    13e0 <func0+0x20>\nadd    $0x4,%rdi\nmov    %edx,%r8d\nmov    %eax,%edx\ncmp    %rdi,%rcx\njne    13f2 <func0+0x32>\ncmp    $0x7fffffff,%r8d\nje     1413 <func0+0x53>\nmov    %r8d,%eax\nret\nmov    $0xffffffff,%r8d\njmp    140f <func0+0x4f>\n"
    },
    {
        "task_id": 90,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    13d5 <func0+0x55>\nlea    -0x1(%rsi),%eax\nmov    $0x7fffffff,%r8d\nmov    $0x7fffffff,%edx\nlea    0x4(%rdi,%rax,4),%rcx\njmp    13b4 <func0+0x34>\nxchg   %ax,%ax\ncmp    %r8d,%eax\njge    13ab <func0+0x2b>\ncmp    %edx,%eax\ncmovne %eax,%r8d\nadd    $0x4,%rdi\ncmp    %rdi,%rcx\nje     13c8 <func0+0x48>\nmov    (%rdi),%eax\ncmp    %edx,%eax\njge    13a0 <func0+0x20>\nadd    $0x4,%rdi\nmov    %edx,%r8d\nmov    %eax,%edx\ncmp    %rdi,%rcx\njne    13b4 <func0+0x34>\ncmp    $0x7fffffff,%r8d\nje     13d5 <func0+0x55>\nmov    %r8d,%eax\nret\nmov    $0xffffffff,%r8d\njmp    13d1 <func0+0x51>\n"
    },
    {
        "task_id": 91,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    12b6 <func0+0x14d>\ncall   1070 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2000,%eax\ntest   %eax,%eax\nje     11dc <func0+0x73>\ncmpl   $0x0,-0xc(%rbp)\nje     11dc <func0+0x73>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x49,%al\njne    11ff <func0+0x96>\ncmpl   $0x0,-0x10(%rbp)\nje     11ff <func0+0x96>\nmovl   $0x1,-0xc(%rbp)\njmp    1237 <func0+0xce>\ncall   1070 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2000,%eax\ntest   %eax,%eax\njne    1237 <func0+0xce>\nmovl   $0x0,-0xc(%rbp)\ncall   1070 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2000,%eax\ntest   %eax,%eax\njne    126f <func0+0x106>\nmovl   $0x0,-0x10(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2e,%al\nje     12ab <func0+0x142>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x3f,%al\nje     12ab <func0+0x142>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x21,%al\njne    12b2 <func0+0x149>\nmovl   $0x1,-0x10(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    119a <func0+0x31>\nmov    -0x8(%rbp),%eax\nleave\nret\n"
    },
    {
        "task_id": 91,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebx\nmov    $0x0,%ebp\ntest   %bl,%bl\nje     1226 <func0+0xbd>\nmov    %rdi,%rbp\ncall   1070 <__ctype_b_loc@plt>\nmov    (%rax),%r9\nmovsbq %bl,%rax\nmovzwl (%r9,%rax,2),%eax\nand    $0x2000,%ax\nlea    0x1(%rbp),%rsi\nmov    $0x1,%edx\nmov    $0x0,%ebp\nmov    $0x0,%edi\nmov    $0x0,%r8d\nmovabs $0x8000400200000000,%r11\n40 00 80\nmov    $0x1,%r10d\njmp    11ca <func0+0x61>\nadd    $0x1,%rsi\ntest   %edx,%edx\nje     11d3 <func0+0x6a>\ncmp    $0x49,%bl\nje     1218 <func0+0xaf>\ntest   %ax,%ax\ncmove  %r8d,%edi\ncmove  %r8d,%edx\ncmp    $0x3f,%bl\nja     11f1 <func0+0x88>\nmov    %r11,%rax\nmov    %ebx,%ecx\nshr    %cl,%rax\ntest   $0x1,%al\ncmovne %r10d,%edx\nmovzbl (%rsi),%ebx\ntest   %bl,%bl\nje     1226 <func0+0xbd>\nmovsbq %bl,%rax\nmovzwl (%r9,%rax,2),%eax\nand    $0x2000,%ax\ntest   %edi,%edi\nje     11c6 <func0+0x5d>\ntest   %ax,%ax\nje     11c6 <func0+0x5d>\nadd    $0x1,%ebp\nmov    $0x0,%edi\njmp    11c6 <func0+0x5d>\nmov    $0x1,%edi\ntest   %ax,%ax\ncmove  %r8d,%edx\njmp    11f1 <func0+0x88>\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 91,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     1360 <func0+0xb0>\nmov    %rdi,%rbp\ncall   1070 <__ctype_b_loc@plt>\nlea    0x1(%rbp),%rdi\nxor    %r8d,%r8d\nxor    %esi,%esi\nmov    (%rax),%r9\nmov    $0x1,%edx\nmov    $0x1,%r11d\nmovabs $0x8000400200000000,%r10\n40 00 80\njmp    131b <func0+0x6b>\ncmp    $0x1,%esi\nsbb    $0xffffffff,%r8d\ntest   %al,%al\njne    1350 <func0+0xa0>\nxor    %esi,%esi\ncmp    $0x3f,%bl\nja     1310 <func0+0x60>\nmov    %r10,%rax\nmov    %ebx,%ecx\nshr    %cl,%rax\ntest   $0x1,%al\ncmovne %r11d,%edx\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\nje     1345 <func0+0x95>\ncmp    $0x49,%bl\nmovsbq %bl,%rcx\nsete   %al\nand    %edx,%eax\ntestb  $0x20,0x1(%r9,%rcx,2)\njne    12f0 <func0+0x40>\nxor    %edx,%edx\ntest   %al,%al\nje     12fb <func0+0x4b>\nmov    $0x1,%esi\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    131b <func0+0x6b>\nadd    $0x8,%rsp\nmov    %r8d,%eax\npop    %rbx\npop    %rbp\nret\nnop\nmov    $0x1,%edx\nmov    $0x1,%esi\njmp    133a <func0+0x8a>\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nxor    %r8d,%r8d\nmov    %r8d,%eax\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 91,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     1360 <func0+0xb0>\nmov    %rdi,%rbp\ncall   1070 <__ctype_b_loc@plt>\nlea    0x1(%rbp),%rdi\nxor    %r8d,%r8d\nxor    %esi,%esi\nmov    (%rax),%r9\nmov    $0x1,%edx\nmovabs $0x8000400200000000,%r11\n40 00 80\nmov    $0x1,%r10d\njmp    131b <func0+0x6b>\ncmp    $0x1,%esi\nsbb    $0xffffffff,%r8d\ntest   %al,%al\njne    1350 <func0+0xa0>\nxor    %esi,%esi\ncmp    $0x3f,%bl\nja     1310 <func0+0x60>\nmov    %r11,%rax\nmov    %ebx,%ecx\nshr    %cl,%rax\ntest   $0x1,%al\ncmovne %r10d,%edx\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\nje     1345 <func0+0x95>\ncmp    $0x49,%bl\nmovsbq %bl,%rcx\nsete   %al\nand    %edx,%eax\ntestb  $0x20,0x1(%r9,%rcx,2)\njne    12f0 <func0+0x40>\nxor    %edx,%edx\ntest   %al,%al\nje     12fb <func0+0x4b>\nmov    $0x1,%esi\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    131b <func0+0x6b>\nadd    $0x8,%rsp\nmov    %r8d,%eax\npop    %rbx\npop    %rbp\nret\nnop\nmov    $0x1,%edx\nmov    $0x1,%esi\njmp    133a <func0+0x8a>\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nxor    %r8d,%r8d\nmov    %r8d,%eax\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 92,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  %xmm2,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nmovd   %eax,%xmm0\ncall   1060 <roundf@plt>\nmovd   %xmm0,%eax\nmovd   %eax,%xmm3\nucomiss -0x4(%rbp),%xmm3\njp     11a8 <func0+0x3f>\nmovd   %eax,%xmm4\nucomiss -0x4(%rbp),%xmm4\nje     11b2 <func0+0x49>\nmov    $0x0,%eax\njmp    1256 <func0+0xed>\nmov    -0x8(%rbp),%eax\nmovd   %eax,%xmm0\ncall   1060 <roundf@plt>\nmovd   %xmm0,%eax\nmovd   %eax,%xmm5\nucomiss -0x8(%rbp),%xmm5\njp     11d6 <func0+0x6d>\nmovd   %eax,%xmm6\nucomiss -0x8(%rbp),%xmm6\nje     11dd <func0+0x74>\nmov    $0x0,%eax\njmp    1256 <func0+0xed>\nmov    -0xc(%rbp),%eax\nmovd   %eax,%xmm0\ncall   1060 <roundf@plt>\nmovd   %xmm0,%eax\nmovd   %eax,%xmm7\nucomiss -0xc(%rbp),%xmm7\njp     1201 <func0+0x98>\nmovd   %eax,%xmm1\nucomiss -0xc(%rbp),%xmm1\nje     1208 <func0+0x9f>\nmov    $0x0,%eax\njmp    1256 <func0+0xed>\nmovss  -0x4(%rbp),%xmm0\naddss  -0x8(%rbp),%xmm0\nucomiss -0xc(%rbp),%xmm0\njp     121e <func0+0xb5>\nucomiss -0xc(%rbp),%xmm0\nje     124a <func0+0xe1>\nmovss  -0x4(%rbp),%xmm0\naddss  -0xc(%rbp),%xmm0\nucomiss -0x8(%rbp),%xmm0\njp     1234 <func0+0xcb>\nucomiss -0x8(%rbp),%xmm0\nje     124a <func0+0xe1>\nmovss  -0x8(%rbp),%xmm0\naddss  -0xc(%rbp),%xmm0\nucomiss -0x4(%rbp),%xmm0\njp     1251 <func0+0xe8>\nucomiss -0x4(%rbp),%xmm0\njne    1251 <func0+0xe8>\nmov    $0x1,%eax\njmp    1256 <func0+0xed>\nmov    $0x0,%eax\nleave\nret\n"
    },
    {
        "task_id": 92,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x18,%rsp\nmovss  %xmm1,0x8(%rsp)\nmovss  %xmm2,0xc(%rsp)\nmovss  %xmm0,0x4(%rsp)\ncall   1060 <roundf@plt>\nmovss  0x4(%rsp),%xmm3\nucomiss %xmm3,%xmm0\njp     1224 <func0+0xbb>\njne    1224 <func0+0xbb>\nmovss  0x8(%rsp),%xmm0\ncall   1060 <roundf@plt>\nmovss  0x8(%rsp),%xmm4\nucomiss %xmm4,%xmm0\njp     122e <func0+0xc5>\njne    122e <func0+0xc5>\nmovss  0xc(%rsp),%xmm0\ncall   1060 <roundf@plt>\nmovss  0xc(%rsp),%xmm5\nucomiss %xmm5,%xmm0\njp     1235 <func0+0xcc>\njne    1235 <func0+0xcc>\nmovss  0x4(%rsp),%xmm0\naddss  0x8(%rsp),%xmm0\nucomiss %xmm5,%xmm0\njp     11e5 <func0+0x7c>\nmov    $0x1,%eax\nje     1229 <func0+0xc0>\nmovss  0x4(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nmovss  0x8(%rsp),%xmm6\nucomiss %xmm6,%xmm0\njp     1203 <func0+0x9a>\nmov    $0x1,%eax\nje     1229 <func0+0xc0>\nmovss  0x8(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nucomiss 0x4(%rsp),%xmm0\nsetnp  %al\nmovzbl %al,%eax\nmov    $0x0,%edx\ncmovne %edx,%eax\njmp    1229 <func0+0xc0>\nmov    $0x0,%eax\nadd    $0x18,%rsp\nret\nmov    $0x0,%eax\njmp    1229 <func0+0xc0>\nmov    $0x0,%eax\njmp    1229 <func0+0xc0>\n"
    },
    {
        "task_id": 92,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x18,%rsp\nmovss  %xmm1,0x4(%rsp)\nmovss  %xmm2,0xc(%rsp)\nmovss  %xmm0,0x8(%rsp)\ncall   1060 <roundf@plt>\nucomiss 0x8(%rsp),%xmm0\njp     14c8 <func0+0xb8>\njne    14c8 <func0+0xb8>\nmovss  0x4(%rsp),%xmm0\ncall   1060 <roundf@plt>\nucomiss 0x4(%rsp),%xmm0\njp     14c8 <func0+0xb8>\njne    14c8 <func0+0xb8>\nmovss  0xc(%rsp),%xmm0\ncall   1060 <roundf@plt>\nmovss  0xc(%rsp),%xmm5\nucomiss %xmm5,%xmm0\njp     14c8 <func0+0xb8>\njne    14c8 <func0+0xb8>\nmovss  0x8(%rsp),%xmm0\naddss  0x4(%rsp),%xmm0\nucomiss %xmm0,%xmm5\njp     1484 <func0+0x74>\nmov    $0x1,%eax\nje     14ca <func0+0xba>\nmovss  0x8(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nmovss  0x4(%rsp),%xmm7\nucomiss %xmm0,%xmm7\njp     14a2 <func0+0x92>\nmov    $0x1,%eax\nje     14ca <func0+0xba>\nmovss  0x4(%rsp),%xmm0\nxor    %eax,%eax\nmov    $0x0,%edx\naddss  0xc(%rsp),%xmm0\nucomiss 0x8(%rsp),%xmm0\nsetnp  %al\ncmovne %edx,%eax\nadd    $0x18,%rsp\nret\nnopl   (%rax)\nxor    %eax,%eax\nadd    $0x18,%rsp\nret\n"
    },
    {
        "task_id": 92,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x18,%rsp\nmovss  %xmm1,0x4(%rsp)\nmovss  %xmm2,0xc(%rsp)\nmovss  %xmm0,0x8(%rsp)\ncall   1060 <roundf@plt>\nucomiss 0x8(%rsp),%xmm0\njp     14c8 <func0+0xb8>\njne    14c8 <func0+0xb8>\nmovss  0x4(%rsp),%xmm0\ncall   1060 <roundf@plt>\nucomiss 0x4(%rsp),%xmm0\njp     14c8 <func0+0xb8>\njne    14c8 <func0+0xb8>\nmovss  0xc(%rsp),%xmm0\ncall   1060 <roundf@plt>\nmovss  0xc(%rsp),%xmm5\nucomiss %xmm5,%xmm0\njp     14c8 <func0+0xb8>\njne    14c8 <func0+0xb8>\nmovss  0x8(%rsp),%xmm0\naddss  0x4(%rsp),%xmm0\nucomiss %xmm0,%xmm5\njp     1484 <func0+0x74>\nmov    $0x1,%eax\nje     14ca <func0+0xba>\nmovss  0x8(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nmovss  0x4(%rsp),%xmm7\nucomiss %xmm0,%xmm7\njp     14a2 <func0+0x92>\nmov    $0x1,%eax\nje     14ca <func0+0xba>\nmovss  0x4(%rsp),%xmm0\nxor    %eax,%eax\nmov    $0x0,%edx\naddss  0xc(%rsp),%xmm0\nucomiss 0x8(%rsp),%xmm0\nsetnp  %al\ncmovne %edx,%eax\nadd    $0x18,%rsp\nret\nnopl   (%rax)\nxor    %eax,%eax\nadd    $0x18,%rsp\nret\n"
    },
    {
        "task_id": 93,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nlea    0xe04(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    12eb <func0+0x102>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x11(%rbp)\ncall   10f0 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmovsbq -0x11(%rbp),%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x200,%eax\ntest   %eax,%eax\nje     1259 <func0+0x70>\nmovsbl -0x11(%rbp),%eax\nmov    %eax,%edi\ncall   10a0 <toupper@plt>\nmov    %al,-0x11(%rbp)\njmp    1289 <func0+0xa0>\ncall   10f0 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmovsbq -0x11(%rbp),%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x100,%eax\ntest   %eax,%eax\nje     1289 <func0+0xa0>\nmovsbl -0x11(%rbp),%eax\nmov    %eax,%edi\ncall   10e0 <tolower@plt>\nmov    %al,-0x11(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    12bd <func0+0xd4>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x11(%rbp)\njne    12b9 <func0+0xd0>\ncmpl   $0x9,-0xc(%rbp)\njg     12d3 <func0+0xea>\nmovzbl -0x11(%rbp),%eax\nadd    $0x2,%eax\nmov    %al,-0x11(%rbp)\njmp    12d3 <func0+0xea>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1292 <func0+0xa9>\njmp    12d4 <func0+0xeb>\nnop\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x11(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1214 <func0+0x2b>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nleave\nret\n"
    },
    {
        "task_id": 93,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,0x8(%rsp)\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     1295 <func0+0xac>\nmov    %rdi,%r14\ncall   10f0 <__ctype_b_loc@plt>\nmov    %rax,%r15\nmov    $0x0,%r12d\nlea    0xde1(%rip),%rbp\njmp    1258 <func0+0x6f>\ntest   $0x1,%ah\nje     1276 <func0+0x8d>\ncall   10e0 <__ctype_tolower_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r13,4),%ebx\njmp    1276 <func0+0x8d>\nlea    0x2(%rbx),%eax\ncmp    $0xa,%ecx\ncmovl  %eax,%ebx\nmov    0x8(%rsp),%rax\nmov    %bl,(%rax,%r12,1)\nadd    $0x1,%r12\nmovzbl (%r14,%r12,1),%ebx\ntest   %bl,%bl\nje     129b <func0+0xb2>\nmovsbq %bl,%r13\nmov    (%r15),%rax\nmovzwl (%rax,%r13,2),%eax\ntest   $0x2,%ah\nje     1225 <func0+0x3c>\ncall   10a0 <__ctype_toupper_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r13,4),%ebx\nmov    $0x0,%eax\nmov    $0x61,%edx\nmov    %eax,%ecx\ncmp    %dl,%bl\nje     1239 <func0+0x50>\nadd    $0x1,%rax\nmovzbl 0x0(%rbp,%rax,1),%edx\ntest   %dl,%dl\njne    1280 <func0+0x97>\njmp    1242 <func0+0x59>\nmov    $0x0,%r12d\nmov    0x8(%rsp),%rax\nmovb   $0x0,(%rax,%r12,1)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 93,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmovzbl (%rdi),%ebx\nmov    %rdi,0x8(%rsp)\ntest   %bl,%bl\nje     1417 <func0+0x97>\ncall   10d0 <__ctype_b_loc@plt>\nxor    %r14d,%r14d\nlea    0xc54(%rip),%r13\nmov    %rax,%r12\nnopl   0x0(%rax,%rax,1)\nmov    (%r12),%rax\nmovsbq %bl,%r15\nmovzwl (%rax,%r15,2),%eax\ntest   $0x2,%ah\nje     1430 <func0+0xb0>\ncall   1090 <__ctype_toupper_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r15,4),%ebx\nxor    %eax,%eax\nmov    $0x61,%edx\njmp    13ee <func0+0x6e>\nadd    $0x1,%rax\nmovzbl 0x0(%r13,%rax,1),%edx\ntest   %dl,%dl\nje     13fd <func0+0x7d>\nmov    %eax,%ecx\ncmp    %dl,%bl\njne    13e0 <func0+0x60>\nlea    0x2(%rbx),%eax\ncmp    $0xa,%ecx\ncmovl  %eax,%ebx\nmov    0x8(%rsp),%rax\nmov    %bl,0x0(%rbp,%r14,1)\nadd    $0x1,%r14\nmovzbl (%rax,%r14,1),%ebx\ntest   %bl,%bl\njne    13b8 <func0+0x38>\nadd    %r14,%rbp\nmovb   $0x0,0x0(%rbp)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%ah\nje     13d7 <func0+0x57>\ncall   10c0 <__ctype_tolower_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r15,4),%ebx\njmp    13d7 <func0+0x57>\n"
    },
    {
        "task_id": 93,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmovzbl (%rdi),%ebx\nmov    %rdi,0x8(%rsp)\ntest   %bl,%bl\nje     1417 <func0+0x97>\ncall   10d0 <__ctype_b_loc@plt>\nxor    %r14d,%r14d\nlea    0xc54(%rip),%r13\nmov    %rax,%r12\nnopl   0x0(%rax,%rax,1)\nmov    (%r12),%rax\nmovsbq %bl,%r15\nmovzwl (%rax,%r15,2),%eax\ntest   $0x2,%ah\nje     1430 <func0+0xb0>\ncall   1090 <__ctype_toupper_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r15,4),%ebx\nxor    %eax,%eax\nmov    $0x61,%edx\njmp    13ee <func0+0x6e>\nadd    $0x1,%rax\nmovzbl 0x0(%r13,%rax,1),%edx\ntest   %dl,%dl\nje     13fd <func0+0x7d>\nmov    %eax,%ecx\ncmp    %dl,%bl\njne    13e0 <func0+0x60>\nlea    0x2(%rbx),%eax\ncmp    $0xa,%ecx\ncmovl  %eax,%ebx\nmov    0x8(%rsp),%rax\nmov    %bl,0x0(%rbp,%r14,1)\nadd    $0x1,%r14\nmovzbl (%rax,%r14,1),%ebx\ntest   %bl,%bl\njne    13b8 <func0+0x38>\nadd    %r14,%rbp\nmovb   $0x0,0x0(%rbp)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%ah\nje     13d7 <func0+0x57>\ncall   10c0 <__ctype_tolower_loc@plt>\nmov    (%rax),%rax\nmovzbl (%rax,%r15,4),%ebx\njmp    13d7 <func0+0x57>\n"
    },
    {
        "task_id": 94,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    11fb <func0+0x92>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njle    11f7 <func0+0x8e>\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x2,-0x8(%rbp)\njmp    11d8 <func0+0x6f>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    11d4 <func0+0x6b>\nmovl   $0x0,-0xc(%rbp)\njmp    11e3 <func0+0x7a>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x4(%rbp)\njge    11be <func0+0x55>\ncmpl   $0x0,-0xc(%rbp)\nje     11f7 <func0+0x8e>\nmov    -0x18(%rbp),%edx\nmov    -0x4(%rbp),%eax\ncmp    %eax,%edx\ncmovge %edx,%eax\nmov    %eax,-0x18(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     118f <func0+0x26>\njmp    1252 <func0+0xe9>\nmov    -0x18(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\nadd    %edx,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njg     1205 <func0+0x9c>\nmov    -0x14(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 94,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11b8 <func0+0x4f>\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r9\nmov    $0x0,%edi\njmp    11d4 <func0+0x6b>\ntest   %edi,%edi\njle    11bf <func0+0x56>\nmov    $0x0,%ecx\nmovslq %edi,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edi,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,4),%edx\nadd    %edx,%edx\nmov    %edi,%esi\nsub    %edx,%esi\nadd    %esi,%ecx\nmov    %edi,%edx\nmov    %eax,%edi\ncmp    $0x9,%edx\njg     118c <func0+0x23>\nmov    %ecx,%eax\nret\nmov    $0x0,%ecx\njmp    11b5 <func0+0x4c>\nmov    $0x0,%ecx\njmp    11b5 <func0+0x4c>\ncmp    %esi,%edi\ncmovl  %esi,%edi\nadd    $0x4,%r8\ncmp    %r9,%r8\nje     1183 <func0+0x1a>\nmov    (%r8),%esi\ncmp    $0x1,%esi\njle    11cb <func0+0x62>\ncmp    $0x3,%esi\njle    11c6 <func0+0x5d>\ntest   $0x1,%sil\nje     11cb <func0+0x62>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njg     11c6 <func0+0x5d>\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    11ec <func0+0x83>\njmp    11cb <func0+0x62>\n"
    },
    {
        "task_id": 94,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1711 <func0+0xa1>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x4(%rdi,%rax,4),%r9\njmp    1699 <func0+0x29>\nnopl   0x0(%rax)\nadd    $0x4,%rdi\ncmp    %r9,%rdi\nje     16e0 <func0+0x70>\nmov    (%rdi),%esi\ncmp    $0x1,%esi\njle    1690 <func0+0x20>\ncmp    $0x3,%esi\njle    16cd <func0+0x5d>\ntest   $0x1,%sil\nje     1690 <func0+0x20>\nmov    $0x2,%ecx\njmp    16c1 <func0+0x51>\nnopw   0x0(%rax,%rax,1)\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1690 <func0+0x20>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njle    16b8 <func0+0x48>\ncmp    %esi,%r8d\ncmovl  %esi,%r8d\nadd    $0x4,%rdi\ncmp    %r9,%rdi\njne    1699 <func0+0x29>\nnopl   (%rax)\nxor    %r9d,%r9d\ntest   %r8d,%r8d\nje     170d <func0+0x9d>\nmov    $0xcccccccd,%ecx\nnopl   (%rax)\nmov    %r8d,%eax\nimul   %rcx,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%edx\nadd    %edx,%edx\nsub    %edx,%r8d\nadd    %r8d,%r9d\nmov    %eax,%r8d\ntest   %eax,%eax\njne    16f0 <func0+0x80>\nmov    %r9d,%eax\nret\nxor    %r9d,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 94,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    15d1 <func0+0xa1>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x4(%rdi,%rax,4),%r9\njmp    1559 <func0+0x29>\nnopl   0x0(%rax)\nadd    $0x4,%rdi\ncmp    %rdi,%r9\nje     15a0 <func0+0x70>\nmov    (%rdi),%esi\ncmp    $0x1,%esi\njle    1550 <func0+0x20>\ncmp    $0x3,%esi\njle    158d <func0+0x5d>\ntest   $0x1,%sil\nje     1550 <func0+0x20>\nmov    $0x2,%ecx\njmp    1581 <func0+0x51>\nnopw   0x0(%rax,%rax,1)\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1550 <func0+0x20>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njle    1578 <func0+0x48>\ncmp    %esi,%r8d\ncmovl  %esi,%r8d\nadd    $0x4,%rdi\ncmp    %rdi,%r9\njne    1559 <func0+0x29>\nnopl   (%rax)\nxor    %r9d,%r9d\ntest   %r8d,%r8d\nje     15cd <func0+0x9d>\nmov    $0xcccccccd,%ecx\nnopl   (%rax)\nmov    %r8d,%eax\nimul   %rcx,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%edx\nadd    %edx,%edx\nsub    %edx,%r8d\nadd    %r8d,%r9d\nmov    %eax,%r8d\ntest   %eax,%eax\njne    15b0 <func0+0x80>\nmov    %r9d,%eax\nret\nxor    %r9d,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 95,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\njne    11ac <func0+0x23>\nmov    $0x0,%eax\njmp    12d9 <func0+0x150>\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    12c8 <func0+0x13f>\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    12ac <func0+0x123>\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\njne    1226 <func0+0x9d>\nmov    $0x0,%eax\njmp    12d9 <func0+0x150>\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x100,%eax\ntest   %eax,%eax\nje     125d <func0+0xd4>\nmovl   $0x1,-0x14(%rbp)\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x200,%eax\ntest   %eax,%eax\nje     1294 <func0+0x10b>\nmovl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\ncmp    $0x2,%eax\njne    12a8 <func0+0x11f>\nmov    $0x0,%eax\njmp    12d9 <func0+0x150>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    11ec <func0+0x63>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11c6 <func0+0x3d>\nmov    $0x1,%eax\nleave\nret\n"
    },
    {
        "task_id": 95,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%eax\ntest   %esi,%esi\nje     1257 <func0+0xce>\njle    11f8 <func0+0x6f>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r15\nlea    -0x1(%rsi),%eax\nshl    $0x4,%rax\nlea    0x10(%rdi,%rax,1),%rax\nmov    %rax,0x8(%rsp)\nmov    $0x0,%r13d\nmov    $0x0,%r12d\nmov    $0x1,%r14d\nmov    (%r15),%rbp\nmovzbl 0x0(%rbp),%ebx\ntest   %bl,%bl\nje     11e6 <func0+0x5d>\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nadd    $0x1,%rbp\njmp    123d <func0+0xb4>\nadd    $0x10,%r15\ncmp    0x8(%rsp),%r15\njne    11cd <func0+0x44>\nmov    $0x1,%eax\njmp    1203 <func0+0x7a>\nmov    $0x1,%eax\nret\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x0,%eax\njmp    1203 <func0+0x7a>\nmov    $0x0,%eax\njmp    1203 <func0+0x7a>\ntest   $0x2,%ah\njne    1219 <func0+0x90>\nmov    %r14d,%r13d\nlea    (%r12,%r13,1),%eax\ncmp    $0x2,%eax\nje     1212 <func0+0x89>\nadd    $0x1,%rbp\nmovzbl -0x1(%rbp),%ebx\ntest   %bl,%bl\nje     11e6 <func0+0x5d>\nmovzbl %bl,%ebx\nmovzwl (%rdx,%rbx,2),%eax\ntest   $0x4,%ah\nje     11fe <func0+0x75>\ntest   $0x1,%ah\njne    1220 <func0+0x97>\ntest   $0x2,%ah\ncmovne %r14d,%r12d\njmp    1228 <func0+0x9f>\nret\n"
    },
    {
        "task_id": 95,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\nje     1550 <func0+0x10>\njmp    1480 <func0.part.0>\nnopl   (%rax)\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 95,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ntest   %esi,%esi\nje     16a0 <func0+0xd0>\njle    16a1 <func0+0xd1>\npush   %r15\nlea    -0x1(%rsi),%eax\nmov    %rdi,%r15\npush   %r14\nshl    $0x4,%rax\nxor    %r14d,%r14d\npush   %r13\nlea    0x10(%rdi,%rax,1),%rax\nxor    %r13d,%r13d\npush   %r12\nmov    $0x1,%r12d\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rax,0x8(%rsp)\nmov    (%r15),%rbp\nmovzbl 0x0(%rbp),%ebx\ntest   %bl,%bl\nje     1688 <func0+0xb8>\ncall   1090 <__ctype_b_loc@plt>\nlea    0x1(%rbp),%rdx\nmov    (%rax),%rsi\njmp    164c <func0+0x7c>\nnopl   0x0(%rax,%rax,1)\ntest   %cx,%cx\ncmovne %r12d,%r13d\nlea    0x0(%r13,%r14,1),%eax\ncmp    $0x2,%eax\nje     1670 <func0+0xa0>\nmovzbl (%rdx),%ebx\nadd    $0x1,%rdx\ntest   %bl,%bl\nje     1688 <func0+0xb8>\nmovzwl (%rsi,%rbx,2),%eax\ntest   $0x4,%ah\nje     1670 <func0+0xa0>\nmov    %eax,%ecx\nand    $0x200,%cx\ntest   $0x1,%ah\nje     1630 <func0+0x60>\ntest   %cx,%cx\njne    1670 <func0+0xa0>\nmov    $0x1,%r14d\njmp    1637 <func0+0x67>\nxchg   %ax,%ax\nxor    %eax,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nadd    $0x10,%r15\ncmp    %r15,0x8(%rsp)\njne    1612 <func0+0x42>\nmov    $0x1,%eax\njmp    1672 <func0+0xa2>\nxchg   %ax,%ax\nret\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 96,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0x30(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x2,-0x18(%rbp)\njmp    1278 <func0+0xcf>\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    1235 <func0+0x8c>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x18(%rbp)\njl     1242 <func0+0x99>\nmov    -0x18(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    1231 <func0+0x88>\nmovl   $0x0,-0x10(%rbp)\njmp    1243 <func0+0x9a>\naddl   $0x1,-0x14(%rbp)\nmov    -0x30(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x14(%rbp)\njl     11f7 <func0+0x4e>\njmp    1243 <func0+0x9a>\nnop\ncmpl   $0x0,-0x10(%rbp)\nje     1274 <func0+0xcb>\nmov    -0x30(%rbp),%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x30(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x30(%rbp),%rax\nmov    %edx,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     11e7 <func0+0x3e>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 96,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%ebp\nmov    %rsi,%rbx\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%r10\nmovl   $0x0,(%rbx)\nmov    $0x2,%edi\ncmp    $0x2,%ebp\njg     11f6 <func0+0x4d>\nmov    %r10,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nmovslq %r9d,%rax\nmov    %edi,(%r10,%rax,4)\nadd    $0x1,%r9d\nmov    %r9d,(%rbx)\nadd    $0x1,%edi\ncmp    %edi,%ebp\nje     11d7 <func0+0x2e>\nmov    (%rbx),%r9d\nmov    %r10,%rsi\nmov    %r9d,%eax\nlea    (%r10,%rax,4),%r8\ntest   %r9d,%r9d\njle    11e1 <func0+0x38>\nmov    (%rsi),%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     11e1 <func0+0x38>\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     11ef <func0+0x46>\nadd    $0x4,%rsi\ncmp    %r8,%rsi\njne    1208 <func0+0x5f>\njmp    11e1 <func0+0x38>\n"
    },
    {
        "task_id": 96,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmovslq %edi,%rdi\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncall   10b0 <malloc@plt>\nmovl   $0x0,0x0(%rbp)\nxor    %r9d,%r9d\nmov    $0x2,%edi\nmov    %rax,%r10\nlea    0x4(%rax),%r11\ncmp    $0x2,%ebx\njle    1788 <func0+0x98>\nnopw   0x0(%rax,%rax,1)\n00 00\ntest   %r9d,%r9d\njle    1765 <func0+0x75>\nlea    -0x1(%r9),%eax\nmov    %r10,%rsi\nlea    (%r11,%rax,4),%r8\njmp    175a <func0+0x6a>\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1774 <func0+0x84>\nadd    $0x4,%rsi\ncmp    %r8,%rsi\nje     1765 <func0+0x75>\nmov    (%rsi),%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    1748 <func0+0x58>\nmovslq %r9d,%rax\nadd    $0x1,%r9d\nmov    %edi,(%r10,%rax,4)\nmov    %r9d,0x0(%rbp)\nadd    $0x1,%edi\ncmp    %edi,%ebx\nje     1788 <func0+0x98>\nmov    0x0(%rbp),%r9d\njmp    1730 <func0+0x40>\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nmov    %r10,%rax\npop    %rbx\npop    %rbp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnopl   (%rax)\n"
    },
    {
        "task_id": 96,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmovslq %edi,%rdi\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncall   10b0 <malloc@plt>\nmovl   $0x0,0x0(%rbp)\nxor    %r9d,%r9d\nmov    $0x2,%edi\nmov    %rax,%r10\nlea    0x4(%rax),%r11\ncmp    $0x2,%ebx\njle    16eb <func0+0x8b>\nnopw   0x0(%rax,%rax,1)\n00 00\ntest   %r9d,%r9d\nje     16d5 <func0+0x75>\nlea    -0x1(%r9),%eax\nmov    %r10,%rsi\nlea    (%r11,%rax,4),%r8\njmp    16ca <func0+0x6a>\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     16e4 <func0+0x84>\nadd    $0x4,%rsi\ncmp    %rsi,%r8\nje     16d5 <func0+0x75>\nmov    (%rsi),%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    16b8 <func0+0x58>\nmovslq %r9d,%rax\nadd    $0x1,%r9d\nmov    %edi,(%r10,%rax,4)\nmov    %r9d,0x0(%rbp)\nadd    $0x1,%edi\ncmp    %edi,%ebx\njne    16a0 <func0+0x40>\nadd    $0x8,%rsp\nmov    %r10,%rax\npop    %rbx\npop    %rbp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\n"
    },
    {
        "task_id": 97,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nmov    %edx,%ecx\nsub    %eax,%ecx\nmov    -0x8(%rbp),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nmov    %eax,%esi\nmovslq %esi,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %esi,%edi\nsar    $0x1f,%edi\nsub    %edi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%esi\nmov    %esi,%edx\nmov    %ecx,%eax\nimul   %edx,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 97,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nneg    %eax\ncmovs  %edi,%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %esi,%ecx\nneg    %ecx\ncmovs  %esi,%ecx\nmovslq %ecx,%rdx\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%edx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%ecx\nimul   %ecx,%eax\nret\n"
    },
    {
        "task_id": 97,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nneg    %eax\ncmovs  %edi,%eax\nmov    $0xcccccccd,%edi\nmov    %eax,%edx\nimul   %rdi,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %esi,%edx\nneg    %edx\ncmovs  %esi,%edx\nmov    %edx,%ecx\nimul   %rdi,%rcx\nshr    $0x23,%rcx\nlea    (%rcx,%rcx,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%edx\nimul   %edx,%eax\nret\n"
    },
    {
        "task_id": 97,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nneg    %eax\ncmovs  %edi,%eax\nmov    $0xcccccccd,%edi\nmov    %eax,%edx\nimul   %rdi,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %esi,%edx\nneg    %edx\ncmovs  %esi,%edx\nmov    %edx,%ecx\nimul   %rdi,%rcx\nshr    $0x23,%rcx\nlea    (%rcx,%rcx,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%edx\nimul   %edx,%eax\nret\n"
    },
    {
        "task_id": 98,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nlea    0xe63(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    11e5 <func0+0x5c>\nmov    -0x1c(%rbp),%eax\nadd    %eax,%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1080 <strchr@plt>\ntest   %rax,%rax\nje     11e1 <func0+0x58>\naddl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1212 <func0+0x89>\nmov    -0x1c(%rbp),%eax\nadd    %eax,%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1070 <strlen@plt>\ncmp    %rax,%rbx\njb     11b5 <func0+0x2c>\nmov    -0x20(%rbp),%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 98,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmpb   $0x0,(%rdi)\nje     11ec <func0+0x63>\nmov    %rdi,%rbp\ncall   1070 <strlen@plt>\nlea    0x1(%rax),%r13\nshr    %r13\nmov    $0x0,%ebx\nmov    $0x0,%r12d\nlea    0xe49(%rip),%r14\ncmp    %r13,%rbx\nje     11e0 <func0+0x57>\nmovsbl 0x0(%rbp,%rbx,2),%esi\nmov    %r14,%rdi\ncall   1080 <strchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmpb   $0x0,0x0(%rbp,%rbx,1)\njne    11bb <func0+0x32>\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    $0x0,%r12d\njmp    11e0 <func0+0x57>\n"
    },
    {
        "task_id": 98,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmpb   $0x0,(%rdi)\nje     1361 <func0+0x61>\nmov    %rdi,%rbp\nxor    %ebx,%ebx\nlea    0xce7(%rip),%r14\nxor    %r12d,%r12d\ncall   1070 <strlen@plt>\nlea    0x1(%rax),%r13\nshr    %r13\njmp    1350 <func0+0x50>\nxchg   %ax,%ax\nmovsbl 0x0(%rbp,%rbx,2),%esi\nmov    %r14,%rdi\ncall   1080 <strchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmpb   $0x0,0x0(%rbp,%rbx,1)\nje     1355 <func0+0x55>\ncmp    %r13,%rbx\njne    1330 <func0+0x30>\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nxor    %r12d,%r12d\njmp    1355 <func0+0x55>\n"
    },
    {
        "task_id": 98,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmpb   $0x0,(%rdi)\nje     1361 <func0+0x61>\nmov    %rdi,%rbp\nxor    %ebx,%ebx\nlea    0xce7(%rip),%r14\nxor    %r12d,%r12d\ncall   1070 <strlen@plt>\nlea    0x1(%rax),%r13\nshr    %r13\njmp    1350 <func0+0x50>\nxchg   %ax,%ax\nmovsbl 0x0(%rbp,%rbx,2),%esi\nmov    %r14,%rdi\ncall   1080 <strchr@plt>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmpb   $0x0,0x0(%rbp,%rbx,1)\nje     1355 <func0+0x55>\ncmp    %rbx,%r13\njne    1330 <func0+0x30>\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nxor    %r12d,%r12d\njmp    1355 <func0+0x55>\n"
    },
    {
        "task_id": 99,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <atof@plt>\nmovq   %xmm0,%rax\nmov    %rax,-0x8(%rbp)\npxor   %xmm0,%xmm0\ncomisd -0x8(%rbp),%xmm0\njbe    11ff <func0+0x56>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  0xeba(%rip),%xmm1\n00\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   10b0 <ceil@plt>\ncvttsd2si %xmm0,%eax\njmp    1223 <func0+0x7a>\nmovsd  -0x8(%rbp),%xmm1\nmovsd  0xe94(%rip),%xmm0\n00\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   10a0 <floor@plt>\ncvttsd2si %xmm0,%eax\nleave\nret\n"
    },
    {
        "task_id": 99,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x0,%esi\ncall   1060 <strtod@plt>\npxor   %xmm1,%xmm1\ncomisd %xmm0,%xmm1\nja     11eb <func0+0x82>\naddsd  0xf0b(%rip),%xmm0\n00\nmovapd %xmm0,%xmm3\nmovsd  0xf17(%rip),%xmm2\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nmovsd  0xef7(%rip),%xmm4\n00\nucomisd %xmm1,%xmm4\njbe    11e2 <func0+0x79>\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovapd %xmm1,%xmm3\ncmpnlesd %xmm0,%xmm3\nmovsd  0xeda(%rip),%xmm4\n00\nandpd  %xmm4,%xmm3\nsubsd  %xmm3,%xmm1\nandnpd %xmm0,%xmm2\nmovapd %xmm1,%xmm3\norpd   %xmm2,%xmm3\ncvttsd2si %xmm3,%eax\nadd    $0x8,%rsp\nret\nsubsd  0xea5(%rip),%xmm0\n00\nmovapd %xmm0,%xmm3\nmovsd  0xeb1(%rip),%xmm2\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nmovsd  0xe91(%rip),%xmm4\n00\nucomisd %xmm1,%xmm4\njbe    1240 <func0+0xd7>\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\ncmpnlesd %xmm1,%xmm3\nmovsd  0xe78(%rip),%xmm4\n00\nandpd  %xmm4,%xmm3\naddsd  %xmm1,%xmm3\nandnpd %xmm0,%xmm2\norpd   %xmm2,%xmm3\ncvttsd2si %xmm3,%eax\njmp    11e6 <func0+0x7d>\n"
    },
    {
        "task_id": 99,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\nxor    %esi,%esi\ncall   1060 <strtod@plt>\npxor   %xmm1,%xmm1\ncomisd %xmm0,%xmm1\nja     1310 <func0+0x90>\naddsd  0xdf7(%rip),%xmm0\n00\nmovsd  0xe07(%rip),%xmm2\n00\nmovsd  0xdef(%rip),%xmm3\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nucomisd %xmm1,%xmm3\nja     12d0 <func0+0x50>\ncvttsd2si %xmm0,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n00\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\nmovsd  0xdc7(%rip),%xmm4\n00\nandnpd %xmm0,%xmm2\nadd    $0x8,%rsp\ncvtsi2sd %rax,%xmm1\nmovapd %xmm1,%xmm3\ncmpnlesd %xmm0,%xmm3\nandpd  %xmm4,%xmm3\nsubsd  %xmm3,%xmm1\norpd   %xmm2,%xmm1\nmovapd %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\nret\nnopl   0x0(%rax)\nsubsd  0xd80(%rip),%xmm0\n00\nmovsd  0xd90(%rip),%xmm2\n00\nmovsd  0xd78(%rip),%xmm3\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nucomisd %xmm1,%xmm3\njbe    12bf <func0+0x3f>\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\nmovapd %xmm0,%xmm3\nmovsd  0xd5d(%rip),%xmm4\n00\nandnpd %xmm0,%xmm2\nadd    $0x8,%rsp\ncvtsi2sd %rax,%xmm1\ncmpnlesd %xmm1,%xmm3\nandpd  %xmm4,%xmm3\naddsd  %xmm3,%xmm1\norpd   %xmm2,%xmm1\nmovapd %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\nret\n"
    },
    {
        "task_id": 99,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\nxor    %esi,%esi\ncall   1060 <strtod@plt>\npxor   %xmm1,%xmm1\ncomisd %xmm0,%xmm1\nja     1310 <func0+0x90>\naddsd  0xdf7(%rip),%xmm0\n00\nmovsd  0xe07(%rip),%xmm2\n00\nmovsd  0xdef(%rip),%xmm3\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nucomisd %xmm1,%xmm3\nja     12d0 <func0+0x50>\ncvttsd2si %xmm0,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n00\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\nmovsd  0xdc7(%rip),%xmm4\n00\nandnpd %xmm0,%xmm2\nadd    $0x8,%rsp\ncvtsi2sd %rax,%xmm1\nmovapd %xmm1,%xmm3\ncmpnlesd %xmm0,%xmm3\nandpd  %xmm4,%xmm3\nsubsd  %xmm3,%xmm1\norpd   %xmm2,%xmm1\nmovapd %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\nret\nnopl   0x0(%rax)\nsubsd  0xd80(%rip),%xmm0\n00\nmovsd  0xd90(%rip),%xmm2\n00\nmovsd  0xd78(%rip),%xmm3\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nucomisd %xmm1,%xmm3\njbe    12bf <func0+0x3f>\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\nmovapd %xmm0,%xmm3\nmovsd  0xd5d(%rip),%xmm4\n00\nandnpd %xmm0,%xmm2\nadd    $0x8,%rsp\ncvtsi2sd %rax,%xmm1\ncmpnlesd %xmm1,%xmm3\nandpd  %xmm4,%xmm3\naddsd  %xmm3,%xmm1\norpd   %xmm2,%xmm1\nmovapd %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\nret\n"
    },
    {
        "task_id": 100,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmovl   $0x1,-0xc(%rbp)\njmp    1212 <func0+0x69>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nadd    $0x2,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     11df <func0+0x36>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 100,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %ebx,(%rax)\ncmp    $0x1,%ebx\njle    11de <func0+0x35>\nmov    %rax,%rdx\nlea    -0x1(%rbx),%ecx\nlea    (%rax,%rcx,4),%rsi\nmov    (%rdx),%ebx\nlea    0x2(%rbx),%ecx\nmov    %ecx,0x4(%rdx)\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\njne    11cd <func0+0x24>\npop    %rbx\nret\n"
    },
    {
        "task_id": 100,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmovslq %edi,%rdi\nmov    %rdi,%rbx\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %ebx,(%rax)\ncmp    $0x1,%ebx\njle    145e <func0+0x3e>\nlea    -0x1(%rbx),%ecx\nlea    0x4(%rax),%rdx\nlea    (%rax,%rcx,4),%rcx\njmp    1454 <func0+0x34>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x4,%rdx\nadd    $0x2,%ebx\nmov    %ebx,(%rdx)\ncmp    %rcx,%rdx\njne    1450 <func0+0x30>\npop    %rbx\nret\n"
    },
    {
        "task_id": 100,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmovslq %edi,%rdi\nmov    %rdi,%rbx\nshl    $0x2,%rdi\ncall   1090 <malloc@plt>\nmov    %ebx,(%rax)\ncmp    $0x1,%ebx\njle    13af <func0+0x3f>\nlea    -0x2(%rbx),%ecx\nlea    0x4(%rax),%rdx\nlea    0x8(%rax,%rcx,4),%rcx\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x2,%ebx\nadd    $0x4,%rdx\nmov    %ebx,-0x4(%rdx)\ncmp    %rdx,%rcx\njne    13a0 <func0+0x30>\npop    %rbx\nret\n"
    },
    {
        "task_id": 101,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmovl   $0xa,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1110 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   10d0 <strlen@plt>\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   1110 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    135d <func0+0x134>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     12b8 <func0+0x8f>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\njne    1330 <func0+0x107>\ncmpl   $0x0,-0x28(%rbp)\njle    1358 <func0+0x12f>\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x2c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x2c(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1130 <strdup@plt>\nmov    %rax,(%rbx)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     1358 <func0+0x12f>\nshll   -0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1120 <realloc@plt>\nmov    %rax,-0x20(%rbp)\njmp    1358 <func0+0x12f>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x28(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x28(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\njmp    1359 <func0+0x130>\nnop\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1290 <func0+0x67>\ncmpl   $0x0,-0x28(%rbp)\njle    13b5 <func0+0x18c>\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x2c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x2c(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1130 <strdup@plt>\nmov    %rax,(%rbx)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   10c0 <free@plt>\nmov    -0x40(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 101,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rbx\nmov    %rsi,0x8(%rsp)\nmov    $0x50,%edi\ncall   1110 <malloc@plt>\nmov    %rax,%r13\nmov    %rbx,%rdi\ncall   10d0 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1110 <malloc@plt>\nmov    %rax,%r12\nmovzbl (%rbx),%eax\ntest   %al,%al\nje     1330 <func0+0x107>\nadd    $0x1,%rbx\nmov    $0x0,%edx\nmov    $0x0,%ebp\nmov    $0xa,%r15d\njmp    129b <func0+0x72>\nmovslq %edx,%rcx\nmov    %al,(%r12,%rcx,1)\nlea    0x1(%rdx),%edx\nadd    $0x1,%rbx\nmovzbl -0x1(%rbx),%eax\ntest   %al,%al\nje     12ec <func0+0xc3>\ncmp    $0x20,%al\nje     12a3 <func0+0x7a>\ncmp    $0x2c,%al\njne    1285 <func0+0x5c>\ntest   %edx,%edx\njle    128f <func0+0x66>\nmovslq %edx,%rdx\nmovb   $0x0,(%r12,%rdx,1)\nlea    0x1(%rbp),%r14d\nmov    %r12,%rdi\ncall   1130 <strdup@plt>\nmovslq %ebp,%rbp\nmov    %rax,0x0(%r13,%rbp,8)\nmov    %r14d,%ebp\nmov    $0x0,%edx\ncmp    %r15d,%r14d\njl     128f <func0+0x66>\nadd    %r15d,%r15d\nmovslq %r15d,%rsi\nshl    $0x3,%rsi\nmov    %r13,%rdi\ncall   1120 <realloc@plt>\nmov    %rax,%r13\nmov    $0x0,%edx\njmp    128f <func0+0x66>\ntest   %edx,%edx\njg     1311 <func0+0xe8>\nmov    %r12,%rdi\ncall   10c0 <free@plt>\nmov    0x8(%rsp),%rax\nmov    %ebp,(%rax)\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovslq %edx,%rdx\nmovb   $0x0,(%r12,%rdx,1)\nlea    0x1(%rbp),%ebx\nmov    %r12,%rdi\ncall   1130 <strdup@plt>\nmovslq %ebp,%rbp\nmov    %rax,0x0(%r13,%rbp,8)\nmov    %ebx,%ebp\njmp    12f0 <func0+0xc7>\nmov    $0x0,%ebp\njmp    12f0 <func0+0xc7>\n"
    },
    {
        "task_id": 101,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    $0x50,%edi\nsub    $0x18,%rsp\nmov    %rsi,0x8(%rsp)\ncall   1110 <malloc@plt>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncall   10d0 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1110 <malloc@plt>\nmov    %rax,%r14\nmovzbl (%rbx),%eax\ntest   %al,%al\nje     1770 <func0+0x110>\nadd    $0x1,%rbx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\nmov    $0xa,%r13d\njmp    16d5 <func0+0x75>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq %ebp,%rdx\nadd    $0x1,%ebp\nmov    %al,(%r14,%rdx,1)\nmovzbl (%rbx),%eax\nadd    $0x1,%rbx\ntest   %al,%al\nje     1728 <func0+0xc8>\ncmp    $0x20,%al\nje     16dd <func0+0x7d>\ncmp    $0x2c,%al\njne    16c0 <func0+0x60>\ntest   %ebp,%ebp\nje     16ca <func0+0x6a>\nmovslq %ebp,%rbp\nmov    %r14,%rdi\nmovb   $0x0,(%r14,%rbp,1)\nlea    0x1(%r15),%ebp\ncall   1130 <strdup@plt>\nmov    %rax,(%r12,%r15,8)\nmovslq %ebp,%r15\nxor    %ebp,%ebp\ncmp    %r13d,%r15d\njl     16ca <func0+0x6a>\nadd    %r13d,%r13d\nmov    %r12,%rdi\nadd    $0x1,%rbx\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\ncall   1120 <realloc@plt>\nmov    %rax,%r12\nmovzbl -0x1(%rbx),%eax\ntest   %al,%al\njne    16d5 <func0+0x75>\nnopl   0x0(%rax)\ntest   %ebp,%ebp\njne    1750 <func0+0xf0>\nmov    %r14,%rdi\ncall   10c0 <free@plt>\nmov    0x8(%rsp),%rax\nmov    %r15d,(%rax)\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxchg   %ax,%ax\nmovslq %ebp,%rbp\nmov    %r14,%rdi\nlea    0x1(%r15),%ebx\nmovb   $0x0,(%r14,%rbp,1)\ncall   1130 <strdup@plt>\nmov    %rax,(%r12,%r15,8)\nmov    %ebx,%r15d\njmp    172c <func0+0xcc>\nnopl   (%rax)\nxor    %r15d,%r15d\njmp    172c <func0+0xcc>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\n"
    },
    {
        "task_id": 101,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    $0x50,%edi\nsub    $0x18,%rsp\nmov    %rsi,0x8(%rsp)\ncall   1110 <malloc@plt>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncall   10d0 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1110 <malloc@plt>\nmov    %rax,%r14\nmovzbl (%rbx),%eax\ntest   %al,%al\nje     17a0 <func0+0x110>\nadd    $0x1,%rbx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\nmov    $0xa,%r13d\njmp    1705 <func0+0x75>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq %ebp,%rdx\nadd    $0x1,%ebp\nmov    %al,(%r14,%rdx,1)\nmovzbl (%rbx),%eax\nadd    $0x1,%rbx\ntest   %al,%al\nje     1758 <func0+0xc8>\ncmp    $0x20,%al\nje     170d <func0+0x7d>\ncmp    $0x2c,%al\njne    16f0 <func0+0x60>\ntest   %ebp,%ebp\nje     16fa <func0+0x6a>\nmovslq %ebp,%rbp\nmov    %r14,%rdi\nmovb   $0x0,(%r14,%rbp,1)\nlea    0x1(%r15),%ebp\ncall   1130 <strdup@plt>\nmov    %rax,(%r12,%r15,8)\nmovslq %ebp,%r15\nxor    %ebp,%ebp\ncmp    %r13d,%r15d\njl     16fa <func0+0x6a>\nadd    %r13d,%r13d\nmov    %r12,%rdi\nadd    $0x1,%rbx\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\ncall   1120 <realloc@plt>\nmov    %rax,%r12\nmovzbl -0x1(%rbx),%eax\ntest   %al,%al\njne    1705 <func0+0x75>\nnopl   0x0(%rax)\ntest   %ebp,%ebp\njne    1780 <func0+0xf0>\nmov    %r14,%rdi\ncall   10c0 <free@plt>\nmov    0x8(%rsp),%rax\nmov    %r15d,(%rax)\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxchg   %ax,%ax\nmovslq %ebp,%rbp\nmov    %r14,%rdi\nlea    0x1(%r15),%ebx\nmovb   $0x0,(%r14,%rbp,1)\ncall   1130 <strdup@plt>\nmov    %rax,(%r12,%r15,8)\nmov    %ebx,%r15d\njmp    175c <func0+0xcc>\nnopl   (%rax)\nxor    %r15d,%r15d\njmp    175c <func0+0xcc>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\n"
    },
    {
        "task_id": 102,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    1166 <func0+0x1d>\nmov    $0xffffffff,%eax\njmp    11a6 <func0+0x5d>\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njne    1188 <func0+0x3f>\nmov    -0x8(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    1188 <func0+0x3f>\nmov    $0xffffffff,%eax\njmp    11a6 <func0+0x5d>\nmov    -0x8(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    11a3 <func0+0x5a>\nmov    -0x8(%rbp),%eax\nsub    $0x1,%eax\njmp    11a6 <func0+0x5d>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 102,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%eax\ncmp    %edi,%esi\njl     1167 <func0+0x3e>\nje     114e <func0+0x25>\nmov    %esi,%ecx\nshr    $0x1f,%ecx\nlea    (%rsi,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\nsete   %dl\nmovzbl %dl,%edx\nsub    %edx,%eax\nret\nmov    %esi,%ecx\nshr    $0x1f,%ecx\nlea    (%rsi,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\nmov    $0xffffffff,%edx\ncmove  %edx,%eax\nret\nmov    $0xffffffff,%eax\nret\n"
    },
    {
        "task_id": 102,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%eax\ncmp    %edi,%esi\njl     1180 <func0+0x40>\nmov    %esi,%ecx\nshr    $0x1f,%ecx\nlea    (%rsi,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    %edi,%esi\nje     1170 <func0+0x30>\ncmp    $0x1,%edx\nsete   %dl\nmovzbl %dl,%edx\nsub    %edx,%eax\nret\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x1,%edx\nmov    $0xffffffff,%edx\ncmove  %edx,%eax\nret\nnopl   0x0(%rax)\nmov    $0xffffffff,%eax\nret\n"
    },
    {
        "task_id": 102,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%eax\ncmp    %edi,%esi\njl     1180 <func0+0x40>\nmov    %esi,%ecx\nshr    $0x1f,%ecx\nlea    (%rsi,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    %edi,%esi\nje     1170 <func0+0x30>\ncmp    $0x1,%edx\nsete   %dl\nmovzbl %dl,%edx\nsub    %edx,%eax\nret\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x1,%edx\nmov    $0xffffffff,%edx\ncmove  %edx,%eax\nret\nnopl   0x0(%rax)\nmov    $0xffffffff,%eax\nret\n"
    },
    {
        "task_id": 103,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njle    11af <func0+0x26>\nlea    0xe5e(%rip),%rax\njmp    1242 <func0+0xb9>\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x10(%rbp)\nmov    $0x21,%edi\ncall   1090 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x20,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x10(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nlea    0x30(%rax),%ecx\nmov    -0xc(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njg     11f5 <func0+0x6c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nleave\nret\n"
    },
    {
        "task_id": 103,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    0xe70(%rip),%r8\ncmp    %esi,%edi\njle    119c <func0+0x13>\nmov    %r8,%rax\nret\npush   %rbx\nadd    %esi,%edi\nmov    %edi,%ebx\nshr    $0x1f,%ebx\nadd    %edi,%ebx\nsar    %ebx\nmov    $0x21,%edi\ncall   1090 <malloc@plt>\nmovb   $0x0,(%rax)\nmovb   $0x0,0x20(%rax)\nadd    $0x1f,%rax\nmov    %rax,%r8\nmov    %ebx,%ecx\nshr    $0x1f,%ecx\nlea    (%rbx,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\nadd    $0x30,%edx\nmov    %dl,(%rax)\nmov    %ebx,%ecx\nmov    %ebx,%edx\nshr    $0x1f,%edx\nadd    %ebx,%edx\nmov    %edx,%ebx\nsar    %ebx\nsub    $0x1,%rax\ncmp    $0x1,%ecx\njg     11bd <func0+0x34>\nmov    %r8,%rax\npop    %rbx\nret\n"
    },
    {
        "task_id": 103,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%edi\njle    14c8 <func0+0x18>\nlea    0xb45(%rip),%r8\nmov    %r8,%rax\nret\nnopl   0x0(%rax,%rax,1)\nadd    %esi,%edi\npush   %rbx\nmov    %edi,%ebx\nshr    $0x1f,%ebx\nadd    %edi,%ebx\nmov    $0x21,%edi\ncall   1090 <malloc@plt>\nsar    %ebx\nmovb   $0x0,(%rax)\nadd    $0x1f,%rax\nmovb   $0x0,0x1(%rax)\nnopl   0x0(%rax)\nmov    %ebx,%ecx\nmov    %rax,%r8\nsub    $0x1,%rax\nshr    $0x1f,%ecx\nlea    (%rbx,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\nadd    $0x30,%edx\nmov    %dl,0x1(%rax)\nmov    %ebx,%edx\nmov    %ecx,%ebx\nadd    %edx,%ebx\nsar    %ebx\ncmp    $0x1,%edx\njg     14f0 <func0+0x40>\nmov    %r8,%rax\npop    %rbx\nret\n"
    },
    {
        "task_id": 103,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%edi\njle    14c8 <func0+0x18>\nlea    0xb45(%rip),%r8\nmov    %r8,%rax\nret\nnopl   0x0(%rax,%rax,1)\nadd    %esi,%edi\npush   %rbx\nmov    %edi,%ebx\nshr    $0x1f,%ebx\nadd    %edi,%ebx\nmov    $0x21,%edi\ncall   1090 <malloc@plt>\nsar    %ebx\nmovb   $0x0,(%rax)\nadd    $0x1f,%rax\nmovb   $0x0,0x1(%rax)\nnopl   0x0(%rax)\nmov    %ebx,%ecx\nmov    %rax,%r8\nsub    $0x1,%rax\nshr    $0x1f,%ecx\nlea    (%rbx,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\nadd    $0x30,%edx\nmov    %dl,0x1(%rax)\nmov    %ebx,%edx\nmov    %ecx,%ebx\nadd    %edx,%ebx\nsar    %ebx\ncmp    $0x1,%edx\njg     14f0 <func0+0x40>\nmov    %r8,%rax\npop    %rbx\nret\n"
    },
    {
        "task_id": 104,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x40(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x14(%rbp)\njmp    12aa <func0+0x101>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmovb   $0x0,-0x15(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njne    124c <func0+0xa3>\nmovb   $0x1,-0x15(%rbp)\njmp    124c <func0+0xa3>\nmov    -0x10(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    122c <func0+0x83>\nmovb   $0x1,-0x15(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njle    125d <func0+0xb4>\nmovzbl -0x15(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\njne    121e <func0+0x75>\nmovzbl -0x15(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     12a6 <func0+0xfd>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x40(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x2,%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x40(%rbp),%rax\nmov    %edx,(%rax)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11f5 <func0+0x4c>\nmovl   $0x0,-0xc(%rbp)\njmp    1380 <func0+0x1d7>\nmovl   $0x0,-0x8(%rbp)\njmp    1367 <func0+0x1be>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rcx\nmov    -0x8(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x2,%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    1363 <func0+0x1ba>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x2,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x2,%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x8(%rbp)\njl     12ce <func0+0x125>\naddl   $0x1,-0xc(%rbp)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%eax\nsub    $0x1,%eax\ncmp    %eax,-0xc(%rbp)\njl     12c2 <func0+0x119>\nnop\nnop\nleave\nret\n"
    },
    {
        "task_id": 104,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r13\nmov    %esi,%r12d\nmov    %rdx,%rbx\nmov    %rcx,%rbp\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,(%rbx)\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    1298 <func0+0xef>\nmov    %r13,%rsi\nlea    -0x1(%r12),%eax\nlea    0x4(%r13,%rax,4),%r8\njmp    121b <func0+0x72>\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\ncmp    $0x9,%edx\njle    1227 <func0+0x7e>\nmov    %eax,%edx\ntest   $0x1,%dl\njne    11f1 <func0+0x48>\nadd    $0x4,%rsi\ncmp    %rsi,%r8\nje     1237 <func0+0x8e>\nmov    (%rsi),%edi\ntest   %edi,%edi\njle    1225 <func0+0x7c>\nmov    %edi,%edx\njmp    120d <func0+0x64>\nje     1212 <func0+0x69>\nmovslq 0x0(%rbp),%rdx\nmov    (%rbx),%rax\nmov    %edi,(%rax,%rdx,4)\naddl   $0x1,0x0(%rbp)\njmp    1212 <func0+0x69>\ncmpl   $0x1,0x0(%rbp)\njle    1298 <func0+0xef>\nmov    $0x0,%r8d\njmp    1281 <func0+0xd8>\nadd    $0x1,%ecx\nmov    %r8d,%edx\nnot    %edx\nadd    0x0(%rbp),%edx\ncmp    %ecx,%edx\njle    1272 <func0+0xc9>\nmov    (%rbx),%rdx\nlea    (%rdx,%rax,1),%rdi\nmov    (%rdi),%esi\nadd    $0x4,%rax\nmov    (%rdx,%rax,1),%edx\ncmp    %edx,%esi\njle    1245 <func0+0x9c>\nmov    %edx,(%rdi)\nmov    (%rbx),%rdx\nmov    %esi,(%rdx,%rax,1)\njmp    1245 <func0+0x9c>\nadd    $0x1,%r8d\nmov    0x0(%rbp),%eax\nsub    $0x1,%eax\ncmp    %r8d,%eax\njle    1298 <func0+0xef>\nmov    0x0(%rbp),%edx\nsub    %r8d,%edx\nmov    $0x0,%eax\nmov    $0x0,%ecx\ncmp    $0x1,%edx\njg     1254 <func0+0xab>\njmp    1272 <func0+0xc9>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 104,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\nmov    %rcx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncall   10b0 <malloc@plt>\nmov    %rax,0x0(%r13)\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    1535 <func0+0xd5>\nmov    %rax,%r8\nlea    -0x1(%r12),%eax\nmov    %rbx,%r9\nxor    %esi,%esi\nlea    0x4(%rbx,%rax,4),%r11\nmov    $0xcccccccd,%edi\nnopl   0x0(%rax)\nmov    (%r9),%r10d\ntest   %r10d,%r10d\nje     14ed <func0+0x8d>\njle    1544 <func0+0xe4>\nmov    %r10d,%eax\nnopl   0x0(%rax)\nmov    %eax,%edx\nmov    %eax,%eax\nmov    %rax,%rcx\nimul   %rdi,%rax\nnot    %edx\nand    $0x1,%edx\nshr    $0x23,%rax\ncmp    $0x9,%ecx\njle    1540 <func0+0xe0>\ntest   %dl,%dl\nje     14d0 <func0+0x70>\nadd    $0x4,%r9\ncmp    %r11,%r9\njne    14b8 <func0+0x58>\nlea    -0x1(%rsi),%edx\ntest   %edx,%edx\njle    1535 <func0+0xd5>\nlea    0x4(%r8),%r9\nnopl   0x0(%rax)\nsub    $0x1,%edx\nmov    %r8,%rax\nmov    %rdx,%rdi\nlea    (%r9,%rdx,4),%rsi\nnopl   (%rax)\nmov    (%rax),%edx\nmov    0x4(%rax),%ecx\ncmp    %ecx,%edx\njle    1526 <func0+0xc6>\nmov    %ecx,(%rax)\nmov    %edx,0x4(%rax)\nadd    $0x4,%rax\ncmp    %rax,%rsi\njne    1518 <func0+0xb8>\nmov    %edi,%edx\ntest   %edi,%edi\njne    1508 <func0+0xa8>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ntest   %dl,%dl\njne    14ed <func0+0x8d>\nmovslq %esi,%rax\nadd    $0x4,%r9\nadd    $0x1,%esi\nmov    %r10d,(%r8,%rax,4)\nmov    %esi,0x0(%rbp)\ncmp    %r11,%r9\njne    14b8 <func0+0x58>\njmp    14f6 <func0+0x96>\n"
    },
    {
        "task_id": 104,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\nmov    %rcx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncall   10b0 <malloc@plt>\nmov    %rax,0x0(%r13)\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    1505 <func0+0xe5>\nmov    %rax,%r8\nlea    -0x1(%r12),%eax\nmov    %rbx,%r9\nxor    %esi,%esi\nlea    0x4(%rbx,%rax,4),%r11\nmov    $0xcccccccd,%edi\nnopl   0x0(%rax)\nmov    (%r9),%r10d\ntest   %r10d,%r10d\nje     14ad <func0+0x8d>\njle    1514 <func0+0xf4>\nmov    %r10d,%eax\nnopl   0x0(%rax)\nmov    %eax,%edx\nmov    %eax,%eax\nmov    %rax,%rcx\nimul   %rdi,%rax\nnot    %edx\nand    $0x1,%edx\nshr    $0x23,%rax\ncmp    $0x9,%ecx\njle    1510 <func0+0xf0>\ntest   %dl,%dl\nje     1490 <func0+0x70>\nadd    $0x4,%r9\ncmp    %r9,%r11\njne    1478 <func0+0x58>\nlea    -0x1(%rsi),%eax\ntest   %eax,%eax\njle    1505 <func0+0xe5>\nlea    0x4(%r8),%r9\nnopl   0x0(%rax)\nsub    $0x1,%eax\nmov    %r8,%rdx\nmov    %rax,%rdi\nlea    (%r9,%rax,4),%rsi\nnopl   (%rax)\nmovq   (%rdx),%xmm0\npshufd $0xe5,%xmm0,%xmm2\nmovd   %xmm0,%ecx\nmovd   %xmm2,%eax\npshufd $0xe1,%xmm0,%xmm1\ncmp    %eax,%ecx\njle    14f6 <func0+0xd6>\nmovq   %xmm1,(%rdx)\nadd    $0x4,%rdx\ncmp    %rdx,%rsi\njne    14d8 <func0+0xb8>\nmov    %edi,%eax\ntest   %edi,%edi\njne    14c8 <func0+0xa8>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ntest   %dl,%dl\njne    14ad <func0+0x8d>\nmovslq %esi,%rax\nadd    $0x4,%r9\nadd    $0x1,%esi\nmov    %r10d,(%r8,%rax,4)\nmov    %esi,0x0(%rbp)\ncmp    %r9,%r11\njne    1478 <func0+0x58>\njmp    14b6 <func0+0x96>\n"
    },
    {
        "task_id": 105,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x90,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %esi,-0x7c(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    %rcx,-0x90(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0xe05(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0xdfb(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0xdf4(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0xded(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0xde8(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0xde2(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0xddc(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0xdd5(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0xdd0(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0xdcb(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x6c(%rbp)\njmp    1337 <func0+0x16e>\nmovl   $0x0,-0x68(%rbp)\njmp    1321 <func0+0x158>\nmov    -0x68(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x68(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x78(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    131d <func0+0x154>\nmov    -0x68(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x64(%rbp)\nmov    -0x68(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x68(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x78(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x64(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x68(%rbp)\nmov    -0x7c(%rbp),%eax\nsub    -0x6c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x68(%rbp)\njl     1282 <func0+0xb9>\naddl   $0x1,-0x6c(%rbp)\nmov    -0x7c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x6c(%rbp)\njl     1276 <func0+0xad>\nmov    -0x90(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x7c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\njmp    13ac <func0+0x1e3>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    13a8 <func0+0x1df>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0x9,%eax\njg     13a8 <func0+0x1df>\nmov    -0x90(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x90(%rbp),%rax\nmov    %edx,(%rax)\nsubl   $0x1,-0x6c(%rbp)\ncmpl   $0x0,-0x6c(%rbp)\njns    135e <func0+0x195>\nmov    -0x90(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,%rdx\nmov    -0x88(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x7c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\nmovl   $0x0,-0x68(%rbp)\njmp    145f <func0+0x296>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    145b <func0+0x292>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0x9,%eax\njg     145b <func0+0x292>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x88(%rbp),%rax\nmov    (%rax),%rsi\nmov    -0x68(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x68(%rbp)\ncltq\nshl    $0x3,%rax\nlea    (%rsi,%rax,1),%rdx\nmovslq %ecx,%rax\nmov    -0x60(%rbp,%rax,8),%rax\nmov    %rax,(%rdx)\nsubl   $0x1,-0x6c(%rbp)\ncmpl   $0x0,-0x6c(%rbp)\njs     1477 <func0+0x2ae>\nmov    -0x90(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x68(%rbp)\njl     13e8 <func0+0x21f>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n00 00\nje     148c <func0+0x2c3>\ncall   10a0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 105,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,%rbx\nmov    %rdx,%r12\nmov    %rcx,%rbp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nlea    0xe52(%rip),%rax\nmov    %rax,(%rsp)\nlea    0xe02(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0xdfa(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0xdf2(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0xdec(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0xde5(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0xdde(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0xdd6(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0xdd0(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0xdca(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    -0x1(%rsi),%r13d\ntest   %r13d,%r13d\njle    12ab <func0+0xe2>\nmov    %r13d,%edi\nlea    0x4(%rbx),%r8\njmp    129b <func0+0xd2>\nadd    $0x4,%rax\ncmp    %rsi,%rax\nje     1292 <func0+0xc9>\nmov    (%rax),%edx\nmov    0x4(%rax),%ecx\ncmp    %ecx,%edx\njle    1279 <func0+0xb0>\nmov    %ecx,(%rax)\nmov    %edx,0x4(%rax)\njmp    1279 <func0+0xb0>\nsub    $0x1,%edi\nje     1341 <func0+0x178>\ntest   %edi,%edi\njle    1292 <func0+0xc9>\nmov    %rbx,%rax\nlea    -0x1(%rdi),%edx\nlea    (%r8,%rdx,4),%rsi\njmp    1282 <func0+0xb9>\nmovl   $0x0,(%rcx)\nje     1348 <func0+0x17f>\nmov    $0x0,%edi\ncall   10d0 <malloc@plt>\nmov    %rax,(%r12)\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1350 <func0+0x187>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nsub    $0x1,%rax\ntest   %eax,%eax\njs     1329 <func0+0x160>\nmov    (%rbx,%rax,4),%edi\nlea    -0x1(%rdi),%edx\ncmp    $0x8,%edx\nja     12e0 <func0+0x117>\naddl   $0x1,0x0(%rbp)\njmp    12e0 <func0+0x117>\nsub    $0x1,%r13\ntest   %r13d,%r13d\njs     12c5 <func0+0xfc>\ncmp    %edx,0x0(%rbp)\njle    12c5 <func0+0xfc>\nmov    (%rbx,%r13,4),%eax\nlea    -0x1(%rax),%ecx\ncmp    $0x8,%ecx\nja     12f9 <func0+0x130>\nmovslq %edx,%rsi\nmov    (%r12),%rcx\ncltq\nmov    (%rsp,%rax,8),%rax\nmov    %rax,(%rcx,%rsi,8)\nlea    0x1(%rdx),%edx\njmp    12f9 <func0+0x130>\nmovslq 0x0(%rbp),%rdi\nshl    $0x3,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,(%r12)\nmov    $0x0,%edx\njmp    1302 <func0+0x139>\nmovl   $0x0,0x0(%rbp)\nmovslq %r13d,%r13\nmov    %r13,%rax\njmp    12e8 <func0+0x11f>\ncall   10a0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 105,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rcx,%r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nlea    -0x1(%rsi),%ebx\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nlea    0xa2a(%rip),%rax\nmov    %rax,(%rsp)\nlea    0x9da(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x9d2(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x9ca(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x9c4(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x9bd(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x9b6(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0x9ae(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0x9a8(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x9a2(%rip),%rax\nmov    %rax,0x48(%rsp)\ntest   %ebx,%ebx\njle    1762 <func0+0x172>\nmov    %ebx,%edx\nlea    0x4(%rdi),%r8\nnopl   (%rax)\nsub    $0x1,%edx\nmov    %rbp,%rax\nmov    %rdx,%rdi\nlea    (%r8,%rdx,4),%rsi\nnopl   (%rax)\nmov    (%rax),%edx\nmov    0x4(%rax),%ecx\ncmp    %ecx,%edx\njle    16be <func0+0xce>\nmov    %ecx,(%rax)\nmov    %edx,0x4(%rax)\nadd    $0x4,%rax\ncmp    %rax,%rsi\njne    16b0 <func0+0xc0>\nmov    %edi,%edx\ntest   %edi,%edi\njne    16a0 <func0+0xb0>\nmovl   $0x0,0x0(%r13)\n00\nmovslq %ebx,%rbx\nxor    %ecx,%ecx\nmov    %rbx,%rax\nnopl   (%rax)\nmov    0x0(%rbp,%rax,4),%edi\nlea    -0x1(%rdi),%edx\ncmp    $0x8,%edx\nja     16f3 <func0+0x103>\nadd    $0x1,%ecx\nmov    %ecx,0x0(%r13)\nsub    $0x1,%rax\ntest   %eax,%eax\njns    16e0 <func0+0xf0>\nmovslq %ecx,%rcx\nlea    0x0(,%rcx,8),%rdi\n00\ncall   10d0 <malloc@plt>\nmov    0x0(%r13),%edi\nxor    %ecx,%ecx\nmov    %rax,(%r12)\njmp    1743 <func0+0x153>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq 0x0(%rbp,%rbx,4),%rdx\nlea    -0x1(%rdx),%esi\ncmp    $0x8,%esi\nja     173b <func0+0x14b>\nmov    (%rsp,%rdx,8),%rdx\nmovslq %ecx,%rsi\nadd    $0x1,%ecx\nmov    %rdx,(%rax,%rsi,8)\nsub    $0x1,%rbx\ntest   %ebx,%ebx\njs     1747 <func0+0x157>\ncmp    %ecx,%edi\njg     1720 <func0+0x130>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    177b <func0+0x18b>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmovl   $0x0,(%rcx)\nje     16d5 <func0+0xe5>\nxor    %edi,%edi\ncall   10d0 <malloc@plt>\nmov    %rax,(%r12)\njmp    1747 <func0+0x157>\ncall   10a0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 105,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rcx,%r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nlea    0xa6f(%rip),%rbx\nmovq   %rbx,%xmm0\nlea    0xa22(%rip),%rbx\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nlea    0xa05(%rip),%rax\nmovq   %rax,%xmm3\nlea    0xa01(%rip),%rax\npunpcklqdq %xmm3,%xmm0\nmovq   %rax,%xmm4\nlea    0x9fc(%rip),%rax\nmovaps %xmm0,(%rsp)\nmovq   %rbx,%xmm0\nlea    0x9e7(%rip),%rbx\nmovq   %rax,%xmm5\npunpcklqdq %xmm4,%xmm0\nlea    0x9e5(%rip),%rax\nmovaps %xmm0,0x10(%rsp)\nmovq   %rbx,%xmm0\nmovq   %rax,%xmm6\nlea    0x9cb(%rip),%rbx\npunpcklqdq %xmm5,%xmm0\nlea    0x9d0(%rip),%rax\nmovaps %xmm0,0x20(%rsp)\nmovq   %rbx,%xmm0\nmovq   %rax,%xmm7\nlea    0x9b4(%rip),%rbx\npunpcklqdq %xmm6,%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovq   %rbx,%xmm0\nlea    -0x1(%rsi),%ebx\npunpcklqdq %xmm7,%xmm0\nmovaps %xmm0,0x40(%rsp)\ntest   %ebx,%ebx\njle    1772 <func0+0x1b2>\nmov    %ebx,%eax\nlea    0x4(%rdi),%r8\nnopw   0x0(%rax,%rax,1)\nsub    $0x1,%eax\nmov    %rbp,%rdx\nmov    %rax,%rdi\nlea    (%r8,%rax,4),%rsi\nnopl   (%rax)\nmovq   (%rdx),%xmm0\npshufd $0xe5,%xmm0,%xmm2\nmovd   %xmm0,%ecx\nmovd   %xmm2,%eax\npshufd $0xe1,%xmm0,%xmm1\ncmp    %eax,%ecx\njle    16ce <func0+0x10e>\nmovq   %xmm1,(%rdx)\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\njne    16b0 <func0+0xf0>\nmov    %edi,%eax\ntest   %edi,%edi\njne    16a0 <func0+0xe0>\nmovl   $0x0,0x0(%r13)\n00\nmovslq %ebx,%rbx\nxor    %ecx,%ecx\nmov    %rbx,%rax\nnopl   (%rax)\nmov    0x0(%rbp,%rax,4),%edi\nlea    -0x1(%rdi),%edx\ncmp    $0x8,%edx\nja     1703 <func0+0x143>\nadd    $0x1,%ecx\nmov    %ecx,0x0(%r13)\nsub    $0x1,%rax\ntest   %eax,%eax\njns    16f0 <func0+0x130>\nmovslq %ecx,%rcx\nlea    0x0(,%rcx,8),%rdi\n00\ncall   10d0 <malloc@plt>\nmov    0x0(%r13),%edi\nxor    %ecx,%ecx\nmov    %rax,(%r12)\njmp    1753 <func0+0x193>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq 0x0(%rbp,%rbx,4),%rdx\nlea    -0x1(%rdx),%esi\ncmp    $0x8,%esi\nja     174b <func0+0x18b>\nmov    (%rsp,%rdx,8),%rdx\nmovslq %ecx,%rsi\nadd    $0x1,%ecx\nmov    %rdx,(%rax,%rsi,8)\nsub    $0x1,%rbx\ntest   %ebx,%ebx\njs     1757 <func0+0x197>\ncmp    %ecx,%edi\njg     1730 <func0+0x170>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    178b <func0+0x1cb>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmovl   $0x0,(%rcx)\nje     16e5 <func0+0x125>\nxor    %edi,%edi\ncall   10d0 <malloc@plt>\nmov    %rax,(%r12)\njmp    1757 <func0+0x197>\ncall   10a0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 106,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x1,-0xc(%rbp)\njmp    1236 <func0+0x8d>\nmov    -0xc(%rbp),%eax\nadd    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0xc(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    1219 <func0+0x70>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\njmp    1232 <func0+0x89>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    11e4 <func0+0x3b>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 106,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\ntest   %ebx,%ebx\njle    11ed <func0+0x44>\nlea    0x1(%rbx),%r8d\nmov    $0x1,%edx\nmov    $0x1,%esi\nmov    $0x0,%ecx\nadd    %edx,%ecx\nimul   %edx,%esi\ntest   $0x1,%dl\nmov    %esi,%edi\ncmovne %ecx,%edi\nmov    %edi,-0x4(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %r8,%rdx\njne    11d3 <func0+0x2a>\npop    %rbx\nret\n"
    },
    {
        "task_id": 106,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmovslq %edi,%rdi\nmov    %rdi,%rbx\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\ntest   %ebx,%ebx\njle    13da <func0+0x4a>\nlea    0x1(%rbx),%r8d\nmov    $0x1,%edx\nmov    $0x1,%esi\nxor    %ecx,%ecx\nnopl   0x0(%rax,%rax,1)\n00\nimul   %edx,%esi\nadd    %edx,%ecx\ntest   $0x1,%dl\nmov    %esi,%edi\ncmovne %ecx,%edi\nmov    %edi,-0x4(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%r8\njne    13c0 <func0+0x30>\npop    %rbx\nret\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 106,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmovslq %edi,%rdi\nmov    %rdi,%rbx\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\ntest   %ebx,%ebx\njle    13d7 <func0+0x47>\nlea    0x1(%rbx),%edi\nmov    $0x1,%edx\nmov    $0x1,%esi\nxor    %ecx,%ecx\nnopw   0x0(%rax,%rax,1)\n00 00\nimul   %edx,%esi\nadd    %edx,%ecx\ntest   $0x1,%dl\nje     13e0 <func0+0x50>\nmov    %ecx,-0x4(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rdi\njne    13c0 <func0+0x30>\npop    %rbx\nret\nnopl   0x0(%rax)\nmov    %esi,-0x4(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rdi\njne    13c0 <func0+0x30>\npop    %rbx\nret\nnop\n"
    },
    {
        "task_id": 107,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    $0x8,%edi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovl   $0x0,(%rax)\nmovl   $0x1,-0x18(%rbp)\njmp    1299 <func0+0xf0>\nmovl   $0x0,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    125d <func0+0xb4>\nmov    -0x14(%rbp),%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nmov    %eax,%edi\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nmov    %edx,%ecx\nsub    %eax,%ecx\nlea    (%rdi,%rcx,1),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njne    11ff <func0+0x56>\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njne    1295 <func0+0xec>\nmov    -0xc(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    1286 <func0+0xdd>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\njmp    1295 <func0+0xec>\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nadd    $0x1,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    11ea <func0+0x41>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 107,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x8,%edi\ncall   10b0 <malloc@plt>\nmov    %rax,%r9\nmovl   $0x0,(%rax)\nmovl   $0x0,0x4(%rax)\ntest   %ebx,%ebx\njle    122d <func0+0x84>\nlea    0x1(%rbx),%r8d\nmov    $0x1,%edi\nmov    $0x0,%r10d\njmp    11eb <func0+0x42>\naddl   $0x1,(%r9)\nadd    $0x1,%edi\ncmp    %edi,%r8d\nje     122d <func0+0x84>\nmov    %edi,%edx\nmov    %r10d,%ecx\ntest   %edi,%edi\nje     11df <func0+0x36>\nlea    (%rcx,%rcx,4),%esi\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%edx\nlea    (%rdx,%rsi,2),%ecx\nmov    %eax,%edx\ntest   %eax,%eax\njne    11f4 <func0+0x4b>\ncmp    %edi,%ecx\njne    11e3 <func0+0x3a>\ntest   $0x1,%dil\nje     11df <func0+0x36>\naddl   $0x1,0x4(%r9)\njmp    11e3 <func0+0x3a>\nmov    %r9,%rax\npop    %rbx\nret\n"
    },
    {
        "task_id": 107,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x8,%edi\ncall   1090 <malloc@plt>\nmovq   $0x0,(%rax)\ntest   %ebx,%ebx\njle    1413 <func0+0x63>\nlea    0x1(%rbx),%r10d\nmov    $0x1,%r9d\nmov    $0xcccccccd,%r8d\nnopl   0x0(%rax)\nmov    %r9d,%ecx\nxor    %esi,%esi\nnopl   (%rax)\nmov    %ecx,%edx\nlea    (%rsi,%rsi,4),%edi\nimul   %r8,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%esi\nadd    %esi,%esi\nsub    %esi,%ecx\nlea    (%rcx,%rdi,2),%esi\nmov    %edx,%ecx\ntest   %edx,%edx\njne    13e8 <func0+0x38>\ncmp    %esi,%r9d\nje     1418 <func0+0x68>\nadd    $0x1,%r9d\ncmp    %r9d,%r10d\njne    13e0 <func0+0x30>\npop    %rbx\nret\nnopl   (%rax)\ntest   $0x1,%r9b\njne    1428 <func0+0x78>\naddl   $0x1,(%rax)\njmp    140a <func0+0x5a>\nnopl   0x0(%rax,%rax,1)\naddl   $0x1,0x4(%rax)\njmp    140a <func0+0x5a>\nxchg   %ax,%ax\n"
    },
    {
        "task_id": 107,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x8,%edi\ncall   1090 <malloc@plt>\nmovq   $0x0,(%rax)\ntest   %ebx,%ebx\njle    1413 <func0+0x63>\nlea    0x1(%rbx),%r10d\nmov    $0x1,%r9d\nmov    $0xcccccccd,%r8d\nnopl   0x0(%rax)\nmov    %r9d,%ecx\nxor    %esi,%esi\nnopl   (%rax)\nmov    %ecx,%edx\nlea    (%rsi,%rsi,4),%edi\nimul   %r8,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%esi\nadd    %esi,%esi\nsub    %esi,%ecx\nlea    (%rcx,%rdi,2),%esi\nmov    %edx,%ecx\ntest   %edx,%edx\njne    13e8 <func0+0x38>\ncmp    %esi,%r9d\nje     1418 <func0+0x68>\nadd    $0x1,%r9d\ncmp    %r10d,%r9d\njne    13e0 <func0+0x30>\npop    %rbx\nret\nnopl   (%rax)\ntest   $0x1,%r9b\njne    1428 <func0+0x78>\naddl   $0x1,(%rax)\njmp    140a <func0+0x5a>\nnopl   0x0(%rax,%rax,1)\naddl   $0x1,0x4(%rax)\njmp    140a <func0+0x5a>\nxchg   %ax,%ax\n"
    },
    {
        "task_id": 108,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    123e <func0+0xd5>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    11ae <func0+0x45>\naddl   $0x1,-0x10(%rbp)\njmp    123a <func0+0xd1>\nmovl   $0x0,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nmov    %eax,-0x4(%rbp)\njmp    1224 <func0+0xbb>\nmov    -0x4(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\nadd    %edx,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njg     11d7 <func0+0x6e>\nmov    -0x4(%rbp),%eax\nsub    %eax,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njle    123a <func0+0xd1>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     118b <func0+0x22>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 108,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11df <func0+0x76>\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r10\nmov    $0x0,%r9d\njmp    11d2 <func0+0x69>\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\ncmp    $0x9,%edx\njle    11c9 <func0+0x60>\nmov    $0x0,%esi\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nmov    %edx,%edi\nsub    %ecx,%edi\nadd    %edi,%esi\nmov    %edx,%ecx\nmov    %eax,%edx\ncmp    $0x63,%ecx\njg     1195 <func0+0x2c>\ncmp    %eax,%esi\nsetg   %al\nmovzbl %al,%eax\nadd    %eax,%r9d\nadd    $0x4,%r8\ncmp    %r10,%r8\nje     11e5 <func0+0x7c>\nmov    (%r8),%eax\ntest   %eax,%eax\njle    1184 <func0+0x1b>\nadd    $0x1,%r9d\njmp    11c9 <func0+0x60>\nmov    $0x0,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 108,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1498 <func0+0x78>\nlea    -0x1(%rsi),%eax\nxor    %r9d,%r9d\nmov    $0xcccccccd,%r10d\nlea    0x4(%rdi,%rax,4),%r11\njmp    144d <func0+0x2d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r9d\nadd    $0x4,%rdi\ncmp    %r11,%rdi\nje     1494 <func0+0x74>\nmov    (%rdi),%eax\ntest   %eax,%eax\njg     1440 <func0+0x20>\nmov    %eax,%edx\nneg    %edx\ncmp    $0xfffffff7,%eax\njge    1444 <func0+0x24>\nxor    %esi,%esi\nxchg   %ax,%ax\nmov    %edx,%eax\nmov    %edx,%r8d\nimul   %r10,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%r8d\nmov    %edx,%ecx\nmov    %eax,%edx\nadd    %r8d,%esi\ncmp    $0x63,%ecx\njg     1460 <func0+0x40>\nxor    %eax,%eax\ncmp    %edx,%esi\nsetg   %al\nadd    $0x4,%rdi\nadd    %eax,%r9d\ncmp    %r11,%rdi\njne    144d <func0+0x2d>\nmov    %r9d,%eax\nret\nxor    %r9d,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 108,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1448 <func0+0x78>\nlea    -0x1(%rsi),%eax\nxor    %r9d,%r9d\nmov    $0xcccccccd,%r10d\nlea    0x4(%rdi,%rax,4),%r11\njmp    13fd <func0+0x2d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r9d\nadd    $0x4,%rdi\ncmp    %r11,%rdi\nje     1444 <func0+0x74>\nmov    (%rdi),%eax\ntest   %eax,%eax\njg     13f0 <func0+0x20>\nmov    %eax,%edx\nneg    %edx\ncmp    $0xfffffff7,%eax\njge    13f4 <func0+0x24>\nxor    %esi,%esi\nxchg   %ax,%ax\nmov    %edx,%eax\nmov    %edx,%r8d\nimul   %r10,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%r8d\nmov    %edx,%ecx\nmov    %eax,%edx\nadd    %r8d,%esi\ncmp    $0x63,%ecx\njg     1410 <func0+0x40>\nxor    %eax,%eax\ncmp    %edx,%esi\nsetg   %al\nadd    $0x4,%rdi\nadd    %eax,%r9d\ncmp    %r11,%rdi\njne    13fd <func0+0x2d>\nmov    %r9d,%eax\nret\nxor    %r9d,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 109,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njne    118c <func0+0x23>\nmov    $0x1,%eax\njmp    120b <func0+0xa2>\nmovl   $0x1,-0x4(%rbp)\njmp    11cd <func0+0x64>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    11c9 <func0+0x60>\naddl   $0x1,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1195 <func0+0x2c>\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    11f9 <func0+0x90>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x1,-0x8(%rbp)\njg     1206 <func0+0x9d>\nmov    $0x1,%eax\njmp    120b <func0+0xa2>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 109,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x1,%eax\ntest   %esi,%esi\nje     11b8 <func0+0x4f>\ncmp    $0x1,%esi\njle    11b9 <func0+0x50>\nmov    %rdi,%rax\nlea    -0x2(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%r8\nmov    $0x0,%edx\nmov    (%rax),%ecx\ncmp    %ecx,0x4(%rax)\nsetl   %cl\nmovzbl %cl,%ecx\nadd    %ecx,%edx\nadd    $0x4,%rax\ncmp    %r8,%rax\njne    118b <func0+0x22>\nmovslq %esi,%rsi\nmov    (%rdi),%eax\ncmp    %eax,-0x4(%rdi,%rsi,4)\nsetg   %al\nmovzbl %al,%eax\nadd    %eax,%edx\ncmp    $0x1,%edx\nsetle  %al\nret\nmov    $0x0,%edx\njmp    11a1 <func0+0x38>\n"
    },
    {
        "task_id": 109,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\nje     1350 <func0+0x10>\njmp    12e0 <func0.part.0>\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 109,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovslq %esi,%rdx\nmov    %rdi,%r8\nmov    $0x1,%eax\ntest   %edx,%edx\nje     15f1 <func0+0x191>\ncmp    $0x1,%edx\njle    1600 <func0+0x1a0>\nlea    -0x2(%rdx),%eax\nlea    -0x1(%rdx),%esi\ncmp    $0x2,%eax\njbe    1604 <func0+0x1a4>\nmov    %esi,%ecx\nmov    %rdi,%rax\npxor   %xmm1,%xmm1\nshr    $0x2,%ecx\nsub    $0x1,%ecx\nshl    $0x4,%rcx\nlea    0x10(%rdi,%rcx,1),%rcx\nnopw   0x0(%rax,%rax,1)\n00 00\nmovdqu (%rax),%xmm0\nmovdqu 0x4(%rax),%xmm2\nadd    $0x10,%rax\npcmpgtd %xmm2,%xmm0\npsubd  %xmm0,%xmm1\ncmp    %rcx,%rax\njne    14b0 <func0+0x50>\nmovdqa %xmm1,%xmm0\nmov    %esi,%edi\npsrldq $0x8,%xmm0\nand    $0xfffffffc,%edi\npaddd  %xmm0,%xmm1\nlea    0x1(%rdi),%ecx\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ncmp    %edi,%esi\nje     15db <func0+0x17b>\nmovslq %ecx,%rdi\nlea    0x1(%rcx),%r10d\nshl    $0x2,%rdi\nlea    (%r8,%rdi,1),%r9\ncmp    %esi,%r10d\njge    1610 <func0+0x1b0>\ncmp    %ecx,%edx\njle    1610 <func0+0x1b0>\nmov    (%r9),%r10d\ncmp    %r10d,-0x4(%r9)\nsetg   %r9b\nmov    0x4(%r8,%rdi,1),%r11d\nmovzbl %r9b,%r9d\nadd    %r9d,%eax\nxor    %r9d,%r9d\ncmp    %r11d,%r10d\nsetg   %r9b\nlea    0x3(%rcx),%r10d\nadd    %r9d,%eax\nlea    0x2(%rcx),%r9d\ncmp    %r10d,%esi\njle    159b <func0+0x13b>\nmov    0x8(%r8,%rdi,1),%r9d\nxor    %r10d,%r10d\ncmp    %r9d,%r11d\nlea    0x5(%rcx),%r11d\nsetg   %r10b\nadd    %r10d,%eax\nmov    0xc(%r8,%rdi,1),%r10d\ncmp    %r10d,%r9d\nsetg   %r9b\nmovzbl %r9b,%r9d\nadd    %r9d,%eax\nlea    0x4(%rcx),%r9d\ncmp    %r11d,%esi\njle    159b <func0+0x13b>\nmov    0x10(%r8,%rdi,1),%esi\nxor    %r9d,%r9d\ncmp    %r10d,%esi\nsetl   %r9b\nadd    %r9d,%eax\ncmp    0x14(%r8,%rdi,1),%esi\njle    1597 <func0+0x137>\nadd    $0x1,%eax\nlea    0x6(%rcx),%r9d\nmovslq %r9d,%rcx\nmov    (%r8,%rcx,4),%edi\nlea    0x0(,%rcx,4),%rsi\n00\ncmp    -0x4(%r8,%rcx,4),%edi\njl     15f8 <func0+0x198>\nlea    0x1(%r9),%ecx\ncmp    %ecx,%edx\njle    15db <func0+0x17b>\ncmp    0x4(%r8,%rsi,1),%edi\njle    15c3 <func0+0x163>\nadd    $0x1,%eax\nadd    $0x2,%r9d\ncmp    %r9d,%edx\njle    15db <func0+0x17b>\nmov    0x8(%r8,%rsi,1),%edi\ncmp    %edi,0x4(%r8,%rsi,1)\njle    15db <func0+0x17b>\nadd    $0x1,%eax\nmov    (%r8),%esi\ncmp    %esi,-0x4(%r8,%rdx,4)\nsetg   %dl\nmovzbl %dl,%edx\nadd    %edx,%eax\ncmp    $0x1,%eax\nsetle  %al\nret\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%eax\njmp    15b1 <func0+0x151>\nnopl   (%rax)\nxor    %eax,%eax\njmp    15db <func0+0x17b>\nxor    %eax,%eax\nmov    $0x1,%ecx\njmp    14f8 <func0+0x98>\nmov    %ecx,%r9d\njmp    159b <func0+0x13b>\n"
    },
    {
        "task_id": 110,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x20(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    11d4 <func0+0x4b>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    11d0 <func0+0x47>\naddl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     11af <func0+0x26>\nmovl   $0x0,-0x4(%rbp)\njmp    120a <func0+0x81>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    1206 <func0+0x7d>\naddl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     11e5 <func0+0x5c>\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1223 <func0+0x9a>\nlea    0xde7(%rip),%rax\njmp    122a <func0+0xa1>\nlea    0xde2(%rip),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 110,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11eb <func0+0x62>\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r9\nmov    $0x0,%eax\nmov    (%r8),%edi\nand    $0x1,%edi\ncmp    $0x1,%edi\nadc    $0x0,%eax\nadd    $0x4,%r8\ncmp    %r9,%r8\njne    11a1 <func0+0x18>\ntest   %ecx,%ecx\njle    11d6 <func0+0x4d>\nmov    $0x0,%edi\nmov    (%rdx,%rdi,4),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nadc    $0x0,%eax\nadd    $0x1,%rdi\ncmp    %edi,%ecx\njg     11bf <func0+0x36>\ncmp    %eax,%esi\nlea    0xe29(%rip),%rax\nlea    0xe1e(%rip),%rdx\ncmovle %rdx,%rax\nret\nmov    $0x0,%eax\ntest   %ecx,%ecx\njg     11ba <func0+0x31>\nlea    0xe09(%rip),%rax\nret\n"
    },
    {
        "task_id": 110,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1528 <func0+0x68>\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r9\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmov    (%rdi),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nadc    $0x0,%eax\nadd    $0x4,%rdi\ncmp    %r9,%rdi\njne    14d8 <func0+0x18>\ntest   %ecx,%ecx\njle    150f <func0+0x4f>\nxor    %edi,%edi\nnopl   (%rax)\nmov    (%rdx,%rdi,4),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nadc    $0x0,%eax\nadd    $0x1,%rdi\ncmp    %edi,%ecx\njg     14f8 <func0+0x38>\ncmp    %eax,%esi\nlea    0xaf0(%rip),%rdx\nlea    0xae5(%rip),%rax\ncmovg  %rdx,%rax\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\ntest   %ecx,%ecx\njg     14f3 <func0+0x33>\nlea    0xacf(%rip),%rax\nret\n"
    },
    {
        "task_id": 110,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r8\nmov    %rdx,%rdi\ntest   %esi,%esi\njle    1638 <func0+0x1c8>\nlea    -0x1(%rsi),%eax\ncmp    $0x2,%eax\njbe    164a <func0+0x1da>\nmov    %esi,%edx\npxor   %xmm1,%xmm1\nmovdqa 0xdf4(%rip),%xmm2\n00\nmov    %r8,%rax\nshr    $0x2,%edx\nmovdqa %xmm1,%xmm3\nsub    $0x1,%edx\nshl    $0x4,%rdx\nlea    0x10(%r8,%rdx,1),%rdx\nnopw   0x0(%rax,%rax,1)\nmovdqu (%rax),%xmm0\nadd    $0x10,%rax\npand   %xmm2,%xmm0\npcmpeqd %xmm3,%xmm0\npsubd  %xmm0,%xmm1\ncmp    %rax,%rdx\njne    14b8 <func0+0x48>\nmovdqa %xmm1,%xmm0\nmov    %esi,%eax\npsrldq $0x8,%xmm0\nand    $0xfffffffc,%eax\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%edx\ntest   $0x3,%sil\nje     1542 <func0+0xd2>\nmovslq %eax,%r9\nlea    0x0(,%r9,4),%r10\n00\nmov    (%r8,%r9,4),%r9d\nand    $0x1,%r9d\ncmp    $0x1,%r9d\nlea    0x1(%rax),%r9d\nadc    $0x0,%edx\ncmp    %r9d,%esi\njle    1542 <func0+0xd2>\nmov    0x4(%r8,%r10,1),%r9d\nand    $0x1,%r9d\ncmp    $0x1,%r9d\nadc    $0x0,%edx\nadd    $0x2,%eax\ncmp    %esi,%eax\njge    1542 <func0+0xd2>\nmov    0x8(%r8,%r10,1),%eax\nand    $0x1,%eax\ncmp    $0x1,%eax\nadc    $0x0,%edx\ntest   %ecx,%ecx\njle    161d <func0+0x1ad>\ntest   %ecx,%ecx\nmov    $0x1,%r9d\ncmovg  %ecx,%r9d\ncmp    $0x3,%ecx\njle    1653 <func0+0x1e3>\nmov    %r9d,%r8d\npxor   %xmm1,%xmm1\nmovdqa 0xd22(%rip),%xmm2\n00\nmov    %rdi,%rax\nshr    $0x2,%r8d\nmovdqa %xmm1,%xmm3\nsub    $0x1,%r8d\nshl    $0x4,%r8\nlea    0x10(%rdi,%r8,1),%r8\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovdqu (%rax),%xmm0\nadd    $0x10,%rax\npand   %xmm2,%xmm0\npcmpeqd %xmm3,%xmm0\npsubd  %xmm0,%xmm1\ncmp    %rax,%r8\njne    1590 <func0+0x120>\nmovdqa %xmm1,%xmm0\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\nadd    %eax,%edx\nmov    %r9d,%eax\nand    $0xfffffffc,%eax\nand    $0x3,%r9d\nje     161d <func0+0x1ad>\nmovslq %eax,%r8\nlea    0x0(,%r8,4),%r9\n00\nmov    (%rdi,%r8,4),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nlea    0x1(%rax),%r8d\nadc    $0x0,%edx\ncmp    %r8d,%ecx\njle    161d <func0+0x1ad>\nmov    0x4(%rdi,%r9,1),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nadc    $0x0,%edx\nadd    $0x2,%eax\ncmp    %eax,%ecx\njle    161d <func0+0x1ad>\nmov    0x8(%rdi,%r9,1),%eax\nand    $0x1,%eax\ncmp    $0x1,%eax\nadc    $0x0,%edx\ncmp    %edx,%esi\nlea    0x9de(%rip),%rax\nlea    0x9db(%rip),%rdx\ncmovg  %rdx,%rax\nret\nnopw   0x0(%rax,%rax,1)\nxor    %edx,%edx\ntest   %ecx,%ecx\njg     154a <func0+0xda>\nlea    0x9bb(%rip),%rax\nret\nxor    %eax,%eax\nxor    %edx,%edx\njmp    14fa <func0+0x8a>\nxor    %eax,%eax\njmp    15d5 <func0+0x165>\n"
    },
    {
        "task_id": 111,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0x98(%rbp)\nmov    %rsi,-0xa0(%rbp)\nmov    %rdx,-0xa8(%rbp)\nmov    %rcx,-0xb0(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x70(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0xd,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0x88(%rbp)\n00 00 00\nmov    -0x98(%rbp),%rax\nmov    %rax,-0x78(%rbp)\nmovl   $0x0,-0x84(%rbp)\n00 00 00\njmp    124d <func0+0xc4>\nmov    -0x78(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     1248 <func0+0xbf>\nmov    -0x78(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nsub    $0x61,%eax\nmov    %eax,-0x7c(%rbp)\nmov    -0x7c(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\nlea    0x1(%rax),%edx\nmov    -0x7c(%rbp),%eax\ncltq\nmov    %edx,-0x70(%rbp,%rax,4)\nmov    -0x7c(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\ncmp    %eax,-0x88(%rbp)\njge    1248 <func0+0xbf>\nmov    -0x7c(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\nmov    %eax,-0x88(%rbp)\naddq   $0x1,-0x78(%rbp)\nmov    -0x78(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    11f8 <func0+0x6f>\nmovl   $0x0,-0x80(%rbp)\njmp    12be <func0+0x135>\nmov    -0x80(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0xa0(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x80(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\nmov    %eax,(%rdx)\nmov    -0x80(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\ncmp    %eax,-0x88(%rbp)\njne    12ba <func0+0x131>\nmov    -0x80(%rbp),%eax\nlea    0x61(%rax),%ecx\nmov    -0x84(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x84(%rbp)\nmovslq %eax,%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x80(%rbp)\ncmpl   $0x19,-0x80(%rbp)\njle    1261 <func0+0xd8>\nmov    -0xa8(%rbp),%rax\nmov    -0x88(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x84(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n00 00\nje     12fe <func0+0x175>\ncall   1070 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 111,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x78,%rsp\nmov    %rdi,%r11\nmov    %rsi,%r8\nmov    %rdx,%r10\nmov    %rcx,%r9\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0xd,%ecx\nrep stos %rax,%es:(%rdi)\nmovzbl (%r11),%eax\ntest   %al,%al\njne    11d3 <func0+0x6a>\nmov    $0x0,%ecx\nmov    $0x0,%eax\nmov    $0x0,%esi\njmp    11e3 <func0+0x7a>\nmovsbl %al,%eax\nsub    $0x61,%eax\ncltq\nmov    (%rsp,%rax,4),%edi\nlea    0x1(%rdi),%edx\nmov    %edx,(%rsp,%rax,4)\ncmp    %edx,%ecx\ncmovl  %edx,%ecx\nadd    $0x1,%r11\nmovzbl (%r11),%eax\ntest   %al,%al\nje     11a5 <func0+0x3c>\ncmp    $0x20,%al\njne    11b1 <func0+0x48>\njmp    11c7 <func0+0x5e>\nadd    $0x1,%rax\ncmp    $0x1a,%rax\nje     11fd <func0+0x94>\nmov    (%rsp,%rax,4),%edx\nmov    %edx,(%r8,%rax,4)\ncmp    %ecx,%edx\njne    11d9 <func0+0x70>\nmovslq %esi,%rdx\nlea    0x61(%rax),%edi\nmov    %dil,(%r9,%rdx,1)\nlea    0x1(%rsi),%esi\njmp    11d9 <func0+0x70>\nmov    %ecx,(%r10)\nmovslq %esi,%rsi\nmovb   $0x0,(%r9,%rsi,1)\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    121d <func0+0xb4>\nadd    $0x78,%rsp\nret\ncall   1060 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 111,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x78,%rsp\nmov    %rdi,%r8\nmov    %rcx,%r10\nmov    $0xd,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r9\nmov    %rdx,%r11\nmov    %r9,%rdi\nrep stos %rax,%es:(%rdi)\nmovsbl (%r8),%eax\ntest   %al,%al\nje     1613 <func0+0xb3>\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x20,%al\nje     15b7 <func0+0x57>\nsub    $0x61,%eax\ncltq\nmov    (%rsp,%rax,4),%edi\nlea    0x1(%rdi),%edx\ncmp    %edx,%ecx\nmov    %edx,(%rsp,%rax,4)\ncmovl  %edx,%ecx\nmovsbl 0x1(%r8),%eax\nadd    $0x1,%r8\ntest   %al,%al\njne    15a0 <func0+0x40>\nmov    (%rsp),%edx\nxor    %eax,%eax\nxor    %edi,%edi\njmp    15d4 <func0+0x74>\nnopl   (%rax)\nmov    (%r9,%rax,4),%edx\nmov    %edx,(%rsi,%rax,4)\ncmp    %edx,%ecx\njne    15e9 <func0+0x89>\nmovslq %edi,%rdx\nlea    0x61(%rax),%r8d\nadd    $0x1,%edi\nmov    %r8b,(%r10,%rdx,1)\nadd    $0x1,%rax\ncmp    $0x1a,%rax\njne    15d0 <func0+0x70>\nmovslq %edi,%rdi\nmov    %ecx,(%r11)\nmovb   $0x0,(%r10,%rdi,1)\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1619 <func0+0xb9>\nadd    $0x78,%rsp\nret\nxor    %edx,%edx\nxor    %ecx,%ecx\njmp    15c7 <func0+0x67>\ncall   1060 <__stack_chk_fail@plt>\nxchg   %ax,%ax\n"
    },
    {
        "task_id": 111,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x78,%rsp\nmov    %rdi,%r9\nmov    %rcx,%r10\nmov    $0xd,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r8\nmov    %rdx,%r11\nmov    %r8,%rdi\nrep stos %rax,%es:(%rdi)\nmovsbl (%r9),%eax\ntest   %al,%al\nje     161b <func0+0xcb>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x20,%al\nje     1608 <func0+0xb8>\nsub    $0x61,%eax\ncltq\nmov    (%rsp,%rax,4),%edi\nlea    0x1(%rdi),%edx\ncmp    %edx,%ecx\nmov    %edx,(%rsp,%rax,4)\ncmovl  %edx,%ecx\nmovsbl 0x1(%r9),%eax\nadd    $0x1,%r9\ntest   %al,%al\njne    1590 <func0+0x40>\nxor    %eax,%eax\nxor    %edi,%edi\nnopl   0x0(%rax,%rax,1)\n00\nmov    (%r8,%rax,4),%edx\nmov    %edx,(%rsi,%rax,4)\ncmp    %ecx,%edx\njne    15d9 <func0+0x89>\nmovslq %edi,%rdx\nlea    0x61(%rax),%r9d\nadd    $0x1,%edi\nmov    %r9b,(%r10,%rdx,1)\nadd    $0x1,%rax\ncmp    $0x1a,%rax\njne    15c0 <func0+0x70>\nmovslq %edi,%rdi\nmov    %ecx,(%r11)\nmovb   $0x0,(%r10,%rdi,1)\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    161f <func0+0xcf>\nadd    $0x78,%rsp\nret\nnopl   0x0(%rax,%rax,1)\nmovsbl 0x1(%r9),%eax\nadd    $0x1,%r9\ntest   %al,%al\njne    1590 <func0+0x40>\njmp    15b4 <func0+0x64>\nxor    %ecx,%ecx\njmp    15b4 <func0+0x64>\ncall   1060 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnop\n"
    },
    {
        "task_id": 112,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %rcx,-0x50(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   10d0 <strlen@plt>\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   1110 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    12cc <func0+0xc3>\nmov    -0x40(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmovb   $0x0,-0x26(%rbp)\njmp    128c <func0+0x83>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    1287 <func0+0x7e>\nmovb   $0x1,-0x26(%rbp)\njmp    1297 <func0+0x8e>\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1266 <func0+0x5d>\nmovzbl -0x26(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     12c8 <func0+0xbf>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x24(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x24(%rbp)\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1258 <func0+0x4f>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   10d0 <strlen@plt>\nmov    %eax,-0x14(%rbp)\nmovb   $0x1,-0x25(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    1344 <func0+0x13b>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x1c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     1340 <func0+0x137>\nmovb   $0x0,-0x25(%rbp)\njmp    1355 <func0+0x14c>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x1c(%rbp)\njl     1310 <func0+0x107>\nmov    -0x8(%rbp),%rdx\nmov    -0x48(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10c0 <strcpy@plt>\ncmpb   $0x0,-0x25(%rbp)\nje     1377 <func0+0x16e>\nlea    0xc93(%rip),%rax\njmp    137e <func0+0x175>\nlea    0xc8f(%rip),%rax\nmov    -0x50(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   10c0 <strcpy@plt>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   10b0 <free@plt>\nnop\nleave\nret\n"
    },
    {
        "task_id": 112,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r14\nmov    %rsi,%rbp\nmov    %rdx,%r13\nmov    %rcx,%r12\ncall   10d0 <strlen@plt>\nlea    0x1(%rax),%edi\nmovslq %edi,%rdi\ncall   1110 <malloc@plt>\nmov    %rax,%rbx\nmovzbl (%r14),%ecx\ntest   %cl,%cl\nje     124f <func0+0x46>\nmovzbl 0x0(%rbp),%edi\nlea    0x1(%r14),%rsi\nmov    $0x0,%r8d\njmp    12ed <func0+0xe4>\nmov    $0x0,%r8d\nmovslq %r8d,%r8\nmovb   $0x0,(%rbx,%r8,1)\nmov    %rbx,%rdi\ncall   10d0 <strlen@plt>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    $0x1,%eax\njle    1294 <func0+0x8b>\ncltq\nlea    -0x1(%rbx,%rax,1),%rdx\nmov    $0x0,%eax\nmovzbl (%rdx),%esi\ncmp    %sil,(%rbx,%rax,1)\njne    12bf <func0+0xb6>\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%ecx\njg     127f <func0+0x76>\nmov    %rbx,%rsi\nmov    %r13,%rdi\ncall   10c0 <strcpy@plt>\nlea    0xd64(%rip),%rsi\nmov    %r12,%rdi\ncall   10c0 <strcpy@plt>\nmov    %rbx,%rdi\ncall   10b0 <free@plt>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    %rbx,%rsi\nmov    %r13,%rdi\ncall   10c0 <strcpy@plt>\nlea    0xd33(%rip),%rsi\njmp    12a6 <func0+0x9d>\nmovslq %r8d,%rax\nmov    %cl,(%rbx,%rax,1)\nlea    0x1(%r8),%r8d\nadd    $0x1,%rsi\nmovzbl -0x1(%rsi),%ecx\ntest   %cl,%cl\nje     1255 <func0+0x4c>\nmov    %rbp,%rdx\nmov    %edi,%eax\ntest   %dil,%dil\nje     12d3 <func0+0xca>\ncmp    %cl,%al\nje     12dd <func0+0xd4>\nadd    $0x1,%rdx\nmovzbl (%rdx),%eax\ntest   %al,%al\njne    12f7 <func0+0xee>\njmp    12d3 <func0+0xca>\n"
    },
    {
        "task_id": 112,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    %rsi,%r14\npush   %r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rcx,%rbp\npush   %rbx\nmov    %rdi,%rbx\ncall   10e0 <strlen@plt>\nlea    0x1(%rax),%edi\nmovslq %edi,%rdi\ncall   1130 <malloc@plt>\nmovzbl (%rbx),%ecx\nmov    %rax,%r13\ntest   %cl,%cl\nje     1601 <func0+0x71>\nmovzbl (%r14),%r8d\nlea    0x1(%rbx),%rsi\nxor    %edi,%edi\nnopl   0x0(%rax)\nmov    %r14,%rdx\nmov    %r8d,%eax\ntest   %r8b,%r8b\njne    15ec <func0+0x5c>\njmp    1660 <func0+0xd0>\nmovzbl 0x1(%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\nje     1660 <func0+0xd0>\ncmp    %al,%cl\njne    15e0 <func0+0x50>\nmovzbl (%rsi),%ecx\nadd    $0x1,%rsi\ntest   %cl,%cl\njne    15d0 <func0+0x40>\nmovslq %edi,%rax\nadd    %r13,%rax\nmovb   $0x0,(%rax)\nmov    %r13,%rdi\ncall   10e0 <strlen@plt>\nmov    %eax,%esi\nshr    $0x1f,%esi\nadd    %eax,%esi\nsar    %esi\ncmp    $0x1,%eax\njle    1680 <func0+0xf0>\nlea    -0x1(%rax),%ecx\nxor    %edx,%edx\nmovslq %ecx,%rcx\nadd    %r13,%rcx\njmp    163c <func0+0xac>\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%rdx\nsub    $0x1,%rcx\ncmp    %edx,%esi\njle    1680 <func0+0xf0>\nmovzbl (%rcx),%ebx\ncmp    %bl,0x0(%r13,%rdx,1)\nje     1630 <func0+0xa0>\nmov    %r13,%rsi\nlea    0x1(%rax),%rdx\nmov    %r12,%rdi\ncall   1120 <memcpy@plt>\nlea    0x9a8(%rip),%rsi\njmp    1696 <func0+0x106>\nxchg   %ax,%ax\nmovslq %edi,%rax\nadd    $0x1,%rsi\nadd    $0x1,%edi\nmov    %cl,0x0(%r13,%rax,1)\nmovzbl -0x1(%rsi),%ecx\ntest   %cl,%cl\njne    15d0 <func0+0x40>\njmp    15fb <func0+0x6b>\nmov    %r13,%rsi\nlea    0x1(%rax),%rdx\nmov    %r12,%rdi\ncall   1120 <memcpy@plt>\nlea    0x974(%rip),%rsi\nmov    %rbp,%rdi\ncall   10d0 <strcpy@plt>\npop    %rbx\nmov    %r13,%rdi\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmp    10c0 <free@plt>\n"
    },
    {
        "task_id": 112,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    %rsi,%r14\npush   %r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rcx,%rbp\npush   %rbx\nmov    %rdi,%rbx\ncall   10e0 <strlen@plt>\nlea    0x1(%rax),%edi\nmovslq %edi,%rdi\ncall   1130 <malloc@plt>\nmovzbl (%rbx),%ecx\nmov    %rax,%r13\ntest   %cl,%cl\nje     1601 <func0+0x71>\nmovzbl (%r14),%r8d\nlea    0x1(%rbx),%rsi\nxor    %edi,%edi\nnopl   0x0(%rax)\nmov    %r14,%rdx\nmov    %r8d,%eax\ntest   %r8b,%r8b\njne    15ec <func0+0x5c>\njmp    1660 <func0+0xd0>\nmovzbl 0x1(%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\nje     1660 <func0+0xd0>\ncmp    %al,%cl\njne    15e0 <func0+0x50>\nmovzbl (%rsi),%ecx\nadd    $0x1,%rsi\ntest   %cl,%cl\njne    15d0 <func0+0x40>\nmovslq %edi,%rax\nadd    %r13,%rax\nmovb   $0x0,(%rax)\nmov    %r13,%rdi\ncall   10e0 <strlen@plt>\nmov    %eax,%esi\nshr    $0x1f,%esi\nadd    %eax,%esi\nsar    %esi\ncmp    $0x1,%eax\njle    1680 <func0+0xf0>\nlea    -0x1(%rax),%ecx\nxor    %edx,%edx\nmovslq %ecx,%rcx\nadd    %r13,%rcx\njmp    163c <func0+0xac>\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%rdx\nsub    $0x1,%rcx\ncmp    %edx,%esi\njle    1680 <func0+0xf0>\nmovzbl (%rcx),%ebx\ncmp    %bl,0x0(%r13,%rdx,1)\nje     1630 <func0+0xa0>\nmov    %r13,%rsi\nlea    0x1(%rax),%rdx\nmov    %r12,%rdi\ncall   1120 <memcpy@plt>\nlea    0x9a8(%rip),%rsi\njmp    1696 <func0+0x106>\nxchg   %ax,%ax\nmovslq %edi,%rax\nadd    $0x1,%rsi\nadd    $0x1,%edi\nmov    %cl,0x0(%r13,%rax,1)\nmovzbl -0x1(%rsi),%ecx\ntest   %cl,%cl\njne    15d0 <func0+0x40>\njmp    15fb <func0+0x6b>\nmov    %r13,%rsi\nlea    0x1(%rax),%rdx\nmov    %r12,%rdi\ncall   1120 <memcpy@plt>\nlea    0x974(%rip),%rsi\nmov    %rbp,%rdi\ncall   10d0 <strcpy@plt>\npop    %rbx\nmov    %r13,%rdi\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmp    10c0 <free@plt>\n"
    },
    {
        "task_id": 113,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    1344 <func0+0x15b>\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    12bd <func0+0xd4>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    12b9 <func0+0xd0>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njg     12b9 <func0+0xd0>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    12b9 <func0+0xd0>\naddl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1231 <func0+0x48>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    $0x64,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,(%rbx)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x20(%rbp),%esi\nmov    -0x20(%rbp),%ecx\nmov    -0x20(%rbp),%edx\nmov    %esi,%r8d\nlea    0xcd5(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   10f0 <sprintf@plt>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     121e <func0+0x35>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 113,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r14\nmov    %esi,%r12d\nmovslq %esi,%rdi\nshl    $0x3,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,%r13\ntest   %r12d,%r12d\njle    12b4 <func0+0xcb>\nmov    %r12d,%r12d\nmov    $0x0,%ebp\nlea    0xde0(%rip),%r15\njmp    129e <func0+0xb5>\nadd    $0x1,%rdx\nmovzbl -0x1(%rdx),%eax\ntest   %al,%al\nje     125d <func0+0x74>\nlea    -0x30(%rax),%ecx\ncmp    $0x9,%cl\nja     122a <func0+0x41>\nmovsbl %al,%eax\nsub    $0x30,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nand    $0x1,%eax\nsub    %ecx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\njmp    122a <func0+0x41>\nmov    $0x64,%edi\ncall   10e0 <malloc@plt>\nmov    %rax,%rdi\nmov    %rax,0x0(%r13,%rbp,8)\nsub    $0x8,%rsp\npush   %rbx\nmov    %ebx,%r9d\nmov    %ebx,%r8d\nmov    %r15,%rcx\nmov    $0x64,%edx\nmov    $0x1,%esi\nmov    $0x0,%eax\ncall   10f0 <__sprintf_chk@plt>\nadd    $0x1,%rbp\nadd    $0x10,%rsp\ncmp    %r12,%rbp\nje     12b4 <func0+0xcb>\nmov    (%r14,%rbp,8),%rdx\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\nmov    $0x0,%ebx\ntest   %al,%al\njne    1236 <func0+0x4d>\njmp    125d <func0+0x74>\nmov    %r13,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 113,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmovslq %esi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nlea    0x0(,%rbp,8),%rdi\n00\nsub    $0x8,%rsp\ncall   10e0 <malloc@plt>\nmov    %rax,%r12\ntest   %ebp,%ebp\njle    14a0 <func0+0xb0>\nxor    %r14d,%r14d\nlea    0xbde(%rip),%r13\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx,%r14,8),%rdx\nxor    %r15d,%r15d\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\nje     1464 <func0+0x74>\nnopw   0x0(%rax,%rax,1)\nlea    -0x30(%rax),%ecx\ncmp    $0x9,%cl\nja     1459 <func0+0x69>\nand    $0x1,%eax\ncmp    $0x1,%al\nsbb    $0xffffffff,%r15d\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\njne    1448 <func0+0x58>\nmov    $0x64,%edi\ncall   10e0 <malloc@plt>\nsub    $0x8,%rsp\nmov    %r15d,%r9d\nmov    %r15d,%r8d\npush   %r15\nmov    %rax,%rdi\nmov    $0x64,%edx\nmov    %r13,%rcx\nmov    %rax,(%r12,%r14,8)\nmov    $0x1,%esi\nxor    %eax,%eax\nadd    $0x1,%r14\ncall   10f0 <__sprintf_chk@plt>\npop    %rax\npop    %rdx\ncmp    %r14,%rbp\njne    1430 <func0+0x40>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnopl   (%rax)\n"
    },
    {
        "task_id": 113,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmovslq %esi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nlea    0x0(,%rbp,8),%rdi\n00\nsub    $0x8,%rsp\ncall   10e0 <malloc@plt>\nmov    %rax,%r12\ntest   %ebp,%ebp\njle    14d0 <func0+0xb0>\nxor    %r14d,%r14d\nlea    0xbae(%rip),%r13\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx,%r14,8),%rdx\nxor    %r15d,%r15d\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\nje     1494 <func0+0x74>\nnopw   0x0(%rax,%rax,1)\nlea    -0x30(%rax),%ecx\ncmp    $0x9,%cl\nja     1489 <func0+0x69>\nand    $0x1,%eax\ncmp    $0x1,%al\nsbb    $0xffffffff,%r15d\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\njne    1478 <func0+0x58>\nmov    $0x64,%edi\ncall   10e0 <malloc@plt>\nsub    $0x8,%rsp\nmov    %r15d,%r9d\nmov    %r15d,%r8d\npush   %r15\nmov    %rax,%rdi\nmov    $0x64,%edx\nmov    %r13,%rcx\nmov    %rax,(%r12,%r14,8)\nmov    $0x1,%esi\nxor    %eax,%eax\nadd    $0x1,%r14\ncall   10f0 <__sprintf_chk@plt>\npop    %rax\npop    %rdx\ncmp    %rbp,%r14\njne    1460 <func0+0x40>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnopl   (%rax)\n"
    },
    {
        "task_id": 114,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x1,-0x14(%rbp)\njmp    11ef <func0+0x86>\ncmpq   $0x0,-0x10(%rbp)\njns    11be <func0+0x55>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\njmp    11d5 <func0+0x6c>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njge    11eb <func0+0x82>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1197 <func0+0x2e>\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 114,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    (%rdi),%rax\ncmp    $0x1,%esi\njle    11a3 <func0+0x3a>\nlea    0x8(%rdi),%rdx\nlea    -0x2(%rsi),%ecx\nlea    0x10(%rdi,%rcx,8),%rsi\nmov    %rax,%rcx\njmp    1199 <func0+0x30>\nmov    (%rdx),%rax\ncmp    %rax,%rcx\ncmovg  %rax,%rcx\nadd    $0x8,%rdx\ncmp    %rsi,%rdx\nje     11a6 <func0+0x3d>\ntest   %rax,%rax\njns    1186 <func0+0x1d>\nadd    (%rdx),%rax\njmp    1189 <func0+0x20>\nmov    %rax,%rcx\nmov    %rcx,%rax\nret\n"
    },
    {
        "task_id": 114,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    (%rdi),%rax\ncmp    $0x1,%esi\njle    16a8 <func0+0x48>\nlea    -0x2(%rsi),%ecx\nlea    0x8(%rdi),%rdx\nmov    %rax,%r8\nlea    0x10(%rdi,%rcx,8),%rdi\nnopl   0x0(%rax,%rax,1)\nmov    (%rdx),%rcx\ntest   %rax,%rax\nlea    (%rax,%rcx,1),%rsi\nmov    %rcx,%rax\ncmovs  %rsi,%rax\ncmp    %rax,%r8\ncmovg  %rax,%r8\nadd    $0x8,%rdx\ncmp    %rdi,%rdx\njne    1680 <func0+0x20>\nmov    %r8,%rax\nret\nnopl   (%rax)\nmov    %rax,%r8\nmov    %r8,%rax\nret\n"
    },
    {
        "task_id": 114,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    (%rdi),%rcx\ncmp    $0x1,%esi\njle    1198 <func0+0x58>\nlea    -0x2(%rsi),%eax\nlea    0x8(%rdi),%rdx\nmov    %rcx,%r8\nlea    0x10(%rdi,%rax,8),%rsi\njmp    1173 <func0+0x33>\nnopl   (%rax)\ncmp    %rax,%r8\ncmovg  %rax,%r8\nadd    $0x8,%rdx\ncmp    %rdx,%rsi\nje     118e <func0+0x4e>\nmov    %rax,%rcx\nmov    (%rdx),%rax\ntest   %rcx,%rcx\njns    1160 <func0+0x20>\nadd    %rcx,%rax\ncmp    %rax,%r8\ncmovg  %rax,%r8\nadd    $0x8,%rdx\ncmp    %rsi,%rdx\njne    1170 <func0+0x30>\nmov    %r8,%rax\nret\nnopw   0x0(%rax,%rax,1)\nmov    %rcx,%r8\nmov    %r8,%rax\nret\n"
    },
    {
        "task_id": 115,
        "type": "O0",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    %ecx,-0x24(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    124e <func0+0x85>\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    122a <func0+0x61>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     11fe <func0+0x35>\ncmpl   $0x0,-0x8(%rbp)\njle    124a <func0+0x81>\nmov    -0x8(%rbp),%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\ncltd\nidivl  -0x24(%rbp)\nadd    %eax,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     11ee <func0+0x25>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 115,
        "type": "O1",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    122f <func0+0x66>\npush   %rbx\nmov    %edx,%r10d\nmov    %ecx,%r9d\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%rdi\nlea    -0x1(%rdx),%eax\nmov    $0x0,%esi\nlea    0x4(,%rax,4),%rbx\n00\nmov    $0x0,%r11d\njmp    1204 <func0+0x3b>\nadd    $0x8,%r8\ncmp    %rdi,%r8\nje     1237 <func0+0x6e>\ntest   %r10d,%r10d\njle    11fb <func0+0x32>\nmov    (%r8),%rax\nlea    (%rbx,%rax,1),%rcx\nmov    %r11d,%edx\nadd    (%rax),%edx\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    1213 <func0+0x4a>\ntest   %edx,%edx\njle    11fb <func0+0x32>\nlea    -0x1(%rdx,%r9,1),%eax\ncltd\nidiv   %r9d\nadd    %eax,%esi\njmp    11fb <func0+0x32>\nmov    $0x0,%esi\nmov    %esi,%eax\nret\nmov    %esi,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 115,
        "type": "O2",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edx,%r10d\nmov    %ecx,%r11d\ntest   %esi,%esi\njle    1638 <func0+0x68>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x8(%rdi,%rax,8),%rsi\nlea    -0x1(%rdx),%eax\nlea    0x4(,%rax,4),%r9\n00\nnopl   0x0(%rax)\ntest   %r10d,%r10d\njle    162b <func0+0x5b>\nmov    (%rdi),%rax\nxor    %edx,%edx\nlea    (%r9,%rax,1),%rcx\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nadd    (%rax),%edx\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    1610 <func0+0x40>\ntest   %edx,%edx\njle    162b <func0+0x5b>\nlea    -0x1(%rdx,%r11,1),%eax\ncltd\nidiv   %r11d\nadd    %eax,%r8d\nadd    $0x8,%rdi\ncmp    %rsi,%rdi\njne    15f8 <func0+0x28>\nmov    %r8d,%eax\nret\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 115,
        "type": "O3",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    161d <func0+0xed>\nlea    -0x1(%rsi),%eax\npush   %r13\nmov    %ecx,%r9d\nmov    %rdi,%rcx\npush   %r12\nmov    %edx,%r8d\nxor    %r10d,%r10d\npush   %rbp\nlea    -0x1(%rdx),%ebp\npush   %rbx\nlea    0x8(%rdi,%rax,8),%rbx\nmov    %edx,%eax\nmov    %edx,%edi\nshr    $0x2,%eax\nand    $0xfffffffc,%edi\nlea    -0x1(%rax),%r11d\nadd    $0x1,%r11\nshl    $0x4,%r11\nnop\ntest   %r8d,%r8d\njle    1600 <func0+0xd0>\nmov    (%rcx),%rsi\ncmp    $0x2,%ebp\njbe    1617 <func0+0xe7>\nmov    %rsi,%rax\nlea    (%r11,%rsi,1),%rdx\npxor   %xmm0,%xmm0\nmovdqu (%rax),%xmm2\nadd    $0x10,%rax\npaddd  %xmm2,%xmm0\ncmp    %rdx,%rax\njne    1590 <func0+0x60>\nmovdqa %xmm0,%xmm1\nmov    %edi,%edx\npsrldq $0x8,%xmm1\npaddd  %xmm1,%xmm0\nmovdqa %xmm0,%xmm1\npsrldq $0x4,%xmm1\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%eax\ncmp    %edi,%r8d\nje     15f0 <func0+0xc0>\nmovslq %edx,%r12\nlea    0x0(,%r12,4),%r13\n00\nadd    (%rsi,%r12,4),%eax\nlea    0x1(%rdx),%r12d\ncmp    %r12d,%r8d\njle    15f0 <func0+0xc0>\nadd    $0x2,%edx\nadd    0x4(%rsi,%r13,1),%eax\ncmp    %edx,%r8d\njle    15f0 <func0+0xc0>\nadd    0x8(%rsi,%r13,1),%eax\ntest   %eax,%eax\njle    1600 <func0+0xd0>\nlea    -0x1(%rax,%r9,1),%eax\ncltd\nidiv   %r9d\nadd    %eax,%r10d\nadd    $0x8,%rcx\ncmp    %rbx,%rcx\njne    1570 <func0+0x40>\npop    %rbx\nmov    %r10d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nxor    %edx,%edx\nxor    %eax,%eax\njmp    15c6 <func0+0x96>\nxor    %eax,%eax\nret\n"
    },
    {
        "task_id": 116,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    12dd <func0+0x154>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmp    12cd <func0+0x144>\nmovl   $0x0,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\njmp    11f9 <func0+0x70>\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\nadd    %eax,-0x18(%rbp)\nsarl   -0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     11ed <func0+0x64>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    121a <func0+0x91>\nmov    -0x10(%rbp),%eax\nand    $0x1,%eax\nadd    %eax,-0x18(%rbp)\nsarl   -0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njg     120e <func0+0x85>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     126a <func0+0xe1>\nmov    -0x10(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njne    12c9 <func0+0x140>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    12c9 <func0+0x140>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11b2 <func0+0x29>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11a4 <func0+0x1b>\nnop\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 116,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    125d <func0+0xd4>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r13\nlea    0x4(%rdi),%r9\nlea    -0x1(%rsi),%r14d\nmov    %esi,%r12d\nmov    $0x1,%ebp\nadd    $0x8,%r13\njmp    1228 <func0+0x9f>\nmov    $0x0,%ecx\njmp    1211 <func0+0x88>\nmov    %r8d,-0x4(%r11)\nmov    %edi,(%r10)\nadd    $0x4,%rsi\ncmp    %rbx,%rsi\nje     1220 <func0+0x97>\nmov    %r9,%r11\nmov    -0x4(%r9),%edi\nmov    %rsi,%r10\nmov    (%rsi),%r8d\ntest   %edi,%edi\njle    1241 <func0+0xb8>\nmov    %edi,%eax\nmov    $0x0,%edx\nmov    %eax,%ecx\nand    $0x1,%ecx\nadd    %ecx,%edx\nsar    %eax\ntest   %eax,%eax\njg     11e7 <func0+0x5e>\ntest   %r8d,%r8d\njle    11b8 <func0+0x2f>\nmov    %r8d,%eax\nmov    $0x0,%ecx\nmov    %eax,%r15d\nand    $0x1,%r15d\nadd    %r15d,%ecx\nsar    %eax\ntest   %eax,%eax\njg     1201 <func0+0x78>\ncmp    %ecx,%edx\njg     11bf <func0+0x36>\ncmp    %r8d,%edi\njle    11c6 <func0+0x3d>\ncmp    %edx,%ecx\njne    11c6 <func0+0x3d>\njmp    11bf <func0+0x36>\nadd    $0x1,%rbp\nadd    $0x4,%r9\ncmp    %r12,%rbp\nje     1252 <func0+0xc9>\nmov    %r14d,%eax\nsub    %ebp,%eax\nlea    -0x1(%rbp,%rax,1),%rax\nlea    0x0(%r13,%rax,4),%rbx\nmov    %r9,%rsi\njmp    11cf <func0+0x46>\nmov    $0x0,%edx\nmov    $0x0,%ecx\ntest   %r8d,%r8d\njg     11f9 <func0+0x70>\njmp    1215 <func0+0x8c>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nret\n"
    },
    {
        "task_id": 116,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\ntest   %ebp,%ebp\njle    1629 <func0+0xa9>\nmov    %rdi,%r12\nlea    0x4(%rdi),%r10\nlea    -0x1(%rbp),%r13d\nmov    $0x1,%ebx\nadd    $0x8,%r12\ncmp    %rbp,%rbx\nje     1629 <func0+0xa9>\nnopl   (%rax)\nmov    %r13d,%eax\nmov    %r10,%rdi\nsub    %ebx,%eax\nlea    -0x1(%rbx,%rax,1),%rax\nlea    (%r12,%rax,4),%r11\nnopl   0x0(%rax)\nmov    -0x4(%r10),%r8d\nmov    (%rdi),%r9d\ntest   %r8d,%r8d\njle    1640 <func0+0xc0>\nmov    %r8d,%eax\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nmov    %eax,%edx\nand    $0x1,%edx\nadd    %edx,%ecx\nsar    %eax\njne    15e0 <func0+0x60>\ntest   %r9d,%r9d\njle    1603 <func0+0x83>\nmov    %r9d,%edx\nxor    %eax,%eax\nnopl   (%rax)\nmov    %edx,%esi\nand    $0x1,%esi\nadd    %esi,%eax\nsar    %edx\njne    15f8 <func0+0x78>\ncmp    %eax,%ecx\njg     1630 <func0+0xb0>\nsete   %al\ncmp    %r9d,%r8d\njle    1613 <func0+0x93>\ntest   %al,%al\njne    1630 <func0+0xb0>\nadd    $0x4,%rdi\ncmp    %r11,%rdi\njne    15c8 <func0+0x48>\nadd    $0x1,%rbx\nadd    $0x4,%r10\ncmp    %rbp,%rbx\njne    15b0 <func0+0x30>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    %r9d,-0x4(%r10)\nmov    %r8d,(%rdi)\njmp    1613 <func0+0x93>\nnopl   0x0(%rax)\nxor    %ecx,%ecx\nmov    $0x1,%eax\ntest   %r9d,%r9d\njg     15f0 <func0+0x70>\njmp    160a <func0+0x8a>\nxchg   %ax,%ax\n"
    },
    {
        "task_id": 116,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    157e <func0+0xae>\npush   %rbp\nmov    %rdi,%r10\nmovslq %esi,%rbp\nmov    $0x1,%r11d\npush   %rbx\nmov    %esi,%ebx\nnopl   (%rax)\nmov    %r11,%rdi\nnopl   0x0(%rax,%rax,1)\nmov    -0x4(%r10,%r11,4),%r8d\nmov    (%r10,%rdi,4),%r9d\ntest   %r8d,%r8d\njle    1570 <func0+0xa0>\nmov    %r8d,%eax\nxor    %ecx,%ecx\nnopl   0x0(%rax,%rax,1)\nmov    %eax,%edx\nand    $0x1,%edx\nadd    %edx,%ecx\nsar    %eax\njne    1510 <func0+0x40>\ntest   %r9d,%r9d\njle    1533 <func0+0x63>\nmov    %r9d,%edx\nxor    %eax,%eax\nnopl   (%rax)\nmov    %edx,%esi\nand    $0x1,%esi\nadd    %esi,%eax\nsar    %edx\njne    1528 <func0+0x58>\ncmp    %eax,%ecx\njg     1560 <func0+0x90>\nsete   %al\ncmp    %r9d,%r8d\njle    1543 <func0+0x73>\ntest   %al,%al\njne    1560 <func0+0x90>\nadd    $0x1,%rdi\ncmp    %edi,%ebx\njg     14f8 <func0+0x28>\nadd    $0x1,%r11\ncmp    %r11,%rbp\njne    14f0 <func0+0x20>\npop    %rbx\npop    %rbp\nret\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %r9d,-0x4(%r10,%r11,4)\nmov    %r8d,(%r10,%rdi,4)\njmp    1543 <func0+0x73>\nnopl   0x0(%rax,%rax,1)\nxor    %ecx,%ecx\nmov    $0x1,%eax\ntest   %r9d,%r9d\njg     1520 <func0+0x50>\njmp    153a <func0+0x6a>\nret\nnop\n"
    },
    {
        "task_id": 117,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x58,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %esi,-0x4c(%rbp)\nmov    %rdx,-0x58(%rbp)\nlea    0xd80(%rip),%rax\nmov    %rax,-0x28(%rbp)\nmovq   $0x0,-0x30(%rbp)\n00\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   1100 <strlen@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   1150 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x34(%rbp)\njmp    1452 <func0+0x1e9>\ncall   1170 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x48(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2000,%eax\ntest   %eax,%eax\njne    1322 <func0+0xb9>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    13d1 <func0+0x168>\nmov    -0x40(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njne    13bf <func0+0x156>\nmov    -0x34(%rbp),%eax\nsub    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x3c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1160 <realloc@plt>\nmov    %rax,-0x30(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1100 <strlen@plt>\nadd    $0x1,%rax\nmov    -0x3c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x30(%rbp),%rdx\nlea    (%rcx,%rdx,1),%rbx\nmov    %rax,%rdi\ncall   1150 <malloc@plt>\nmov    %rax,(%rbx)\nmov    -0x3c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10f0 <strcpy@plt>\naddl   $0x1,-0x3c(%rbp)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\nmovl   $0x0,-0x40(%rbp)\njmp    144e <func0+0x1e5>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x34(%rbp),%eax\nsub    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1120 <strchr@plt>\ntest   %rax,%rax\njne    144e <func0+0x1e5>\ncall   1170 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x48(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\nje     144e <func0+0x1e5>\naddl   $0x1,-0x40(%rbp)\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\ncmp    %rax,-0x20(%rbp)\njae    12d9 <func0+0x70>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   10e0 <free@plt>\nmov    -0x58(%rbp),%rax\nmov    -0x3c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 117,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%r14\nmov    %esi,0x10(%rsp)\nmov    %rdx,0x28(%rsp)\ncall   1100 <strlen@plt>\nmov    %rax,%r13\nlea    0x1(%rax),%rdi\ncall   1150 <malloc@plt>\nmov    %rax,0x20(%rsp)\ncall   1170 <__ctype_b_loc@plt>\nmov    %rax,%r15\nmov    $0x0,%ebx\nmovl   $0x0,0xc(%rsp)\n00\nmovl   $0x0,0x14(%rsp)\n00\nmovl   $0x0,0x8(%rsp)\n00\nmovq   $0x0,0x18(%rsp)\n00 00\njmp    12fa <func0+0x91>\nmov    0x8(%rsp),%esi\ncmp    %esi,0x10(%rsp)\nje     1355 <func0+0xec>\nmov    0x4(%rsp),%eax\nadd    $0x1,%eax\nmov    %eax,0xc(%rsp)\nmovl   $0x0,0x8(%rsp)\n00\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r13\nje     13b2 <func0+0x149>\nmov    %rax,%rbx\nmov    %ebx,0x4(%rsp)\nmov    %ebx,%eax\nmov    (%r15),%r12\nmovzbl (%r14,%rbx,1),%ebp\nmovsbq %bpl,%rdx\ntestb  $0x20,0x1(%r12,%rdx,2)\njne    12cd <func0+0x64>\ntest   %bpl,%bpl\nje     12cd <func0+0x64>\nsub    0xc(%rsp),%eax\ncltq\nmov    0x20(%rsp),%rcx\nmov    %bpl,(%rcx,%rax,1)\nmovsbl %bpl,%esi\nlea    0xcd1(%rip),%rdi\ncall   1120 <strchr@plt>\ntest   %rax,%rax\njne    12ea <func0+0x81>\nmovzbl %bpl,%ebp\nmovzwl (%r12,%rbp,2),%eax\nand    $0x400,%ax\ncmp    $0x1,%ax\nsbbl   $0xffffffff,0x8(%rsp)\njmp    12ea <func0+0x81>\nsub    0xc(%rsp),%eax\ncltq\nmov    0x20(%rsp),%r12\nmovb   $0x0,(%r12,%rax,1)\naddl   $0x1,0x14(%rsp)\nmov    0x14(%rsp),%eax\nmovslq %eax,%rbp\nshl    $0x3,%rbp\nmov    %rbp,%rsi\nmov    0x18(%rsp),%rdi\ncall   1160 <realloc@plt>\nmov    %rax,0x18(%rsp)\nmov    %r12,%rdi\ncall   1100 <strlen@plt>\nlea    0x1(%rax),%rdi\ncall   1150 <malloc@plt>\nmov    %rax,%rdi\nmov    0x18(%rsp),%rax\nmov    %rdi,-0x8(%rax,%rbp,1)\nmov    %r12,%rsi\ncall   10f0 <strcpy@plt>\njmp    12d7 <func0+0x6e>\nmov    0x20(%rsp),%rdi\ncall   10e0 <free@plt>\nmov    0x28(%rsp),%rax\nmov    0x14(%rsp),%ecx\nmov    %ecx,(%rax)\nmov    0x18(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 117,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x38,%rsp\nmov    %esi,0xc(%rsp)\nmov    %rdx,0x28(%rsp)\ncall   10f0 <strlen@plt>\nlea    0x1(%rax),%rdi\nmov    %rax,%r15\ncall   1150 <malloc@plt>\nadd    $0x1,%r15d\nmov    %rax,%rbp\ncall   1170 <__ctype_b_loc@plt>\nmovl   $0x0,0x20(%rsp)\n00\nxor    %r11d,%r11d\nxor    %r8d,%r8d\nmov    (%rax),%r12\njmp    16a2 <func0+0x72>\nnopl   0x0(%rax,%rax,1)\ncmp    %r8d,0xc(%rsp)\nje     1740 <func0+0x110>\nmov    %ebx,%r11d\nxor    %r8d,%r8d\nadd    $0x1,%r14\ncmp    %ebx,%r15d\nje     1711 <func0+0xe1>\nmovsbq (%r14),%rsi\nmov    %ebx,%eax\nadd    $0x1,%ebx\nmov    %rsi,%rdx\ntestb  $0x20,0x1(%r12,%rsi,2)\njne    1688 <func0+0x58>\ntest   %sil,%sil\nje     1688 <func0+0x58>\nsub    %r11d,%eax\nlea    0x93f(%rip),%rdi\nmov    %r8d,0x24(%rsp)\ncltq\nmov    %r11d,0x18(%rsp)\nmov    %sil,0x0(%rbp,%rax,1)\nmovsbl %sil,%esi\nmov    %dl,0x10(%rsp)\ncall   1110 <strchr@plt>\nmovzbl 0x10(%rsp),%edx\nmov    0x18(%rsp),%r11d\ntest   %rax,%rax\nmov    0x24(%rsp),%r8d\njne    1699 <func0+0x69>\nmovzwl (%r12,%rdx,2),%eax\nand    $0x400,%ax\ncmp    $0x1,%ax\nsbb    $0xffffffff,%r8d\nadd    $0x1,%r14\ncmp    %ebx,%r15d\njne    16a2 <func0+0x72>\nmov    %rbp,%rdi\ncall   10e0 <free@plt>\nmov    0x28(%rsp),%rax\nmov    0x20(%rsp),%ecx\nmov    %ecx,(%rax)\nadd    $0x38,%rsp\nmov    %r13,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\naddl   $0x1,0x20(%rsp)\nmovslq 0x20(%rsp),%rsi\nsub    %r11d,%eax\nmov    %r13,%rdi\ncltq\nshl    $0x3,%rsi\nmovb   $0x0,0x0(%rbp,%rax,1)\nmov    %rsi,0x18(%rsp)\ncall   1160 <realloc@plt>\nmov    %rbp,%rdi\nmov    %rax,%r13\ncall   10f0 <strlen@plt>\nlea    0x1(%rax),%rdx\nmov    %rdx,%rdi\nmov    %rdx,0x10(%rsp)\ncall   1150 <malloc@plt>\nmov    0x18(%rsp),%rsi\nmov    0x10(%rsp),%rdx\nmov    %rax,%rdi\nmov    %rax,-0x8(%r13,%rsi,1)\nmov    %rbp,%rsi\ncall   1140 <memcpy@plt>\njmp    1693 <func0+0x63>\n"
    },
    {
        "task_id": 117,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x38,%rsp\nmov    %esi,0xc(%rsp)\nmov    %rdx,0x28(%rsp)\ncall   10f0 <strlen@plt>\nlea    0x1(%rax),%rdi\nmov    %rax,%r15\ncall   1150 <malloc@plt>\nadd    $0x1,%r15d\nmov    %rax,%rbp\ncall   1170 <__ctype_b_loc@plt>\nmovl   $0x0,0x20(%rsp)\n00\nxor    %r11d,%r11d\nxor    %r8d,%r8d\nmov    (%rax),%r12\njmp    16c2 <func0+0x72>\nnopl   0x0(%rax,%rax,1)\ncmp    %r8d,0xc(%rsp)\nje     1760 <func0+0x110>\nmov    %ebx,%r11d\nxor    %r8d,%r8d\nadd    $0x1,%r14\ncmp    %ebx,%r15d\nje     1731 <func0+0xe1>\nmovsbq (%r14),%rsi\nmov    %ebx,%eax\nadd    $0x1,%ebx\nmov    %rsi,%rdx\ntestb  $0x20,0x1(%r12,%rsi,2)\njne    16a8 <func0+0x58>\ntest   %sil,%sil\nje     16a8 <func0+0x58>\nsub    %r11d,%eax\nlea    0x91f(%rip),%rdi\nmov    %r8d,0x24(%rsp)\ncltq\nmov    %r11d,0x18(%rsp)\nmov    %sil,0x0(%rbp,%rax,1)\nmovsbl %sil,%esi\nmov    %dl,0x10(%rsp)\ncall   1110 <strchr@plt>\nmovzbl 0x10(%rsp),%edx\nmov    0x18(%rsp),%r11d\ntest   %rax,%rax\nmov    0x24(%rsp),%r8d\njne    16b9 <func0+0x69>\nmovzwl (%r12,%rdx,2),%eax\nand    $0x400,%ax\ncmp    $0x1,%ax\nsbb    $0xffffffff,%r8d\nadd    $0x1,%r14\ncmp    %ebx,%r15d\njne    16c2 <func0+0x72>\nmov    %rbp,%rdi\ncall   10e0 <free@plt>\nmov    0x28(%rsp),%rax\nmov    0x20(%rsp),%ecx\nmov    %ecx,(%rax)\nadd    $0x38,%rsp\nmov    %r13,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\naddl   $0x1,0x20(%rsp)\nmovslq 0x20(%rsp),%rsi\nsub    %r11d,%eax\nmov    %r13,%rdi\ncltq\nshl    $0x3,%rsi\nmovb   $0x0,0x0(%rbp,%rax,1)\nmov    %rsi,0x18(%rsp)\ncall   1160 <realloc@plt>\nmov    %rbp,%rdi\nmov    %rax,%r13\ncall   10f0 <strlen@plt>\nlea    0x1(%rax),%rdx\nmov    %rdx,%rdi\nmov    %rdx,0x10(%rsp)\ncall   1150 <malloc@plt>\nmov    0x18(%rsp),%rsi\nmov    0x10(%rsp),%rdx\nmov    %rax,%rdi\nmov    %rax,-0x8(%r13,%rsi,1)\nmov    %rbp,%rsi\ncall   1140 <memcpy@plt>\njmp    16b3 <func0+0x63>\n"
    },
    {
        "task_id": 118,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nlea    0xe48(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <strlen@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nsub    $0x2,%eax\nmov    %eax,-0x14(%rbp)\njmp    127e <func0+0xd5>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\nje     127a <func0+0xd1>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\njne    127a <func0+0xd1>\nmov    -0x14(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\njne    127a <func0+0xd1>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,0x2da0(%rip)\nlea    0x2d99(%rip),%rax\njmp    1296 <func0+0xed>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     11e3 <func0+0x3a>\nmovb   $0x0,0x2d82(%rip)\nlea    0x2d7b(%rip),%rax\nleave\nret\n"
    },
    {
        "task_id": 118,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbp\ncall   1080 <strlen@plt>\nlea    -0x2(%rax),%edx\ntest   %edx,%edx\njle    123d <func0+0x94>\nmovslq %edx,%rdx\nlea    0x0(%rbp,%rdx,1),%rbx\nlea    -0x1(%rbp,%rdx,1),%r14\nlea    -0x3(%rax),%eax\nsub    %rax,%r14\nlea    0xe26(%rip),%r12\njmp    11e9 <func0+0x40>\nsub    $0x1,%rbx\ncmp    %r14,%rbx\nje     1221 <func0+0x78>\nmovzbl (%rbx),%ebp\nmovsbl %bpl,%esi\nmov    %r12,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\nje     11e0 <func0+0x37>\nmovsbl 0x1(%rbx),%esi\nmov    %r12,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\njne    11e0 <func0+0x37>\nmovsbl -0x1(%rbx),%esi\nmov    %r12,%rdi\ncall   1090 <strchr@plt>\ntest   %rax,%rax\njne    11e0 <func0+0x37>\njmp    1226 <func0+0x7d>\nmov    $0x0,%ebp\nmov    %bpl,0x2de4(%rip)\nlea    0x2ddd(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    $0x0,%ebp\njmp    1226 <func0+0x7d>\n"
    },
    {
        "task_id": 118,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\nlea    -0x2(%rax),%edx\ntest   %edx,%edx\njle    1500 <func0+0xa0>\nmovslq %edx,%rdx\nsub    $0x3,%eax\nlea    0xb76(%rip),%r12\nlea    -0x1(%rbp,%rdx,1),%r13\nlea    0x0(%rbp,%rdx,1),%rbx\nsub    %rax,%r13\njmp    14a9 <func0+0x49>\nnopl   (%rax)\nsub    $0x1,%rbx\ncmp    %r13,%rbx\nje     1500 <func0+0xa0>\nmovsbl (%rbx),%esi\nmov    %r12,%rdi\nmov    %esi,%ebp\ncall   1080 <strchr@plt>\ntest   %rax,%rax\nje     14a0 <func0+0x40>\nmovsbl 0x1(%rbx),%esi\nmov    %r12,%rdi\ncall   1080 <strchr@plt>\ntest   %rax,%rax\njne    14a0 <func0+0x40>\nmovsbl -0x1(%rbx),%esi\nmov    %r12,%rdi\ncall   1080 <strchr@plt>\ntest   %rax,%rax\njne    14a0 <func0+0x40>\nmov    %bpl,0x2b2d(%rip)\nadd    $0x8,%rsp\nlea    0x2b22(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nxor    %ebp,%ebp\njmp    14dd <func0+0x7d>\n"
    },
    {
        "task_id": 118,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\nlea    -0x2(%rax),%edx\ntest   %edx,%edx\njle    1500 <func0+0xa0>\nmovslq %edx,%rdx\nsub    $0x3,%eax\nlea    0xb76(%rip),%r12\nlea    -0x1(%rbp,%rdx,1),%r13\nlea    0x0(%rbp,%rdx,1),%rbx\nsub    %rax,%r13\njmp    14a9 <func0+0x49>\nnopl   (%rax)\nsub    $0x1,%rbx\ncmp    %r13,%rbx\nje     1500 <func0+0xa0>\nmovsbl (%rbx),%esi\nmov    %r12,%rdi\nmov    %esi,%ebp\ncall   1080 <strchr@plt>\ntest   %rax,%rax\nje     14a0 <func0+0x40>\nmovsbl 0x1(%rbx),%esi\nmov    %r12,%rdi\ncall   1080 <strchr@plt>\ntest   %rax,%rax\njne    14a0 <func0+0x40>\nmovsbl -0x1(%rbx),%esi\nmov    %r12,%rdi\ncall   1080 <strchr@plt>\ntest   %rax,%rax\njne    14a0 <func0+0x40>\nmov    %bpl,0x2b2d(%rip)\nadd    $0x8,%rsp\nlea    0x2b22(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nxor    %ebp,%ebp\njmp    14dd <func0+0x7d>\n"
    },
    {
        "task_id": 119,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1070 <strlen@plt>\nmov    %eax,-0x8(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1070 <strlen@plt>\nmov    %eax,-0x4(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1213 <func0+0x8a>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    11ea <func0+0x61>\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    1202 <func0+0x79>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njns    120f <func0+0x86>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njl     11d2 <func0+0x49>\nmovl   $0x0,-0x10(%rbp)\njmp    1265 <func0+0xdc>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    123c <func0+0xb3>\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    1254 <func0+0xcb>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njns    1261 <func0+0xd8>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     1224 <func0+0x9b>\ncmpl   $0x0,-0x14(%rbp)\njne    1285 <func0+0xfc>\ncmpl   $0x0,-0xc(%rbp)\nje     1285 <func0+0xfc>\nlea    0xd88(%rip),%rax\njmp    1353 <func0+0x1ca>\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    12dd <func0+0x154>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    12b4 <func0+0x12b>\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    12cc <func0+0x143>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njns    12d9 <func0+0x150>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     129c <func0+0x113>\nmovl   $0x0,-0x10(%rbp)\njmp    132f <func0+0x1a6>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    1306 <func0+0x17d>\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    131e <func0+0x195>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njns    132b <func0+0x1a2>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njl     12ee <func0+0x165>\ncmpl   $0x0,-0x14(%rbp)\njne    134c <func0+0x1c3>\ncmpl   $0x0,-0xc(%rbp)\nje     134c <func0+0x1c3>\nlea    0xcbe(%rip),%rax\njmp    1353 <func0+0x1ca>\nlea    0xcb9(%rip),%rax\nleave\nret\n"
    },
    {
        "task_id": 119,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    %rsi,%rbp\ncall   1070 <strlen@plt>\nmov    %rax,%r12\nmov    %eax,%r13d\nmov    %rbp,%rdi\ncall   1070 <strlen@plt>\nmov    %eax,%r8d\ntest   %r12d,%r12d\njle    1320 <func0+0x197>\nmov    %rbx,%rsi\nlea    -0x1(%r12),%edx\nlea    0x1(%rbx,%rdx,1),%r10\nmov    $0x1,%ecx\nmov    $0x0,%edx\nmov    $0x0,%r9d\njmp    11f8 <func0+0x6f>\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%edx\ntest   %edx,%edx\ncmovs  %r9d,%ecx\nadd    $0x1,%rsi\ncmp    %r10,%rsi\nje     1206 <func0+0x7d>\nmovzbl (%rsi),%edi\ncmp    $0x28,%dil\njne    11db <func0+0x52>\nadd    $0x1,%edx\njmp    11e9 <func0+0x60>\ntest   %eax,%eax\njle    1244 <func0+0xbb>\nmov    %rbp,%rsi\nlea    -0x1(%rax),%eax\nlea    0x1(%rbp,%rax,1),%r9\nmov    $0x0,%edi\njmp    1231 <func0+0xa8>\nadd    $0x1,%edx\ntest   %edx,%edx\ncmovs  %edi,%ecx\nadd    $0x1,%rsi\ncmp    %rsi,%r9\nje     12f8 <func0+0x16f>\nmovzbl (%rsi),%eax\ncmp    $0x28,%al\nje     121c <func0+0x93>\ncmp    $0x29,%al\nsete   %al\nmovzbl %al,%eax\nsub    %eax,%edx\njmp    121f <func0+0x96>\ntest   %edx,%edx\njne    1257 <func0+0xce>\nlea    0xdb5(%rip),%rax\ntest   %ecx,%ecx\njne    12ed <func0+0x164>\nmov    $0x1,%edx\nmov    $0x0,%eax\ntest   %r12d,%r12d\njg     12a0 <func0+0x117>\nlea    0xd97(%rip),%rax\njmp    12ed <func0+0x164>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r8d\njle    129b <func0+0x112>\nmovzbl 0x0(%rbp,%rcx,1),%esi\ncmp    $0x28,%sil\nje     126f <func0+0xe6>\ncmp    $0x29,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%eax\njmp    1272 <func0+0xe9>\ntest   %r12d,%r12d\njle    12d7 <func0+0x14e>\nmov    $0x0,%ecx\nmov    $0x0,%edi\njmp    12bd <func0+0x134>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r13d\njle    12d7 <func0+0x14e>\nmovzbl (%rbx,%rcx,1),%esi\ncmp    $0x28,%sil\nje     12ac <func0+0x123>\ncmp    $0x29,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%eax\njmp    12af <func0+0x126>\ntest   %eax,%eax\njne    12e6 <func0+0x15d>\nlea    0xd22(%rip),%rax\ntest   %edx,%edx\njne    12ed <func0+0x164>\nlea    0xd1b(%rip),%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ntest   %ecx,%ecx\nje     1307 <func0+0x17e>\nlea    0xd01(%rip),%rax\ntest   %edx,%edx\nje     12ed <func0+0x164>\nmov    $0x0,%ecx\nmov    $0x1,%edx\nmov    $0x0,%eax\nmov    $0x0,%edi\njmp    1280 <func0+0xf7>\nmov    $0x1,%ecx\nmov    $0x0,%edx\ntest   %eax,%eax\njg     120a <func0+0x81>\nlea    0xccb(%rip),%rax\njmp    12ed <func0+0x164>\n"
    },
    {
        "task_id": 119,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\nmov    %rbx,%rdi\nmov    %rax,%r13\nmov    %eax,%r12d\ncall   1070 <strlen@plt>\ntest   %r13d,%r13d\njle    1690 <func0+0x1c0>\nlea    -0x1(%r13),%edx\nmov    %rbp,%rsi\nmov    $0x1,%ecx\nxor    %r8d,%r8d\nlea    0x1(%rbp,%rdx,1),%r9\nxor    %edx,%edx\njmp    153d <func0+0x6d>\nnopl   0x0(%rax,%rax,1)\n00\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%edx\ntest   %edx,%edx\ncmovs  %r8d,%ecx\nadd    $0x1,%rsi\ncmp    %r9,%rsi\nje     1558 <func0+0x88>\nmovzbl (%rsi),%edi\ncmp    $0x28,%dil\njne    1520 <func0+0x50>\nadd    $0x1,%edx\ntest   %edx,%edx\ncmovs  %r8d,%ecx\nadd    $0x1,%rsi\ncmp    %r9,%rsi\njne    153d <func0+0x6d>\ntest   %eax,%eax\njle    16a8 <func0+0x1d8>\nsub    $0x1,%eax\nmov    %rbx,%rsi\nxor    %r9d,%r9d\nlea    0x1(%rbx,%rax,1),%r8\nmov    %rbx,%rax\njmp    1595 <func0+0xc5>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%edx\ntest   %edx,%edx\ncmovs  %r9d,%ecx\nadd    $0x1,%rax\ncmp    %r8,%rax\nje     15b0 <func0+0xe0>\nmovzbl (%rax),%edi\ncmp    $0x28,%dil\njne    1578 <func0+0xa8>\nadd    $0x1,%edx\ntest   %edx,%edx\ncmovs  %r9d,%ecx\nadd    $0x1,%rax\ncmp    %r8,%rax\njne    1595 <func0+0xc5>\ntest   %edx,%edx\njne    15d0 <func0+0x100>\nand    $0x1,%ecx\nlea    0xa46(%rip),%rax\nje     15d0 <func0+0x100>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%edx\nxor    %eax,%eax\nxor    %edi,%edi\njmp    15f9 <func0+0x129>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x29,%cl\nsete   %cl\nmovzbl %cl,%ecx\nsub    %ecx,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rsi\ncmp    %r8,%rsi\nje     1612 <func0+0x142>\nmovzbl (%rsi),%ecx\ncmp    $0x28,%cl\njne    15e0 <func0+0x110>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rsi\ncmp    %r8,%rsi\njne    15f9 <func0+0x129>\ntest   %r13d,%r13d\njle    1658 <func0+0x188>\nxor    %ecx,%ecx\nxor    %edi,%edi\njmp    163c <func0+0x16c>\nnopl   (%rax)\ncmp    $0x29,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r12d\njle    1658 <func0+0x188>\nmovzbl 0x0(%rbp,%rcx,1),%esi\ncmp    $0x28,%sil\njne    1620 <func0+0x150>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r12d\njg     163c <func0+0x16c>\ntest   %eax,%eax\njne    1678 <func0+0x1a8>\nand    $0x1,%edx\nje     1678 <func0+0x1a8>\nadd    $0x8,%rsp\nlea    0x998(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax,%rax,1)\nadd    $0x8,%rsp\nlea    0x985(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\nxor    %edx,%edx\nmov    $0x1,%ecx\ntest   %eax,%eax\njg     1560 <func0+0x90>\njmp    1661 <func0+0x191>\nnopl   0x0(%rax)\ntest   %edx,%edx\njne    16bc <func0+0x1ec>\nand    $0x1,%ecx\nlea    0x94e(%rip),%rax\njne    15c0 <func0+0xf0>\nxor    %eax,%eax\nmov    $0x1,%edx\njmp    1617 <func0+0x147>\n"
    },
    {
        "task_id": 119,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\nmov    %rbx,%rdi\nmov    %rax,%r13\nmov    %eax,%r12d\ncall   1070 <strlen@plt>\ntest   %r13d,%r13d\njle    1690 <func0+0x1c0>\nlea    -0x1(%r13),%edx\nmov    %rbp,%rsi\nmov    $0x1,%ecx\nxor    %r8d,%r8d\nlea    0x1(%rbp,%rdx,1),%r9\nxor    %edx,%edx\njmp    153d <func0+0x6d>\nnopl   0x0(%rax,%rax,1)\n00\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%edx\ntest   %edx,%edx\ncmovs  %r8d,%ecx\nadd    $0x1,%rsi\ncmp    %r9,%rsi\nje     1558 <func0+0x88>\nmovzbl (%rsi),%edi\ncmp    $0x28,%dil\njne    1520 <func0+0x50>\nadd    $0x1,%edx\ntest   %edx,%edx\ncmovs  %r8d,%ecx\nadd    $0x1,%rsi\ncmp    %r9,%rsi\njne    153d <func0+0x6d>\ntest   %eax,%eax\njle    16a8 <func0+0x1d8>\nsub    $0x1,%eax\nmov    %rbx,%rsi\nxor    %r9d,%r9d\nlea    0x1(%rbx,%rax,1),%r8\nmov    %rbx,%rax\njmp    1595 <func0+0xc5>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%edx\ntest   %edx,%edx\ncmovs  %r9d,%ecx\nadd    $0x1,%rax\ncmp    %rax,%r8\nje     15b0 <func0+0xe0>\nmovzbl (%rax),%edi\ncmp    $0x28,%dil\njne    1578 <func0+0xa8>\nadd    $0x1,%edx\ntest   %edx,%edx\ncmovs  %r9d,%ecx\nadd    $0x1,%rax\ncmp    %rax,%r8\njne    1595 <func0+0xc5>\ntest   %edx,%edx\njne    15d0 <func0+0x100>\nand    $0x1,%ecx\nlea    0xa46(%rip),%rax\nje     15d0 <func0+0x100>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%edx\nxor    %eax,%eax\nxor    %edi,%edi\njmp    15f9 <func0+0x129>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x29,%cl\nsete   %cl\nmovzbl %cl,%ecx\nsub    %ecx,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rsi\ncmp    %rsi,%r8\nje     1612 <func0+0x142>\nmovzbl (%rsi),%ecx\ncmp    $0x28,%cl\njne    15e0 <func0+0x110>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rsi\ncmp    %rsi,%r8\njne    15f9 <func0+0x129>\ntest   %r13d,%r13d\njle    1658 <func0+0x188>\nxor    %ecx,%ecx\nxor    %edi,%edi\njmp    163c <func0+0x16c>\nnopl   (%rax)\ncmp    $0x29,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r12d\njle    1658 <func0+0x188>\nmovzbl 0x0(%rbp,%rcx,1),%esi\ncmp    $0x28,%sil\njne    1620 <func0+0x150>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r12d\njg     163c <func0+0x16c>\ntest   %eax,%eax\njne    1678 <func0+0x1a8>\nand    $0x1,%edx\nje     1678 <func0+0x1a8>\nadd    $0x8,%rsp\nlea    0x998(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax,%rax,1)\nadd    $0x8,%rsp\nlea    0x985(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\nxor    %edx,%edx\nmov    $0x1,%ecx\ntest   %eax,%eax\njg     1560 <func0+0x90>\njmp    1661 <func0+0x191>\nnopl   0x0(%rax)\ntest   %edx,%edx\njne    16bc <func0+0x1ec>\nand    $0x1,%ecx\nlea    0x94e(%rip),%rax\njne    15c0 <func0+0xf0>\nxor    %eax,%eax\nmov    $0x1,%edx\njmp    1617 <func0+0x147>\n"
    },
    {
        "task_id": 120,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    %rcx,-0x28(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    124c <func0+0xe3>\nmovl   $0x0,-0xc(%rbp)\njmp    1236 <func0+0xcd>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    1232 <func0+0xc9>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0xc(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    -0x10(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0xc(%rbp)\njl     1197 <func0+0x2e>\naddl   $0x1,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\njl     118b <func0+0x22>\nmovl   $0x0,-0x8(%rbp)\njmp    129f <func0+0x136>\nmov    -0x1c(%rbp),%eax\nsub    -0x20(%rbp),%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     1264 <func0+0xfb>\nnop\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 120,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%r8\nmov    %esi,%r10d\nmov    %edx,%ebx\nmov    %rcx,%r9\nlea    -0x1(%rsi),%edi\ntest   %edi,%edi\njle    11b4 <func0+0x4b>\nlea    0x4(%r8),%r11\njmp    11a4 <func0+0x3b>\nadd    $0x4,%rax\ncmp    %rsi,%rax\nje     119f <func0+0x36>\nmov    (%rax),%edx\nmov    0x4(%rax),%ecx\ncmp    %ecx,%edx\njle    1186 <func0+0x1d>\nmov    %ecx,(%rax)\nmov    %edx,0x4(%rax)\njmp    1186 <func0+0x1d>\nsub    $0x1,%edi\nje     11b4 <func0+0x4b>\ntest   %edi,%edi\njle    119f <func0+0x36>\nmov    %r8,%rax\nlea    -0x1(%rdi),%edx\nlea    (%r11,%rdx,4),%rsi\njmp    118f <func0+0x26>\ntest   %ebx,%ebx\njle    11dc <func0+0x73>\nmov    %ebx,%esi\nmovslq %r10d,%r10\nmovslq %ebx,%rbx\nsub    %rbx,%r10\nlea    (%r8,%r10,4),%rcx\nmov    $0x0,%eax\nmov    (%rcx,%rax,4),%edx\nmov    %edx,(%r9,%rax,4)\nadd    $0x1,%rax\ncmp    %rsi,%rax\njne    11cc <func0+0x63>\npop    %rbx\nret\n"
    },
    {
        "task_id": 120,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edx,%ebx\nlea    -0x1(%rsi),%edx\nmov    %rdi,%r8\nmov    %esi,%r11d\nmov    %rcx,%r9\ntest   %edx,%edx\njle    177d <func0+0x4d>\nlea    0x4(%rdi),%r10\nnopl   0x0(%rax,%rax,1)\nsub    $0x1,%edx\nmov    %r8,%rax\nmov    %rdx,%rdi\nlea    (%r10,%rdx,4),%rsi\nnopl   (%rax)\nmov    (%rax),%edx\nmov    0x4(%rax),%ecx\ncmp    %ecx,%edx\njle    176e <func0+0x3e>\nmov    %ecx,(%rax)\nmov    %edx,0x4(%rax)\nadd    $0x4,%rax\ncmp    %rax,%rsi\njne    1760 <func0+0x30>\nmov    %edi,%edx\ntest   %edi,%edi\njne    1750 <func0+0x20>\ntest   %ebx,%ebx\njle    17a0 <func0+0x70>\nsub    %ebx,%r11d\nmovslq %ebx,%rsi\nmovslq %r11d,%rax\nlea    (%r8,%rax,4),%rcx\nxor    %eax,%eax\nmov    (%rcx,%rax,4),%edx\nmov    %edx,(%r9,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    1790 <func0+0x60>\npop    %rbx\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnopl   (%rax)\n"
    },
    {
        "task_id": 120,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovslq %esi,%r11\npush   %rbx\nmov    %rdi,%r8\nmov    %edx,%r9d\nlea    -0x1(%r11),%eax\nmov    %rcx,%r10\ntest   %eax,%eax\njle    16ed <func0+0x5d>\nlea    0x4(%rdi),%rbx\nnopl   (%rax)\nsub    $0x1,%eax\nmov    %r8,%rdx\nmov    %rax,%rdi\nlea    (%rbx,%rax,4),%rsi\nnopl   (%rax)\nmovq   (%rdx),%xmm0\npshufd $0xe5,%xmm0,%xmm2\nmovd   %xmm0,%eax\nmovd   %xmm2,%ecx\npshufd $0xe1,%xmm0,%xmm1\ncmp    %eax,%ecx\njge    16de <func0+0x4e>\nmovq   %xmm1,(%rdx)\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\njne    16c0 <func0+0x30>\nmov    %edi,%eax\ntest   %edi,%edi\njne    16b0 <func0+0x20>\ntest   %r9d,%r9d\njle    17a2 <func0+0x112>\nmovslq %r9d,%rax\nmov    %r11d,%esi\nmov    %r10,%rdx\nsub    %rax,%r11\nsub    %r9d,%esi\nlea    0x4(,%r11,4),%rax\n00\nlea    (%r8,%rax,1),%rcx\nsub    %rcx,%rdx\ncmp    $0x8,%rdx\njbe    17a4 <func0+0x114>\nlea    -0x1(%r9),%edx\ncmp    $0x2,%edx\njbe    17a4 <func0+0x114>\nmov    %r9d,%edx\nlea    -0x4(%r8,%rax,1),%rcx\nxor    %eax,%eax\nshr    $0x2,%edx\nshl    $0x4,%rdx\nnopl   0x0(%rax,%rax,1)\n00\nmovdqu (%rcx,%rax,1),%xmm3\nmovups %xmm3,(%r10,%rax,1)\nadd    $0x10,%rax\ncmp    %rax,%rdx\njne    1740 <func0+0xb0>\nmov    %r9d,%eax\nand    $0xfffffffc,%eax\ntest   $0x3,%r9b\nje     17a2 <func0+0x112>\nlea    (%rsi,%rax,1),%edx\nmov    %eax,%ecx\nmovslq %edx,%rdx\nlea    0x0(,%rcx,4),%rdi\n00\nmov    (%r8,%rdx,4),%edx\nmov    %edx,(%r10,%rcx,4)\nlea    0x1(%rax),%edx\ncmp    %edx,%r9d\njle    17a2 <func0+0x112>\nadd    %esi,%edx\nadd    $0x2,%eax\nmovslq %edx,%rdx\nmov    (%r8,%rdx,4),%edx\nmov    %edx,0x4(%r10,%rdi,1)\ncmp    %eax,%r9d\njle    17a2 <func0+0x112>\nadd    %esi,%eax\ncltq\nmov    (%r8,%rax,4),%eax\nmov    %eax,0x8(%r10,%rdi,1)\npop    %rbx\nret\nmov    %r9d,%r9d\nlea    (%r8,%r11,4),%rcx\nxor    %eax,%eax\nnopl   (%rax)\nmov    (%rcx,%rax,4),%edx\nmov    %edx,(%r10,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%r9\njne    17b0 <func0+0x120>\npop    %rbx\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnopl   (%rax)\n"
    },
    {
        "task_id": 121,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11cf <func0+0x66>\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    11cb <func0+0x62>\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncmp    %eax,-0x1c(%rbp)\njg     1188 <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 121,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11a8 <func0+0x3f>\nmov    %rdi,%rcx\nsub    $0x1,%esi\nshr    %esi\nmov    %esi,%esi\nlea    0x8(%rdi,%rsi,8),%r8\nmov    $0x0,%esi\nmov    (%rcx),%eax\nmov    %eax,%edi\nshr    $0x1f,%edi\nlea    (%rax,%rdi,1),%edx\nand    $0x1,%edx\nsub    %edi,%edx\nadd    %esi,%eax\ncmp    $0x1,%edx\ncmove  %eax,%esi\nadd    $0x8,%rcx\ncmp    %r8,%rcx\njne    1185 <func0+0x1c>\nmov    %esi,%eax\nret\nmov    $0x0,%esi\njmp    11a5 <func0+0x3c>\n"
    },
    {
        "task_id": 121,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1420 <func0+0x40>\nsub    $0x1,%esi\nxor    %r8d,%r8d\nshr    %esi\nlea    0x8(%rdi,%rsi,8),%rsi\nnopl   (%rax)\nmov    (%rdi),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nlea    (%rax,%rcx,1),%edx\nadd    %r8d,%eax\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\ncmove  %eax,%r8d\nadd    $0x8,%rdi\ncmp    %rsi,%rdi\njne    13f8 <func0+0x18>\nmov    %r8d,%eax\nret\nxchg   %ax,%ax\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 121,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rcx\ntest   %esi,%esi\njle    1280 <func0+0x140>\nlea    -0x1(%rsi),%edx\ncmp    $0x7,%edx\njbe    1283 <func0+0x143>\nshr    $0x3,%edx\nmov    %rdi,%rax\nmovdqa 0xea7(%rip),%xmm4\n00\npxor   %xmm2,%xmm2\nlea    -0x1(%rdx),%edi\nshl    $0x5,%rdi\nlea    0x20(%rcx,%rdi,1),%rdi\nnopl   0x0(%rax)\nmovdqu (%rax),%xmm1\nmovdqu 0x10(%rax),%xmm5\nadd    $0x20,%rax\nshufps $0x88,%xmm5,%xmm1\nmovdqa %xmm1,%xmm3\nmovdqa %xmm1,%xmm0\npsrld  $0x1f,%xmm3\npaddd  %xmm3,%xmm0\npand   %xmm4,%xmm0\npsubd  %xmm3,%xmm0\npcmpeqd %xmm4,%xmm0\npand   %xmm1,%xmm0\npaddd  %xmm0,%xmm2\ncmp    %rdi,%rax\njne    1180 <func0+0x40>\nmovdqa %xmm2,%xmm0\nlea    0x0(,%rdx,4),%r9d\n00\nshl    $0x3,%edx\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm2\nmovdqa %xmm2,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm2\nmovd   %xmm2,%eax\nmovslq %edx,%rdx\nmov    (%rcx,%rdx,4),%edx\nmov    %edx,%r8d\nshr    $0x1f,%r8d\nlea    (%rdx,%r8,1),%edi\nadd    %eax,%edx\nand    $0x1,%edi\nsub    %r8d,%edi\ncmp    $0x1,%edi\ncmove  %edx,%eax\nlea    0x2(%r9,%r9,1),%edx\ncmp    %esi,%edx\njge    1282 <func0+0x142>\nmovslq %edx,%rdi\nlea    0x0(,%rdi,4),%r9\n00\nmov    (%rcx,%rdi,4),%edi\nmov    %edi,%r10d\nshr    $0x1f,%r10d\nlea    (%rdi,%r10,1),%r8d\nadd    %eax,%edi\nand    $0x1,%r8d\nsub    %r10d,%r8d\ncmp    $0x1,%r8d\ncmove  %edi,%eax\nlea    0x2(%rdx),%edi\ncmp    %edi,%esi\njle    1282 <func0+0x142>\nmov    0x8(%rcx,%r9,1),%edi\nmov    %edi,%r10d\nshr    $0x1f,%r10d\nlea    (%rdi,%r10,1),%r8d\nadd    %eax,%edi\nand    $0x1,%r8d\nsub    %r10d,%r8d\ncmp    $0x1,%r8d\ncmove  %edi,%eax\nadd    $0x4,%edx\ncmp    %edx,%esi\njle    1282 <func0+0x142>\nmov    0x10(%rcx,%r9,1),%edx\nmov    %edx,%esi\nshr    $0x1f,%esi\nlea    (%rdx,%rsi,1),%ecx\nadd    %eax,%edx\nand    $0x1,%ecx\nsub    %esi,%ecx\ncmp    $0x1,%ecx\ncmove  %edx,%eax\nret\nxchg   %ax,%ax\nxor    %eax,%eax\nret\nxor    %r9d,%r9d\nxor    %eax,%eax\nxor    %edx,%edx\njmp    11e4 <func0+0xa4>\n"
    },
    {
        "task_id": 122,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11db <func0+0x72>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0xffffff9d,%eax\njl     11d7 <func0+0x6e>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0x63,%eax\njg     11d7 <func0+0x6e>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1188 <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 122,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    119d <func0+0x34>\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rdi\nmov    $0x0,%ecx\nmov    (%rdx),%eax\nlea    0x63(%rax),%esi\nadd    %ecx,%eax\ncmp    $0xc7,%esi\ncmovb  %eax,%ecx\nadd    $0x4,%rdx\ncmp    %rdi,%rdx\njne    1181 <func0+0x18>\nmov    %ecx,%eax\nret\nmov    $0x0,%ecx\njmp    119a <func0+0x31>\n"
    },
    {
        "task_id": 122,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1320 <func0+0x40>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x4(%rdi,%rax,4),%rcx\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi),%eax\nlea    0x63(%rax),%edx\nadd    %r8d,%eax\ncmp    $0xc7,%edx\ncmovb  %eax,%r8d\nadd    $0x4,%rdi\ncmp    %rcx,%rdi\njne    12f8 <func0+0x18>\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 122,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rcx\nmov    %esi,%edx\ntest   %esi,%esi\njle    1238 <func0+0xf8>\nlea    -0x1(%rsi),%eax\ncmp    $0x2,%eax\njbe    1241 <func0+0x101>\nshr    $0x2,%esi\nmov    %rdi,%rax\npxor   %xmm1,%xmm1\nmovdqa 0xec1(%rip),%xmm3\n00\nmovdqa 0xea9(%rip),%xmm2\n00\nsub    $0x1,%esi\nmovdqa 0xe8e(%rip),%xmm4\n00\nshl    $0x4,%rsi\nlea    0x10(%rdi,%rsi,1),%rsi\npsubd  %xmm3,%xmm2\nnop\nmovdqu (%rax),%xmm0\nmovdqu (%rax),%xmm5\nadd    $0x10,%rax\npaddd  %xmm4,%xmm0\npsubd  %xmm3,%xmm0\npcmpgtd %xmm2,%xmm0\npandn  %xmm5,%xmm0\npaddd  %xmm0,%xmm1\ncmp    %rax,%rsi\njne    1190 <func0+0x50>\nmovdqa %xmm1,%xmm0\nmov    %edx,%esi\npsrldq $0x8,%xmm0\nand    $0xfffffffc,%esi\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ntest   $0x3,%dl\nje     1240 <func0+0x100>\nmovslq %esi,%rdi\nlea    0x0(,%rdi,4),%r8\n00\nmov    (%rcx,%rdi,4),%edi\nlea    0x63(%rdi),%r9d\nadd    %eax,%edi\ncmp    $0xc7,%r9d\ncmovb  %edi,%eax\nlea    0x1(%rsi),%edi\ncmp    %edx,%edi\njge    123a <func0+0xfa>\nmov    0x4(%rcx,%r8,1),%edi\nlea    0x63(%rdi),%r9d\nadd    %eax,%edi\ncmp    $0xc7,%r9d\ncmovb  %edi,%eax\nadd    $0x2,%esi\ncmp    %edx,%esi\njge    123a <func0+0xfa>\nmov    0x8(%rcx,%r8,1),%edx\nlea    0x63(%rdx),%ecx\nadd    %eax,%edx\ncmp    $0xc7,%ecx\ncmovb  %edx,%eax\nret\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\nret\nxor    %esi,%esi\nxor    %eax,%eax\njmp    11dd <func0+0x9d>\n"
    },
    {
        "task_id": 123,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0xa,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x1,(%rax)\nmov    -0x20(%rbp),%rax\nmovl   $0x1,(%rax)\njmp    1286 <func0+0xbd>\nmov    -0x14(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    1277 <func0+0xae>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njg     1241 <func0+0x78>\nshll   -0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10d0 <realloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x28(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x14(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    1286 <func0+0xbd>\nmov    -0x14(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njne    1200 <func0+0x37>\nmovl   $0x1,-0xc(%rbp)\njmp    1337 <func0+0x16e>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmp    12f5 <func0+0x12c>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nsubl   $0x1,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njs     1316 <func0+0x14d>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x4(%rbp)\njl     12c0 <func0+0xf7>\nmov    -0x8(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njl     129c <func0+0xd3>\nnop\nnop\nleave\nret\n"
    },
    {
        "task_id": 123,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%r8\nmov    %rdx,%rbx\nmovl   $0x1,(%rdx)\nmovl   $0x1,(%rsi)\ncmp    $0x1,%edi\nje     1244 <func0+0x7b>\nmov    %edi,%ebp\nmov    $0xa,%r12d\njmp    120d <func0+0x44>\ncmp    %r12d,(%rbx)\njge    122d <func0+0x64>\nmov    (%rbx),%eax\nlea    0x1(%rax),%edx\nmov    %edx,(%rbx)\ncltq\nmov    %ebp,(%r8,%rax,4)\nlea    0x1(%rbp,%rbp,2),%ebp\ncmp    $0x1,%ebp\nje     1244 <func0+0x7b>\nmov    %ebp,%edx\nshr    $0x1f,%edx\nlea    0x0(%rbp,%rdx,1),%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nje     11f2 <func0+0x29>\nmov    %ebp,%eax\nshr    $0x1f,%eax\nadd    %ebp,%eax\nsar    %eax\nmov    %eax,%ebp\njmp    1208 <func0+0x3f>\nadd    %r12d,%r12d\nmovslq %r12d,%rsi\nshl    $0x2,%rsi\nmov    %r8,%rdi\ncall   10d0 <realloc@plt>\nmov    %rax,%r8\njmp    11f7 <func0+0x2e>\ncmpl   $0x1,(%rbx)\njle    128e <func0+0xc5>\nmov    %r8,%r9\nmov    $0x0,%edi\njmp    126a <func0+0xa1>\nmovslq %edx,%rdx\nmov    %esi,0x4(%r8,%rdx,4)\nadd    $0x1,%rdi\nadd    $0x4,%r9\nlea    0x1(%rdi),%eax\ncmp    %eax,(%rbx)\njle    128e <func0+0xc5>\nmov    0x4(%r9),%esi\nmov    %edi,%edx\nmov    %r9,%rax\ntest   %edi,%edi\njs     1253 <func0+0x8a>\nmov    (%rax),%ecx\ncmp    %esi,%ecx\njle    1253 <func0+0x8a>\nmov    %ecx,0x4(%rax)\nsub    $0x1,%edx\nsub    $0x4,%rax\ncmp    $0xffffffff,%edx\njne    1277 <func0+0xae>\njmp    1253 <func0+0x8a>\npop    %rbx\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 123,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %edi,%ebx\nmov    %rsi,%rdi\nmovl   $0x1,(%rdx)\nmovl   $0x1,(%rsi)\ncmp    $0x1,%ebx\nje     149d <func0+0x6d>\nmov    $0xa,%r12d\njmp    1470 <func0+0x40>\nnopl   0x0(%rax)\nmov    %ebx,%eax\nshr    $0x1f,%eax\nadd    %ebx,%eax\nsar    %eax\nmov    %eax,%ebx\ncmp    $0x1,%ebx\nje     149d <func0+0x6d>\nmov    %ebx,%edx\nshr    $0x1f,%edx\nlea    (%rbx,%rdx,1),%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    1460 <func0+0x30>\nmovslq 0x0(%rbp),%rax\ncmp    %eax,%r12d\njle    1500 <func0+0xd0>\nlea    0x1(%rax),%edx\nmov    %edx,0x0(%rbp)\nmov    %ebx,(%rdi,%rax,4)\nlea    0x1(%rbx,%rbx,2),%ebx\ncmp    $0x1,%ebx\njne    1470 <func0+0x40>\ncmpl   $0x1,0x0(%rbp)\nmov    $0x1,%r8d\njle    14e5 <func0+0xb5>\nnopl   0x0(%rax)\nmov    (%rdi,%r8,4),%esi\nlea    -0x1(%r8),%rax\nnopl   0x0(%rax,%rax,1)\n00\nmov    (%rdi,%rax,4),%edx\nmov    %eax,%ecx\ncmp    %esi,%edx\njle    14f0 <func0+0xc0>\nmov    %edx,0x4(%rdi,%rax,4)\nsub    $0x1,%rax\ncmp    $0xffffffff,%eax\njne    14c0 <func0+0x90>\nmov    %rdi,%rax\nmov    %esi,(%rax)\nadd    $0x1,%r8\ncmp    %r8d,0x0(%rbp)\njg     14b0 <func0+0x80>\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nlea    (%rdi,%rcx,4),%rax\njmp    14d9 <func0+0xa9>\nnopl   0x0(%rax)\nadd    %r12d,%r12d\nmovslq %r12d,%rsi\nshl    $0x2,%rsi\ncall   10d0 <realloc@plt>\nmov    %rax,%rdi\nmovslq 0x0(%rbp),%rax\njmp    148b <func0+0x5b>\nnopl   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 123,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %edi,%ebx\nmov    %rsi,%rdi\nmovl   $0x1,(%rdx)\nmovl   $0x1,(%rsi)\ncmp    $0x1,%ebx\nje     148d <func0+0x6d>\nmov    $0xa,%r12d\njmp    1460 <func0+0x40>\nnopl   0x0(%rax)\nmov    %ebx,%eax\nshr    $0x1f,%eax\nadd    %ebx,%eax\nsar    %eax\nmov    %eax,%ebx\ncmp    $0x1,%ebx\nje     148d <func0+0x6d>\nmov    %ebx,%edx\nshr    $0x1f,%edx\nlea    (%rbx,%rdx,1),%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    1450 <func0+0x30>\nmovslq 0x0(%rbp),%rax\ncmp    %eax,%r12d\njle    14f0 <func0+0xd0>\nlea    0x1(%rax),%edx\nmov    %edx,0x0(%rbp)\nmov    %ebx,(%rdi,%rax,4)\nlea    0x1(%rbx,%rbx,2),%ebx\ncmp    $0x1,%ebx\njne    1460 <func0+0x40>\ncmpl   $0x1,0x0(%rbp)\nmov    $0x1,%r8d\njle    14d5 <func0+0xb5>\nnopl   0x0(%rax)\nmov    (%rdi,%r8,4),%esi\nlea    -0x1(%r8),%rax\nnopl   0x0(%rax,%rax,1)\n00\nmov    (%rdi,%rax,4),%edx\nmov    %eax,%ecx\ncmp    %esi,%edx\njle    14e0 <func0+0xc0>\nmov    %edx,0x4(%rdi,%rax,4)\nsub    $0x1,%rax\ncmp    $0xffffffff,%eax\njne    14b0 <func0+0x90>\nmov    %rdi,%rax\nmov    %esi,(%rax)\nadd    $0x1,%r8\ncmp    %r8d,0x0(%rbp)\njg     14a0 <func0+0x80>\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nlea    (%rdi,%rcx,4),%rax\njmp    14c9 <func0+0xa9>\nnopl   0x0(%rax)\nadd    %r12d,%r12d\nmovslq %r12d,%rsi\nshl    $0x2,%rsi\ncall   10d0 <realloc@plt>\nmov    %rax,%rdi\nmovslq 0x0(%rbp),%rax\njmp    147b <func0+0x5b>\nnopl   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 124,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <strlen@plt>\ncmp    $0xa,%rax\nje     11e4 <func0+0x3b>\nmov    $0x0,%eax\njmp    135b <func0+0x1b2>\nmovl   $0x0,-0x24(%rbp)\njmp    124d <func0+0xa4>\ncmpl   $0x2,-0x24(%rbp)\nje     11f9 <func0+0x50>\ncmpl   $0x5,-0x24(%rbp)\njne    1217 <func0+0x6e>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\nje     1249 <func0+0xa0>\nmov    $0x0,%eax\njmp    135b <func0+0x1b2>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    123f <func0+0x96>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njle    1249 <func0+0xa0>\nmov    $0x0,%eax\njmp    135b <func0+0x1b2>\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x9,-0x24(%rbp)\njle    11ed <func0+0x44>\nmov    -0x38(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0x13(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x12(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x3,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x10(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xf(%rbp)\nmovb   $0x0,-0xe(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x6,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xd(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x7,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xc(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xb(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x9,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xa(%rbp)\nmovb   $0x0,-0x9(%rbp)\nlea    -0x13(%rbp),%rax\nmov    %rax,%rdi\ncall   10b0 <atoi@plt>\nmov    %eax,-0x20(%rbp)\nlea    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   10b0 <atoi@plt>\nmov    %eax,-0x1c(%rbp)\nlea    -0xd(%rbp),%rax\nmov    %rax,%rdi\ncall   10b0 <atoi@plt>\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x20(%rbp)\njle    1304 <func0+0x15b>\ncmpl   $0xc,-0x20(%rbp)\njle    130b <func0+0x162>\nmov    $0x0,%eax\njmp    135b <func0+0x1b2>\ncmpl   $0x0,-0x1c(%rbp)\njle    1317 <func0+0x16e>\ncmpl   $0x1f,-0x1c(%rbp)\njle    131e <func0+0x175>\nmov    $0x0,%eax\njmp    135b <func0+0x1b2>\ncmpl   $0x4,-0x20(%rbp)\nje     1336 <func0+0x18d>\ncmpl   $0x6,-0x20(%rbp)\nje     1336 <func0+0x18d>\ncmpl   $0x9,-0x20(%rbp)\nje     1336 <func0+0x18d>\ncmpl   $0xb,-0x20(%rbp)\njne    1343 <func0+0x19a>\ncmpl   $0x1f,-0x1c(%rbp)\njne    1343 <func0+0x19a>\nmov    $0x0,%eax\njmp    135b <func0+0x1b2>\ncmpl   $0x2,-0x20(%rbp)\njne    1356 <func0+0x1ad>\ncmpl   $0x1d,-0x1c(%rbp)\njle    1356 <func0+0x1ad>\nmov    $0x0,%eax\njmp    135b <func0+0x1b2>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     136f <func0+0x1c6>\ncall   1090 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 124,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%rbx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncall   1080 <strlen@plt>\nmov    %rax,%rdx\nmov    $0x0,%eax\ncmp    $0xa,%rdx\njne    12eb <func0+0x142>\nmov    $0x0,%eax\njmp    11f8 <func0+0x4f>\ncmpb   $0x2d,(%rbx,%rax,1)\njne    1302 <func0+0x159>\nadd    $0x1,%rax\ncmp    $0xa,%rax\nje     1218 <func0+0x6f>\ncmp    $0x2,%eax\nje     11e4 <func0+0x3b>\ncmp    $0x5,%eax\nje     11e4 <func0+0x3b>\nmovzbl (%rbx,%rax,1),%ecx\nlea    -0x30(%rcx),%edx\ncmp    $0x9,%dl\njbe    11ee <func0+0x45>\nmov    $0x0,%eax\njmp    12eb <func0+0x142>\nmovzbl (%rbx),%eax\nmov    %al,0xd(%rsp)\nmovzbl 0x1(%rbx),%eax\nmov    %al,0xe(%rsp)\nmovb   $0x0,0xf(%rsp)\nmovzbl 0x3(%rbx),%eax\nmov    %al,0x10(%rsp)\nmovzbl 0x4(%rbx),%eax\nmov    %al,0x11(%rsp)\nmovb   $0x0,0x12(%rsp)\nmovzbl 0x6(%rbx),%eax\nmov    %al,0x13(%rsp)\nmovzbl 0x7(%rbx),%eax\nmov    %al,0x14(%rsp)\nmovzbl 0x8(%rbx),%eax\nmov    %al,0x15(%rsp)\nmovzbl 0x9(%rbx),%eax\nmov    %al,0x16(%rsp)\nmovb   $0x0,0x17(%rsp)\nlea    0xd(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncall   10b0 <strtol@plt>\nmov    %rax,%rbx\nlea    0x10(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncall   10b0 <strtol@plt>\nmov    %rax,%rbp\nlea    0x13(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncall   10b0 <strtol@plt>\nlea    -0x1(%rbx),%edx\nmov    $0x0,%eax\ncmp    $0xb,%edx\nja     12eb <func0+0x142>\nlea    -0x1(%rbp),%edx\ncmp    $0x1e,%edx\nja     12eb <func0+0x142>\ncmp    $0xb,%ebx\nja     12d7 <func0+0x12e>\nmov    $0xa50,%eax\nbt     %rbx,%rax\njae    12d7 <func0+0x12e>\nmov    $0x0,%eax\ncmp    $0x1f,%ebp\nje     12eb <func0+0x142>\ncmp    $0x2,%ebx\nsete   %al\ncmp    $0x1d,%ebp\nsetg   %dl\nand    %edx,%eax\nxor    $0x1,%eax\nmovzbl %al,%eax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\n00 00\njne    1309 <func0+0x160>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nret\nmov    $0x0,%eax\njmp    12eb <func0+0x142>\ncall   1090 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 124,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncall   1080 <strlen@plt>\nmov    %rax,%r8\nxor    %eax,%eax\ncmp    $0xa,%r8\njne    155a <func0+0x6a>\nxor    %eax,%eax\nmov    $0x24,%ecx\njmp    153f <func0+0x4f>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\ncmp    $0x2d,%dl\njne    1558 <func0+0x68>\nadd    $0x1,%rax\ncmp    $0xa,%rax\nje     1578 <func0+0x88>\nbt     %rax,%rcx\nmovzbl (%rbx,%rax,1),%edx\njb     1530 <func0+0x40>\nsub    $0x30,%edx\ncmp    $0x9,%dl\njbe    1535 <func0+0x45>\nnopl   0x0(%rax)\nxor    %eax,%eax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\n00 00\njne    1622 <func0+0x132>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\nmovzwl (%rbx),%eax\nlea    0xd(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0xf(%rsp)\nmov    %ax,0xd(%rsp)\nmovzwl 0x3(%rbx),%eax\nmovb   $0x0,0x12(%rsp)\nmov    %ax,0x10(%rsp)\nmov    0x6(%rbx),%eax\nmovb   $0x0,0x17(%rsp)\nmov    %eax,0x13(%rsp)\ncall   10b0 <strtol@plt>\nlea    0x10(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %rax,%rbx\ncall   10b0 <strtol@plt>\nlea    0x13(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %rax,%rbp\ncall   10b0 <strtol@plt>\nlea    -0x1(%rbx),%eax\ncmp    $0xb,%eax\nja     1558 <func0+0x68>\nlea    -0x1(%rbp),%eax\ncmp    $0x1e,%eax\nja     1558 <func0+0x68>\ncmp    $0xb,%ebx\nja     1609 <func0+0x119>\nmov    $0xa50,%eax\nbt     %rbx,%rax\njae    1609 <func0+0x119>\ncmp    $0x1f,%ebp\nje     1558 <func0+0x68>\ncmp    $0x2,%ebx\nsete   %al\ncmp    $0x1d,%ebp\nsetg   %dl\nand    %edx,%eax\nxor    $0x1,%eax\nmovzbl %al,%eax\njmp    155a <func0+0x6a>\ncall   1090 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 124,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncall   1080 <strlen@plt>\nmov    %rax,%r8\nxor    %eax,%eax\ncmp    $0xa,%r8\njne    1650 <func0+0x160>\nmovzbl (%rbx),%ecx\nlea    -0x30(%rcx),%edx\ncmp    $0x9,%dl\nja     1650 <func0+0x160>\nmovzbl 0x1(%rbx),%esi\nmovzwl (%rbx),%ecx\nlea    -0x30(%rsi),%edx\ncmp    $0x9,%dl\nja     1650 <func0+0x160>\ncmpb   $0x2d,0x2(%rbx)\njne    1650 <func0+0x160>\nmovzbl 0x3(%rbx),%esi\nlea    -0x30(%rsi),%edx\ncmp    $0x9,%dl\nja     1650 <func0+0x160>\nmovzbl 0x4(%rbx),%edi\nmovzwl 0x3(%rbx),%esi\nlea    -0x30(%rdi),%edx\ncmp    $0x9,%dl\nja     1650 <func0+0x160>\ncmpb   $0x2d,0x5(%rbx)\njne    1650 <func0+0x160>\nmovzbl 0x6(%rbx),%edi\nlea    -0x30(%rdi),%edx\ncmp    $0x9,%dl\nja     1650 <func0+0x160>\nmovzbl 0x7(%rbx),%edi\nlea    -0x30(%rdi),%edx\ncmp    $0x9,%dl\nja     1650 <func0+0x160>\nmovzbl 0x8(%rbx),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     1667 <func0+0x177>\nmovzbl 0x9(%rbx),%eax\nmov    0x6(%rbx),%edx\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     1667 <func0+0x177>\nmov    %si,0xc(%rsp)\nlea    0x8(%rsp),%rdi\nxor    %esi,%esi\nmov    %edx,0x10(%rsp)\nmov    $0xa,%edx\nmov    %cx,0x8(%rsp)\nmovb   $0x0,0xa(%rsp)\nmovb   $0x0,0xe(%rsp)\nmovb   $0x0,0x14(%rsp)\ncall   10b0 <strtol@plt>\nlea    0xc(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %rax,%rbx\ncall   10b0 <strtol@plt>\nmov    $0xa,%edx\nlea    0x10(%rsp),%rdi\nxor    %esi,%esi\nmov    %rax,%rbp\ncall   10b0 <strtol@plt>\nlea    -0x1(%rbx),%edx\nxor    %eax,%eax\ncmp    $0xb,%edx\nja     1650 <func0+0x160>\nlea    -0x1(%rbp),%edx\ncmp    $0x1e,%edx\nja     1650 <func0+0x160>\ncmp    $0xb,%ebx\nja     1639 <func0+0x149>\nmov    $0xa50,%edx\nbt     %rbx,%rdx\njae    1639 <func0+0x149>\ncmp    $0x1f,%ebp\nje     1650 <func0+0x160>\ncmp    $0x2,%ebx\nsete   %al\ncmp    $0x1d,%ebp\nsetg   %dl\nand    %edx,%eax\nxor    $0x1,%eax\nmovzbl %al,%eax\nnopl   (%rax)\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\n00 00\njne    166b <func0+0x17b>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nret\nxor    %eax,%eax\njmp    1650 <func0+0x160>\ncall   1090 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 125,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0xa8,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %rsi,-0xb0(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x98(%rbp)\n00 00 00\nmovl   $0x0,-0x94(%rbp)\n00 00 00\nmovl   $0x0,-0x90(%rbp)\n00 00 00\nmov    -0xa8(%rbp),%rax\nmov    %rax,%rdi\ncall   10f0 <strlen@plt>\nmov    %eax,-0x8c(%rbp)\nmovq   $0x0,-0x88(%rbp)\n00 00 00 00\nmovq   $0x0,-0x80(%rbp)\n00\nmovq   $0x0,-0x78(%rbp)\n00\nmovq   $0x0,-0x70(%rbp)\n00\nmovq   $0x0,-0x68(%rbp)\n00\nmovq   $0x0,-0x60(%rbp)\n00\nmovq   $0x0,-0x58(%rbp)\n00\nmovq   $0x0,-0x50(%rbp)\n00\nmovq   $0x0,-0x48(%rbp)\n00\nmovq   $0x0,-0x40(%rbp)\n00\nmovq   $0x0,-0x38(%rbp)\n00\nmovq   $0x0,-0x30(%rbp)\n00\nmovq   $0x0,-0x28(%rbp)\n00\nmovl   $0x0,-0x20(%rbp)\nmovb   $0x0,-0x1c(%rbp)\nmov    -0xa8(%rbp),%rax\nmov    $0x20,%esi\nmov    %rax,%rdi\ncall   1110 <strchr@plt>\ntest   %rax,%rax\njne    1375 <func0+0x10c>\nmov    -0xa8(%rbp),%rax\nmov    $0x2c,%esi\nmov    %rax,%rdi\ncall   1110 <strchr@plt>\ntest   %rax,%rax\nje     148d <func0+0x224>\nmov    -0x8c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1140 <malloc@plt>\nmov    %rax,-0x88(%rbp)\nmovl   $0x0,-0x9c(%rbp)\n00 00 00\njmp    1476 <func0+0x20d>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     13f0 <func0+0x187>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\nje     13f0 <func0+0x187>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1443 <func0+0x1da>\ncmpl   $0x0,-0x98(%rbp)\njle    146f <func0+0x206>\nmov    -0x98(%rbp),%eax\ncltq\nmovb   $0x0,-0x80(%rbp,%rax,1)\nmov    -0x90(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x88(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nlea    -0x80(%rbp),%rax\nmov    %rax,%rdi\ncall   1160 <strdup@plt>\nmov    %rax,(%rbx)\naddl   $0x1,-0x90(%rbp)\nmovl   $0x0,-0x98(%rbp)\n00 00 00\njmp    146f <func0+0x206>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x98(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x98(%rbp)\nmovzbl (%rcx),%edx\ncltq\nmov    %dl,-0x80(%rbp,%rax,1)\naddl   $0x1,-0x9c(%rbp)\nmov    -0x9c(%rbp),%eax\ncmp    -0x8c(%rbp),%eax\njle    13a2 <func0+0x139>\njmp    1571 <func0+0x308>\nmovl   $0x0,-0x9c(%rbp)\n00 00 00\njmp    150a <func0+0x2a1>\ncall   1170 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0xa8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x200,%eax\ntest   %eax,%eax\nje     1503 <func0+0x29a>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nsub    $0x61,%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    1503 <func0+0x29a>\naddl   $0x1,-0x94(%rbp)\naddl   $0x1,-0x9c(%rbp)\nmov    -0x9c(%rbp),%eax\ncmp    -0x8c(%rbp),%eax\njl     1499 <func0+0x230>\nmov    $0x8,%edi\ncall   1140 <malloc@plt>\nmov    %rax,-0x88(%rbp)\nmov    $0xc,%edi\ncall   1140 <malloc@plt>\nmov    %rax,%rdx\nmov    -0x88(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x88(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x94(%rbp),%edx\nlea    0xab1(%rip),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   1150 <sprintf@plt>\nmovl   $0x1,-0x90(%rbp)\n00 00 00\nmov    -0xb0(%rbp),%rax\nmov    -0x90(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x88(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     159b <func0+0x332>\ncall   1100 <__stack_chk_fail@plt>\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 125,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x78,%rsp\nmov    %rdi,%r12\nmov    %rsi,%r14\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\ncall   10f0 <strlen@plt>\nmov    %rax,%rbp\nmovq   $0x0,(%rsp)\n00\nmovq   $0x0,0x8(%rsp)\n00 00\nmovq   $0x0,0x10(%rsp)\n00 00\nmovq   $0x0,0x18(%rsp)\n00 00\nmovq   $0x0,0x20(%rsp)\n00 00\nmovq   $0x0,0x28(%rsp)\n00 00\nmovq   $0x0,0x30(%rsp)\n00 00\nmovq   $0x0,0x38(%rsp)\n00 00\nmovq   $0x0,0x40(%rsp)\n00 00\nmovq   $0x0,0x48(%rsp)\n00 00\nmovq   $0x0,0x50(%rsp)\n00 00\nmovq   $0x0,0x58(%rsp)\n00 00\nmovl   $0x0,0x60(%rsp)\n00\nmovb   $0x0,0x64(%rsp)\nmov    $0x20,%esi\nmov    %r12,%rdi\ncall   1110 <strchr@plt>\ntest   %rax,%rax\nje     1356 <func0+0xed>\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\nshl    $0x3,%rdi\ncall   1140 <malloc@plt>\nmov    %rax,%r13\ntest   %ebp,%ebp\njs     1476 <func0+0x20d>\nmov    %r12,%rbx\nmov    %ebp,%ebp\nlea    0x1(%r12,%rbp,1),%r12\nmov    $0x0,%ebp\nmov    $0x0,%edx\nmov    %rsp,%r15\njmp    13a0 <func0+0x137>\nmov    $0x2c,%esi\nmov    %r12,%rdi\ncall   1110 <strchr@plt>\ntest   %rax,%rax\njne    1323 <func0+0xba>\nmov    $0x0,%ebx\ntest   %ebp,%ebp\njle    1410 <func0+0x1a7>\ncall   1160 <__ctype_b_loc@plt>\nmov    (%rax),%rdi\nmov    %r12,%rdx\nlea    -0x1(%rbp),%eax\nlea    0x1(%r12,%rax,1),%rsi\nmov    $0x0,%ebx\njmp    13e3 <func0+0x17a>\ntest   %edx,%edx\njg     13b6 <func0+0x14d>\nadd    $0x1,%rbx\ncmp    %r12,%rbx\nje     1451 <func0+0x1e8>\nmovzbl (%rbx),%eax\ntest   $0xdf,%al\nje     138f <func0+0x126>\ncmp    $0x2c,%al\nje     138f <func0+0x126>\nmovslq %edx,%rcx\nmov    %al,(%rsp,%rcx,1)\nlea    0x1(%rdx),%edx\njmp    1393 <func0+0x12a>\nmovslq %edx,%rdx\nmovb   $0x0,(%rsp,%rdx,1)\nmov    %r15,%rdi\ncall   1150 <strdup@plt>\nmov    %rax,%rdx\nmovslq %ebp,%rax\nmov    %rdx,0x0(%r13,%rax,8)\nadd    $0x1,%ebp\nmov    $0x0,%edx\njmp    1393 <func0+0x12a>\nadd    $0x1,%rdx\ncmp    %rsi,%rdx\nje     1410 <func0+0x1a7>\nmovzbl (%rdx),%eax\nmovsbq %al,%rcx\ntestb  $0x2,0x1(%rdi,%rcx,2)\nje     13da <func0+0x171>\nmovsbl %al,%eax\nsub    $0x61,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nand    $0x1,%eax\nsub    %ecx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\njmp    13da <func0+0x171>\nmov    $0x8,%edi\ncall   1140 <malloc@plt>\nmov    %rax,%r13\nmov    $0xc,%edi\ncall   1140 <malloc@plt>\nmov    %rax,%rdi\nmov    %rax,0x0(%r13)\nmov    %ebx,%r8d\nlea    0xbcc(%rip),%rcx\nmov    $0xc,%edx\nmov    $0x1,%esi\nmov    $0x0,%eax\ncall   1170 <__sprintf_chk@plt>\nmov    $0x1,%ebp\nmov    %ebp,(%r14)\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    147d <func0+0x214>\nmov    %r13,%rax\nadd    $0x78,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x0,%ebp\njmp    1451 <func0+0x1e8>\ncall   1100 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 125,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x78,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\ncall   10f0 <strlen@plt>\npxor   %xmm0,%xmm0\nmov    %rbx,%rdi\nmov    $0x20,%esi\nmovl   $0x0,0x60(%rsp)\n00\nmov    %rax,%r12\nmovb   $0x0,0x64(%rsp)\nmovaps %xmm0,(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\ncall   1110 <strchr@plt>\ntest   %rax,%rax\nje     16e8 <func0+0x128>\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\nshl    $0x3,%rdi\ncall   1140 <malloc@plt>\nmov    %rax,%r14\ntest   %r12d,%r12d\njs     1798 <func0+0x1d8>\nmov    %r12d,%r12d\nxor    %edx,%edx\nmov    %rsp,%r15\nlea    0x1(%rbx,%r12,1),%r13\nxor    %r12d,%r12d\njmp    1694 <func0+0xd4>\nnopl   0x0(%rax,%rax,1)\ntest   %edx,%edx\nje     168b <func0+0xcb>\nmovslq %edx,%rdx\nmov    %r15,%rdi\nmovb   $0x0,(%rsp,%rdx,1)\ncall   1150 <strdup@plt>\nxor    %edx,%edx\nmov    %rax,%r8\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmov    %r8,(%r14,%rax,8)\nadd    $0x1,%rbx\ncmp    %rbx,%r13\nje     16b8 <func0+0xf8>\nmovzbl (%rbx),%eax\ntest   $0xdf,%al\nje     1668 <func0+0xa8>\ncmp    $0x2c,%al\nje     1668 <func0+0xa8>\nmovslq %edx,%rcx\nadd    $0x1,%rbx\nadd    $0x1,%edx\nmov    %al,(%rsp,%rcx,1)\ncmp    %rbx,%r13\njne    1694 <func0+0xd4>\nnopl   0x0(%rax)\nmov    %r12d,0x0(%rbp)\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    17a5 <func0+0x1e5>\nadd    $0x78,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x2c,%esi\nmov    %rbx,%rdi\ncall   1110 <strchr@plt>\ntest   %rax,%rax\njne    1634 <func0+0x74>\ntest   %r12d,%r12d\njle    17a0 <func0+0x1e0>\ncall   1160 <__ctype_b_loc@plt>\nmov    (%rax),%rsi\nlea    -0x1(%r12),%eax\nxor    %r12d,%r12d\nlea    0x1(%rbx,%rax,1),%rcx\nnopl   0x0(%rax)\nmovsbq (%rbx),%rdx\nmov    %rdx,%rax\ntestb  $0x2,0x1(%rsi,%rdx,2)\nje     1749 <func0+0x189>\nsub    $0x61,%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r12d\nadd    $0x1,%rbx\ncmp    %rbx,%rcx\njne    1720 <func0+0x160>\nmov    $0x8,%edi\ncall   1140 <malloc@plt>\nmov    $0xc,%edi\nmov    %rax,%r14\ncall   1140 <malloc@plt>\nmov    %r12d,%r8d\nmov    $0xc,%edx\nlea    0x88c(%rip),%rcx\nmov    %rax,(%r14)\nmov    %rax,%rdi\nxor    %eax,%eax\nmov    $0x1,%esi\nmov    $0x1,%r12d\ncall   1170 <__sprintf_chk@plt>\njmp    16b8 <func0+0xf8>\nnopl   (%rax)\nxor    %r12d,%r12d\njmp    16b8 <func0+0xf8>\nxor    %r12d,%r12d\njmp    1752 <func0+0x192>\ncall   1100 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 125,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x78,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\ncall   10f0 <strlen@plt>\npxor   %xmm0,%xmm0\nmov    %rbx,%rdi\nmov    $0x20,%esi\nmovl   $0x0,0x60(%rsp)\n00\nmov    %rax,%r12\nmovb   $0x0,0x64(%rsp)\nmovaps %xmm0,(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\ncall   1110 <strchr@plt>\ntest   %rax,%rax\nje     16f8 <func0+0x128>\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\nshl    $0x3,%rdi\ncall   1140 <malloc@plt>\nmov    %rax,%r14\ntest   %r12d,%r12d\njs     17a8 <func0+0x1d8>\nmov    %r12d,%r12d\nxor    %edx,%edx\nmov    %rsp,%r15\nlea    0x1(%rbx,%r12,1),%r13\nxor    %r12d,%r12d\njmp    16a4 <func0+0xd4>\nnopl   0x0(%rax,%rax,1)\ntest   %edx,%edx\nje     169b <func0+0xcb>\nmovslq %edx,%rdx\nmov    %r15,%rdi\nmovb   $0x0,(%rsp,%rdx,1)\ncall   1150 <strdup@plt>\nxor    %edx,%edx\nmov    %rax,%r8\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmov    %r8,(%r14,%rax,8)\nadd    $0x1,%rbx\ncmp    %rbx,%r13\nje     16c8 <func0+0xf8>\nmovzbl (%rbx),%eax\ntest   $0xdf,%al\nje     1678 <func0+0xa8>\ncmp    $0x2c,%al\nje     1678 <func0+0xa8>\nmovslq %edx,%rcx\nadd    $0x1,%rbx\nadd    $0x1,%edx\nmov    %al,(%rsp,%rcx,1)\ncmp    %rbx,%r13\njne    16a4 <func0+0xd4>\nnopl   0x0(%rax)\nmov    %r12d,0x0(%rbp)\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    17b5 <func0+0x1e5>\nadd    $0x78,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x2c,%esi\nmov    %rbx,%rdi\ncall   1110 <strchr@plt>\ntest   %rax,%rax\njne    1644 <func0+0x74>\ntest   %r12d,%r12d\njle    17b0 <func0+0x1e0>\ncall   1160 <__ctype_b_loc@plt>\nmov    (%rax),%rsi\nlea    -0x1(%r12),%eax\nxor    %r12d,%r12d\nlea    0x1(%rbx,%rax,1),%rcx\nnopl   0x0(%rax)\nmovsbq (%rbx),%rdx\nmov    %rdx,%rax\ntestb  $0x2,0x1(%rsi,%rdx,2)\nje     1759 <func0+0x189>\nsub    $0x61,%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r12d\nadd    $0x1,%rbx\ncmp    %rbx,%rcx\njne    1730 <func0+0x160>\nmov    $0x8,%edi\ncall   1140 <malloc@plt>\nmov    $0xc,%edi\nmov    %rax,%r14\ncall   1140 <malloc@plt>\nmov    %r12d,%r8d\nmov    $0xc,%edx\nlea    0x87c(%rip),%rcx\nmov    %rax,(%r14)\nmov    %rax,%rdi\nxor    %eax,%eax\nmov    $0x1,%esi\nmov    $0x1,%r12d\ncall   1170 <__sprintf_chk@plt>\njmp    16c8 <func0+0xf8>\nnopl   (%rax)\nxor    %r12d,%r12d\njmp    16c8 <func0+0xf8>\nxor    %r12d,%r12d\njmp    1762 <func0+0x192>\ncall   1100 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 126,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njne    1188 <func0+0x1f>\nmov    $0x1,%eax\njmp    1250 <func0+0xe7>\nmovl   $0x1,-0x4(%rbp)\njmp    123f <func0+0xd6>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    11ce <func0+0x65>\nmov    $0x0,%eax\njmp    1250 <func0+0xe7>\ncmpl   $0x1,-0x4(%rbp)\njle    123b <func0+0xd2>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    123b <func0+0xd2>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x8(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    123b <func0+0xd2>\nmov    $0x0,%eax\njmp    1250 <func0+0xe7>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1194 <func0+0x2b>\nmov    $0x1,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 126,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    11a8 <func0+0x3f>\nmov    %esi,%esi\nmov    $0x1,%eax\njmp    1184 <func0+0x1b>\nadd    $0x1,%rax\ncmp    %rsi,%rax\nje     11a2 <func0+0x39>\nmov    (%rdi,%rax,4),%edx\nmov    -0x4(%rdi,%rax,4),%ecx\ncmp    %ecx,%edx\njl     11ae <func0+0x45>\njne    117b <func0+0x12>\ncmp    $0x1,%eax\njle    117b <func0+0x12>\ncmp    -0x8(%rdi,%rax,4),%edx\njne    117b <func0+0x12>\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\nmov    $0x1,%eax\nret\nmov    $0x0,%eax\nret\n"
    },
    {
        "task_id": 126,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\nje     1600 <func0+0x10>\njmp    15a0 <func0.part.0>\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 126,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    15c0 <func0+0x40>\nmovslq %esi,%rsi\nmov    $0x1,%eax\njmp    15a1 <func0+0x21>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rax\ncmp    %rax,%rsi\nje     15c0 <func0+0x40>\nmov    (%rdi,%rax,4),%edx\nmov    -0x4(%rdi,%rax,4),%ecx\ncmp    %ecx,%edx\njl     15bb <func0+0x3b>\ncmp    $0x1,%eax\nje     1598 <func0+0x18>\ncmp    %ecx,%edx\njne    1598 <func0+0x18>\ncmp    -0x8(%rdi,%rax,4),%edx\njne    1598 <func0+0x18>\nxor    %eax,%eax\nret\nxchg   %ax,%ax\nmov    $0x1,%eax\nret\n"
    },
    {
        "task_id": 127,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %edx,-0x1c(%rbp)\nmov    %ecx,-0x20(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x14(%rbp),%eax\ncmp    %eax,%edx\ncmovge %edx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x20(%rbp),%edx\nmov    -0x18(%rbp),%eax\ncmp    %eax,%edx\ncmovle %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njg     11b1 <func0+0x48>\nlea    0xe59(%rip),%rax\njmp    11e6 <func0+0x7d>\nmovl   $0x2,-0x10(%rbp)\njmp    11d4 <func0+0x6b>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x10(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    11d0 <func0+0x67>\nlea    0xe3a(%rip),%rax\njmp    11e6 <func0+0x7d>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x4(%rbp)\njge    11ba <func0+0x51>\nlea    0xe25(%rip),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 127,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%ecx\ncmovg  %esi,%ecx\ncmp    %edi,%edx\ncmovl  %edi,%edx\nsub    %edx,%ecx\nlea    0xe84(%rip),%rax\ncmp    $0x1,%ecx\njle    11be <func0+0x55>\nlea    0xe7b(%rip),%rax\ncmp    $0x3,%ecx\njle    11be <func0+0x55>\nlea    0xe6c(%rip),%rax\ntest   $0x1,%cl\nje     11be <func0+0x55>\nmov    $0x2,%esi\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njg     11bf <func0+0x56>\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\njne    11a2 <func0+0x39>\nlea    0xe46(%rip),%rax\nret\nlea    0xe41(%rip),%rax\nret\n"
    },
    {
        "task_id": 127,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%ecx\nlea    0xeb7(%rip),%rax\ncmovg  %esi,%ecx\ncmp    %edi,%edx\ncmovl  %edi,%edx\nsub    %edx,%ecx\ncmp    $0x1,%ecx\njle    11a7 <func0+0x67>\nlea    0xea4(%rip),%rax\ncmp    $0x3,%ecx\njle    11a7 <func0+0x67>\nlea    0xe95(%rip),%rax\ntest   $0x1,%cl\nje     11a7 <func0+0x67>\nmov    $0x2,%esi\njmp    1189 <func0+0x49>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     11a0 <func0+0x60>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1180 <func0+0x40>\nlea    0xe6b(%rip),%rax\nret\nnopl   (%rax)\nlea    0xe5d(%rip),%rax\nret\n"
    },
    {
        "task_id": 127,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%ecx\nlea    0xeb7(%rip),%rax\ncmovg  %esi,%ecx\ncmp    %edi,%edx\ncmovl  %edi,%edx\nsub    %edx,%ecx\ncmp    $0x1,%ecx\njle    11a7 <func0+0x67>\nlea    0xea4(%rip),%rax\ncmp    $0x3,%ecx\njle    11a7 <func0+0x67>\nlea    0xe95(%rip),%rax\ntest   $0x1,%cl\nje     11a7 <func0+0x67>\nmov    $0x2,%esi\njmp    1189 <func0+0x49>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     11a0 <func0+0x60>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1180 <func0+0x40>\nlea    0xe6b(%rip),%rax\nret\nnopl   (%rax)\nlea    0xe5d(%rip),%rax\nret\n"
    },
    {
        "task_id": 128,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njne    1188 <func0+0x1f>\nmov    $0xffff8000,%eax\njmp    1210 <func0+0xa7>\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1201 <func0+0x98>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nadd    %eax,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    11e0 <func0+0x77>\nmovl   $0x0,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njns    11fd <func0+0x94>\nnegl   -0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     119f <func0+0x36>\nmov    -0xc(%rbp),%eax\nimul   -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 128,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\nje     11bd <func0+0x54>\njle    11af <func0+0x46>\nmov    %rdi,%rcx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r8\nmov    $0x1,%edi\nmov    $0x0,%eax\njmp    1195 <func0+0x2c>\nmov    %edx,%edi\nadd    $0x4,%rcx\ncmp    %r8,%rcx\nje     11b9 <func0+0x50>\nmov    (%rcx),%edx\nmov    %edx,%esi\nneg    %esi\ncmovs  %edx,%esi\nadd    %esi,%eax\ntest   %edx,%edx\nje     118a <func0+0x21>\nmov    %edi,%esi\nneg    %esi\ntest   %edx,%edx\ncmovs  %esi,%edi\njmp    118c <func0+0x23>\nmov    $0x1,%edi\nmov    $0x0,%eax\nimul   %edi,%eax\nret\nmov    $0xffff8000,%eax\nret\n"
    },
    {
        "task_id": 128,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\nje     1493 <func0+0x53>\njle    1490 <func0+0x50>\nlea    -0x1(%rsi),%eax\nmov    $0x1,%esi\nlea    0x4(%rdi,%rax,4),%r8\nxor    %eax,%eax\njmp    1472 <func0+0x32>\nnopl   0x0(%rax,%rax,1)\nmov    %esi,%ecx\nneg    %ecx\ntest   %edx,%edx\ncmovs  %ecx,%esi\nadd    $0x4,%rdi\ncmp    %r8,%rdi\nje     148c <func0+0x4c>\nmov    (%rdi),%edx\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nadd    %ecx,%eax\ntest   %edx,%edx\njne    1460 <func0+0x20>\nadd    $0x4,%rdi\nxor    %esi,%esi\ncmp    %r8,%rdi\njne    1472 <func0+0x32>\nimul   %esi,%eax\nret\nxor    %eax,%eax\nret\nmov    $0xffff8000,%eax\nret\n"
    },
    {
        "task_id": 128,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\nje     1473 <func0+0x53>\njle    1470 <func0+0x50>\nlea    -0x1(%rsi),%eax\nmov    $0x1,%esi\nlea    0x4(%rdi,%rax,4),%r8\nxor    %eax,%eax\njmp    1452 <func0+0x32>\nnopl   0x0(%rax,%rax,1)\nmov    %esi,%ecx\nneg    %ecx\ntest   %edx,%edx\ncmovs  %ecx,%esi\nadd    $0x4,%rdi\ncmp    %r8,%rdi\nje     146c <func0+0x4c>\nmov    (%rdi),%edx\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nadd    %ecx,%eax\ntest   %edx,%edx\njne    1440 <func0+0x20>\nadd    $0x4,%rdi\nxor    %esi,%esi\ncmp    %r8,%rdi\njne    1452 <func0+0x32>\nimul   %esi,%eax\nret\nxor    %eax,%eax\nret\nmov    $0xffff8000,%eax\nret\n"
    },
    {
        "task_id": 129,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %edx,-0x30(%rbp)\nmov    %rcx,-0x38(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    121b <func0+0x72>\nmovl   $0x0,-0x18(%rbp)\njmp    120f <func0+0x66>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0x1,%eax\njne    120b <func0+0x62>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x10(%rbp)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11d5 <func0+0x2c>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11cc <func0+0x23>\nmov    -0x2c(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njle    1284 <func0+0xdb>\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    1284 <func0+0xdb>\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x14(%rbp)\njge    12e9 <func0+0x140>\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    12e9 <func0+0x140>\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njle    1349 <func0+0x1a0>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nsub    $0x4,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    1349 <func0+0x1a0>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nsub    $0x4,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\njge    13ae <func0+0x205>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    13ae <func0+0x205>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x38(%rbp),%rax\nmov    -0x30(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    1418 <func0+0x26f>\nmov    -0x1c(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    13fb <func0+0x252>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\njmp    1414 <func0+0x26b>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     13d5 <func0+0x22c>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 129,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r10\nmov    %esi,%r11d\nmov    %edx,%ebx\nmov    %rcx,%r12\ntest   %esi,%esi\njle    11f0 <func0+0x47>\nmov    %esi,%ecx\nmov    $0x0,%edi\nmov    %edi,%esi\nmov    (%r10,%rdi,8),%rdx\nmov    $0x0,%eax\ncmpl   $0x1,(%rdx,%rax,4)\ncmove  %eax,%r8d\ncmove  %esi,%r9d\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    11d2 <func0+0x29>\nadd    $0x1,%rdi\ncmp    %rcx,%rdi\njne    11c7 <func0+0x1e>\nmov    %r11d,%ebp\nimul   %r11d,%ebp\ntest   %r9d,%r9d\njle    120f <func0+0x66>\nmovslq %r9d,%rdx\nmovslq %r8d,%rax\nmov    -0x8(%r10,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\nsub    $0x1,%r11d\ncmp    %r9d,%r11d\njle    122b <func0+0x82>\nmovslq %r9d,%rdx\nmovslq %r8d,%rax\nmov    0x8(%r10,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\ntest   %r8d,%r8d\njle    1243 <func0+0x9a>\nmovslq %r9d,%rdx\nmovslq %r8d,%rax\nmov    (%r10,%rdx,8),%rdx\nmov    -0x4(%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\ncmp    %r8d,%r11d\njle    125c <func0+0xb3>\nmovslq %r9d,%r9\nmovslq %r8d,%r8\nmov    (%r10,%r9,8),%rax\nmov    0x4(%rax,%r8,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\nmov    %ebx,(%r12)\nmovslq %ebx,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\ntest   %ebx,%ebx\njle    1290 <func0+0xe7>\nmov    %ebx,%ebx\nmov    $0x0,%edx\nmov    $0x1,%esi\ntest   $0x1,%dl\nmov    %esi,%ecx\ncmovne %ebp,%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rbx,%rdx\njne    127c <func0+0xd3>\npop    %rbx\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 129,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rdi,%r10\nmov    %esi,%r11d\nmov    %rcx,%r12\npush   %rbp\npush   %rbx\nmov    %edx,%ebx\ntest   %esi,%esi\njle    183e <func0+0x4e>\nmovslq %esi,%rdx\nxor    %edi,%edi\nnopl   0x0(%rax)\nmov    (%r10,%rdi,8),%rcx\nmov    %edi,%esi\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\n00\ncmpl   $0x1,(%rcx,%rax,4)\ncmove  %eax,%r8d\ncmove  %esi,%r9d\nadd    $0x1,%rax\ncmp    %rdx,%rax\njne    1820 <func0+0x30>\nadd    $0x1,%rdi\ncmp    %rdx,%rdi\njne    1810 <func0+0x20>\nmov    %r11d,%ebp\nimul   %r11d,%ebp\ntest   %r9d,%r9d\nje     185d <func0+0x6d>\nmovslq %r9d,%rdx\nmovslq %r8d,%rax\nmov    -0x8(%r10,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\nsub    $0x1,%r11d\ncmp    %r9d,%r11d\njle    187c <func0+0x8c>\nlea    0x1(%r9),%edx\nmovslq %r8d,%rax\nmovslq %edx,%rdx\nmov    (%r10,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\ntest   %r8d,%r8d\nje     1894 <func0+0xa4>\nmovslq %r9d,%rdx\nmovslq %r8d,%rax\nmov    (%r10,%rdx,8),%rdx\nmov    -0x4(%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\ncmp    %r8d,%r11d\njle    18ae <func0+0xbe>\nmovslq %r9d,%r9\nlea    0x1(%r8),%eax\nmov    (%r10,%r9,8),%rdx\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\nmov    %ebx,(%r12)\nmovslq %ebx,%r12\nlea    0x0(,%r12,4),%rdi\n00\ncall   10b0 <malloc@plt>\nxor    %edx,%edx\nmov    $0x1,%esi\ntest   %ebx,%ebx\njle    18e4 <func0+0xf4>\nnopl   (%rax)\ntest   $0x1,%dl\nmov    %esi,%ecx\ncmovne %ebp,%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%r12\njne    18d0 <func0+0xe0>\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 129,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nlea    -0x1(%rsi),%r15d\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %edx,0x4(%rsp)\nmov    %rcx,0x8(%rsp)\ntest   %esi,%esi\njle    19c8 <func0+0x288>\nmov    %esi,%edx\nmov    %esi,%r13d\nmovdqa 0x959(%rip),%xmm7\n00\nmov    %esi,%ebp\nshr    $0x2,%edx\nand    $0xfffffffc,%r13d\npcmpeqd %xmm10,%xmm10\nxor    %ecx,%ecx\nmovdqa 0x950(%rip),%xmm9\n00 00\nlea    -0x1(%rdx),%r14d\nadd    $0x1,%r14\nshl    $0x4,%r14\nnopl   0x0(%rax)\nmov    (%r12,%rcx,8),%rdx\nmov    %ecx,%r10d\ncmp    $0x7,%r15d\njbe    1b50 <func0+0x410>\nmovd   %eax,%xmm4\nlea    (%r14,%rdx,1),%rdi\npxor   %xmm2,%xmm2\nmov    %rdx,%rax\npshufd $0x0,%xmm4,%xmm5\nmovd   %ecx,%xmm4\nmovdqa %xmm10,%xmm6\nmovdqa 0x8ea(%rip),%xmm3\n00\npshufd $0x0,%xmm4,%xmm11\nmovdqa 0x8cc(%rip),%xmm4\n00\nnopl   0x0(%rax)\nmovdqu (%rax),%xmm0\nmovdqa %xmm11,%xmm8\nmovdqa %xmm3,%xmm1\nadd    $0x10,%rax\npaddd  %xmm7,%xmm3\npcmpeqd %xmm9,%xmm0\nmovdqa %xmm0,%xmm12\npand   %xmm0,%xmm8\npand   %xmm0,%xmm1\npandn  %xmm5,%xmm12\nmovdqa %xmm12,%xmm5\npor    %xmm8,%xmm5\nmovdqa %xmm0,%xmm8\npandn  %xmm6,%xmm8\nmovdqa %xmm8,%xmm6\npor    %xmm1,%xmm6\nmovdqa %xmm4,%xmm1\npaddd  %xmm7,%xmm4\npand   %xmm0,%xmm1\npandn  %xmm2,%xmm0\nmovdqa %xmm0,%xmm2\npor    %xmm1,%xmm2\ncmp    %rax,%rdi\njne    17e8 <func0+0xa8>\nmovdqa %xmm6,%xmm0\nmovd   %xmm2,%ebx\npsrldq $0x8,%xmm0\nmovdqa %xmm0,%xmm1\npcmpgtd %xmm6,%xmm1\npand   %xmm1,%xmm0\npandn  %xmm6,%xmm1\npor    %xmm0,%xmm1\nmovdqa %xmm1,%xmm3\npsrldq $0x4,%xmm3\nmovdqa %xmm3,%xmm0\npcmpgtd %xmm1,%xmm0\npand   %xmm0,%xmm3\npandn  %xmm1,%xmm0\npor    %xmm3,%xmm0\nmovd   %xmm0,%eax\npshufd $0x55,%xmm2,%xmm0\ncmp    $0xffffffff,%eax\nmovd   %xmm0,%r9d\ncmovne %eax,%r8d\nmovd   %xmm0,%eax\nmovdqa %xmm2,%xmm0\ncmp    %r9d,%ebx\npunpckhdq %xmm2,%xmm0\ncmovae %ebx,%eax\nmovd   %xmm0,%edi\ncmp    %edi,%eax\njb     1b38 <func0+0x3f8>\npshufd $0x55,%xmm5,%xmm0\nmovd   %xmm5,%r11d\ncmp    %r9d,%ebx\nmovd   %xmm0,(%rsp)\ncmovb  (%rsp),%r11d\npshufd $0xff,%xmm2,%xmm2\npshufd $0xff,%xmm5,%xmm5\ncmp    %edi,%eax\ncmovb  %edi,%eax\nmovd   %xmm2,%edi\ncmp    %edi,%eax\nmovd   %xmm5,%eax\nmov    %r13d,%edi\ncmovae %r11d,%eax\ncmp    %r13d,%esi\nje     19bb <func0+0x27b>\nmovslq %edi,%r11\ncmpl   $0x1,(%rdx,%r11,4)\nlea    0x0(,%r11,4),%r9\n00\nlea    0x1(%rdi),%r11d\ncmove  %edi,%r8d\ncmove  %r10d,%eax\ncmp    %r11d,%esi\njle    19bb <func0+0x27b>\ncmpl   $0x1,0x4(%rdx,%r9,1)\ncmove  %r11d,%r8d\nlea    0x2(%rdi),%r11d\ncmove  %r10d,%eax\ncmp    %r11d,%esi\njle    19bb <func0+0x27b>\ncmpl   $0x1,0x8(%rdx,%r9,1)\ncmove  %r11d,%r8d\nlea    0x3(%rdi),%r11d\ncmove  %r10d,%eax\ncmp    %esi,%r11d\njge    19bb <func0+0x27b>\ncmpl   $0x1,0xc(%rdx,%r9,1)\ncmove  %r11d,%r8d\nlea    0x4(%rdi),%r11d\ncmove  %r10d,%eax\ncmp    %r11d,%esi\njle    19bb <func0+0x27b>\ncmpl   $0x1,0x10(%rdx,%r9,1)\ncmove  %r11d,%r8d\nlea    0x5(%rdi),%r11d\ncmove  %r10d,%eax\ncmp    %esi,%r11d\njge    19bb <func0+0x27b>\ncmpl   $0x1,0x14(%rdx,%r9,1)\ncmove  %r11d,%r8d\nlea    0x6(%rdi),%r11d\ncmove  %r10d,%eax\ncmp    %r11d,%esi\njle    19bb <func0+0x27b>\ncmpl   $0x1,0x18(%rdx,%r9,1)\ncmove  %r11d,%r8d\ncmove  %r10d,%eax\nadd    $0x7,%edi\ncmp    %edi,%esi\njle    19bb <func0+0x27b>\ncmpl   $0x1,0x1c(%rdx,%r9,1)\ncmove  %edi,%r8d\ncmove  %r10d,%eax\nadd    $0x1,%rcx\ncmp    %rbp,%rcx\njne    17a0 <func0+0x60>\nmov    %esi,%ebx\nimul   %esi,%ebx\ntest   %eax,%eax\njle    19e4 <func0+0x2a4>\nmovslq %eax,%rcx\nmovslq %r8d,%rdx\nmov    -0x8(%r12,%rcx,8),%rcx\nmov    (%rcx,%rdx,4),%edx\ncmp    %edx,%ebx\ncmovg  %edx,%ebx\ncmp    %eax,%r15d\njle    19fe <func0+0x2be>\nlea    0x1(%rax),%ecx\nmovslq %r8d,%rdx\nmovslq %ecx,%rcx\nmov    (%r12,%rcx,8),%rcx\nmov    (%rcx,%rdx,4),%edx\ncmp    %edx,%ebx\ncmovg  %edx,%ebx\ntest   %r8d,%r8d\njle    1a16 <func0+0x2d6>\nmovslq %eax,%rcx\nmovslq %r8d,%rdx\nmov    (%r12,%rcx,8),%rcx\nmov    -0x4(%rcx,%rdx,4),%edx\ncmp    %edx,%ebx\ncmovg  %edx,%ebx\ncmp    %r8d,%r15d\njle    1a30 <func0+0x2f0>\ncltq\nlea    0x1(%r8),%edx\nmov    (%r12,%rax,8),%rax\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\nmovslq 0x4(%rsp),%rdi\nmov    0x8(%rsp),%rax\nmov    %edi,(%rax)\nmov    %rdi,%r14\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%r8\ntest   %r14d,%r14d\njle    1b21 <func0+0x3e1>\nlea    -0x1(%r14),%eax\ncmp    $0x2,%eax\njbe    1b57 <func0+0x417>\nmovd   %ebx,%xmm7\nshr    $0x2,%r14d\nmov    %r8,%rax\npxor   %xmm4,%xmm4\nmov    %r14d,%edx\nmovdqa 0x645(%rip),%xmm1\n00\nmovdqa 0x64d(%rip),%xmm5\n00\npshufd $0x0,%xmm7,%xmm6\nshl    $0x4,%rdx\nmovdqa 0x64c(%rip),%xmm2\n00\nadd    %r8,%rdx\nnopw   0x0(%rax,%rax,1)\n00 00\nmovdqa %xmm1,%xmm0\nmovdqa %xmm2,%xmm3\npaddd  %xmm5,%xmm1\nadd    $0x10,%rax\npand   %xmm2,%xmm0\npcmpeqd %xmm4,%xmm0\npand   %xmm0,%xmm3\npandn  %xmm6,%xmm0\npor    %xmm3,%xmm0\nmovups %xmm0,-0x10(%rax)\ncmp    %rdx,%rax\njne    1aa0 <func0+0x360>\nmov    0x4(%rsp),%esi\nmov    %esi,%eax\nand    $0xfffffffc,%eax\ntest   $0x3,%sil\nje     1b21 <func0+0x3e1>\nmovslq %eax,%rcx\nadd    $0x1,%eax\nmovl   $0x1,(%r8,%rcx,4)\n00\nlea    0x0(,%rcx,4),%rdx\n00\ncmp    %eax,%esi\njle    1b21 <func0+0x3e1>\nadd    $0x4,%rdx\nmov    $0x1,%ecx\nlea    (%r8,%rdx,1),%rsi\ntest   $0x1,%al\njne    1b73 <func0+0x433>\nmov    %ecx,(%rsi)\nadd    $0x1,%eax\ncmp    %eax,0x4(%rsp)\njle    1b21 <func0+0x3e1>\ntest   $0x1,%al\nmov    $0x1,%eax\ncmove  %eax,%ebx\nmov    %ebx,0x4(%r8,%rdx,1)\nadd    $0x18,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmovdqa %xmm5,%xmm0\npunpckhdq %xmm5,%xmm0\nmovd   %xmm0,%r11d\njmp    18d7 <func0+0x197>\nnopw   0x0(%rax,%rax,1)\nxor    %edi,%edi\njmp    1900 <func0+0x1c0>\ncmpl   $0x1,0x4(%rsp)\nmovl   $0x1,(%r8)\njle    1b21 <func0+0x3e1>\nlea    0x4(%r8),%rsi\nmov    $0x1,%eax\nmov    $0x4,%edx\nmov    %ebx,%ecx\njmp    1b07 <func0+0x3c7>\nnopw   0x0(%rax,%rax,1)\n00 00\n"
    },
    {
        "task_id": 130,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0x1,(%rax)\ncmpl   $0x0,-0x14(%rbp)\njne    11e9 <func0+0x40>\nmov    -0x8(%rbp),%rax\njmp    12a4 <func0+0xfb>\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovl   $0x3,(%rax)\nmovl   $0x2,-0xc(%rbp)\njmp    1294 <func0+0xeb>\nmov    -0xc(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    1236 <func0+0x8d>\nmov    -0xc(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nadd    $0x1,%edx\nmov    %edx,(%rax)\njmp    1290 <func0+0xe7>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x8(%rax),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %edx,%eax\nlea    0x1(%rax),%edx\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,%esi\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nadd    %esi,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    1203 <func0+0x5a>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 130,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nlea    0x1(%rdi),%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmovl   $0x1,(%rax)\ntest   %ebx,%ebx\nje     121a <func0+0x71>\nmovl   $0x3,0x4(%rax)\ncmp    $0x1,%ebx\njle    121a <func0+0x71>\nlea    0x1(%rbx),%r8d\nmov    $0x2,%edx\njmp    1204 <func0+0x5b>\nmov    -0x8(%rax,%rdx,4),%esi\nadd    -0x4(%rax,%rdx,4),%esi\nlea    0x1(%rdx),%edi\nmov    %edi,%ecx\nshr    $0x1f,%ecx\nadd    %edi,%ecx\nsar    %ecx\nlea    0x1(%rsi,%rcx,1),%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %r8,%rdx\nje     121a <func0+0x71>\ntest   $0x1,%dl\njne    11e0 <func0+0x37>\nmov    %edx,%ecx\nshr    $0x1f,%ecx\nadd    %edx,%ecx\nsar    %ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax,%rdx,4)\njmp    11fb <func0+0x52>\npop    %rbx\nret\n"
    },
    {
        "task_id": 130,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmovl   $0x1,(%rax)\ntest   %ebx,%ebx\nje     17ab <func0+0x7b>\nmovl   $0x3,0x4(%rax)\ncmp    $0x1,%ebx\njle    17ab <func0+0x7b>\nmov    %rax,%rcx\nmov    $0x2,%edx\njmp    1782 <func0+0x52>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    %esi,%edi\nadd    $0x4,%rcx\nsar    %edi\nadd    $0x1,%edi\nmov    %edi,0x4(%rcx)\ncmp    %esi,%ebx\nje     17ab <func0+0x7b>\nmov    %edx,%edi\nmov    %edx,%esi\nadd    $0x1,%edx\nand    $0x1,%edi\ntest   %edi,%edi\nje     1770 <func0+0x40>\nmov    %edx,%r8d\nmov    (%rcx),%edi\nadd    0x4(%rcx),%edi\nadd    $0x4,%rcx\nsar    %r8d\nlea    0x1(%rdi,%r8,1),%edi\nmov    %edi,0x4(%rcx)\ncmp    %esi,%ebx\njne    1782 <func0+0x52>\npop    %rbx\nret\nnopl   (%rax)\n"
    },
    {
        "task_id": 130,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmovl   $0x1,(%rax)\ntest   %ebx,%ebx\nje     167b <func0+0x7b>\nmovl   $0x3,0x4(%rax)\ncmp    $0x1,%ebx\njle    167b <func0+0x7b>\nmov    %rax,%rcx\nmov    $0x2,%edx\njmp    1652 <func0+0x52>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    %esi,%edi\nadd    $0x4,%rcx\nsar    %edi\nadd    $0x1,%edi\nmov    %edi,0x4(%rcx)\ncmp    %esi,%ebx\nje     167b <func0+0x7b>\nmov    %edx,%edi\nmov    %edx,%esi\nadd    $0x1,%edx\nand    $0x1,%edi\ntest   %edi,%edi\nje     1640 <func0+0x40>\nmov    %edx,%r8d\nmov    (%rcx),%edi\nadd    0x4(%rcx),%edi\nadd    $0x4,%rcx\nsar    %r8d\nlea    0x1(%rdi,%r8,1),%edi\nmov    %edi,0x4(%rcx)\ncmp    %esi,%ebx\njne    1652 <func0+0x52>\npop    %rbx\nret\nnopl   (%rax)\n"
    },
    {
        "task_id": 131,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    11d3 <func0+0x8a>\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nsub    %eax,%edx\nmov    %edx,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    11b3 <func0+0x6a>\nmovl   $0x1,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nimul   -0x4(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     1164 <func0+0x1b>\ncmpl   $0x0,-0x8(%rbp)\nje     11e4 <func0+0x9b>\nmov    -0xc(%rbp),%eax\njmp    11e9 <func0+0xa0>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 131,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%edx\ntest   %edi,%edi\njle    11be <func0+0x75>\nmov    $0x0,%edi\nmov    $0x1,%esi\njmp    117b <func0+0x32>\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\ncmp    $0x9,%edx\njle    11b6 <func0+0x6d>\nmov    %eax,%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,%r8d\nshr    $0x1f,%r8d\nlea    (%rax,%r8,1),%ecx\nand    $0x1,%ecx\nsub    %r8d,%ecx\ncmp    $0x1,%ecx\njne    115f <func0+0x16>\nimul   %eax,%esi\nmov    %ecx,%edi\njmp    115f <func0+0x16>\ntest   %edi,%edi\ncmove  %edi,%esi\nmov    %esi,%eax\nret\nmov    $0x0,%esi\njmp    11bb <func0+0x72>\n"
    },
    {
        "task_id": 131,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %r8d,%r8d\ntest   %edi,%edi\njle    131a <func0+0x5a>\nmov    $0x1,%r9d\nmov    $0xcccccccd,%esi\njmp    12e2 <func0+0x22>\nnopl   0x0(%rax,%rax,1)\n00\nmov    %eax,%edi\nmov    %edi,%eax\nmov    %rax,%rdx\nimul   %rsi,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%ecx\nmov    %edi,%edx\nadd    %ecx,%ecx\nsub    %ecx,%edx\nmov    %edi,%ecx\nand    $0x1,%ecx\nje     1306 <func0+0x46>\nimul   %edx,%r9d\nmov    %ecx,%r8d\nimul   %rsi,%rax\nshr    $0x23,%rax\ncmp    $0x9,%edi\njg     12e0 <func0+0x20>\ntest   %r8d,%r8d\ncmovne %r9d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 131,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %r8d,%r8d\ntest   %edi,%edi\njle    12ea <func0+0x5a>\nmov    $0x1,%r9d\nmov    $0xcccccccd,%esi\njmp    12b2 <func0+0x22>\nnopl   0x0(%rax,%rax,1)\n00\nmov    %eax,%edi\nmov    %edi,%eax\nmov    %rax,%rdx\nimul   %rsi,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%ecx\nmov    %edi,%edx\nadd    %ecx,%ecx\nsub    %ecx,%edx\nmov    %edi,%ecx\nand    $0x1,%ecx\nje     12d6 <func0+0x46>\nimul   %edx,%r9d\nmov    %ecx,%r8d\nimul   %rsi,%rax\nshr    $0x23,%rax\ncmp    $0x9,%edi\njg     12b0 <func0+0x20>\ntest   %r8d,%r8d\ncmovne %r9d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 132,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    11f2 <func0+0x89>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5b,%al\njne    11a9 <func0+0x40>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5d,%al\njne    11c1 <func0+0x58>\nsubl   $0x1,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njns    11ce <func0+0x65>\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njle    11dc <func0+0x73>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x1c(%rbp)\njge    11ee <func0+0x85>\nmov    $0x1,%eax\njmp    120e <func0+0xa5>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1060 <strlen@plt>\ncmp    %rax,%rbx\njb     1191 <func0+0x28>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 132,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    %rbx,%rdx\nlea    (%rbx,%rax,1),%rdi\nmov    $0x0,%ecx\nmov    $0x0,%eax\njmp    11a6 <func0+0x3d>\nadd    $0x1,%eax\ntest   %eax,%eax\nmov    $0x0,%esi\ncmovs  %esi,%eax\ncmp    %eax,%ecx\ncmovl  %eax,%ecx\nadd    $0x1,%rdx\nlea    -0x1(%rcx),%esi\ncmp    %esi,%eax\njl     11cb <func0+0x62>\ncmp    %rdi,%rdx\nje     11c4 <func0+0x5b>\nmovzbl (%rdx),%esi\ncmp    $0x5b,%sil\nje     1189 <func0+0x20>\ncmp    $0x5d,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%eax\njmp    118c <func0+0x23>\nmov    $0x0,%eax\npop    %rbx\nret\nmov    $0x1,%eax\njmp    11c9 <func0+0x60>\n"
    },
    {
        "task_id": 132,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    %rbx,%rdi\nxor    %ecx,%ecx\nxor    %edx,%edx\nadd    %rbx,%rax\njmp    148d <func0+0x3d>\nnopl   0x0(%rax)\ncmp    $0x5d,%sil\njne    147d <func0+0x2d>\nsub    $0x1,%edx\njae    147d <func0+0x2d>\nxor    %edx,%edx\ncmp    %edx,%ecx\ncmovl  %edx,%ecx\nadd    $0x1,%rdi\nlea    -0x1(%rcx),%esi\ncmp    %edx,%esi\njg     14ae <func0+0x5e>\ncmp    %rdi,%rax\nje     14b8 <func0+0x68>\nmovzbl (%rdi),%esi\ncmp    $0x5b,%sil\njne    1470 <func0+0x20>\nadd    $0x1,%edx\ncmp    %edx,%ecx\ncmovl  %edx,%ecx\nadd    $0x1,%rdi\nlea    -0x1(%rcx),%esi\ncmp    %edx,%esi\njle    148d <func0+0x3d>\nmov    $0x1,%eax\npop    %rbx\nret\nnopl   (%rax)\nxor    %eax,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 132,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   1060 <strlen@plt>\nmov    %rbx,%rdi\nxor    %ecx,%ecx\nxor    %edx,%edx\nadd    %rbx,%rax\njmp    148d <func0+0x3d>\nnopl   0x0(%rax)\ncmp    $0x5d,%sil\njne    147d <func0+0x2d>\nsub    $0x1,%edx\njae    147d <func0+0x2d>\nxor    %edx,%edx\ncmp    %edx,%ecx\ncmovl  %edx,%ecx\nadd    $0x1,%rdi\nlea    -0x1(%rcx),%esi\ncmp    %edx,%esi\njg     14ae <func0+0x5e>\ncmp    %rdi,%rax\nje     14b8 <func0+0x68>\nmovzbl (%rdi),%esi\ncmp    $0x5b,%sil\njne    1470 <func0+0x20>\nadd    $0x1,%edx\ncmp    %edx,%ecx\ncmovl  %edx,%ecx\nadd    $0x1,%rdi\nlea    -0x1(%rcx),%esi\ncmp    %edx,%esi\njle    148d <func0+0x3d>\nmov    $0x1,%eax\npop    %rbx\nret\nnopl   (%rax)\nxor    %eax,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 133,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    121d <func0+0x94>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\ncvtss2sd %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   1090 <ceil@plt>\ncvttsd2si %xmm0,%ebx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovq   %xmm2,%rax\nmovq   %rax,%xmm0\ncall   1090 <ceil@plt>\ncvttsd2si %xmm0,%eax\nimul   %ebx,%eax\nadd    %eax,-0x18(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11ad <func0+0x24>\nmov    -0x18(%rbp),%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 133,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11e2 <func0+0x79>\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rsi\nmov    $0x0,%ecx\nmovss  0xfa3(%rip),%xmm4\n00\nmovss  0xfaf(%rip),%xmm3\n00\nmovss  0xf97(%rip),%xmm5\n00\njmp    11ad <func0+0x44>\ncvttss2si %xmm2,%eax\nimul   %eax,%eax\nadd    %eax,%ecx\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\nje     11e7 <func0+0x7e>\nmovss  (%rdx),%xmm1\nmovaps %xmm1,%xmm2\nmovaps %xmm1,%xmm0\nandps  %xmm3,%xmm0\nucomiss %xmm0,%xmm4\njbe    119b <func0+0x32>\ncvttss2si %xmm1,%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\ncmpnless %xmm0,%xmm2\nandps  %xmm5,%xmm2\naddss  %xmm2,%xmm0\nmovaps %xmm3,%xmm2\nandnps %xmm1,%xmm2\norps   %xmm0,%xmm2\njmp    119b <func0+0x32>\nmov    $0x0,%ecx\nmov    %ecx,%eax\nret\n"
    },
    {
        "task_id": 133,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    15d0 <func0+0x80>\nlea    -0x1(%rsi),%eax\nmovss  0xbc9(%rip),%xmm4\n00\nxor    %r8d,%r8d\nmovss  0xbd2(%rip),%xmm3\n00\nmovss  0xbba(%rip),%xmm5\n00\nlea    0x4(%rdi,%rax,4),%rdx\nnopl   0x0(%rax,%rax,1)\nmovss  (%rdi),%xmm0\nmovaps %xmm0,%xmm1\nandps  %xmm3,%xmm1\nucomiss %xmm1,%xmm4\njbe    15b6 <func0+0x66>\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\nmovaps %xmm0,%xmm2\ncvtsi2ss %eax,%xmm1\ncmpnless %xmm1,%xmm2\nandps  %xmm5,%xmm2\naddss  %xmm2,%xmm1\nmovaps %xmm3,%xmm2\nandnps %xmm0,%xmm2\nmovaps %xmm1,%xmm0\norps   %xmm2,%xmm0\ncvttss2si %xmm0,%eax\nadd    $0x4,%rdi\nimul   %eax,%eax\nadd    %eax,%r8d\ncmp    %rdx,%rdi\njne    1580 <func0+0x30>\nmov    %r8d,%eax\nret\nnopl   (%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 133,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1590 <func0+0x80>\nlea    -0x1(%rsi),%eax\nmovss  0xc09(%rip),%xmm4\n00\nxor    %r8d,%r8d\nmovss  0xc02(%rip),%xmm3\n00\nmovss  0xc0a(%rip),%xmm5\n00\nlea    0x4(%rdi,%rax,4),%rdx\nnopl   0x0(%rax,%rax,1)\nmovss  (%rdi),%xmm0\nmovaps %xmm0,%xmm1\nandps  %xmm3,%xmm1\nucomiss %xmm1,%xmm4\njbe    1576 <func0+0x66>\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\nmovaps %xmm0,%xmm2\ncvtsi2ss %eax,%xmm1\ncmpnless %xmm1,%xmm2\nandps  %xmm5,%xmm2\naddss  %xmm2,%xmm1\nmovaps %xmm3,%xmm2\nandnps %xmm0,%xmm2\nmovaps %xmm1,%xmm0\norps   %xmm2,%xmm0\ncvttss2si %xmm0,%eax\nadd    $0x4,%rdi\nimul   %eax,%eax\nadd    %eax,%r8d\ncmp    %rdi,%rdx\njne    1540 <func0+0x30>\nmov    %r8d,%eax\nret\nnopl   (%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 134,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1070 <strlen@plt>\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    11b8 <func0+0x2f>\nmov    $0x0,%eax\njmp    124c <func0+0xc3>\nmov    -0x4(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x6(%rbp)\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmovzbl -0x6(%rbp),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\njne    11f9 <func0+0x70>\nmov    $0x0,%eax\njmp    124c <func0+0xc3>\ncmpl   $0x1,-0x4(%rbp)\njne    1206 <func0+0x7d>\nmov    $0x1,%eax\njmp    124c <func0+0xc3>\nmov    -0x4(%rbp),%eax\ncltq\nlea    -0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x5(%rbp)\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmovzbl -0x5(%rbp),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\nje     1247 <func0+0xbe>\nmov    $0x0,%eax\njmp    124c <func0+0xc3>\nmov    $0x1,%eax\nleave\nret\n"
    },
    {
        "task_id": 134,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r12\ncall   1070 <strlen@plt>\nmov    %eax,%ebp\ntest   %eax,%eax\nje     11d6 <func0+0x4d>\nmovslq %eax,%r13\ncall   1090 <__ctype_b_loc@plt>\nmov    (%rax),%rax\nmovzbl -0x1(%r12,%r13,1),%edx\ntestb  $0x4,0x1(%rax,%rdx,2)\nje     11e3 <func0+0x5a>\ncmp    $0x1,%ebp\nje     11d6 <func0+0x4d>\nmovzbl -0x2(%r12,%r13,1),%edx\nmovzwl (%rax,%rdx,2),%ebp\nshr    $0xa,%bp\nxor    $0x1,%ebp\nand    $0x1,%ebp\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    $0x0,%ebp\njmp    11d6 <func0+0x4d>\n"
    },
    {
        "task_id": 134,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     13f3 <func0+0x53>\nmovslq %eax,%r13\ncall   1090 <__ctype_b_loc@plt>\nmovzbl -0x1(%rbp,%r13,1),%edx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rdx,2)\nje     1408 <func0+0x68>\ncmp    $0x1,%r12d\nje     13f3 <func0+0x53>\nmovzbl -0x2(%rbp,%r13,1),%edx\nmovzwl (%rax,%rdx,2),%r12d\nshr    $0xa,%r12w\nxor    $0x1,%r12d\nand    $0x1,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nxor    %r12d,%r12d\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 134,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   1070 <strlen@plt>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     13f3 <func0+0x53>\nmovslq %eax,%r13\ncall   1090 <__ctype_b_loc@plt>\nmovzbl -0x1(%rbp,%r13,1),%edx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rdx,2)\nje     1408 <func0+0x68>\ncmp    $0x1,%r12d\nje     13f3 <func0+0x53>\nmovzbl -0x2(%rbp,%r13,1),%edx\nmovzwl (%rax,%rdx,2),%r12d\nshr    $0xa,%r12w\nxor    $0x1,%r12d\nand    $0x1,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nxor    %r12d,%r12d\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\n"
    },
    {
        "task_id": 135,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0xffffffff,-0x8(%rbp)\nmovl   $0x1,-0x4(%rbp)\njmp    11c2 <func0+0x59>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    11be <func0+0x55>\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1188 <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 135,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    1194 <func0+0x2b>\nmov    %esi,%esi\nmov    $0x1,%eax\nmov    $0xffffffff,%edx\nmov    -0x4(%rdi,%rax,4),%ecx\ncmp    %ecx,(%rdi,%rax,4)\ncmovl  %eax,%edx\nadd    $0x1,%rax\ncmp    %rsi,%rax\njne    117e <func0+0x15>\nmov    %edx,%eax\nret\nmov    $0xffffffff,%edx\njmp    1191 <func0+0x28>\n"
    },
    {
        "task_id": 135,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    1390 <func0+0x40>\nmovslq %esi,%rsi\nmov    $0x1,%eax\nmov    $0xffffffff,%r8d\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    -0x4(%rdi,%rax,4),%edx\ncmp    %edx,(%rdi,%rax,4)\ncmovl  %eax,%r8d\nadd    $0x1,%rax\ncmp    %rsi,%rax\njne    1370 <func0+0x20>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax,%rax,1)\n00\nmov    $0xffffffff,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 135,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    12f0 <func0+0x1b0>\nlea    -0x2(%rsi),%eax\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%r8d\nmov    %esi,%ecx\ncmp    $0x2,%eax\njbe    12f6 <func0+0x1b6>\nmov    %r8d,%esi\nmovdqa 0xea3(%rip),%xmm2\n00\nmov    %rdi,%rax\npxor   %xmm3,%xmm3\nshr    $0x2,%esi\nmovdqa 0xea1(%rip),%xmm4\n00\nsub    $0x1,%esi\nshl    $0x4,%rsi\nlea    0x10(%rdi,%rsi,1),%rsi\nnopl   0x0(%rax,%rax,1)\nmovdqu (%rax),%xmm0\nmovdqu 0x4(%rax),%xmm5\nmovdqa %xmm2,%xmm1\nadd    $0x10,%rax\npaddd  %xmm4,%xmm2\npcmpgtd %xmm5,%xmm0\npand   %xmm0,%xmm1\npandn  %xmm3,%xmm0\nmovdqa %xmm0,%xmm3\npor    %xmm1,%xmm3\ncmp    %rsi,%rax\njne    1190 <func0+0x50>\nmovdqa %xmm3,%xmm0\nmov    $0xffffffff,%esi\nmov    %r8d,%edi\npsrldq $0x8,%xmm0\nmovdqa %xmm0,%xmm1\npcmpgtd %xmm3,%xmm1\npand   %xmm1,%xmm0\npandn  %xmm3,%xmm1\npor    %xmm0,%xmm1\nmovdqa %xmm1,%xmm2\npsrldq $0x4,%xmm2\nmovdqa %xmm2,%xmm0\npcmpgtd %xmm1,%xmm0\npand   %xmm0,%xmm2\npandn  %xmm1,%xmm0\npor    %xmm2,%xmm0\nmovd   %xmm0,%eax\ntest   %eax,%eax\ncmove  %esi,%eax\nand    $0xfffffffc,%edi\nlea    0x1(%rdi),%esi\ncmp    %edi,%r8d\nje     12e8 <func0+0x1a8>\nmovslq %esi,%rdi\nlea    0x1(%rsi),%r9d\npush   %rbx\nshl    $0x2,%rdi\nlea    (%rdx,%rdi,1),%r10\ncmp    %r8d,%r9d\njge    1305 <func0+0x1c5>\ncmp    %esi,%ecx\njle    1305 <func0+0x1c5>\nmov    (%r10),%r11d\ncmp    %r11d,-0x4(%r10)\nmov    0x4(%rdx,%rdi,1),%r10d\ncmovg  %esi,%eax\ncmp    %r10d,%r11d\nlea    0x2(%rsi),%r11d\ncmovg  %r9d,%eax\nlea    0x3(%rsi),%r9d\ncmp    %r9d,%r8d\njg     12a0 <func0+0x160>\nmovslq %r11d,%rsi\nmov    (%rdx,%rsi,4),%r8d\nlea    0x0(,%rsi,4),%rdi\n00\ncmp    -0x4(%rdx,%rsi,4),%r8d\nlea    0x1(%r11),%esi\ncmovl  %r11d,%eax\ncmp    %esi,%ecx\njle    129b <func0+0x15b>\ncmp    0x4(%rdx,%rdi,1),%r8d\ncmovle %eax,%esi\nlea    0x2(%r11),%eax\ncmp    %eax,%ecx\njle    130d <func0+0x1cd>\nmov    0x8(%rdx,%rdi,1),%ebx\ncmp    %ebx,0x4(%rdx,%rdi,1)\ncmovle %esi,%eax\npop    %rbx\nret\nnopl   (%rax)\nmov    0x8(%rdx,%rdi,1),%ebx\ncmp    %ebx,%r10d\nmov    0xc(%rdx,%rdi,1),%r10d\ncmovg  %r11d,%eax\nlea    0x4(%rsi),%r11d\ncmp    %r10d,%ebx\ncmovg  %r9d,%eax\nlea    0x5(%rsi),%r9d\ncmp    %r9d,%r8d\njle    125c <func0+0x11c>\nmov    0x10(%rdx,%rdi,1),%r8d\ncmp    %r10d,%r8d\ncmovge %eax,%r11d\ncmp    0x14(%rdx,%rdi,1),%r8d\nmov    %r11d,%eax\nlea    0x6(%rsi),%r11d\ncmovg  %r9d,%eax\njmp    125c <func0+0x11c>\nnopl   (%rax)\nret\nnopl   0x0(%rax)\nmov    $0xffffffff,%eax\nret\nmov    $0x1,%esi\nmov    $0xffffffff,%eax\njmp    1218 <func0+0xd8>\nmov    %esi,%r11d\njmp    125c <func0+0x11c>\nmov    %esi,%eax\npop    %rbx\nret\n"
    },
    {
        "task_id": 136,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1242 <func0+0xd9>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njns    11ea <func0+0x81>\ncmpl   $0x0,-0xc(%rbp)\nje     11d1 <func0+0x68>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njge    11ea <func0+0x81>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    123e <func0+0xd5>\ncmpl   $0x0,-0x8(%rbp)\nje     1225 <func0+0xbc>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x8(%rbp)\njle    123e <func0+0xd5>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1196 <func0+0x2d>\nmov    -0x28(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 136,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11b1 <func0+0x48>\nmov    %rdi,%rcx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r8\nmov    $0x0,%esi\nmov    $0x0,%edi\njmp    119f <func0+0x36>\ncmp    %edi,%eax\njg     1190 <func0+0x27>\ntest   %edi,%edi\njne    1196 <func0+0x2d>\nmov    %eax,%edi\njmp    1196 <func0+0x2d>\nmov    %eax,%esi\nadd    $0x4,%rcx\ncmp    %r8,%rcx\nje     11bb <func0+0x52>\nmov    (%rcx),%eax\ntest   %eax,%eax\njs     1188 <func0+0x1f>\njle    1196 <func0+0x2d>\ncmp    %esi,%eax\njl     1194 <func0+0x2b>\ntest   %esi,%esi\nje     1194 <func0+0x2b>\njmp    1196 <func0+0x2d>\nmov    $0x0,%esi\nmov    $0x0,%edi\nmov    %edi,(%rdx)\nmov    %esi,0x4(%rdx)\nret\n"
    },
    {
        "task_id": 136,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1620 <func0+0x50>\nlea    -0x1(%rsi),%eax\nxor    %ecx,%ecx\nxor    %esi,%esi\nlea    0x4(%rdi,%rax,4),%r8\nnopl   0x0(%rax)\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     1610 <func0+0x40>\nje     15fa <func0+0x2a>\ntest   %ecx,%ecx\nje     15f8 <func0+0x28>\ncmp    %ecx,%eax\njge    15fa <func0+0x2a>\nmov    %eax,%ecx\nadd    $0x4,%rdi\ncmp    %rdi,%r8\njne    15e8 <func0+0x18>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nret\nnopl   0x0(%rax)\ncmp    %esi,%eax\njg     1618 <func0+0x48>\ntest   %esi,%esi\njne    15fa <func0+0x2a>\nmov    %eax,%esi\njmp    15fa <func0+0x2a>\nnopl   0x0(%rax)\nxor    %ecx,%ecx\nxor    %esi,%esi\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nret\nnopw   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 136,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    15a0 <func0+0x50>\nlea    -0x1(%rsi),%eax\nxor    %ecx,%ecx\nxor    %esi,%esi\nlea    0x4(%rdi,%rax,4),%r8\nnopl   0x0(%rax)\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     1590 <func0+0x40>\nje     157a <func0+0x2a>\ntest   %ecx,%ecx\nje     1578 <func0+0x28>\ncmp    %ecx,%eax\njge    157a <func0+0x2a>\nmov    %eax,%ecx\nadd    $0x4,%rdi\ncmp    %rdi,%r8\njne    1568 <func0+0x18>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nret\nnopl   0x0(%rax)\ncmp    %esi,%eax\njg     1598 <func0+0x48>\ntest   %esi,%esi\njne    157a <func0+0x2a>\nmov    %eax,%esi\njmp    157a <func0+0x2a>\nnopl   0x0(%rax)\nxor    %ecx,%ecx\nxor    %esi,%esi\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nret\nnopw   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 137,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   10f0 <strdup@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   10f0 <strdup@plt>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    125d <func0+0x74>\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\njne    1259 <func0+0x70>\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x2e,(%rax)\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1235 <func0+0x4c>\nmovl   $0x0,-0x34(%rbp)\njmp    12a2 <func0+0xb9>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\njne    129e <func0+0xb5>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x2e,(%rax)\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    127a <func0+0x91>\nlea    -0x30(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10b0 <strtod@plt>\nmovq   %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1301 <func0+0x118>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nlea    0xd0c(%rip),%rax\njmp    1398 <func0+0x1af>\nlea    -0x30(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10b0 <strtod@plt>\nmovq   %xmm0,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1349 <func0+0x160>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nlea    0xcc1(%rip),%rax\njmp    1398 <func0+0x1af>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmovsd  -0x18(%rbp),%xmm0\nucomisd -0x10(%rbp),%xmm0\njp     1382 <func0+0x199>\nmovsd  -0x18(%rbp),%xmm0\nucomisd -0x10(%rbp),%xmm0\njne    1382 <func0+0x199>\nlea    0xc96(%rip),%rax\njmp    1398 <func0+0x1af>\nmovsd  -0x18(%rbp),%xmm0\ncomisd -0x10(%rbp),%xmm0\njbe    1394 <func0+0x1ab>\nmov    -0x48(%rbp),%rax\njmp    1398 <func0+0x1af>\nmov    -0x50(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     13ac <func0+0x1c3>\ncall   10c0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 137,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmov    %rdi,%r13\nmov    %rsi,%r12\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncall   10f0 <strdup@plt>\nmov    %rax,%rbx\nmov    %r12,%rdi\ncall   10f0 <strdup@plt>\nmov    %rax,%rbp\nmovzbl (%rbx),%edx\ntest   %dl,%dl\nje     1243 <func0+0x5a>\nmov    %rbx,%rax\njmp    1239 <func0+0x50>\nadd    $0x1,%rax\nmovzbl (%rax),%edx\ntest   %dl,%dl\nje     1243 <func0+0x5a>\ncmp    $0x2c,%dl\njne    122e <func0+0x45>\nmovb   $0x2e,(%rax)\njmp    122e <func0+0x45>\nmovzbl 0x0(%rbp),%edx\ntest   %dl,%dl\nje     1265 <func0+0x7c>\nmov    %rbp,%rax\njmp    125b <func0+0x72>\nadd    $0x1,%rax\nmovzbl (%rax),%edx\ntest   %dl,%dl\nje     1265 <func0+0x7c>\ncmp    $0x2c,%dl\njne    1250 <func0+0x67>\nmovb   $0x2e,(%rax)\njmp    1250 <func0+0x67>\nlea    0x10(%rsp),%rsi\nmov    %rbx,%rdi\ncall   10b0 <strtod@plt>\nmovq   %xmm0,%r14\nmov    0x10(%rsp),%rax\ncmpb   $0x0,(%rax)\njne    12dc <func0+0xf3>\nlea    0x10(%rsp),%rsi\nmov    %rbp,%rdi\ncall   10b0 <strtod@plt>\nmovsd  %xmm0,0x8(%rsp)\nmov    0x10(%rsp),%rax\ncmpb   $0x0,(%rax)\njne    1310 <func0+0x127>\nmov    %rbx,%rdi\ncall   10a0 <free@plt>\nmov    %rbp,%rdi\ncall   10a0 <free@plt>\nmovq   %r14,%xmm2\nmovsd  0x8(%rsp),%xmm1\nucomisd %xmm1,%xmm2\njp     12c8 <func0+0xdf>\nlea    0xd4c(%rip),%rax\nje     12f3 <func0+0x10a>\nmovq   %r14,%xmm4\ncomisd 0x8(%rsp),%xmm4\nmov    %r12,%rax\ncmova  %r13,%rax\njmp    12f3 <func0+0x10a>\nmov    %rbx,%rdi\ncall   10a0 <free@plt>\nmov    %rbp,%rdi\ncall   10a0 <free@plt>\nlea    0xd11(%rip),%rax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\n00 00\njne    1329 <func0+0x140>\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    %rbx,%rdi\ncall   10a0 <free@plt>\nmov    %rbp,%rdi\ncall   10a0 <free@plt>\nlea    0xcdd(%rip),%rax\njmp    12f3 <func0+0x10a>\ncall   10c0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 137,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncall   10f0 <strdup@plt>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncall   10f0 <strdup@plt>\nmovzbl (%r12),%edx\nmov    %rax,%r13\ntest   %dl,%dl\nje     1474 <func0+0x64>\nmov    %r12,%rax\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x2c,%dl\njne    1468 <func0+0x58>\nmovb   $0x2e,(%rax)\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    1460 <func0+0x50>\nmovzbl 0x0(%r13),%edx\ntest   %dl,%dl\nje     1494 <func0+0x84>\nmov    %r13,%rax\ncmp    $0x2c,%dl\njne    1488 <func0+0x78>\nmovb   $0x2e,(%rax)\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    1480 <func0+0x70>\nlea    0x10(%rsp),%r14\nmov    %r12,%rdi\nmov    %r14,%rsi\ncall   10b0 <strtod@plt>\nmov    0x10(%rsp),%rax\nmovq   %xmm0,%r15\ncmpb   $0x0,(%rax)\njne    1510 <func0+0x100>\nmov    %r14,%rsi\nmov    %r13,%rdi\ncall   10b0 <strtod@plt>\nmov    0x10(%rsp),%rax\ncmpb   $0x0,(%rax)\njne    1510 <func0+0x100>\nmov    %r12,%rdi\nmovsd  %xmm0,0x8(%rsp)\ncall   10a0 <free@plt>\nmov    %r13,%rdi\ncall   10a0 <free@plt>\nmovsd  0x8(%rsp),%xmm0\nmovq   %r15,%xmm1\nucomisd %xmm0,%xmm1\njp     14f8 <func0+0xe8>\nlea    0xb1c(%rip),%rax\nje     1527 <func0+0x117>\nmovq   %r15,%xmm2\nmov    %rbx,%rax\ncomisd %xmm0,%xmm2\ncmova  %rbp,%rax\njmp    1527 <func0+0x117>\nnopw   0x0(%rax,%rax,1)\nmov    %r12,%rdi\ncall   10a0 <free@plt>\nmov    %r13,%rdi\ncall   10a0 <free@plt>\nlea    0xadd(%rip),%rax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\n00 00\njne    1546 <func0+0x136>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 137,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncall   10f0 <strdup@plt>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncall   10f0 <strdup@plt>\nmovzbl (%r12),%edx\nmov    %rax,%r13\ntest   %dl,%dl\nje     1475 <func0+0x65>\nmov    %r12,%rax\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x2c,%dl\nje     1550 <func0+0x140>\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    1460 <func0+0x50>\nmovzbl 0x0(%r13),%edx\ntest   %dl,%dl\nje     149d <func0+0x8d>\nmov    %r13,%rax\nnopl   0x0(%rax)\ncmp    $0x2c,%dl\nje     1570 <func0+0x160>\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    1488 <func0+0x78>\nlea    0x10(%rsp),%r14\nmov    %r12,%rdi\nmov    %r14,%rsi\ncall   10b0 <strtod@plt>\nmov    0x10(%rsp),%rax\nmovq   %xmm0,%r15\ncmpb   $0x0,(%rax)\njne    1518 <func0+0x108>\nmov    %r14,%rsi\nmov    %r13,%rdi\ncall   10b0 <strtod@plt>\nmov    0x10(%rsp),%rax\ncmpb   $0x0,(%rax)\njne    1518 <func0+0x108>\nmov    %r12,%rdi\nmovsd  %xmm0,0x8(%rsp)\ncall   10a0 <free@plt>\nmov    %r13,%rdi\ncall   10a0 <free@plt>\nmovsd  0x8(%rsp),%xmm0\nmovq   %r15,%xmm1\nucomisd %xmm0,%xmm1\njp     1501 <func0+0xf1>\nlea    0xb13(%rip),%rax\nje     152f <func0+0x11f>\nmovq   %r15,%xmm2\nmov    %rbx,%rax\ncomisd %xmm0,%xmm2\ncmova  %rbp,%rax\njmp    152f <func0+0x11f>\nnopl   0x0(%rax,%rax,1)\nmov    %r12,%rdi\ncall   10a0 <free@plt>\nmov    %r13,%rdi\ncall   10a0 <free@plt>\nlea    0xad5(%rip),%rax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\n00 00\njne    1588 <func0+0x178>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxchg   %ax,%ax\nmovb   $0x2e,(%rax)\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    1460 <func0+0x50>\njmp    1475 <func0+0x65>\nnopl   0x0(%rax,%rax,1)\n00\nmovb   $0x2e,(%rax)\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    1488 <func0+0x78>\njmp    149d <func0+0x8d>\ncall   10c0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 138,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    116b <func0+0x22>\ncmpl   $0x7,-0x4(%rbp)\njle    116b <func0+0x22>\nmov    $0x1,%eax\njmp    1170 <func0+0x27>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 138,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%edx\nxor    $0x1,%edx\ncmp    $0x7,%edi\nsetg   %al\nmovzbl %al,%eax\nand    %edx,%eax\nret\n"
    },
    {
        "task_id": 138,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x7,%edi\nnot    %edi\nsetg   %al\nand    %edi,%eax\nmovzbl %al,%eax\nret\n"
    },
    {
        "task_id": 138,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x7,%edi\nnot    %edi\nsetg   %al\nand    %edi,%eax\nmovzbl %al,%eax\nret\n"
    },
    {
        "task_id": 139,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmovq   $0x1,-0x10(%rbp)\n00\nmovq   $0x1,-0x8(%rbp)\n00\nmovl   $0x1,-0x14(%rbp)\njmp    118f <func0+0x46>\nmov    -0x14(%rbp),%eax\ncltq\nmov    -0x10(%rbp),%rdx\nimul   %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nimul   -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    116d <func0+0x24>\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n"
    },
    {
        "task_id": 139,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    1178 <func0+0x2f>\nlea    0x1(%rdi),%esi\nmov    $0x1,%eax\nmov    $0x1,%ecx\nmov    $0x1,%edx\nimul   %rax,%rdx\nimul   %rdx,%rcx\nadd    $0x1,%rax\ncmp    %rsi,%rax\njne    1163 <func0+0x1a>\nmov    %rcx,%rax\nret\nmov    $0x1,%ecx\njmp    1174 <func0+0x2b>\n"
    },
    {
        "task_id": 139,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    11e8 <func0+0x38>\nlea    0x1(%rdi),%ecx\nmov    $0x1,%eax\nmov    $0x1,%r8d\nmov    $0x1,%edx\nnopl   0x0(%rax,%rax,1)\nimul   %rax,%rdx\nadd    $0x1,%rax\nimul   %rdx,%r8\ncmp    %rcx,%rax\njne    11d0 <func0+0x20>\nmov    %r8,%rax\nret\nnopl   (%rax)\nmov    $0x1,%r8d\nmov    %r8,%rax\nret\n"
    },
    {
        "task_id": 139,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    1178 <func0+0x38>\nlea    0x1(%rdi),%ecx\nmov    $0x1,%eax\nmov    $0x1,%r8d\nmov    $0x1,%edx\nnopl   0x0(%rax,%rax,1)\nimul   %rax,%rdx\nadd    $0x1,%rax\nimul   %rdx,%r8\ncmp    %rcx,%rax\njne    1160 <func0+0x20>\nmov    %r8,%rax\nret\nnopl   (%rax)\nmov    $0x1,%r8d\nmov    %r8,%rax\nret\n"
    },
    {
        "task_id": 140,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    1290 <func0+0xe7>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\njne    11f5 <func0+0x4c>\naddl   $0x1,-0x1c(%rbp)\njmp    128c <func0+0xe3>\ncmpl   $0x1,-0x1c(%rbp)\njne    1211 <func0+0x68>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\ncmpl   $0x2,-0x1c(%rbp)\njne    1243 <func0+0x9a>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\ncmpl   $0x2,-0x1c(%rbp)\njle    125f <func0+0xb6>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x2d,(%rax)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <strlen@plt>\ncmp    %rax,%rbx\njb     11d8 <func0+0x2f>\ncmpl   $0x1,-0x1c(%rbp)\njne    12c7 <func0+0x11e>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\ncmpl   $0x2,-0x1c(%rbp)\njne    12f9 <func0+0x150>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\ncmpl   $0x2,-0x1c(%rbp)\njle    1315 <func0+0x16c>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x2d,(%rax)\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 140,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    %rsi,%r13\nmov    $0x0,%ebp\nmov    $0x0,%ebx\nmov    $0x0,%r14d\njmp    1208 <func0+0x5f>\nadd    $0x1,%r14d\njmp    1204 <func0+0x5b>\nlea    0x1(%rbx),%eax\nmovslq %ebx,%rbx\nmovb   $0x5f,0x0(%r13,%rbx,1)\njmp    11ef <func0+0x46>\njle    1242 <func0+0x99>\nlea    0x1(%rbx),%eax\nmovslq %ebx,%rbx\nmovb   $0x2d,0x0(%r13,%rbx,1)\nlea    0x1(%rax),%ebx\nmovzbl (%r12,%rbp,1),%edx\ncltq\nmov    %dl,0x0(%r13,%rax,1)\nmov    $0x0,%r14d\nadd    $0x1,%rbp\nmov    %r12,%rdi\ncall   1080 <strlen@plt>\ncmp    %rbp,%rax\njbe    1246 <func0+0x9d>\ncmpb   $0x20,(%r12,%rbp,1)\nje     11cd <func0+0x24>\ncmp    $0x1,%r14d\nje     11d3 <func0+0x2a>\ncmp    $0x2,%r14d\njne    11e1 <func0+0x38>\nmovslq %ebx,%rax\nmovb   $0x5f,0x0(%r13,%rax,1)\nlea    0x2(%rbx),%eax\nadd    $0x1,%ebx\nmovslq %ebx,%rbx\nmovb   $0x5f,0x0(%r13,%rbx,1)\njmp    11ef <func0+0x46>\nmov    %ebx,%eax\njmp    11ef <func0+0x46>\ncmp    $0x1,%r14d\nje     126c <func0+0xc3>\ncmp    $0x2,%r14d\njne    127a <func0+0xd1>\nmovslq %ebx,%rax\nmovb   $0x5f,0x0(%r13,%rax,1)\nlea    0x2(%rbx),%eax\nadd    $0x1,%ebx\nmovslq %ebx,%rbx\nmovb   $0x5f,0x0(%r13,%rbx,1)\njmp    1288 <func0+0xdf>\nlea    0x1(%rbx),%eax\nmovslq %ebx,%rbx\nmovb   $0x5f,0x0(%r13,%rbx,1)\njmp    1288 <func0+0xdf>\njle    1299 <func0+0xf0>\nlea    0x1(%rbx),%eax\nmovslq %ebx,%rbx\nmovb   $0x2d,0x0(%r13,%rbx,1)\ncltq\nmovb   $0x0,0x0(%r13,%rax,1)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    %ebx,%eax\njmp    1288 <func0+0xdf>\n"
    },
    {
        "task_id": 140,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nxor    %r15d,%r15d\npush   %r14\nmov    %rsi,%r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\njmp    13d1 <func0+0x61>\nnopl   (%rax)\nlea    0x1(%r12),%eax\ncmp    $0x1,%r13d\nje     1400 <func0+0x90>\ncmp    $0x2,%r13d\njne    13f0 <func0+0x80>\ncltq\nmovb   $0x5f,(%rdx)\nmovb   $0x5f,(%r14,%rax,1)\nlea    0x2(%r12),%eax\nmovzbl 0x0(%rbp,%rbx,1),%edx\nlea    0x1(%rax),%r12d\ncltq\nxor    %r13d,%r13d\nmovslq %r12d,%r15\nmov    %dl,(%r14,%rax,1)\nadd    $0x1,%rbx\nmov    %rbp,%rdi\ncall   1070 <strlen@plt>\nlea    (%r14,%r15,1),%rdx\ncmp    %rbx,%rax\njbe    1408 <func0+0x98>\ncmpb   $0x20,0x0(%rbp,%rbx,1)\njne    1398 <func0+0x28>\nadd    $0x1,%r13d\njmp    13cd <func0+0x5d>\nnop\njle    145c <func0+0xec>\nmovb   $0x2d,(%rdx)\njmp    13b8 <func0+0x48>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovb   $0x5f,(%rdx)\njmp    13b8 <func0+0x48>\nnopl   (%rax)\ncmp    $0x1,%r13d\nje     1450 <func0+0xe0>\ncmp    $0x2,%r13d\njne    1430 <func0+0xc0>\nlea    0x1(%r12),%eax\nadd    $0x2,%r12d\nmovb   $0x5f,(%rdx)\ncltq\nmovslq %r12d,%r15\nmovb   $0x5f,(%r14,%rax,1)\njmp    143c <func0+0xcc>\nnopl   0x0(%rax)\njle    143c <func0+0xcc>\nmovb   $0x2d,(%rdx)\nadd    $0x1,%r12d\nmovslq %r12d,%r15\nmovb   $0x0,(%r14,%r15,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nadd    $0x1,%r12d\nmovb   $0x5f,(%rdx)\nmovslq %r12d,%r15\njmp    143c <func0+0xcc>\nmov    %r12d,%eax\njmp    13b8 <func0+0x48>\n"
    },
    {
        "task_id": 140,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nxor    %r15d,%r15d\npush   %r14\nmov    %rsi,%r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\njmp    13d1 <func0+0x61>\nnopl   (%rax)\nlea    0x1(%r12),%eax\ncmp    $0x1,%r13d\nje     1400 <func0+0x90>\ncmp    $0x2,%r13d\njne    13f0 <func0+0x80>\ncltq\nmovb   $0x5f,(%rdx)\nmovb   $0x5f,(%r14,%rax,1)\nlea    0x2(%r12),%eax\nmovzbl 0x0(%rbp,%rbx,1),%edx\nlea    0x1(%rax),%r12d\ncltq\nxor    %r13d,%r13d\nmovslq %r12d,%r15\nmov    %dl,(%r14,%rax,1)\nadd    $0x1,%rbx\nmov    %rbp,%rdi\ncall   1070 <strlen@plt>\nlea    (%r14,%r15,1),%rdx\ncmp    %rbx,%rax\njbe    1408 <func0+0x98>\ncmpb   $0x20,0x0(%rbp,%rbx,1)\njne    1398 <func0+0x28>\nadd    $0x1,%r13d\njmp    13cd <func0+0x5d>\nnop\njle    145c <func0+0xec>\nmovb   $0x2d,(%rdx)\njmp    13b8 <func0+0x48>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovb   $0x5f,(%rdx)\njmp    13b8 <func0+0x48>\nnopl   (%rax)\ncmp    $0x1,%r13d\nje     1450 <func0+0xe0>\ncmp    $0x2,%r13d\njne    1430 <func0+0xc0>\nlea    0x1(%r12),%eax\nadd    $0x2,%r12d\nmovb   $0x5f,(%rdx)\ncltq\nmovslq %r12d,%r15\nmovb   $0x5f,(%r14,%rax,1)\njmp    143c <func0+0xcc>\nnopl   0x0(%rax)\njle    143c <func0+0xcc>\nmovb   $0x2d,(%rdx)\nadd    $0x1,%r12d\nmovslq %r12d,%r15\nmovb   $0x0,(%r14,%r15,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nadd    $0x1,%r12d\nmovb   $0x5f,(%rdx)\nmovslq %r12d,%r15\njmp    143c <func0+0xcc>\nmov    %r12d,%eax\njmp    13b8 <func0+0x48>\n"
    },
    {
        "task_id": 141,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1070 <strlen@plt>\nmov    %eax,-0xc(%rbp)\ncmpl   $0x4,-0xc(%rbp)\njg     11c8 <func0+0x3f>\nlea    0xe45(%rip),%rax\njmp    12d6 <func0+0x14d>\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0x19(%rbp)\ncmpb   $0x40,-0x19(%rbp)\njle    11ea <func0+0x61>\ncmpb   $0x5a,-0x19(%rbp)\njle    11e4 <func0+0x5b>\ncmpb   $0x60,-0x19(%rbp)\njle    11ea <func0+0x61>\ncmpb   $0x7a,-0x19(%rbp)\njle    11f6 <func0+0x6d>\nlea    0xe17(%rip),%rax\njmp    12d6 <func0+0x14d>\nmov    -0xc(%rbp),%eax\ncltq\nlea    -0x4(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0xdf6(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1261 <func0+0xd8>\nmov    -0x8(%rbp),%rax\nlea    0xde1(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1261 <func0+0xd8>\nmov    -0x8(%rbp),%rax\nlea    0xdcc(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1261 <func0+0xd8>\nlea    0xda9(%rip),%rax\njmp    12d6 <func0+0x14d>\nmovl   $0x0,-0x10(%rbp)\njmp    12b2 <func0+0x129>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    1296 <func0+0x10d>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njg     1296 <func0+0x10d>\naddl   $0x1,-0x18(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2e,%al\njne    12ae <func0+0x125>\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     126a <func0+0xe1>\ncmpl   $0x3,-0x18(%rbp)\njg     12c6 <func0+0x13d>\ncmpl   $0x1,-0x14(%rbp)\nje     12cf <func0+0x146>\nlea    0xd3b(%rip),%rax\njmp    12d6 <func0+0x14d>\nlea    0xd44(%rip),%rax\nleave\nret\n"
    },
    {
        "task_id": 141,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\ncall   1070 <strlen@plt>\nmov    %rax,%rbp\nlea    0xe61(%rip),%rax\ncmp    $0x4,%ebp\njle    126c <func0+0xe3>\nmovzbl (%rbx),%eax\nlea    -0x5b(%rax),%edx\ncmp    $0x5,%dl\njbe    1265 <func0+0xdc>\nsub    $0x41,%eax\ncmp    $0x39,%al\nja     1265 <func0+0xdc>\nmovslq %ebp,%rax\nlea    -0x4(%rbx,%rax,1),%r12\nlea    0xf97(%rip),%rsi\nmov    %r12,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1210 <func0+0x87>\nlea    0xe6f(%rip),%rsi\nmov    %r12,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1210 <func0+0x87>\nlea    0xe4e(%rip),%rsi\nmov    %r12,%rdi\ncall   1090 <strcmp@plt>\nmov    %eax,%edx\nlea    0xdf8(%rip),%rax\ntest   %edx,%edx\njne    126c <func0+0xe3>\nmov    %rbx,%rax\nlea    -0x1(%rbp),%edx\nlea    0x1(%rbx,%rdx,1),%r8\nmov    $0x0,%edi\nmov    $0x0,%esi\njmp    123b <func0+0xb2>\ncmp    $0x2e,%dl\nsete   %dl\nmovzbl %dl,%edx\nadd    %edx,%edi\nadd    $0x1,%rax\ncmp    %r8,%rax\nje     124b <func0+0xc2>\nmovzbl (%rax),%edx\nlea    -0x30(%rdx),%ecx\ncmp    $0x9,%cl\nja     1227 <func0+0x9e>\nadd    $0x1,%esi\njmp    1232 <func0+0xa9>\ncmp    $0x3,%esi\njg     125c <func0+0xd3>\nlea    0xdb0(%rip),%rax\ncmp    $0x1,%edi\nje     126c <func0+0xe3>\nlea    0xda1(%rip),%rax\njmp    126c <func0+0xe3>\nlea    0xd98(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 141,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nlea    0x823(%rip),%r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\ncall   1070 <strlen@plt>\ncmp    $0x4,%eax\njle    1873 <func0+0xa3>\nmovzbl (%rbx),%r13d\nmov    %rax,%rbp\nlea    -0x5b(%r13),%eax\ncmp    $0x5,%al\njbe    1880 <func0+0xb0>\nlea    -0x41(%r13),%eax\ncmp    $0x39,%al\nja     1880 <func0+0xb0>\nmovslq %ebp,%rax\nlea    0x957(%rip),%rsi\nlea    -0x4(%rbx,%rax,1),%r14\nmov    %r14,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\njne    1898 <func0+0xc8>\nlea    -0x1(%rbp),%ecx\nmov    %rbx,%rax\nxor    %edi,%edi\nxor    %esi,%esi\nadd    %rbx,%rcx\njmp    1849 <func0+0x79>\nnopl   (%rax)\nadd    $0x1,%esi\ncmp    %rax,%rcx\nje     1862 <func0+0x92>\nmovzbl 0x1(%rax),%r13d\nadd    $0x1,%rax\nlea    -0x30(%r13),%edx\ncmp    $0x9,%dl\njbe    1838 <func0+0x68>\nxor    %edx,%edx\ncmp    $0x2e,%r13b\nsete   %dl\nadd    %edx,%edi\ncmp    %rax,%rcx\njne    1840 <func0+0x70>\ncmp    $0x3,%esi\njg     1880 <func0+0xb0>\nlea    0x799(%rip),%r12\ncmp    $0x1,%edi\njne    1880 <func0+0xb0>\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnop\nlea    0x77d(%rip),%r12\npop    %rbx\npop    %rbp\nmov    %r12,%rax\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nlea    0x7b8(%rip),%rsi\nmov    %r14,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1826 <func0+0x56>\nlea    0x793(%rip),%rsi\nmov    %r14,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1826 <func0+0x56>\njmp    1873 <func0+0xa3>\n"
    },
    {
        "task_id": 141,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nlea    0x823(%rip),%r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\ncall   1070 <strlen@plt>\ncmp    $0x4,%eax\njle    1c7f <func0+0x4af>\nmovzbl (%rbx),%r13d\nmov    %rax,%rbp\nlea    -0x5b(%r13),%eax\ncmp    $0x5,%al\njbe    1c78 <func0+0x4a8>\nlea    -0x41(%r13),%eax\ncmp    $0x39,%al\nja     1c78 <func0+0x4a8>\nmovslq %ebp,%rax\nlea    0x94f(%rip),%rsi\nlea    -0x4(%rbx,%rax,1),%r14\nmov    %r14,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\njne    1c90 <func0+0x4c0>\nlea    -0x1(%rbp),%eax\ncmp    $0xe,%eax\njbe    1d70 <func0+0x5a0>\nmov    %ebp,%edx\npxor   %xmm2,%xmm2\nmovdqa 0xe03(%rip),%xmm8\n00 00\nmovdqa 0xe0b(%rip),%xmm7\n00\nshr    $0x4,%edx\nmovdqa %xmm2,%xmm10\npxor   %xmm4,%xmm4\nmov    %rbx,%rax\nsub    $0x1,%edx\nmovdqa 0xe01(%rip),%xmm6\n00\nmovdqa 0xe09(%rip),%xmm5\n00\npxor   %xmm3,%xmm3\nshl    $0x4,%rdx\nlea    0x10(%rbx,%rdx,1),%rdx\nnopl   0x0(%rax)\nmovdqu (%rax),%xmm0\nmovdqu (%rax),%xmm9\nmovdqa %xmm4,%xmm11\nadd    $0x10,%rax\npaddb  %xmm8,%xmm0\npcmpeqb %xmm6,%xmm9\npsubusb %xmm7,%xmm0\npcmpeqb %xmm4,%xmm0\nmovdqa %xmm0,%xmm1\npand   %xmm5,%xmm0\npcmpeqb %xmm4,%xmm1\npand   %xmm9,%xmm1\npcmpgtb %xmm1,%xmm11\nmovdqa %xmm1,%xmm9\npunpcklbw %xmm11,%xmm9\npunpckhbw %xmm11,%xmm1\nmovdqa %xmm3,%xmm11\npcmpgtw %xmm9,%xmm11\nmovdqa %xmm9,%xmm12\npunpcklwd %xmm11,%xmm12\npunpckhwd %xmm11,%xmm9\nmovdqa %xmm1,%xmm11\npsubd  %xmm12,%xmm2\npsubd  %xmm9,%xmm2\nmovdqa %xmm3,%xmm9\npcmpgtw %xmm1,%xmm9\npunpcklwd %xmm9,%xmm11\npunpckhwd %xmm9,%xmm1\nmovdqa %xmm0,%xmm9\npsubd  %xmm11,%xmm2\nmovdqa %xmm3,%xmm11\npsubd  %xmm1,%xmm2\nmovdqa %xmm4,%xmm1\npcmpgtb %xmm0,%xmm1\npunpcklbw %xmm1,%xmm9\npunpckhbw %xmm1,%xmm0\npcmpgtw %xmm9,%xmm11\nmovdqa %xmm9,%xmm1\npunpcklwd %xmm11,%xmm1\npunpckhwd %xmm11,%xmm9\npaddd  %xmm10,%xmm1\nmovdqa %xmm0,%xmm10\npaddd  %xmm9,%xmm1\nmovdqa %xmm3,%xmm9\npcmpgtw %xmm0,%xmm9\npunpcklwd %xmm9,%xmm10\npunpckhwd %xmm9,%xmm0\npaddd  %xmm10,%xmm1\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm10\ncmp    %rdx,%rax\njne    1888 <func0+0xb8>\nmovdqa %xmm1,%xmm0\nmov    %ebp,%ecx\npsrldq $0x8,%xmm0\nand    $0xfffffff0,%ecx\npaddd  %xmm0,%xmm10\nmovdqa %xmm10,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm10\nmovdqa %xmm2,%xmm0\npsrldq $0x8,%xmm0\nmovd   %xmm10,%eax\npaddd  %xmm0,%xmm2\nmovdqa %xmm2,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm2\nmovd   %xmm2,%edx\ntest   $0xf,%bpl\nje     1c60 <func0+0x490>\nmovslq %ecx,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    19f8 <func0+0x228>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\njmp    19fb <func0+0x22b>\nxor    %ecx,%ecx\nxor    %edx,%edx\nxor    %eax,%eax\nnopl   0x0(%rax)\nadd    $0x1,%eax\nadd    $0x1,%ecx\ncmp    %ecx,%ebp\njle    1c60 <func0+0x490>\nmovslq %ecx,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1cc0 <func0+0x4f0>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0x1(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1cd0 <func0+0x500>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0x2(%rcx),%esi\ncmp    %ebp,%esi\njge    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1ce0 <func0+0x510>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0x3(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1cf0 <func0+0x520>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0x4(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1d00 <func0+0x530>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0x5(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1d10 <func0+0x540>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0x6(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1d20 <func0+0x550>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0x7(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1d30 <func0+0x560>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0x8(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1d40 <func0+0x570>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0x9(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1d50 <func0+0x580>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0xa(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1d60 <func0+0x590>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0xb(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1d90 <func0+0x5c0>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nlea    0xc(%rcx),%esi\ncmp    %esi,%ebp\njle    1c60 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%esi\nlea    -0x30(%rsi),%edi\ncmp    $0x9,%dil\njbe    1d98 <func0+0x5c8>\ncmp    $0x2e,%sil\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%edx\nadd    $0xd,%ecx\ncmp    %ecx,%ebp\njle    1c60 <func0+0x490>\nmovslq %ecx,%rcx\nmovzbl (%rbx,%rcx,1),%ecx\nlea    -0x30(%rcx),%esi\ncmp    $0x9,%sil\nja     1da0 <func0+0x5d0>\nadd    $0x1,%eax\nnopw   0x0(%rax,%rax,1)\ncmp    $0x3,%eax\njg     1c78 <func0+0x4a8>\nlea    0x39b(%rip),%r12\ncmp    $0x1,%edx\nje     1c7f <func0+0x4af>\nnopl   0x0(%rax)\nlea    0x385(%rip),%r12\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nlea    0x3c0(%rip),%rsi\nmov    %r14,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1832 <func0+0x62>\nlea    0x39b(%rip),%rsi\nmov    %r14,%rdi\ncall   1090 <strcmp@plt>\ntest   %eax,%eax\nje     1832 <func0+0x62>\njmp    1c7f <func0+0x4af>\nadd    $0x1,%eax\njmp    1a28 <func0+0x258>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1a55 <func0+0x285>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1a82 <func0+0x2b2>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1aaf <func0+0x2df>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1adc <func0+0x30c>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1b09 <func0+0x339>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1b36 <func0+0x366>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1b63 <func0+0x393>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1b90 <func0+0x3c0>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1bbd <func0+0x3ed>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%eax\njmp    1bea <func0+0x41a>\nnopl   0x0(%rax,%rax,1)\n00\nsub    $0x30,%r13d\ncmp    $0x9,%r13b\njbe    19ee <func0+0x21e>\nxor    %edx,%edx\nxor    %eax,%eax\nmov    $0x1,%ecx\njmp    1a06 <func0+0x236>\nnopl   0x0(%rax)\nadd    $0x1,%eax\njmp    1c13 <func0+0x443>\nadd    $0x1,%eax\njmp    1c3c <func0+0x46c>\ncmp    $0x2e,%cl\nsete   %cl\nmovzbl %cl,%ecx\nadd    %ecx,%edx\njmp    1c60 <func0+0x490>\n"
    },
    {
        "task_id": 142,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1259 <func0+0xf0>\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\njne    11e5 <func0+0x7c>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nadd    %eax,-0x8(%rbp)\njmp    1255 <func0+0xec>\nmov    -0x4(%rbp),%eax\nand    $0x3,%eax\ntest   %eax,%eax\njne    123c <func0+0xd3>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nadd    %eax,-0x8(%rbp)\njmp    1255 <func0+0xec>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     118b <func0+0x22>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 142,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r8\ntest   %esi,%esi\njle    11cb <func0+0x62>\nmov    %esi,%esi\nmov    $0x0,%edx\nmov    $0x0,%ecx\njmp    119e <func0+0x35>\ntest   $0x3,%dl\njne    11c5 <func0+0x5c>\nmov    (%r8,%rdx,4),%edi\nmov    %edi,%eax\nimul   %edi,%eax\nimul   %edi,%eax\nadd    %eax,%ecx\nadd    $0x1,%rdx\ncmp    %rsi,%rdx\nje     11d0 <func0+0x67>\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%edi\nsar    $0x1f,%edi\nsub    %edi,%eax\nlea    (%rax,%rax,2),%eax\ncmp    %edx,%eax\njne    1182 <func0+0x19>\nmov    (%r8,%rdx,4),%eax\nimul   %eax,%eax\nadd    %eax,%ecx\njmp    1195 <func0+0x2c>\nadd    (%r8,%rdx,4),%ecx\njmp    1195 <func0+0x2c>\nmov    $0x0,%ecx\nmov    %ecx,%eax\nret\n"
    },
    {
        "task_id": 142,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1620 <func0+0x60>\nmovslq %esi,%rsi\nxor    %eax,%eax\nxor    %r8d,%r8d\njmp    15e7 <func0+0x27>\nnopw   0x0(%rax,%rax,1)\nimul   %edx,%edx\nadd    %edx,%r8d\nadd    $0x1,%rax\ncmp    %rsi,%rax\nje     1610 <func0+0x50>\nimul   $0xaaaaaaab,%eax,%edx\ncmp    $0x55555555,%edx\nmov    (%rdi,%rax,4),%edx\njbe    15d8 <func0+0x18>\ntest   $0x3,%al\njne    1618 <func0+0x58>\nmov    %edx,%ecx\nadd    $0x1,%rax\nimul   %edx,%ecx\nimul   %ecx,%edx\nadd    %edx,%r8d\ncmp    %rsi,%rax\njne    15e7 <func0+0x27>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax)\nadd    %edx,%r8d\njmp    15de <func0+0x1e>\nnopl   (%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 142,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1540 <func0+0x60>\nmovslq %esi,%rsi\nxor    %eax,%eax\nxor    %r8d,%r8d\njmp    1507 <func0+0x27>\nnopw   0x0(%rax,%rax,1)\nimul   %edx,%edx\nadd    %edx,%r8d\nadd    $0x1,%rax\ncmp    %rsi,%rax\nje     1530 <func0+0x50>\nimul   $0xaaaaaaab,%eax,%edx\ncmp    $0x55555555,%edx\nmov    (%rdi,%rax,4),%edx\njbe    14f8 <func0+0x18>\ntest   $0x3,%al\njne    1538 <func0+0x58>\nmov    %edx,%ecx\nadd    $0x1,%rax\nimul   %edx,%ecx\nimul   %ecx,%edx\nadd    %edx,%r8d\ncmp    %rsi,%rax\njne    1507 <func0+0x27>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax)\nadd    %edx,%r8d\njmp    14fe <func0+0x1e>\nnopl   (%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\n"
    },
    {
        "task_id": 143,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    129f <func0+0xf6>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     11fb <func0+0x52>\naddl   $0x1,-0x14(%rbp)\njmp    129b <func0+0xf2>\ncmpl   $0x1,-0x14(%rbp)\njle    1232 <func0+0x89>\nmovb   $0x1,-0x15(%rbp)\nmovl   $0x2,-0x8(%rbp)\njmp    1225 <func0+0x7c>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    1221 <func0+0x78>\nmovb   $0x0,-0x15(%rbp)\njmp    1236 <func0+0x8d>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    120e <func0+0x65>\njmp    1236 <func0+0x8d>\nmovb   $0x0,-0x15(%rbp)\ncmpb   $0x0,-0x15(%rbp)\nje     1294 <func0+0xeb>\ncmpl   $0x0,-0x10(%rbp)\njle    1258 <func0+0xaf>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x20,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    -0x14(%rbp),%ecx\nmovslq %ecx,%rcx\nmov    %rdx,%rsi\nsub    %rcx,%rsi\nmov    -0x28(%rbp),%rdx\nadd    %rdx,%rsi\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x30(%rbp),%rdx\nadd    %rdx,%rcx\nmov    %rax,%rdx\nmov    %rcx,%rdi\ncall   10b0 <memcpy@plt>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    11de <func0+0x35>\ncmpl   $0x1,-0x14(%rbp)\njle    12ee <func0+0x145>\nmovb   $0x1,-0x15(%rbp)\nmovl   $0x2,-0x8(%rbp)\njmp    12e1 <func0+0x138>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    12dd <func0+0x134>\nmovb   $0x0,-0x15(%rbp)\njmp    12f2 <func0+0x149>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    12ca <func0+0x121>\njmp    12f2 <func0+0x149>\nmovb   $0x0,-0x15(%rbp)\ncmpb   $0x0,-0x15(%rbp)\nje     1350 <func0+0x1a7>\ncmpl   $0x0,-0x10(%rbp)\njle    1314 <func0+0x16b>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x20,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    -0x14(%rbp),%ecx\nmovslq %ecx,%rcx\nmov    %rdx,%rsi\nsub    %rcx,%rsi\nmov    -0x28(%rbp),%rdx\nadd    %rdx,%rsi\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x30(%rbp),%rdx\nadd    %rdx,%rcx\nmov    %rax,%rdx\nmov    %rcx,%rdi\ncall   10b0 <memcpy@plt>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nleave\nret\n"
    },
    {
        "task_id": 143,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%r14\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     125a <func0+0xb1>\nmov    %rdi,%r12\nmov    $0x0,%r13d\nmov    $0x0,%ebx\nmov    $0x0,%ebp\njmp    11ef <func0+0x46>\ncmp    $0x1,%ebx\njg     11f8 <func0+0x4f>\nmov    $0x0,%ebx\nadd    $0x1,%rbp\nmovzbl (%r12,%rbp,1),%eax\ntest   %al,%al\nje     122f <func0+0x86>\ncmp    $0x20,%al\nje     11d8 <func0+0x2f>\nadd    $0x1,%ebx\njmp    11e2 <func0+0x39>\ncmp    $0x3,%ebx\njle    129c <func0+0xf3>\ntest   $0x1,%bl\nje     1228 <func0+0x7f>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njg     129c <func0+0xf3>\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    120b <func0+0x62>\nmov    %edx,%ebx\njmp    11e2 <func0+0x39>\nmov    $0x0,%ebx\njmp    11e2 <func0+0x39>\ncmp    $0x1,%ebx\njle    128b <func0+0xe2>\ncmp    $0x3,%ebx\njle    1262 <func0+0xb9>\ntest   $0x1,%bl\nje     128b <func0+0xe2>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njg     1262 <func0+0xb9>\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    1243 <func0+0x9a>\njmp    128b <func0+0xe2>\nmov    $0x0,%r13d\njmp    128b <func0+0xe2>\ntest   %r13d,%r13d\njle    1273 <func0+0xca>\nmovslq %r13d,%rax\nmovb   $0x20,(%r14,%rax,1)\nlea    0x1(%r13),%r13d\nmovslq %ebx,%rdx\nmovslq %r13d,%rdi\nadd    %r14,%rdi\nsub    %rdx,%rbp\nlea    (%r12,%rbp,1),%rsi\ncall   10b0 <memcpy@plt>\nadd    %ebx,%r13d\nmovslq %r13d,%r13\nmovb   $0x0,(%r14,%r13,1)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ntest   %r13d,%r13d\njle    12ad <func0+0x104>\nmovslq %r13d,%rax\nmovb   $0x20,(%r14,%rax,1)\nlea    0x1(%r13),%r13d\nmovslq %ebx,%rdx\nmovslq %r13d,%rdi\nadd    %r14,%rdi\nmov    %rbp,%rsi\nsub    %rdx,%rsi\nadd    %r12,%rsi\ncall   10b0 <memcpy@plt>\nadd    %ebx,%r13d\nmov    $0x0,%ebx\njmp    11e2 <func0+0x39>\n"
    },
    {
        "task_id": 143,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     1482 <func0+0xc2>\nmov    %rdi,%rbp\nxor    %r13d,%r13d\nxor    %ecx,%ecx\nxor    %ebx,%ebx\njmp    1400 <func0+0x40>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%ecx\nadd    $0x1,%rbx\nmovzbl 0x0(%rbp,%rbx,1),%eax\ntest   %al,%al\nje     141c <func0+0x5c>\ncmp    $0x20,%al\njne    13f0 <func0+0x30>\ncmp    $0x1,%ecx\njg     1498 <func0+0xd8>\nadd    $0x1,%rbx\nxor    %ecx,%ecx\nmovzbl 0x0(%rbp,%rbx,1),%eax\ntest   %al,%al\njne    1400 <func0+0x40>\ncmp    $0x1,%ecx\njle    147c <func0+0xbc>\ncmp    $0x3,%ecx\njle    144d <func0+0x8d>\nmov    $0x2,%esi\ntest   $0x1,%cl\njne    1441 <func0+0x81>\njmp    147c <func0+0xbc>\nnopw   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     147c <func0+0xbc>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1438 <func0+0x78>\ntest   %r13d,%r13d\nje     1500 <func0+0x140>\nlea    0x1(%r13),%eax\nmovslq %r13d,%r13\nmovslq %eax,%rdi\nmovb   $0x20,(%r12,%r13,1)\nlea    (%rcx,%rax,1),%r13d\nadd    %r12,%rdi\nmovslq %ecx,%rdx\nsub    %rdx,%rbx\nlea    0x0(%rbp,%rbx,1),%rsi\ncall   1090 <memcpy@plt>\nmovslq %r13d,%r13\nadd    %r13,%r12\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\ncmp    $0x3,%ecx\njle    14c9 <func0+0x109>\ntest   $0x1,%cl\nje     140d <func0+0x4d>\nmov    $0x2,%esi\njmp    14bd <func0+0xfd>\nnopl   (%rax)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     140d <func0+0x4d>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    14b0 <func0+0xf0>\ntest   %r13d,%r13d\nje     1510 <func0+0x150>\nlea    0x1(%r13),%eax\nmovslq %r13d,%r13\nmovslq %eax,%rdi\nmovb   $0x20,(%r12,%r13,1)\nlea    (%rax,%rcx,1),%r13d\nadd    %r12,%rdi\nmovslq %ecx,%rdx\nmov    %rbx,%rsi\nsub    %rdx,%rsi\nadd    %rbp,%rsi\ncall   1090 <memcpy@plt>\nxor    %ecx,%ecx\njmp    13f3 <func0+0x33>\nnopl   0x0(%rax)\nmov    %ecx,%r13d\nmov    %r12,%rdi\njmp    146c <func0+0xac>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%r13d\nmov    %r12,%rdi\njmp    14e4 <func0+0x124>\n"
    },
    {
        "task_id": 143,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     1482 <func0+0xc2>\nmov    %rdi,%rbp\nxor    %r13d,%r13d\nxor    %ecx,%ecx\nxor    %ebx,%ebx\njmp    1400 <func0+0x40>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%ecx\nadd    $0x1,%rbx\nmovzbl 0x0(%rbp,%rbx,1),%eax\ntest   %al,%al\nje     141c <func0+0x5c>\ncmp    $0x20,%al\njne    13f0 <func0+0x30>\ncmp    $0x1,%ecx\njg     1498 <func0+0xd8>\nadd    $0x1,%rbx\nxor    %ecx,%ecx\nmovzbl 0x0(%rbp,%rbx,1),%eax\ntest   %al,%al\njne    1400 <func0+0x40>\ncmp    $0x1,%ecx\njle    147c <func0+0xbc>\ncmp    $0x3,%ecx\njle    144d <func0+0x8d>\nmov    $0x2,%esi\ntest   $0x1,%cl\njne    1441 <func0+0x81>\njmp    147c <func0+0xbc>\nnopw   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     147c <func0+0xbc>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    1438 <func0+0x78>\ntest   %r13d,%r13d\nje     1500 <func0+0x140>\nlea    0x1(%r13),%eax\nmovslq %r13d,%r13\nmovslq %eax,%rdi\nmovb   $0x20,(%r12,%r13,1)\nlea    (%rcx,%rax,1),%r13d\nadd    %r12,%rdi\nmovslq %ecx,%rdx\nsub    %rdx,%rbx\nlea    0x0(%rbp,%rbx,1),%rsi\ncall   1090 <memcpy@plt>\nmovslq %r13d,%r13\nadd    %r13,%r12\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\ncmp    $0x3,%ecx\njle    14c9 <func0+0x109>\ntest   $0x1,%cl\nje     140d <func0+0x4d>\nmov    $0x2,%esi\njmp    14bd <func0+0xfd>\nnopl   (%rax)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     140d <func0+0x4d>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    14b0 <func0+0xf0>\ntest   %r13d,%r13d\nje     1510 <func0+0x150>\nlea    0x1(%r13),%eax\nmovslq %r13d,%r13\nmovslq %eax,%rdi\nmovb   $0x20,(%r12,%r13,1)\nlea    (%rax,%rcx,1),%r13d\nadd    %r12,%rdi\nmovslq %ecx,%rdx\nmov    %rbx,%rsi\nsub    %rdx,%rsi\nadd    %rbp,%rsi\ncall   1090 <memcpy@plt>\nxor    %ecx,%ecx\njmp    13f3 <func0+0x33>\nnopl   0x0(%rax)\nmov    %ecx,%r13d\nmov    %r12,%rdi\njmp    146c <func0+0xac>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%r13d\nmov    %r12,%rdi\njmp    14e4 <func0+0x124>\n"
    },
    {
        "task_id": 144,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x110,%rsp\nmov    %rdi,-0x108(%rbp)\nmov    %rsi,-0x110(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0xf8(%rbp)\n00 00 00\njmp    11ed <func0+0x64>\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x108(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xf8(%rbp),%eax\ncltq\nmov    %dl,-0xe0(%rbp,%rax,1)\naddl   $0x1,-0xf8(%rbp)\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x108(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njne    11c1 <func0+0x38>\nmov    -0xf8(%rbp),%eax\ncltq\nmovb   $0x0,-0xe0(%rbp,%rax,1)\n00\nlea    -0xe0(%rbp),%rax\nmov    %rax,%rdi\ncall   1090 <atoi@plt>\nmov    %eax,-0xf0(%rbp)\nmovl   $0x0,-0xf4(%rbp)\n00 00 00\naddl   $0x1,-0xf8(%rbp)\njmp    126f <func0+0xe6>\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x108(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xf4(%rbp),%eax\ncltq\nmov    %dl,-0x70(%rbp,%rax,1)\naddl   $0x1,-0xf8(%rbp)\naddl   $0x1,-0xf4(%rbp)\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x108(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    123f <func0+0xb6>\nmov    -0xf4(%rbp),%eax\ncltq\nmovb   $0x0,-0x70(%rbp,%rax,1)\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncall   1090 <atoi@plt>\nmov    %eax,-0xec(%rbp)\nmovl   $0x0,-0xf8(%rbp)\n00 00 00\njmp    12e0 <func0+0x157>\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x110(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xf8(%rbp),%eax\ncltq\nmov    %dl,-0xe0(%rbp,%rax,1)\naddl   $0x1,-0xf8(%rbp)\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x110(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njne    12b4 <func0+0x12b>\nmov    -0xf8(%rbp),%eax\ncltq\nmovb   $0x0,-0xe0(%rbp,%rax,1)\n00\nlea    -0xe0(%rbp),%rax\nmov    %rax,%rdi\ncall   1090 <atoi@plt>\nmov    %eax,-0xe8(%rbp)\nmovl   $0x0,-0xf4(%rbp)\n00 00 00\naddl   $0x1,-0xf8(%rbp)\njmp    1362 <func0+0x1d9>\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x110(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xf4(%rbp),%eax\ncltq\nmov    %dl,-0x70(%rbp,%rax,1)\naddl   $0x1,-0xf8(%rbp)\naddl   $0x1,-0xf4(%rbp)\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x110(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1332 <func0+0x1a9>\nmov    -0xf4(%rbp),%eax\ncltq\nmovb   $0x0,-0x70(%rbp,%rax,1)\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncall   1090 <atoi@plt>\nmov    %eax,-0xe4(%rbp)\nmov    -0xf0(%rbp),%eax\nimul   -0xe8(%rbp),%eax\nmov    -0xec(%rbp),%edx\nmov    %edx,%ecx\nimul   -0xe4(%rbp),%ecx\ncltd\nidiv   %ecx\nmov    %edx,%eax\ntest   %eax,%eax\njne    13c7 <func0+0x23e>\nmov    $0x1,%eax\njmp    13cc <func0+0x243>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     13e0 <func0+0x257>\ncall   1070 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 144,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xe0,%rsp\nmov    %rdi,%rbp\nmov    %rsi,%rbx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xd8(%rsp)\n00\nxor    %eax,%eax\nmovzbl (%rdi),%edx\ncmp    $0x2f,%dl\nje     131d <func0+0x194>\nmov    $0x1,%eax\nlea    -0x1(%rsp),%rcx\nmov    %dl,(%rcx,%rax,1)\nmov    %eax,%r13d\nadd    $0x1,%rax\nmovzbl -0x1(%rbp,%rax,1),%edx\ncmp    $0x2f,%dl\njne    11cb <func0+0x42>\nmovslq %r13d,%rax\nmovb   $0x0,(%rsp,%rax,1)\nmov    %rsp,%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncall   1090 <strtol@plt>\nmov    %rax,%r12\nlea    0x1(%r13),%eax\ncltq\nmovzbl 0x0(%rbp,%rax,1),%eax\ntest   %al,%al\nje     1328 <func0+0x19f>\nmov    $0x1,%edx\nlea    0x6f(%rsp),%rsi\nmovslq %r13d,%r13\nadd    %r13,%rbp\nmov    %al,(%rsi,%rdx,1)\nmov    %edx,%ecx\nadd    $0x1,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%eax\ntest   %al,%al\njne    121e <func0+0x95>\nmovslq %ecx,%rcx\nmovb   $0x0,0x70(%rsp,%rcx,1)\nlea    0x70(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncall   1090 <strtol@plt>\nmov    %rax,%r13\nmovzbl (%rbx),%eax\ncmp    $0x2f,%al\nje     1332 <func0+0x1a9>\nmov    $0x1,%edx\nlea    -0x1(%rsp),%rcx\nmov    %al,(%rcx,%rdx,1)\nmov    %edx,%ebp\nadd    $0x1,%rdx\nmovzbl -0x1(%rbx,%rdx,1),%eax\ncmp    $0x2f,%al\njne    1264 <func0+0xdb>\nmovslq %ebp,%rax\nmovb   $0x0,(%rsp,%rax,1)\nmov    %rsp,%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncall   1090 <strtol@plt>\nmov    %rax,%r14\nlea    0x1(%rbp),%eax\ncltq\nmovzbl (%rbx,%rax,1),%eax\ntest   %al,%al\nje     133c <func0+0x1b3>\nmov    $0x1,%edx\nlea    0x6f(%rsp),%rsi\nmovslq %ebp,%rbp\nadd    %rbp,%rbx\nmov    %al,(%rsi,%rdx,1)\nmov    %edx,%ecx\nadd    $0x1,%rdx\nmovzbl (%rbx,%rdx,1),%eax\ntest   %al,%al\njne    12b3 <func0+0x12a>\nmovslq %ecx,%rcx\nmovb   $0x0,0x70(%rsp,%rcx,1)\nlea    0x70(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncall   1090 <strtol@plt>\nmov    %rax,%rdx\nmov    %r14d,%eax\nimul   %r12d,%eax\nimul   %edx,%r13d\ncltd\nidiv   %r13d\ntest   %edx,%edx\nsete   %al\nmovzbl %al,%eax\nmov    0xd8(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    1343 <func0+0x1ba>\nadd    $0xe0,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    $0x0,%r13d\njmp    11df <func0+0x56>\nmov    $0x0,%ecx\njmp    1230 <func0+0xa7>\nmov    $0x0,%ebp\njmp    1276 <func0+0xed>\nmov    $0x0,%ecx\njmp    12c4 <func0+0x13b>\ncall   1070 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 144,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0xf8,%rsp\nmovzbl (%rdi),%edx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xe8(%rsp)\n00\nxor    %eax,%eax\ncmp    $0x2f,%dl\nje     1640 <func0+0x1b0>\nmov    $0x1,%eax\nlea    0xf(%rsp),%rsi\nnopl   0x0(%rax)\nmov    %dl,(%rsi,%rax,1)\nmovslq %eax,%rcx\nadd    $0x1,%rax\nmovzbl -0x1(%rbp,%rax,1),%edx\ncmp    $0x2f,%dl\njne    14d8 <func0+0x48>\nlea    0x1(%rcx),%r15d\nmovslq %r15d,%r14\nlea    0x10(%rsp),%r13\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0x10(%rsp,%rcx,1)\nmov    %r13,%rdi\ncall   1090 <strtol@plt>\nmov    %rax,0x8(%rsp)\nmovzbl 0x0(%rbp,%r14,1),%eax\ntest   %al,%al\nje     1658 <func0+0x1c8>\nmovslq %r15d,%r15\nmov    $0x1,%edx\nlea    0x7f(%rsp),%rsi\nadd    %r15,%rbp\nnop\nmov    %al,(%rsi,%rdx,1)\nmovslq %edx,%rcx\nadd    $0x1,%rdx\nmovzbl -0x1(%rbp,%rdx,1),%eax\ntest   %al,%al\njne    1530 <func0+0xa0>\nlea    0x80(%rsp),%r14\n00\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0x80(%rsp,%rcx,1)\n00\nmov    %r14,%rdi\ncall   1090 <strtol@plt>\nmovzbl (%r12),%ecx\nmov    %rax,%rbp\ncmp    $0x2f,%cl\nje     1660 <func0+0x1d0>\nmov    $0x1,%edx\nlea    0xf(%rsp),%rsi\nnopl   (%rax)\nmov    %cl,(%rsi,%rdx,1)\nmovslq %edx,%rax\nadd    $0x1,%rdx\nmovzbl -0x1(%r12,%rdx,1),%ecx\ncmp    $0x2f,%cl\njne    1580 <func0+0xf0>\nlea    0x1(%rax),%ebx\nmovslq %ebx,%r15\nmov    %r13,%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0x10(%rsp,%rax,1)\ncall   1090 <strtol@plt>\nmovzbl (%r12,%r15,1),%ecx\nmov    %rax,%r13\ntest   %cl,%cl\nje     1678 <func0+0x1e8>\nmovslq %ebx,%r8\nmov    $0x1,%edx\nlea    0x7f(%rsp),%rsi\nadd    %r8,%r12\nnop\nmov    %cl,(%rsi,%rdx,1)\nmovslq %edx,%rax\nadd    $0x1,%rdx\nmovzbl -0x1(%r12,%rdx,1),%ecx\ntest   %cl,%cl\njne    15d0 <func0+0x140>\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %r14,%rdi\nmovb   $0x0,0x80(%rsp,%rax,1)\n00\ncall   1090 <strtol@plt>\nmov    %rax,%r8\nmov    0x8(%rsp),%eax\nimul   %r8d,%ebp\nimul   %r13d,%eax\ncltd\nidiv   %ebp\nxor    %eax,%eax\ntest   %edx,%edx\nsete   %al\nmov    0xe8(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    167f <func0+0x1ef>\nadd    $0xf8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmov    $0x1,%r14d\nmov    $0x1,%r15d\nxor    %ecx,%ecx\njmp    14f3 <func0+0x63>\nnopl   0x0(%rax,%rax,1)\nxor    %ecx,%ecx\njmp    1543 <func0+0xb3>\nnop\nmov    $0x1,%r15d\nmov    $0x1,%ebx\nxor    %eax,%eax\njmp    159b <func0+0x10b>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\njmp    15e4 <func0+0x154>\ncall   1070 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 144,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0xf8,%rsp\nmovzbl (%rdi),%edx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xe8(%rsp)\n00\nxor    %eax,%eax\ncmp    $0x2f,%dl\nje     1640 <func0+0x1b0>\nmov    $0x1,%eax\nlea    0xf(%rsp),%rsi\nnopl   0x0(%rax)\nmov    %dl,(%rsi,%rax,1)\nmovslq %eax,%rcx\nadd    $0x1,%rax\nmovzbl -0x1(%rbp,%rax,1),%edx\ncmp    $0x2f,%dl\njne    14d8 <func0+0x48>\nlea    0x1(%rcx),%r15d\nmovslq %r15d,%r14\nlea    0x10(%rsp),%r13\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0x10(%rsp,%rcx,1)\nmov    %r13,%rdi\ncall   1090 <strtol@plt>\nmov    %rax,0x8(%rsp)\nmovzbl 0x0(%rbp,%r14,1),%eax\ntest   %al,%al\nje     1658 <func0+0x1c8>\nmovslq %r15d,%r15\nmov    $0x1,%edx\nlea    0x7f(%rsp),%rsi\nadd    %r15,%rbp\nnop\nmov    %al,(%rsi,%rdx,1)\nmovslq %edx,%rcx\nadd    $0x1,%rdx\nmovzbl -0x1(%rbp,%rdx,1),%eax\ntest   %al,%al\njne    1530 <func0+0xa0>\nlea    0x80(%rsp),%r14\n00\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0x80(%rsp,%rcx,1)\n00\nmov    %r14,%rdi\ncall   1090 <strtol@plt>\nmovzbl (%r12),%ecx\nmov    %rax,%rbp\ncmp    $0x2f,%cl\nje     1660 <func0+0x1d0>\nmov    $0x1,%edx\nlea    0xf(%rsp),%rsi\nnopl   (%rax)\nmov    %cl,(%rsi,%rdx,1)\nmovslq %edx,%rax\nadd    $0x1,%rdx\nmovzbl -0x1(%r12,%rdx,1),%ecx\ncmp    $0x2f,%cl\njne    1580 <func0+0xf0>\nlea    0x1(%rax),%ebx\nmovslq %ebx,%r15\nmov    %r13,%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0x10(%rsp,%rax,1)\ncall   1090 <strtol@plt>\nmovzbl (%r12,%r15,1),%ecx\nmov    %rax,%r13\ntest   %cl,%cl\nje     1678 <func0+0x1e8>\nmovslq %ebx,%r8\nmov    $0x1,%edx\nlea    0x7f(%rsp),%rsi\nadd    %r8,%r12\nnop\nmov    %cl,(%rsi,%rdx,1)\nmovslq %edx,%rax\nadd    $0x1,%rdx\nmovzbl -0x1(%r12,%rdx,1),%ecx\ntest   %cl,%cl\njne    15d0 <func0+0x140>\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %r14,%rdi\nmovb   $0x0,0x80(%rsp,%rax,1)\n00\ncall   1090 <strtol@plt>\nmov    %rax,%r8\nmov    0x8(%rsp),%eax\nimul   %r8d,%ebp\nimul   %r13d,%eax\ncltd\nidiv   %ebp\nxor    %eax,%eax\ntest   %edx,%edx\nsete   %al\nmov    0xe8(%rsp),%rdx\n00\nsub    %fs:0x28,%rdx\n00 00\njne    167f <func0+0x1ef>\nadd    $0xf8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmov    $0x1,%r14d\nmov    $0x1,%r15d\nxor    %ecx,%ecx\njmp    14f3 <func0+0x63>\nnopl   0x0(%rax,%rax,1)\nxor    %ecx,%ecx\njmp    1543 <func0+0xb3>\nnop\nmov    $0x1,%r15d\nmov    $0x1,%ebx\nxor    %eax,%eax\njmp    159b <func0+0x10b>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\njmp    15e4 <func0+0x154>\ncall   1070 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 145,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %esi,-0x4c(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x4c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   1100 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x3c(%rbp)\njmp    1315 <func0+0x10c>\nmov    -0x3c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nlea    -0x14(%rbp),%rax\nlea    0xd94(%rip),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   1110 <sprintf@plt>\nmovl   $0x0,-0x38(%rbp)\nlea    -0x14(%rbp),%rax\nmov    %rax,%rdi\ncall   10d0 <strlen@plt>\nmov    %eax,-0x24(%rbp)\nmovl   $0x1,-0x34(%rbp)\njmp    12ba <func0+0xb1>\nmov    -0x34(%rbp),%eax\ncltq\nmovzbl -0x14(%rbp,%rax,1),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nadd    %eax,-0x38(%rbp)\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     12a3 <func0+0x9a>\nmov    -0x3c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    12eb <func0+0xe2>\nmovzbl -0x14(%rbp),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nadd    %eax,-0x38(%rbp)\njmp    12f8 <func0+0xef>\nmovzbl -0x14(%rbp),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nsub    %eax,-0x38(%rbp)\nmov    -0x3c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njl     124c <func0+0x43>\nmovl   $0x0,-0x30(%rbp)\njmp    143f <func0+0x236>\nmovl   $0x1,-0x2c(%rbp)\njmp    142f <func0+0x226>\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    142b <func0+0x222>\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x2c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x2c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x48(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njl     1339 <func0+0x130>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njl     132d <func0+0x124>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   10b0 <free@plt>\nmov    -0x48(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     146f <func0+0x266>\ncall   10e0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 145,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%rbx\nmov    %rdi,(%rsp)\nmov    %esi,%r13d\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncall   1100 <malloc@plt>\nmov    %rax,%r15\ntest   %r13d,%r13d\njle    1351 <func0+0x148>\nlea    -0x1(%r13),%eax\nlea    0x4(%rbx,%rax,4),%rax\nmov    %rax,0x8(%rsp)\nmov    %r15,%rbp\njmp    1283 <func0+0x7a>\nmov    $0x0,%eax\njmp    12e4 <func0+0xdb>\nmovsbl 0x1c(%rsp),%edx\nsub    $0x30,%edx\nsub    %edx,%eax\nmov    %eax,0x0(%rbp)\nadd    $0x4,%rbx\nadd    $0x4,%rbp\ncmp    0x8(%rsp),%rbx\nje     12fc <func0+0xf3>\nmov    %rbx,%r14\nlea    0x1c(%rsp),%r12\nmov    (%rbx),%eax\nmov    %eax,%r8d\nneg    %r8d\ncmovs  %eax,%r8d\nlea    0xd66(%rip),%rcx\nmov    $0xc,%edx\nmov    $0x1,%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   1110 <__sprintf_chk@plt>\nmov    %r12,%rdi\ncall   10d0 <strlen@plt>\ncmp    $0x1,%eax\njle    1260 <func0+0x57>\nlea    0x1d(%rsp),%rdx\nlea    -0x2(%rax),%eax\nlea    0x1e(%rsp,%rax,1),%rsi\nmov    $0x0,%eax\nmovsbl (%rdx),%ecx\nlea    -0x30(%rax,%rcx,1),%eax\nadd    $0x1,%rdx\ncmp    %rsi,%rdx\njne    12d4 <func0+0xcb>\ncmpl   $0x0,(%r14)\njle    1267 <func0+0x5e>\nmovsbl 0x1c(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\njmp    1271 <func0+0x68>\nlea    -0x2(%r13),%eax\nlea    0x8(%r15,%rax,4),%rdi\nmov    $0x0,%r8d\njmp    133d <func0+0x134>\nadd    $0x4,%rax\nadd    $0x4,%rdx\ncmp    %rdi,%rax\nje     1334 <func0+0x12b>\nmov    -0x4(%rax),%esi\nmov    (%rax),%ecx\ncmp    %ecx,%esi\njle    130d <func0+0x104>\nmov    %esi,(%rax)\nmov    %ecx,-0x4(%rax)\nmov    (%rdx),%ecx\nmov    -0x4(%rdx),%esi\nmov    %esi,(%rdx)\nmov    %ecx,-0x4(%rdx)\njmp    130d <func0+0x104>\nadd    $0x1,%r8d\ncmp    %r8d,%r13d\nje     1351 <func0+0x148>\nlea    0x4(%r15),%rax\nmov    (%rsp),%rbx\nlea    0x4(%rbx),%rdx\ncmp    $0x1,%r13d\njg     131a <func0+0x111>\njmp    1334 <func0+0x12b>\nmov    %r15,%rdi\ncall   10b0 <free@plt>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    137c <func0+0x173>\nmov    (%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10e0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 145,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,(%rsp)\nmovslq %esi,%rdi\nmov    %rdi,%rbx\nshl    $0x2,%rdi\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncall   1100 <malloc@plt>\nmov    %rax,%r12\ntest   %ebx,%ebx\njle    188e <func0+0x15e>\nlea    0x4(%r14),%rdi\nlea    -0x1(%rbx),%eax\nmov    %r12,0x10(%rsp)\nmov    %r14,%r13\nlea    (%rdi,%rax,4),%rax\nmov    %rdi,0x8(%rsp)\nlea    0x2e(%rsp),%rdi\nmov    %ebx,0x1c(%rsp)\nlea    0x2c(%rsp),%rbp\nmov    %r13,%rbx\nmov    %rdi,%r15\nlea    0x85e(%rip),%r14\nmov    %rax,%r13\nnopl   0x0(%rax)\nmov    (%rbx),%eax\nmov    %rbp,%rdi\nmov    %r14,%rcx\nmov    $0xc,%edx\nmov    $0x1,%esi\nmov    %eax,%r8d\nneg    %r8d\ncmovs  %eax,%r8d\nxor    %eax,%eax\ncall   1110 <__sprintf_chk@plt>\nmov    %rbp,%rdi\ncall   10d0 <strlen@plt>\ncmp    $0x1,%rax\njbe    18c0 <func0+0x190>\nlea    -0x2(%rax),%esi\nlea    0x2d(%rsp),%rdx\nxor    %eax,%eax\nadd    %r15,%rsi\nnopw   0x0(%rax,%rax,1)\nmovsbl (%rdx),%ecx\nadd    $0x1,%rdx\nlea    -0x30(%rax,%rcx,1),%eax\ncmp    %rsi,%rdx\njne    17f8 <func0+0xc8>\nmovsbl 0x2c(%rsp),%edx\nsub    $0x30,%edx\nlea    (%rax,%rdx,1),%ecx\nsub    %edx,%eax\nmov    (%rbx),%edx\ntest   %edx,%edx\ncmovg  %ecx,%eax\nadd    $0x4,%rbx\nadd    $0x4,%r12\nmov    %eax,-0x4(%r12)\ncmp    %r13,%rbx\njne    17b0 <func0+0x80>\nmov    0x1c(%rsp),%ebx\nmov    0x10(%rsp),%r12\nxor    %r8d,%r8d\nmov    0x8(%rsp),%r9\nlea    -0x2(%rbx),%eax\nlea    0x8(%r12,%rax,4),%rdi\nnopw   0x0(%rax,%rax,1)\n00 00\nlea    0x4(%r12),%rax\nmov    %r9,%rdx\ncmp    $0x1,%ebx\nje     1885 <func0+0x155>\nnopl   (%rax)\nmov    -0x4(%rax),%esi\nmov    (%rax),%ecx\ncmp    %ecx,%esi\njle    1878 <func0+0x148>\nmov    %esi,(%rax)\nmov    -0x4(%rdx),%esi\nmov    %ecx,-0x4(%rax)\nmov    (%rdx),%ecx\nmov    %esi,(%rdx)\nmov    %ecx,-0x4(%rdx)\nadd    $0x4,%rax\nadd    $0x4,%rdx\ncmp    %rax,%rdi\njne    1860 <func0+0x130>\nadd    $0x1,%r8d\ncmp    %r8d,%ebx\njne    1850 <func0+0x120>\nmov    %r12,%rdi\ncall   10b0 <free@plt>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    18c7 <func0+0x197>\nmov    (%rsp),%rax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\njmp    1808 <func0+0xd8>\ncall   10e0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 145,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\nmovslq %esi,%rdi\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nshl    $0x2,%rdi\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\ncall   1100 <malloc@plt>\nmov    %rax,(%rsp)\ntest   %ebx,%ebx\njle    17b8 <func0+0x1b8>\nmov    %rax,%rbp\nlea    -0x1(%rbx),%eax\nmov    %r12,%r15\nlea    0x4(%r12,%rax,4),%rax\nlea    0x1c(%rsp),%r13\nmov    %rax,0x8(%rsp)\nlea    0x9a5(%rip),%r14\njmp    1715 <func0+0x115>\nnopl   0x0(%rax)\nmovsbl 0x1d(%rsp),%eax\nsub    $0x30,%eax\ncmp    $0x2,%edx\nje     16ee <func0+0xee>\nmovsbl 0x1e(%rsp),%ecx\nlea    -0x30(%rax,%rcx,1),%eax\ncmp    $0x3,%edx\nje     16ee <func0+0xee>\nmovsbl 0x1f(%rsp),%ecx\nlea    -0x30(%rax,%rcx,1),%eax\ncmp    $0x4,%edx\nje     16ee <func0+0xee>\nmovsbl 0x20(%rsp),%ecx\nlea    -0x30(%rax,%rcx,1),%eax\ncmp    $0x5,%edx\nje     16ee <func0+0xee>\nmovsbl 0x21(%rsp),%ecx\nlea    -0x30(%rax,%rcx,1),%eax\ncmp    $0x6,%edx\nje     16ee <func0+0xee>\nmovsbl 0x22(%rsp),%ecx\nlea    -0x30(%rax,%rcx,1),%eax\ncmp    $0x7,%edx\nje     16ee <func0+0xee>\nmovsbl 0x23(%rsp),%ecx\nlea    -0x30(%rax,%rcx,1),%eax\ncmp    $0x8,%edx\nje     16ee <func0+0xee>\nmovsbl 0x24(%rsp),%ecx\nlea    -0x30(%rax,%rcx,1),%eax\ncmp    $0x9,%edx\nje     16ee <func0+0xee>\nmovsbl 0x25(%rsp),%ecx\nlea    -0x30(%rax,%rcx,1),%eax\ncmp    $0xb,%edx\njne    16ee <func0+0xee>\nmovsbl 0x26(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\nmovsbl 0x1c(%rsp),%edx\nsub    $0x30,%edx\nlea    (%rax,%rdx,1),%ecx\nsub    %edx,%eax\nmov    (%r15),%edx\ntest   %edx,%edx\ncmovg  %ecx,%eax\nadd    $0x4,%r15\nadd    $0x4,%rbp\nmov    %eax,-0x4(%rbp)\ncmp    %r15,0x8(%rsp)\nje     1758 <func0+0x158>\nmov    (%r15),%eax\nmov    $0xc,%edx\nmov    %r14,%rcx\nmov    $0x1,%esi\nmov    %r13,%rdi\nmov    %eax,%r8d\nneg    %r8d\ncmovs  %eax,%r8d\nxor    %eax,%eax\ncall   1110 <__sprintf_chk@plt>\nmov    %r13,%rdi\ncall   10d0 <strlen@plt>\nmov    %rax,%rdx\ncmp    $0x1,%rax\nja     1668 <func0+0x68>\nxor    %eax,%eax\njmp    16ee <func0+0xee>\nnopw   0x0(%rax,%rax,1)\ncmp    $0x1,%ebx\nje     17b8 <func0+0x1b8>\nmov    (%rsp),%rdi\nlea    -0x2(%rbx),%eax\nxor    %r8d,%r8d\nlea    0x4(%rdi,%rax,4),%rdi\nnopl   0x0(%rax)\nmov    (%rsp),%rdx\nmov    %r12,%rcx\nnopw   0x0(%rax,%rax,1)\n00 00\nmovq   (%rdx),%xmm0\npshufd $0xe5,%xmm0,%xmm2\nmovd   %xmm0,%eax\nmovd   %xmm2,%esi\npshufd $0xe1,%xmm0,%xmm1\ncmp    %eax,%esi\njge    17a2 <func0+0x1a2>\nmovq   %xmm1,(%rdx)\nrolq   $0x20,(%rcx)\nadd    $0x4,%rdx\nadd    $0x4,%rcx\ncmp    %rdx,%rdi\njne    1780 <func0+0x180>\nadd    $0x1,%r8d\ncmp    %r8d,%ebx\njne    1770 <func0+0x170>\nmov    (%rsp),%rdi\ncall   10b0 <free@plt>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    17e3 <func0+0x1e3>\nadd    $0x38,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10e0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n00\n"
    },
    {
        "task_id": 146,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1261 <func0+0xf8>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0xa,%eax\njle    125d <func0+0xf4>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nsub    %eax,%edx\nmov    %edx,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\njmp    1227 <func0+0xbe>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x9,-0xc(%rbp)\njg     1207 <func0+0x9e>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    125d <func0+0xf4>\nmov    -0x8(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    125d <func0+0xf4>\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     118b <func0+0x22>\nmov    -0x14(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 146,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    11fe <func0+0x95>\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r9\nmov    $0x0,%r10d\njmp    1191 <func0+0x28>\nadd    $0x4,%r8\ncmp    %r9,%r8\nje     1204 <func0+0x9b>\nmov    (%r8),%edi\ncmp    $0xa,%edi\njle    1188 <func0+0x1f>\nmov    %edi,%edx\nmov    %edx,%ecx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\ncmp    $0x63,%ecx\njg     119b <func0+0x32>\nshr    $0x1f,%eax\nadd    %eax,%edx\nand    $0x1,%edx\nsub    %eax,%edx\ncmp    $0x1,%edx\njne    1188 <func0+0x1f>\nmovslq %edi,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edi,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,4),%eax\nadd    %eax,%eax\nsub    %eax,%edi\nmov    %edi,%eax\nshr    $0x1f,%eax\nadd    %eax,%edi\nand    $0x1,%edi\nsub    %eax,%edi\ncmp    $0x1,%edi\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r10d\njmp    1188 <func0+0x1f>\nmov    $0x0,%r10d\nmov    %r10d,%eax\nret\n"
    },
    {
        "task_id": 146,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1435 <func0+0x65>\nlea    -0x1(%rsi),%eax\nxor    %r9d,%r9d\nmov    $0xcccccccd,%esi\nlea    0x4(%rdi,%rax,4),%r8\njmp    13f9 <func0+0x29>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rdi\ncmp    %r8,%rdi\nje     1431 <func0+0x61>\nmov    (%rdi),%ecx\ncmp    $0xa,%ecx\njle    13f0 <func0+0x20>\nmov    %ecx,%eax\nnopw   0x0(%rax,%rax,1)\nmov    %eax,%eax\nmov    %rax,%rdx\nimul   %rsi,%rax\nshr    $0x23,%rax\ncmp    $0x63,%edx\njg     1408 <func0+0x38>\ntest   $0x1,%al\nje     13f0 <func0+0x20>\nand    $0x1,%ecx\ncmp    $0x1,%ecx\nsbb    $0xffffffff,%r9d\nadd    $0x4,%rdi\ncmp    %r8,%rdi\njne    13f9 <func0+0x29>\nmov    %r9d,%eax\nret\nxor    %r9d,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 146,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    13e5 <func0+0x65>\nlea    -0x1(%rsi),%eax\nxor    %r9d,%r9d\nmov    $0xcccccccd,%esi\nlea    0x4(%rdi,%rax,4),%r8\njmp    13a9 <func0+0x29>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rdi\ncmp    %r8,%rdi\nje     13e1 <func0+0x61>\nmov    (%rdi),%ecx\ncmp    $0xa,%ecx\njle    13a0 <func0+0x20>\nmov    %ecx,%eax\nnopw   0x0(%rax,%rax,1)\nmov    %eax,%eax\nmov    %rax,%rdx\nimul   %rsi,%rax\nshr    $0x23,%rax\ncmp    $0x63,%edx\njg     13b8 <func0+0x38>\ntest   $0x1,%al\nje     13a0 <func0+0x20>\nand    $0x1,%ecx\ncmp    $0x1,%ecx\nsbb    $0xffffffff,%r9d\nadd    $0x4,%rdi\ncmp    %r8,%rdi\njne    13a9 <func0+0x29>\nmov    %r9d,%eax\nret\nxor    %r9d,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 147,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %edi,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x28(%rbp)\nmov    -0x64(%rbp),%eax\nadd    $0x1,%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmov    -0x64(%rbp),%eax\nadd    $0x1,%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x54(%rbp)\njmp    1259 <func0+0xb0>\nmov    -0x54(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    $0x4,%esi\nmov    $0x3,%edi\ncall   10a0 <calloc@plt>\nmov    %rax,(%rbx)\nmov    -0x54(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    $0x4,%esi\nmov    $0x3,%edi\ncall   10a0 <calloc@plt>\nmov    %rax,(%rbx)\naddl   $0x1,-0x54(%rbp)\nmov    -0x54(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    1207 <func0+0x5e>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nlea    0x8(%rax),%rdx\nmovl   $0x0,(%rdx)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nadd    $0x4,%rax\nmov    (%rdx),%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rdx\nmov    (%rdx),%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nlea    0x8(%rax),%rdx\nmovl   $0x0,(%rdx)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nadd    $0x4,%rax\nmov    (%rdx),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rdx\nmov    (%rdx),%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmovl   $0x1,-0x50(%rbp)\njmp    13db <func0+0x232>\nmov    -0x50(%rbp),%eax\nimul   %eax,%eax\nsub    -0x50(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    -0x50(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x28(%rbp),%rax\nlea    (%rcx,%rax,1),%rsi\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,(%rsi)\nmovl   $0x0,-0x4c(%rbp)\njmp    135e <func0+0x1b5>\nmov    -0x50(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x4c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    -0x50(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%rcx\nmov    -0x4c(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x4c(%rbp)\ncmpl   $0x2,-0x4c(%rbp)\njle    130e <func0+0x165>\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x50(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\n00\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nmov    -0x50(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rsi\nmov    -0x28(%rbp),%rax\nadd    %rsi,%rax\nmov    (%rax),%eax\ncltq\nshl    $0x2,%rax\nadd    %rcx,%rax\nadd    $0x1,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x50(%rbp)\nmov    -0x50(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    12c3 <func0+0x11a>\nmovl   $0x1,-0x48(%rbp)\njmp    15e4 <func0+0x43b>\nmovl   $0x1,-0x44(%rbp)\njmp    1530 <func0+0x387>\nmovl   $0x0,-0x40(%rbp)\njmp    1458 <func0+0x2af>\nmov    -0x44(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    -0x44(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%rcx\nmov    -0x40(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x40(%rbp)\ncmpl   $0x2,-0x40(%rbp)\njle    1408 <func0+0x25f>\ncmpl   $0x0,-0x44(%rbp)\njle    152c <func0+0x383>\nmovl   $0x0,-0x3c(%rbp)\njmp    1522 <func0+0x379>\nmov    -0x44(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rsi\nmov    -0x44(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x3c(%rbp),%eax\nadd    %eax,%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmovslq %eax,%rdx\nshl    $0x2,%rdx\nadd    %rsi,%rdx\nmov    (%rdx),%esi\nmov    -0x44(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x3,%rdx\nlea    -0x8(%rdx),%rcx\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%rcx\nmov    -0x3c(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%ecx\nmov    -0x44(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rdi\n00\nmov    -0x18(%rbp),%rdx\nadd    %rdi,%rdx\nmov    (%rdx),%rdx\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    (%rsi,%rcx,1),%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x2,-0x3c(%rbp)\njle    1474 <func0+0x2cb>\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    13ff <func0+0x256>\nmovl   $0x0,-0x38(%rbp)\njmp    15d4 <func0+0x42b>\nmovl   $0x0,-0x34(%rbp)\njmp    15ca <func0+0x421>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x34(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    -0x38(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%rcx\nmov    -0x34(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x34(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0x2,-0x34(%rbp)\njle    1551 <func0+0x3a8>\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    1548 <func0+0x39f>\naddl   $0x1,-0x48(%rbp)\ncmpl   $0x2,-0x48(%rbp)\njle    13f3 <func0+0x24a>\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    (%rax),%eax\nmov    %eax,-0x2c(%rbp)\nmovl   $0x0,-0x30(%rbp)\njmp    1655 <func0+0x4ac>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   1080 <free@plt>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   1080 <free@plt>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    1613 <func0+0x46a>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <free@plt>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <free@plt>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1080 <free@plt>\nmov    -0x2c(%rbp),%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 147,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %edi,%r13d\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%r14\nlea    0x1(%r13),%eax\ncltq\nlea    0x0(,%rax,8),%rbx\n00\nmov    %rbx,0x8(%rsp)\nmov    %rbx,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%rbp\nmov    %rbx,%rdi\ncall   10b0 <malloc@plt>\nmov    %rax,%rbx\ntest   %r13d,%r13d\njs     1239 <func0+0x90>\nlea    0x1(%r13),%r15d\nshl    $0x3,%r15\nmov    $0x0,%r12d\nmov    $0x4,%esi\nmov    $0x3,%edi\ncall   10a0 <calloc@plt>\nmov    %rax,0x0(%rbp,%r12,1)\nmov    $0x4,%esi\nmov    $0x3,%edi\ncall   10a0 <calloc@plt>\nmov    %rax,(%rbx,%r12,1)\nadd    $0x8,%r12\ncmp    %r12,%r15\njne    1209 <func0+0x60>\nmov    0x0(%rbp),%rax\nmovl   $0x0,0x8(%rax)\nmovl   $0x0,0x4(%rax)\nmovl   $0x0,(%rax)\nmov    (%rbx),%rax\nmovl   $0x0,0x8(%rax)\nmovl   $0x0,0x4(%rax)\nmovl   $0x0,(%rax)\ntest   %r13d,%r13d\njle    12ce <func0+0x125>\nlea    0x1(%r13),%esi\nmov    $0x1,%ecx\nmov    %ecx,%edx\nimul   %ecx,%edx\nsub    %ecx,%edx\nadd    $0x1,%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%edi\nsar    $0x1f,%edi\nsub    %edi,%eax\nlea    (%rax,%rax,2),%edi\nmov    %edx,%eax\nsub    %edi,%eax\nmov    %eax,-0x4(%r14,%rcx,4)\nmov    -0x8(%rbp,%rcx,8),%rdi\nmov    0x0(%rbp,%rcx,8),%rdx\nmov    (%rdi),%r8d\nmov    %r8d,(%rdx)\nmov    0x4(%rdi),%r8d\nmov    %r8d,0x4(%rdx)\nmov    0x8(%rdi),%edi\nmov    %edi,0x8(%rdx)\ncltq\naddl   $0x1,(%rdx,%rax,4)\nadd    $0x1,%rcx\ncmp    %rcx,%rsi\njne    1276 <func0+0xcd>\nmov    $0x2,%r10d\nlea    0x1(%r13),%r9d\njmp    138e <func0+0x1e5>\nadd    $0x1,%rcx\ncmp    %rcx,%r9\nje     134d <func0+0x1a4>\nmov    -0x8(%rbx,%rcx,8),%rax\nmov    (%rbx,%rcx,8),%rsi\nmov    (%rax),%edx\nmov    %edx,(%rsi)\nmov    0x4(%rax),%edx\nmov    %edx,0x4(%rsi)\nmov    0x8(%rax),%eax\nmov    %eax,0x8(%rsi)\ntest   %ecx,%ecx\njle    12dd <func0+0x134>\nmov    -0x4(%r14,%rcx,4),%r8d\nmov    -0x8(%rbp,%rcx,8),%rdi\nmov    $0x0,%edx\nlea    (%r8,%rdx,1),%eax\nmovslq %eax,%r11\nimul   $0x55555556,%r11,%r11\nshr    $0x20,%r11\nmov    %eax,%r12d\nsar    $0x1f,%r12d\nsub    %r12d,%r11d\nlea    (%r11,%r11,2),%r11d\nsub    %r11d,%eax\ncltq\nmov    (%rdi,%rdx,4),%r11d\nadd    %r11d,(%rsi,%rax,4)\nadd    $0x1,%rdx\ncmp    $0x3,%rdx\njne    1312 <func0+0x169>\njmp    12dd <func0+0x134>\njne    1388 <func0+0x1df>\nmov    $0x0,%edx\nmov    (%rbx,%rdx,8),%rax\nmov    0x0(%rbp,%rdx,8),%rcx\nmov    (%rax),%esi\nmov    %esi,(%rcx)\nmovl   $0x0,(%rax)\nmov    0x4(%rax),%esi\nmov    %esi,0x4(%rcx)\nmovl   $0x0,0x4(%rax)\nmov    0x8(%rax),%esi\nmov    %esi,0x8(%rcx)\nmovl   $0x0,0x8(%rax)\nadd    $0x1,%rdx\ncmp    %edx,%r13d\njge    1352 <func0+0x1a9>\nsub    $0x1,%r10d\nje     139d <func0+0x1f4>\ntest   %r13d,%r13d\njle    134b <func0+0x1a2>\nmov    $0x1,%ecx\njmp    12e6 <func0+0x13d>\nmov    0x8(%rsp),%rax\nmov    -0x8(%rbp,%rax,1),%rax\nmov    (%rax),%r15d\ntest   %r13d,%r13d\njs     13d9 <func0+0x230>\nlea    0x1(%r13),%r13d\nshl    $0x3,%r13\nmov    $0x0,%r12d\nmov    0x0(%rbp,%r12,1),%rdi\ncall   1080 <free@plt>\nmov    (%rbx,%r12,1),%rdi\ncall   1080 <free@plt>\nadd    $0x8,%r12\ncmp    %r13,%r12\njne    13bd <func0+0x214>\nmov    %rbp,%rdi\ncall   1080 <free@plt>\nmov    %rbx,%rdi\ncall   1080 <free@plt>\nmov    %r14,%rdi\ncall   1080 <free@plt>\nmov    %r15d,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 147,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmovslq %edi,%rbx\nlea    0x0(,%rbx,4),%rdi\n00\nmov    %rbx,%r14\nsub    $0x18,%rsp\ncall   10b0 <malloc@plt>\nmov    %rax,%rbp\nlea    0x1(%rbx),%eax\ncltq\nlea    0x0(,%rax,8),%r15\n00\nmov    %r15,%rdi\nmov    %r15,0x8(%rsp)\ncall   10b0 <malloc@plt>\nmov    %r15,%rdi\nmov    %rax,%r12\ncall   10b0 <malloc@plt>\nmov    %rax,%r13\ntest   %ebx,%ebx\njs     151e <func0+0x29e>\nlea    0x8(,%rbx,8),%rax\n00\nxor    %r15d,%r15d\nmov    %rbx,(%rsp)\nmov    %r15,%rbx\nmov    %rax,%r15\nnopl   (%rax)\nmov    $0x4,%esi\nmov    $0x3,%edi\ncall   10a0 <calloc@plt>\nmov    $0x4,%esi\nmov    $0x3,%edi\nmov    %rax,(%r12,%rbx,1)\ncall   10a0 <calloc@plt>\nmov    %rax,0x0(%r13,%rbx,1)\nadd    $0x8,%rbx\ncmp    %rbx,%r15\njne    12f0 <func0+0x70>\nmov    (%r12),%r9\nmov    0x0(%r13),%r10\nmov    (%rsp),%rbx\nmovq   $0x0,(%r9)\nmovl   $0x0,0x8(%r9)\n00\nmovq   $0x0,(%r10)\nmovl   $0x0,0x8(%r10)\n00\ntest   %r14d,%r14d\njle    13ab <func0+0x12b>\nmov    %r9,%rdi\nmov    $0x1,%ecx\nmov    $0xaaaaaaab,%esi\njmp    1367 <func0+0xe7>\nxchg   %ax,%ax\nadd    $0x1,%rcx\nmov    %rdx,%rdi\nlea    -0x1(%rcx),%edx\nimul   %ecx,%edx\nlea    0x1(%rdx),%eax\nmov    %rax,%rdx\nimul   %rsi,%rax\nshr    $0x21,%rax\nlea    (%rax,%rax,2),%r8d\nmov    %edx,%eax\nmov    (%r12,%rcx,8),%rdx\nsub    %r8d,%eax\nmov    (%rdi),%r8d\nmov    %eax,-0x4(%rbp,%rcx,4)\ncltq\nmov    %r8d,(%rdx)\nmov    0x4(%rdi),%r8d\nmov    %r8d,0x4(%rdx)\nmov    0x8(%rdi),%edi\nmov    %edi,0x8(%rdx)\naddl   $0x1,(%rdx,%rax,4)\ncmp    %rbx,%rcx\njne    1360 <func0+0xe0>\nmovl   $0x2,(%rsp)\ntest   %r14d,%r14d\njle    148a <func0+0x20a>\nmov    %r9,%r15\nmov    %r10,%rax\nmov    $0x1,%r11d\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    (%rax),%edx\nmov    0x0(%r13,%r11,8),%rcx\nmov    -0x4(%rbp,%r11,4),%esi\nmov    %edx,(%rcx)\nmov    0x4(%rax),%edx\nmov    %edx,0x4(%rcx)\nmov    0x8(%rax),%eax\nxor    %edx,%edx\nmov    %eax,0x8(%rcx)\nlea    (%rsi,%rdx,1),%eax\nmovslq %eax,%rdi\nmov    %eax,%r8d\nimul   $0x55555556,%rdi,%rdi\nsar    $0x1f,%r8d\nshr    $0x20,%rdi\nsub    %r8d,%edi\nlea    (%rdi,%rdi,2),%edi\nsub    %edi,%eax\nmov    (%r15,%rdx,4),%edi\nadd    $0x1,%rdx\ncltq\nadd    %edi,(%rcx,%rax,4)\ncmp    $0x3,%rdx\njne    13ec <func0+0x16c>\ncmp    %rbx,%r11\nje     1438 <func0+0x1b8>\nmov    (%r12,%r11,8),%r15\nmov    %rcx,%rax\nadd    $0x1,%r11\njmp    13d0 <func0+0x150>\nnopl   0x0(%rax)\nmov    %r9,%rcx\nmov    %r10,%rax\nxor    %edx,%edx\njmp    1451 <func0+0x1d1>\nnopw   0x0(%rax,%rax,1)\nmov    0x0(%r13,%rdx,8),%rax\nmov    (%r12,%rdx,8),%rcx\nmov    (%rax),%rsi\nadd    $0x1,%rdx\nmovq   $0x0,(%rax)\nmov    %rsi,(%rcx)\nmov    0x8(%rax),%esi\nmovl   $0x0,0x8(%rax)\nmov    %esi,0x8(%rcx)\ncmp    %edx,%r14d\njge    1448 <func0+0x1c8>\ncmpl   $0x1,(%rsp)\nje     14b0 <func0+0x230>\nmovl   $0x1,(%rsp)\ntest   %r14d,%r14d\njg     13bb <func0+0x13b>\njne    1474 <func0+0x1f4>\nmov    (%r10),%rax\nmov    $0x3,%ecx\nmov    %r10,%rdi\nmov    %rax,(%r9)\nmov    0x8(%r10),%eax\nmov    %eax,0x8(%r9)\nmov    %r14d,%eax\nrep stos %eax,%es:(%rdi)\njmp    1474 <func0+0x1f4>\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rax\nmov    -0x8(%r12,%rax,1),%rax\nmov    (%rax),%r15d\ntest   %r14d,%r14d\njs     14f4 <func0+0x274>\nlea    0x8(,%rbx,8),%rbx\n00\nxor    %r14d,%r14d\nmov    %r9,%rdi\njmp    14dc <func0+0x25c>\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%r14,1),%rdi\ncall   1080 <free@plt>\nmov    0x0(%r13,%r14,1),%rdi\nadd    $0x8,%r14\ncall   1080 <free@plt>\ncmp    %rbx,%r14\njne    14d8 <func0+0x258>\nmov    %r12,%rdi\ncall   1080 <free@plt>\nmov    %r13,%rdi\ncall   1080 <free@plt>\nmov    %rbp,%rdi\ncall   1080 <free@plt>\nadd    $0x18,%rsp\nmov    %r15d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    (%r12),%r9\nmov    (%rax),%r10\nmovq   $0x0,(%r9)\nmovl   $0x0,0x8(%r9)\n00\nmovq   $0x0,(%r10)\nmovl   $0x0,0x8(%r10)\n00\njmp    13ab <func0+0x12b>\n"
    },
    {
        "task_id": 147,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmovslq %edi,%r14\npush   %r13\nlea    0x0(,%r14,4),%rdi\n00\npush   %r12\npush   %rbp\npush   %rbx\nmov    %r14,%rbx\nsub    $0x18,%rsp\ncall   10b0 <malloc@plt>\nmov    %rax,%r13\nlea    0x1(%r14),%eax\ncltq\nlea    0x0(,%rax,8),%r15\n00\nmov    %r15,%rdi\nmov    %r15,0x8(%rsp)\ncall   10b0 <malloc@plt>\nmov    %r15,%rdi\nxor    %r15d,%r15d\nmov    %rax,%rbp\ncall   10b0 <malloc@plt>\nmov    %rax,%r12\nlea    0x8(,%r14,8),%rax\n00\nmov    %rax,(%rsp)\ntest   %r14d,%r14d\njs     1546 <func0+0x2c6>\nnopl   0x0(%rax)\nmov    $0x4,%esi\nmov    $0x3,%edi\ncall   10a0 <calloc@plt>\nmov    $0x4,%esi\nmov    $0x3,%edi\nmov    %rax,0x0(%rbp,%r15,1)\ncall   10a0 <calloc@plt>\nmov    %rax,(%r12,%r15,1)\nadd    $0x8,%r15\ncmp    (%rsp),%r15\njne    12f0 <func0+0x70>\nmov    0x0(%rbp),%rax\nmov    (%r12),%r9\nmovl   $0x0,0x8(%rax)\nmovq   $0x0,(%rax)\nmovl   $0x0,0x8(%r9)\n00\nmovq   $0x0,(%r9)\ntest   %ebx,%ebx\njle    13aa <func0+0x12a>\nxor    %edx,%edx\nxor    %edi,%edi\nmov    $0xaaaaaaab,%esi\njmp    135f <func0+0xdf>\nnopl   (%rax)\nmov    0x0(%rbp,%rdx,8),%rax\nmov    (%rax),%edi\nlea    0x1(%rdx),%ecx\nimul   %edx,%ecx\nlea    0x1(%rcx),%eax\nmov    %rax,%rcx\nimul   %rsi,%rax\nshr    $0x21,%rax\nlea    (%rax,%rax,2),%r10d\nmov    %ecx,%eax\nmov    0x8(%rbp,%rdx,8),%rcx\nsub    %r10d,%eax\nmov    0x0(%rbp,%rdx,8),%r10\nmov    %edi,(%rcx)\nmov    0x4(%r10),%edi\nmov    %eax,0x0(%r13,%rdx,4)\ncltq\nadd    $0x1,%rdx\nmov    %edi,0x4(%rcx)\nmov    0x8(%r10),%edi\nmov    %edi,0x8(%rcx)\naddl   $0x1,(%rcx,%rax,4)\ncmp    %r14,%rdx\njne    1358 <func0+0xd8>\nmov    $0x2,%r10d\nmov    %r9,%rdx\nxor    %esi,%esi\ntest   %ebx,%ebx\njle    14b4 <func0+0x234>\nnopl   (%rax)\nmov    %rdx,%rax\nmov    0x8(%r12,%rsi,8),%rdx\nmov    (%rax),%ecx\nmov    %ecx,(%rdx)\nmov    0x4(%rax),%ecx\nmov    %ecx,0x4(%rdx)\nmovslq 0x0(%r13,%rsi,4),%rcx\nmov    0x8(%rax),%eax\nmov    %eax,0x8(%rdx)\nmov    %rcx,%rax\nimul   $0x55555556,%rcx,%rcx\nmov    %eax,%edi\nsar    $0x1f,%edi\nshr    $0x20,%rcx\nsub    %edi,%ecx\nlea    (%rcx,%rcx,2),%edi\nmov    %eax,%ecx\nsub    %edi,%ecx\nmov    0x0(%rbp,%rsi,8),%rdi\nadd    $0x1,%rsi\nmovslq %ecx,%rcx\nmov    (%rdi),%r11d\nadd    %r11d,(%rdx,%rcx,4)\nlea    0x1(%rax),%ecx\nadd    $0x2,%eax\nmovslq %ecx,%r11\nmov    %ecx,%r15d\nimul   $0x55555556,%r11,%r11\nsar    $0x1f,%r15d\nshr    $0x20,%r11\nsub    %r15d,%r11d\nlea    (%r11,%r11,2),%r11d\nsub    %r11d,%ecx\nmov    0x4(%rdi),%r11d\nmovslq %ecx,%rcx\nadd    %r11d,(%rdx,%rcx,4)\nmovslq %eax,%rcx\nmov    %eax,%r11d\nimul   $0x55555556,%rcx,%rcx\nsar    $0x1f,%r11d\nshr    $0x20,%rcx\nsub    %r11d,%ecx\nlea    (%rcx,%rcx,2),%ecx\nsub    %ecx,%eax\nmov    0x8(%rdi),%ecx\ncltq\nadd    %ecx,(%rdx,%rax,4)\ncmp    %r14,%rsi\njne    13c0 <func0+0x140>\nxor    %eax,%eax\nnopl   0x0(%rax)\nmov    (%r12,%rax,8),%rdx\nmov    0x0(%rbp,%rax,8),%rcx\nadd    $0x1,%rax\nmov    (%rdx),%rsi\nmovq   $0x0,(%rdx)\nmov    %rsi,(%rcx)\nmov    0x8(%rdx),%esi\nmovl   $0x0,0x8(%rdx)\nmov    %esi,0x8(%rcx)\ncmp    %eax,%ebx\njge    1470 <func0+0x1f0>\ncmp    $0x1,%r10d\nje     14e0 <func0+0x260>\nmov    $0x1,%r10d\nmov    %r9,%rdx\nxor    %esi,%esi\ntest   %ebx,%ebx\njg     13c0 <func0+0x140>\njne    149b <func0+0x21b>\nmov    (%r12),%rax\nmov    0x0(%rbp),%rdx\nmov    (%rax),%rcx\nmovq   $0x0,(%rax)\nmov    %rcx,(%rdx)\nmov    0x8(%rax),%ecx\nmovl   $0x0,0x8(%rax)\nmov    %ecx,0x8(%rdx)\njmp    149b <func0+0x21b>\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rax\nlea    0x8(,%r14,8),%r15\n00\nxor    %r14d,%r14d\nmov    -0x8(%rbp,%rax,1),%rax\nmov    (%rax),%eax\nmov    %eax,(%rsp)\ntest   %ebx,%ebx\njs     151c <func0+0x29c>\nxchg   %ax,%ax\nmov    0x0(%rbp,%r14,1),%rdi\ncall   1080 <free@plt>\nmov    (%r12,%r14,1),%rdi\nadd    $0x8,%r14\ncall   1080 <free@plt>\ncmp    %r15,%r14\njne    1500 <func0+0x280>\nmov    %rbp,%rdi\ncall   1080 <free@plt>\nmov    %r12,%rdi\ncall   1080 <free@plt>\nmov    %r13,%rdi\ncall   1080 <free@plt>\nmov    (%rsp),%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x0(%rbp),%rax\nmov    (%r12),%r9\nmovl   $0x0,0x8(%rax)\nmovq   $0x0,(%rax)\nmovl   $0x0,0x8(%r9)\n00\nmovq   $0x0,(%r9)\njmp    13aa <func0+0x12a>\n"
    },
    {
        "task_id": 148,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x90,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0xe0b(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0xe08(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0xe03(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0xdfe(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0xdf8(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0xdf5(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0xdf1(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0xded(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0xffffffff,-0x68(%rbp)\nmovl   $0xffffffff,-0x64(%rbp)\nmovl   $0x0,-0x60(%rbp)\njmp    12af <func0+0xe6>\nmov    -0x60(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,8),%rax\nmov    -0x78(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10c0 <strcmp@plt>\ntest   %eax,%eax\njne    1288 <func0+0xbf>\nmov    -0x60(%rbp),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x60(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,8),%rax\nmov    -0x80(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10c0 <strcmp@plt>\ntest   %eax,%eax\njne    12ab <func0+0xe2>\nmov    -0x60(%rbp),%eax\nmov    %eax,-0x64(%rbp)\naddl   $0x1,-0x60(%rbp)\ncmpl   $0x7,-0x60(%rbp)\njle    1265 <func0+0x9c>\ncmpl   $0xffffffff,-0x68(%rbp)\nje     12c9 <func0+0x100>\ncmpl   $0xffffffff,-0x64(%rbp)\nje     12c9 <func0+0x100>\nmov    -0x68(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njne    12e0 <func0+0x117>\nmov    -0x88(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    $0x0,%eax\njmp    1387 <func0+0x1be>\nmov    -0x68(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    12fa <func0+0x131>\nmov    -0x68(%rbp),%eax\nmov    %eax,-0x5c(%rbp)\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x5c(%rbp),%eax\nmov    %eax,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\nsub    -0x68(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x88(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x88(%rbp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njg     132d <func0+0x164>\nmov    -0x88(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    $0x0,%eax\njmp    1387 <func0+0x1be>\nmov    -0x88(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   10d0 <malloc@plt>\nmov    %rax,-0x58(%rbp)\nmov    -0x68(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x60(%rbp)\njmp    137b <func0+0x1b2>\nmov    -0x60(%rbp),%eax\nsub    -0x68(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x60(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,8),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x60(%rbp)\nmov    -0x60(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njl     1353 <func0+0x18a>\nmov    -0x58(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     139b <func0+0x1d2>\ncall   10a0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 148,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,%r15\nmov    %rsi,(%rsp)\nmov    %rdx,0x8(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nlea    0xe06(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0xe02(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0xdfc(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0xdf6(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0xdef(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0xdeb(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0xde6(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0xde1(%rip),%rax\nmov    %rax,0x48(%rsp)\nmov    $0x0,%ebx\nmov    $0xffffffff,%ebp\nmov    $0xffffffff,%r13d\nmov    0x10(%rsp,%rbx,8),%r12\nmov    %r15,%rsi\nmov    %r12,%rdi\ncall   10c0 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%r13d\nmov    (%rsp),%rsi\nmov    %r12,%rdi\ncall   10c0 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nadd    $0x1,%rbx\ncmp    $0x8,%rbx\njne    1267 <func0+0x9e>\ncmp    $0xffffffff,%ebp\nsete   %al\ncmp    %ebp,%r13d\nsete   %dl\nor     %dl,%al\njne    1330 <func0+0x167>\ncmp    $0xffffffff,%r13d\nje     1330 <func0+0x167>\ncmp    %ebp,%r13d\njle    12bf <func0+0xf6>\nmov    %r13d,%eax\nmov    %ebp,%r13d\nmov    %eax,%ebp\nmov    %ebp,%eax\nsub    %r13d,%eax\nsub    $0x1,%eax\nmov    0x8(%rsp),%rcx\nmov    %eax,(%rcx)\ntest   %eax,%eax\njle    1342 <func0+0x179>\ncltq\nlea    0x0(,%rax,8),%rdi\n00\ncall   10d0 <malloc@plt>\nlea    0x1(%r13),%edx\ncmp    %edx,%ebp\njle    1311 <func0+0x148>\nsub    $0x2,%ebp\nsub    %r13d,%ebp\nmovslq %r13d,%r13\nlea    0x10(%rsp,%r13,8),%rsi\nmov    $0x0,%edx\nmov    0x8(%rsi,%rdx,8),%rcx\nmov    %rcx,(%rax,%rdx,8)\nmov    %rdx,%rcx\nadd    $0x1,%rdx\ncmp    %rbp,%rcx\njne    12fc <func0+0x133>\nmov    0x58(%rsp),%rdx\nsub    %fs:0x28,%rdx\n00 00\njne    134f <func0+0x186>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x8(%rsp),%rax\nmovl   $0x0,(%rax)\nmov    $0x0,%eax\njmp    1311 <func0+0x148>\nmovl   $0x0,(%rcx)\nmov    $0x0,%eax\njmp    1311 <func0+0x148>\ncall   10a0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 148,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    $0xffffffff,%r15d\npush   %r14\nmov    %rdi,%r14\nlea    0xa4c(%rip),%rdi\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\nmov    $0xffffffff,%ebp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x68,%rsp\nmov    %rdx,0x8(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nlea    0xa24(%rip),%rax\nmov    %rdi,0x10(%rsp)\nmov    %rax,0x18(%rsp)\nlea    0xa19(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0xa13(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0xa0c(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0xa08(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0xa03(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x9fe(%rip),%rax\nmov    %rax,0x48(%rsp)\njmp    1645 <func0+0xa5>\nnopl   0x0(%rax)\nmov    0x10(%rsp,%rbx,8),%rdi\nmov    %r14,%rsi\nmov    %rdi,(%rsp)\ncall   10d0 <strcmp@plt>\nmov    (%rsp),%rdi\nmov    %r13,%rsi\ntest   %eax,%eax\ncmove  %ebx,%ebp\ncall   10d0 <strcmp@plt>\ntest   %eax,%eax\ncmove  %ebx,%r15d\nadd    $0x1,%rbx\ncmp    $0x8,%rbx\njne    1640 <func0+0xa0>\ncmp    $0xffffffff,%r15d\nsete   %al\ncmp    %r15d,%ebp\nsete   %cl\nor     %cl,%al\njne    1718 <func0+0x178>\ncmp    $0xffffffff,%ebp\nje     1718 <func0+0x178>\ncmp    %r15d,%ebp\njg     1708 <func0+0x168>\nmov    %r15d,%eax\nmov    0x8(%rsp),%rcx\nsub    %ebp,%eax\nsub    $0x1,%eax\nmov    %eax,(%rcx)\ntest   %eax,%eax\njle    1718 <func0+0x178>\ncltq\nlea    0x0(,%rax,8),%rdi\n00\ncall   10f0 <malloc@plt>\nmov    %rax,%r8\nlea    0x1(%rbp),%eax\ncmp    %eax,%r15d\njle    16e2 <func0+0x142>\nlea    -0x2(%r15),%edx\ncltq\nmov    %r8,%rdi\nsub    %ebp,%edx\nlea    0x10(%rsp,%rax,8),%rsi\nlea    0x8(,%rdx,8),%rdx\n00\ncall   10e0 <memcpy@plt>\nmov    %rax,%r8\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    1728 <func0+0x188>\nadd    $0x68,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmov    %ebp,%eax\nmov    %r15d,%ebp\nmov    %eax,%r15d\njmp    1695 <func0+0xf5>\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rax\nxor    %r8d,%r8d\nmovl   $0x0,(%rax)\njmp    16e2 <func0+0x142>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   (%rax)\n"
    },
    {
        "task_id": 148,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rdi,%r15\nlea    0xa14(%rip),%rdi\nlea    0xa35(%rip),%r9\npush   %r14\nmovq   %rdi,%xmm0\nlea    0xa0d(%rip),%r14\npush   %r13\nlea    0xa0f(%rip),%r13\npush   %r12\nmov    %rsi,%r12\nmov    %r15,%rsi\npush   %rbp\nlea    0x9ee(%rip),%rbp\npush   %rbx\nmovq   %rbp,%xmm1\nxor    %ebx,%ebx\npunpcklqdq %xmm1,%xmm0\nsub    $0x68,%rsp\nmov    %rdx,(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nmovaps %xmm0,0x10(%rsp)\nmovq   %r14,%xmm0\nmovhps 0x272d(%rip),%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovq   %r13,%xmm0\nmovhps 0x2724(%rip),%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovq   %r9,%xmm0\nmovhps 0x271b(%rip),%xmm0\nmovaps %xmm0,0x40(%rsp)\ncall   10d0 <strcmp@plt>\nmov    %r12,%rsi\nlea    0x97b(%rip),%rdi\ntest   %eax,%eax\nsetne  %bl\ncall   10d0 <strcmp@plt>\nmov    %rbp,%rdi\nmov    %r15,%rsi\ntest   %eax,%eax\nsetne  %al\nneg    %ebx\nmovzbl %al,%eax\nmov    %eax,0xc(%rsp)\ncall   10d0 <strcmp@plt>\nmov    $0x1,%edx\nmov    %rbp,%rdi\nmov    %r12,%rsi\ntest   %eax,%eax\ncmove  %edx,%ebx\ncall   10d0 <strcmp@plt>\nmov    0xc(%rsp),%ebp\nmov    %r14,%rdi\nmov    %r15,%rsi\nmov    $0x1,%edx\nneg    %ebp\ntest   %eax,%eax\ncmove  %edx,%ebp\ncall   10d0 <strcmp@plt>\nmov    $0x2,%edx\nmov    %r14,%rdi\nmov    %r12,%rsi\ntest   %eax,%eax\nmov    $0x4,%r14d\ncmove  %edx,%ebx\ncall   10d0 <strcmp@plt>\nmov    $0x2,%edx\nmov    %r15,%rsi\ntest   %eax,%eax\nlea    0x910(%rip),%rdi\ncmove  %edx,%ebp\ncall   10d0 <strcmp@plt>\nmov    $0x3,%edx\nmov    %r12,%rsi\ntest   %eax,%eax\nlea    0x8f7(%rip),%rdi\ncmove  %edx,%ebx\ncall   10d0 <strcmp@plt>\nmov    $0x3,%edx\nmov    %r13,%rdi\nmov    %r15,%rsi\ntest   %eax,%eax\ncmove  %edx,%ebp\ncall   10d0 <strcmp@plt>\nmov    %r13,%rdi\nmov    %r12,%rsi\nmov    $0x6,%r13d\ntest   %eax,%eax\ncmove  %r14d,%ebx\ncall   10d0 <strcmp@plt>\nmov    %r15,%rsi\nlea    0x8c6(%rip),%rdi\ntest   %eax,%eax\ncmove  %r14d,%ebp\nmov    $0x5,%r14d\ncall   10d0 <strcmp@plt>\nmov    %r12,%rsi\nlea    0x8ab(%rip),%rdi\ntest   %eax,%eax\ncmove  %r14d,%ebx\ncall   10d0 <strcmp@plt>\nlea    0x8a0(%rip),%r9\nmov    %r15,%rsi\ntest   %eax,%eax\nmov    %r9,%rdi\ncmove  %r14d,%ebp\ncall   10d0 <strcmp@plt>\nlea    0x888(%rip),%r9\nmov    %r12,%rsi\ntest   %eax,%eax\nmov    %r9,%rdi\ncmove  %r13d,%ebx\ncall   10d0 <strcmp@plt>\nmov    %r15,%rsi\nlea    0x874(%rip),%rdi\ntest   %eax,%eax\ncmove  %r13d,%ebp\ncall   10d0 <strcmp@plt>\nmov    %r12,%rsi\nlea    0x85f(%rip),%rdi\ntest   %eax,%eax\nje     1800 <func0+0x220>\ncall   10d0 <strcmp@plt>\ntest   %eax,%eax\njne    18c0 <func0+0x2e0>\ncmp    $0x7,%ebx\nje     18b0 <func0+0x2d0>\ncmp    $0xffffffff,%ebx\nje     18b0 <func0+0x2d0>\nmov    $0x7,%r12d\njmp    183c <func0+0x25c>\nnop\ncall   10d0 <strcmp@plt>\nmov    $0x7,%r12d\ntest   %eax,%eax\nje     18b0 <func0+0x2d0>\ncmp    $0xffffffff,%ebp\nsete   %al\ncmp    %ebp,%r12d\nsete   %dl\nor     %dl,%al\njne    18b0 <func0+0x2d0>\ncmp    $0xffffffff,%r12d\nje     18b0 <func0+0x2d0>\ncmp    %ebp,%r12d\njle    18de <func0+0x2fe>\nmov    %ebp,%ebx\nmov    %r12d,%eax\nmov    (%rsp),%rcx\nsub    %ebx,%eax\nsub    $0x1,%eax\nmov    %eax,(%rcx)\ntest   %eax,%eax\njle    18b0 <func0+0x2d0>\ncltq\nlea    0x0(,%rax,8),%rdi\n00\ncall   10f0 <malloc@plt>\nmov    %rax,%r8\nlea    0x1(%rbx),%eax\ncmp    %eax,%r12d\njle    1889 <func0+0x2a9>\nsub    $0x2,%r12d\ncltq\nmov    %r8,%rdi\nsub    %ebx,%r12d\nlea    0x10(%rsp,%rax,8),%rsi\nlea    0x8(,%r12,8),%rdx\n00\ncall   10e0 <memcpy@plt>\nmov    %rax,%r8\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\n00 00\njne    18d9 <func0+0x2f9>\nadd    $0x68,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    (%rsp),%rax\nxor    %r8d,%r8d\nmovl   $0x0,(%rax)\njmp    1889 <func0+0x2a9>\nnop\ncmp    $0xffffffff,%ebp\nmov    %ebx,%r12d\nsete   %al\ncmp    %ebp,%r12d\nsete   %dl\nor     %dl,%al\nje     1827 <func0+0x247>\njmp    18b0 <func0+0x2d0>\ncall   10b0 <__stack_chk_fail@plt>\nmov    %r12d,%ebx\nmov    %ebp,%r12d\njmp    183c <func0+0x25c>\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 149,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x48(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x28(%rbp)\njmp    129f <func0+0x96>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   10d0 <strlen@plt>\nand    $0x1,%eax\ntest   %rax,%rax\njne    129b <func0+0x92>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%rax\nmov    %rax,(%rdx)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x48(%rbp),%rax\nmov    %edx,(%rax)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     1233 <func0+0x2a>\nmovl   $0x0,-0x28(%rbp)\njmp    13ec <func0+0x1e3>\nmovl   $0x0,-0x24(%rbp)\njmp    13d3 <func0+0x1ca>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   10d0 <strlen@plt>\nmov    %rax,-0x18(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   10d0 <strlen@plt>\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nja     1362 <func0+0x159>\nmov    -0x18(%rbp),%rax\ncmp    -0x10(%rbp),%rax\njne    13cf <func0+0x1c6>\nmov    -0x24(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\n00\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1100 <strcmp@plt>\ntest   %eax,%eax\njle    13cf <func0+0x1c6>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x24(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x38(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\nmov    -0x24(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x24(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nsub    -0x28(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x24(%rbp)\njl     12bf <func0+0xb6>\naddl   $0x1,-0x28(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x28(%rbp)\njl     12b3 <func0+0xaa>\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1110 <malloc@plt>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    1452 <func0+0x249>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x28(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x28(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x28(%rbp)\njl     141f <func0+0x216>\nmov    -0x20(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 149,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r12\nmov    %rdx,%r15\nmovl   $0x0,(%rdx)\ntest   %esi,%esi\njle    12eb <func0+0xe2>\nmov    %rdi,%rbx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r13\njmp    1245 <func0+0x3c>\nadd    $0x8,%rbx\ncmp    %r13,%rbx\nje     1261 <func0+0x58>\nmov    (%rbx),%rbp\nmov    %rbp,%rdi\ncall   10d0 <strlen@plt>\ntest   $0x1,%al\njne    123c <func0+0x33>\nmovslq (%r15),%rax\nmov    %rbp,(%r12,%rax,8)\naddl   $0x1,(%r15)\njmp    123c <func0+0x33>\nmov    (%r15),%eax\ncmp    $0x1,%eax\njle    12f0 <func0+0xe7>\nmovl   $0x0,0xc(%rsp)\n00\njmp    12d8 <func0+0xcf>\nmov    %r14,(%r12,%rbx,8)\nmov    %r13,0x8(%r12,%rbx,8)\nadd    $0x1,%rbx\nmov    0xc(%rsp),%eax\nnot    %eax\nadd    (%r15),%eax\ncmp    %ebx,%eax\njle    12c5 <func0+0xbc>\nmov    (%r12,%rbx,8),%r13\nmov    %r13,%rdi\ncall   10d0 <strlen@plt>\nmov    %rax,%rbp\nmov    0x8(%r12,%rbx,8),%r14\nmov    %r14,%rdi\ncall   10d0 <strlen@plt>\ncmp    %rax,%rbp\nja     1277 <func0+0x6e>\njne    1280 <func0+0x77>\nmov    %r14,%rsi\nmov    %r13,%rdi\ncall   1100 <strcmp@plt>\ntest   %eax,%eax\njg     1277 <func0+0x6e>\njmp    1280 <func0+0x77>\naddl   $0x1,0xc(%rsp)\nmov    0xc(%rsp),%ecx\nmov    (%r15),%eax\nlea    -0x1(%rax),%edx\ncmp    %ecx,%edx\njle    12f0 <func0+0xe7>\nmov    (%r15),%eax\nsub    0xc(%rsp),%eax\nmov    $0x0,%ebx\ncmp    $0x1,%eax\njg     1291 <func0+0x88>\njmp    12c5 <func0+0xbc>\nmov    $0x0,%eax\ncltq\nlea    0x0(,%rax,8),%rdi\n00\ncall   1110 <malloc@plt>\nmov    (%r15),%esi\ntest   %esi,%esi\njle    131e <func0+0x115>\nmov    %esi,%esi\nmov    $0x0,%edx\nmov    (%r12,%rdx,8),%rcx\nmov    %rcx,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rdx,%rsi\njne    130d <func0+0x104>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 149,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovl   $0x0,(%rdx)\nmov    %rdi,(%rsp)\nmov    %rdx,0x10(%rsp)\ntest   %esi,%esi\njle    1884 <func0+0x154>\nlea    0x8(%rdi),%rdx\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nmov    %rdx,0x8(%rsp)\nlea    (%rdx,%rax,8),%r12\nxchg   %ax,%ax\nmov    (%rbx),%r13\nmov    %r13,%rdi\ncall   10e0 <strlen@plt>\ntest   $0x1,%al\njne    1794 <func0+0x64>\nmov    (%rsp),%rdx\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmov    %r13,(%rdx,%rax,8)\nmov    0x10(%rsp),%rax\nmov    %ebp,(%rax)\nadd    $0x8,%rbx\ncmp    %r12,%rbx\njne    1770 <func0+0x40>\nlea    -0x1(%rbp),%r12d\nmovslq %ebp,%rbp\nlea    0x0(,%rbp,8),%rax\n00\nmov    %rax,0x18(%rsp)\ntest   %r12d,%r12d\njle    1823 <func0+0xf3>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    0x8(%rsp),%rcx\nlea    -0x1(%r12),%eax\nmov    (%rsp),%r15\nmov    %rax,%r12\nlea    (%rcx,%rax,8),%rbp\njmp    17ef <func0+0xbf>\nnopw   0x0(%rax,%rax,1)\n00 00\nje     1868 <func0+0x138>\nadd    $0x8,%r15\ncmp    %r15,%rbp\nje     181e <func0+0xee>\nmov    (%r15),%r14\nmov    %r14,%rdi\ncall   10e0 <strlen@plt>\nmov    0x8(%r15),%r13\nmov    %rax,%rbx\nmov    %r13,%rdi\ncall   10e0 <strlen@plt>\ncmp    %rax,%rbx\njbe    17e0 <func0+0xb0>\nmov    %r13,(%r15)\nmov    %r14,0x8(%r15)\nadd    $0x8,%r15\ncmp    %r15,%rbp\njne    17ef <func0+0xbf>\ntest   %r12d,%r12d\njne    17c0 <func0+0x90>\nmov    0x18(%rsp),%rdi\ncall   1130 <malloc@plt>\nmov    %rax,%r8\nmov    0x10(%rsp),%rax\nmovslq (%rax),%rax\ntest   %eax,%eax\njle    1853 <func0+0x123>\nmov    (%rsp),%rsi\nmov    %r8,%rdi\nlea    0x0(,%rax,8),%rdx\n00\ncall   1120 <memcpy@plt>\nmov    %rax,%r8\nadd    $0x28,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nmov    %r13,%rsi\nmov    %r14,%rdi\ncall   1110 <strcmp@plt>\ntest   %eax,%eax\njle    17e6 <func0+0xb6>\nmov    %r13,(%r15)\nmov    %r14,0x8(%r15)\njmp    1815 <func0+0xe5>\nmovq   $0x0,0x18(%rsp)\n00 00\njmp    1823 <func0+0xf3>\nnop\n"
    },
    {
        "task_id": 149,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmovl   $0x0,(%rdx)\nmov    %rdi,0x10(%rsp)\nmov    %rdx,0x20(%rsp)\ntest   %esi,%esi\njle    19be <func0+0x16e>\nlea    0x8(%rdi),%rdx\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nmov    %rdx,0x18(%rsp)\nlea    (%rdx,%rax,8),%r12\nnop\nmov    (%rbx),%r13\nmov    %r13,%rdi\ncall   10e0 <strlen@plt>\ntest   $0x1,%al\njne    18b5 <func0+0x65>\nmov    0x10(%rsp),%rdx\nmovslq %ebp,%rax\nadd    $0x1,%ebp\nmov    %r13,(%rdx,%rax,8)\nmov    0x20(%rsp),%rax\nmov    %ebp,(%rax)\nadd    $0x8,%rbx\ncmp    %rbx,%r12\njne    1890 <func0+0x40>\nlea    -0x1(%rbp),%r13d\nmovslq %ebp,%rbp\nlea    0x0(,%rbp,8),%rax\n00\nmov    %rax,0x28(%rsp)\ntest   %r13d,%r13d\njle    1957 <func0+0x107>\nnopl   0x0(%rax,%rax,1)\nmov    0x18(%rsp),%rcx\nlea    -0x1(%r13),%eax\nmov    0x10(%rsp),%r15\nmov    %rax,%r13\nlea    (%rcx,%rax,8),%r12\njmp    190f <func0+0xbf>\nnopw   0x0(%rax,%rax,1)\n00 00\nje     19a0 <func0+0x150>\nadd    $0x8,%r15\ncmp    %r12,%r15\nje     1952 <func0+0x102>\nmov    (%r15),%rbp\nmov    %rbp,%rdi\ncall   10e0 <strlen@plt>\nmov    0x8(%r15),%r14\nmovq   %rbp,%xmm1\nmov    %rax,%rbx\nmovq   %r14,%xmm0\nmov    %r14,%rdi\npunpcklqdq %xmm1,%xmm0\nmovaps %xmm0,(%rsp)\ncall   10e0 <strlen@plt>\ncmp    %rax,%rbx\njbe    1900 <func0+0xb0>\nmovdqa (%rsp),%xmm2\nmovups %xmm2,(%r15)\nadd    $0x8,%r15\ncmp    %r12,%r15\njne    190f <func0+0xbf>\ntest   %r13d,%r13d\njne    18e0 <func0+0x90>\nmov    0x28(%rsp),%rdi\ncall   1130 <malloc@plt>\nmov    %rax,%r8\nmov    0x20(%rsp),%rax\nmovslq (%rax),%rax\ntest   %eax,%eax\njle    1988 <func0+0x138>\nmov    0x10(%rsp),%rsi\nmov    %r8,%rdi\nlea    0x0(,%rax,8),%rdx\n00\ncall   1120 <memcpy@plt>\nmov    %rax,%r8\nadd    $0x38,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    %r14,%rsi\nmov    %rbp,%rdi\ncall   1110 <strcmp@plt>\ntest   %eax,%eax\njle    1906 <func0+0xb6>\nmovdqa (%rsp),%xmm2\nmovups %xmm2,(%r15)\njmp    1949 <func0+0xf9>\nmovq   $0x0,0x28(%rsp)\n00 00\njmp    1957 <func0+0x107>\nnopl   0x0(%rax)\n"
    },
    {
        "task_id": 150,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %edx,-0x1c(%rbp)\nmovl   $0x1,-0x8(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njg     116e <func0+0x25>\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    118f <func0+0x46>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    118b <func0+0x42>\nmovl   $0x0,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    1177 <func0+0x2e>\ncmpl   $0x0,-0x8(%rbp)\nje     11a5 <func0+0x5c>\nmov    -0x18(%rbp),%eax\njmp    11a8 <func0+0x5f>\nmov    -0x1c(%rbp),%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 150,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edx,%r9d\ncmp    $0x1,%edi\nsetg   %r8b\nmovzbl %r8b,%r8d\ncmp    $0x3,%edi\njle    117c <func0+0x33>\nmov    $0x2,%ecx\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\ncmove  %edx,%r8d\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    1165 <func0+0x1c>\ntest   %r8d,%r8d\ncmovne %esi,%r9d\nmov    %r9d,%eax\nret\n"
    },
    {
        "task_id": 150,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %r8d,%r8d\ncmp    $0x1,%edi\nmov    %edx,%r10d\nsetg   %r8b\ncmp    $0x3,%edi\njle    1327 <func0+0x37>\nmov    $0x2,%ecx\nxor    %r9d,%r9d\nxchg   %ax,%ax\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\ncmove  %r9d,%r8d\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    1310 <func0+0x20>\ntest   %r8d,%r8d\ncmovne %esi,%r10d\nmov    %r10d,%eax\nret\n"
    },
    {
        "task_id": 150,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %r8d,%r8d\ncmp    $0x1,%edi\nmov    %edx,%r10d\nsetg   %r8b\ncmp    $0x3,%edi\njle    12c7 <func0+0x37>\nmov    $0x2,%ecx\nxor    %r9d,%r9d\nxchg   %ax,%ax\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\ncmove  %r9d,%r8d\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %eax,%edi\njge    12b0 <func0+0x20>\ntest   %r8d,%r8d\ncmovne %esi,%r10d\nmov    %r10d,%eax\nret\n"
    },
    {
        "task_id": 151,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovq   $0x0,-0x18(%rbp)\n00\nmovl   $0x0,-0x1c(%rbp)\njmp    130b <func0+0x182>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nmovsd  %xmm2,-0x38(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm3,%xmm3\ncvtss2sd %xmm0,%xmm3\nmovq   %xmm3,%rax\nmovq   %rax,%xmm0\ncall   1070 <round@plt>\nmovapd %xmm0,%xmm1\nmovsd  -0x38(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovq   0xf56(%rip),%xmm1\n00\nandpd  %xmm0,%xmm1\nmovsd  0xf5a(%rip),%xmm0\n00\ncomisd %xmm1,%xmm0\njbe    1307 <func0+0x17e>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\ncomiss %xmm1,%xmm0\njbe    1307 <func0+0x17e>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm4,%xmm4\ncvtss2sd %xmm0,%xmm4\nmovq   %xmm4,%rax\nmovq   %rax,%xmm0\ncall   1070 <round@plt>\ncvttsd2si %xmm0,%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    1307 <func0+0x17e>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm5,%xmm5\ncvtss2sd %xmm0,%xmm5\nmovq   %xmm5,%rax\nmovq   %rax,%xmm0\ncall   1070 <round@plt>\ncvttsd2si %xmm0,%ebx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm6,%xmm6\ncvtss2sd %xmm0,%xmm6\nmovq   %xmm6,%rax\nmovq   %rax,%xmm0\ncall   1070 <round@plt>\ncvttsd2si %xmm0,%eax\nimul   %ebx,%eax\ncltq\nadd    %rax,-0x18(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     11b1 <func0+0x28>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"
    },
    {
        "task_id": 151,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\ntest   %esi,%esi\njle    1225 <func0+0x9c>\nmov    %rdi,%rbx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rbp\nmov    $0x0,%r12d\njmp    11b9 <func0+0x30>\nadd    $0x4,%rbx\ncmp    %rbp,%rbx\nje     122b <func0+0xa2>\nmovss  (%rbx),%xmm3\nmovss  %xmm3,0xc(%rsp)\nmovaps %xmm3,%xmm0\ncall   1070 <roundf@plt>\nmovss  0xc(%rsp),%xmm3\npxor   %xmm1,%xmm1\ncvtss2sd %xmm3,%xmm1\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nandpd  0xf73(%rip),%xmm1\n00\nmovsd  0xf7b(%rip),%xmm4\n00\ncomisd %xmm1,%xmm4\njbe    11b0 <func0+0x27>\ncomiss 0xf66(%rip),%xmm3\njbe    11b0 <func0+0x27>\ncvttss2si %xmm0,%edx\nmov    %edx,%ecx\nshr    $0x1f,%ecx\nlea    (%rdx,%rcx,1),%eax\nand    $0x1,%eax\nsub    %ecx,%eax\ncmp    $0x1,%eax\njne    11b0 <func0+0x27>\nimul   %edx,%edx\nmovslq %edx,%rdx\nadd    %rdx,%r12\njmp    11b0 <func0+0x27>\nmov    $0x0,%r12d\nmov    %r12,%rax\nadd    $0x10,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 151,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\ntest   %esi,%esi\njle    14b0 <func0+0xb0>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %r12d,%r12d\nlea    0x4(%rdi,%rax,4),%rbp\nnopw   0x0(%rax,%rax,1)\nmovss  (%rbx),%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm2,0xc(%rsp)\ncall   1070 <roundf@plt>\nmovss  0xc(%rsp),%xmm2\npxor   %xmm1,%xmm1\npxor   %xmm3,%xmm3\nmovsd  0xd20(%rip),%xmm4\n00\ncvtss2sd %xmm0,%xmm3\ncvtss2sd %xmm2,%xmm1\nsubsd  %xmm3,%xmm1\nandpd  0xcfc(%rip),%xmm1\n00\ncomisd %xmm1,%xmm4\njbe    1498 <func0+0x98>\npxor   %xmm5,%xmm5\ncomiss %xmm5,%xmm2\njbe    1498 <func0+0x98>\ncvttss2si %xmm0,%edx\nmov    %edx,%ecx\nshr    $0x1f,%ecx\nlea    (%rdx,%rcx,1),%eax\nand    $0x1,%eax\nsub    %ecx,%eax\ncmp    $0x1,%eax\njne    1498 <func0+0x98>\nimul   %edx,%edx\nmovslq %edx,%rdx\nadd    %rdx,%r12\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rbx\ncmp    %rbx,%rbp\njne    1428 <func0+0x28>\nadd    $0x10,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   (%rax)\nadd    $0x10,%rsp\nxor    %r12d,%r12d\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 151,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\ntest   %esi,%esi\njle    1540 <func0+0xb0>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %r12d,%r12d\nlea    0x4(%rdi,%rax,4),%rbp\nnopw   0x0(%rax,%rax,1)\nmovss  (%rbx),%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm2,0xc(%rsp)\ncall   1070 <roundf@plt>\nmovss  0xc(%rsp),%xmm2\npxor   %xmm1,%xmm1\npxor   %xmm3,%xmm3\nmovsd  0xcb0(%rip),%xmm4\n00\ncvtss2sd %xmm0,%xmm3\ncvtss2sd %xmm2,%xmm1\nsubsd  %xmm3,%xmm1\nandpd  0xc6c(%rip),%xmm1\n00\ncomisd %xmm1,%xmm4\njbe    1528 <func0+0x98>\npxor   %xmm5,%xmm5\ncomiss %xmm5,%xmm2\njbe    1528 <func0+0x98>\ncvttss2si %xmm0,%edx\nmov    %edx,%ecx\nshr    $0x1f,%ecx\nlea    (%rdx,%rcx,1),%eax\nand    $0x1,%eax\nsub    %ecx,%eax\ncmp    $0x1,%eax\njne    1528 <func0+0x98>\nimul   %edx,%edx\nmovslq %edx,%rdx\nadd    %rdx,%r12\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rbx\ncmp    %rbx,%rbp\njne    14b8 <func0+0x28>\nadd    $0x10,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   (%rax)\nadd    $0x10,%rsp\nxor    %r12d,%r12d\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\n"
    },
    {
        "task_id": 152,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x2c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    11da <func0+0x71>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %eax,%ecx\nneg    %ecx\ncmovns %ecx,%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1189 <func0+0x20>\nnop\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 152,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r9\ntest   %ecx,%ecx\njle    1198 <func0+0x2f>\nmov    %ecx,%ecx\nmov    $0x0,%eax\nmov    (%r9,%rax,4),%edi\nsub    (%rsi,%rax,4),%edi\nmov    %edi,%r8d\nneg    %r8d\ncmovns %r8d,%edi\nmov    %edi,(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    117b <func0+0x12>\nret\n"
    },
    {
        "task_id": 152,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r9\ntest   %ecx,%ecx\njle    168d <func0+0x2d>\nmovslq %ecx,%rcx\nxor    %eax,%eax\nmov    (%r9,%rax,4),%edi\nsub    (%rsi,%rax,4),%edi\nmov    %edi,%r8d\nneg    %r8d\ncmovns %r8d,%edi\nmov    %edi,(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rcx\njne    1670 <func0+0x10>\nret\nxchg   %ax,%ax\n"
    },
    {
        "task_id": 152,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %ecx,%ecx\njle    135f <func0+0x11f>\nlea    0x4(%rdi),%r8\nmov    %rdx,%rax\nsub    %r8,%rax\ncmp    $0x8,%rax\nlea    -0x1(%rcx),%eax\nseta   %r8b\ncmp    $0x2,%eax\nseta   %al\ntest   %al,%r8b\nje     1338 <func0+0xf8>\nlea    0x4(%rsi),%r8\nmov    %rdx,%rax\nsub    %r8,%rax\ncmp    $0x8,%rax\njbe    1338 <func0+0xf8>\nmov    %ecx,%r8d\nxor    %eax,%eax\nshr    $0x2,%r8d\nshl    $0x4,%r8\nnopl   0x0(%rax)\nmovdqu (%rdi,%rax,1),%xmm0\nmovdqu (%rsi,%rax,1),%xmm2\npsubd  %xmm2,%xmm0\nmovdqa %xmm0,%xmm1\npsrad  $0x1f,%xmm1\npxor   %xmm1,%xmm0\npsubd  %xmm1,%xmm0\nmovups %xmm0,(%rdx,%rax,1)\nadd    $0x10,%rax\ncmp    %r8,%rax\njne    1298 <func0+0x58>\nmov    %ecx,%r8d\nand    $0xfffffffc,%r8d\ntest   $0x3,%cl\nje     135f <func0+0x11f>\nmov    %r8d,%r10d\nmov    (%rdi,%r10,4),%r9d\nsub    (%rsi,%r10,4),%r9d\nlea    0x0(,%r10,4),%rax\n00\nmov    %r9d,%r11d\nneg    %r11d\ncmovns %r11d,%r9d\nmov    %r9d,(%rdx,%r10,4)\nlea    0x1(%r8),%r9d\ncmp    %r9d,%ecx\njle    135f <func0+0x11f>\nmov    0x4(%rdi,%rax,1),%r9d\nsub    0x4(%rsi,%rax,1),%r9d\nmov    %r9d,%r10d\nneg    %r10d\ncmovns %r10d,%r9d\nadd    $0x2,%r8d\nmov    %r9d,0x4(%rdx,%rax,1)\ncmp    %r8d,%ecx\njle    135f <func0+0x11f>\nmov    0x8(%rdi,%rax,1),%ecx\nsub    0x8(%rsi,%rax,1),%ecx\nmov    %ecx,%esi\nneg    %esi\ncmovns %esi,%ecx\nmov    %ecx,0x8(%rdx,%rax,1)\nret\nnopl   0x0(%rax)\nmov    %ecx,%ecx\nxor    %eax,%eax\nnopl   0x0(%rax)\nmov    (%rdi,%rax,4),%r8d\nsub    (%rsi,%rax,4),%r8d\nmov    %r8d,%r9d\nneg    %r9d\ncmovns %r9d,%r8d\nmov    %r8d,(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    1340 <func0+0x100>\nret\n"
    },
    {
        "task_id": 153,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %edx,-0x44(%rbp)\nmov    %rcx,-0x50(%rbp)\nmovl   $0xfffffc18,-0x20(%rbp)\nmovq   $0x0,-0x10(%rbp)\n00\nmovl   $0x0,-0x1c(%rbp)\njmp    126f <func0+0xc6>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    1241 <func0+0x98>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x21(%rbp)\ncmpb   $0x40,-0x21(%rbp)\njle    122d <func0+0x84>\ncmpb   $0x5a,-0x21(%rbp)\njg     122d <func0+0x84>\naddl   $0x1,-0x18(%rbp)\ncmpb   $0x60,-0x21(%rbp)\njle    123d <func0+0x94>\ncmpb   $0x7a,-0x21(%rbp)\njg     123d <func0+0x94>\nsubl   $0x1,-0x18(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    120a <func0+0x61>\nmov    -0x18(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njle    126b <func0+0xc2>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x10(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     11df <func0+0x36>\nmov    -0x10(%rbp),%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x50(%rbp),%rax\nlea    0xd7a(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   10b0 <sprintf@plt>\nnop\nleave\nret\n"
    },
    {
        "task_id": 153,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r8\nmov    %rcx,%rbp\ntest   %edx,%edx\njle    1227 <func0+0x7e>\nmov    %rsi,%rdi\nlea    -0x1(%rdx),%eax\nlea    0x8(%rsi,%rax,8),%rbx\nmov    $0x0,%r9d\nmov    $0xfffffc18,%r11d\njmp    1211 <func0+0x68>\nsub    $0x61,%eax\ncmp    $0x1a,%al\nsbb    $0x0,%ecx\nadd    $0x1,%rdx\nmovzbl -0x1(%rdx),%eax\ntest   %al,%al\nje     11fd <func0+0x54>\nlea    -0x41(%rax),%esi\ncmp    $0x19,%sil\nja     11d6 <func0+0x2d>\nadd    $0x1,%ecx\njmp    11de <func0+0x35>\nmov    $0x0,%ecx\ncmp    %ecx,%r11d\njge    1208 <func0+0x5f>\nmov    %r10,%r9\nmov    %ecx,%r11d\nadd    $0x8,%rdi\ncmp    %rbx,%rdi\nje     122d <func0+0x84>\nmov    (%rdi),%r10\nmovzbl (%r10),%eax\ntest   %al,%al\nje     11f8 <func0+0x4f>\nlea    0x1(%r10),%rdx\nmov    $0x0,%ecx\njmp    11ea <func0+0x41>\nmov    $0x0,%r9d\nlea    0xdd0(%rip),%rcx\nmov    $0xffffffffffffffff,%rdx\nmov    $0x1,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   10b0 <__sprintf_chk@plt>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 153,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rdi,%r8\nmov    %rcx,%r11\npush   %rbx\ntest   %edx,%edx\njle    17e4 <func0+0xa4>\nlea    -0x1(%rdx),%eax\nxor    %r9d,%r9d\nmov    $0xfffffc18,%ebx\nlea    0x8(%rsi,%rax,8),%rbp\nnopl   0x0(%rax)\nmov    (%rsi),%r10\nmovzbl (%r10),%eax\ntest   %al,%al\nje     17e0 <func0+0xa0>\nlea    0x1(%r10),%rdx\nxor    %ecx,%ecx\njmp    178e <func0+0x4e>\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\nadd    $0x1,%ecx\ntest   %al,%al\nje     17aa <func0+0x6a>\nlea    -0x41(%rax),%edi\ncmp    $0x19,%dil\njbe    1780 <func0+0x40>\nsub    $0x61,%eax\ncmp    $0x1a,%al\nsbb    $0x0,%ecx\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\njne    178e <func0+0x4e>\ncmp    %ecx,%ebx\njge    17b3 <func0+0x73>\nmov    %r10,%r9\nmov    %ecx,%ebx\nadd    $0x8,%rsi\ncmp    %rbp,%rsi\njne    1768 <func0+0x28>\npop    %rbx\nlea    0x840(%rip),%rcx\nmov    $0xffffffffffffffff,%rdx\npop    %rbp\nmov    $0x1,%esi\nmov    %r11,%rdi\nxor    %eax,%eax\njmp    1090 <__sprintf_chk@plt>\nnopl   0x0(%rax,%rax,1)\nxor    %ecx,%ecx\njmp    17aa <func0+0x6a>\nxor    %r9d,%r9d\njmp    17bc <func0+0x7c>\n"
    },
    {
        "task_id": 153,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rdi,%r8\nmov    %rcx,%r11\npush   %rbx\ntest   %edx,%edx\njle    1894 <func0+0xa4>\nlea    -0x1(%rdx),%eax\nxor    %r9d,%r9d\nmov    $0xfffffc18,%ebx\nlea    0x8(%rsi,%rax,8),%rbp\nnopl   0x0(%rax)\nmov    (%rsi),%r10\nmovzbl (%r10),%eax\ntest   %al,%al\nje     1890 <func0+0xa0>\nlea    0x1(%r10),%rdx\nxor    %ecx,%ecx\njmp    183e <func0+0x4e>\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\nadd    $0x1,%ecx\ntest   %al,%al\nje     185a <func0+0x6a>\nlea    -0x41(%rax),%edi\ncmp    $0x19,%dil\njbe    1830 <func0+0x40>\nsub    $0x61,%eax\ncmp    $0x1a,%al\nsbb    $0x0,%ecx\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\njne    183e <func0+0x4e>\ncmp    %ecx,%ebx\njge    1863 <func0+0x73>\nmov    %r10,%r9\nmov    %ecx,%ebx\nadd    $0x8,%rsi\ncmp    %rbp,%rsi\njne    1818 <func0+0x28>\npop    %rbx\nlea    0x790(%rip),%rcx\nmov    $0xffffffffffffffff,%rdx\npop    %rbp\nmov    $0x1,%esi\nmov    %r11,%rdi\nxor    %eax,%eax\njmp    1090 <__sprintf_chk@plt>\nnopl   0x0(%rax,%rax,1)\nxor    %ecx,%ecx\njmp    185a <func0+0x6a>\nxor    %r9d,%r9d\njmp    186c <func0+0x7c>\n"
    },
    {
        "task_id": 154,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10c0 <strlen@plt>\nmov    %eax,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   10c0 <strlen@plt>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    12cf <func0+0xe6>\nmov    -0xc(%rbp),%eax\nsub    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   10b0 <strncpy@plt>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmov    -0x14(%rbp),%ecx\nmovslq %ecx,%rcx\nsub    %rcx,%rax\nmov    %rax,%rsi\nmov    -0x8(%rbp),%rax\nlea    (%rsi,%rax,1),%rcx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   10b0 <strncpy@plt>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10f0 <strstr@plt>\ntest   %rax,%rax\nje     12cb <func0+0xe2>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmov    $0x1,%eax\njmp    12ec <func0+0x103>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     123d <func0+0x54>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmov    $0x0,%eax\nleave\nret\n"
    },
    {
        "task_id": 154,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r14\nmov    %rsi,%r13\nmov    %rsi,%rdi\ncall   10c0 <strlen@plt>\nmov    %rax,%rbx\nmov    %eax,%r12d\nlea    0x1(%rax,%rax,1),%edi\nmovslq %edi,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,%rbp\ntest   %ebx,%ebx\njle    1278 <func0+0x8f>\nlea    -0x1(%rbx),%r15d\nmov    $0x0,%ebx\nmovslq %r12d,%r12\njmp    1233 <func0+0x4a>\nmov    %rax,%rbx\nmov    %r12,%rdx\nsub    %rbx,%rdx\nlea    0x0(%r13,%rbx,1),%rsi\nmov    %rbp,%rdi\ncall   10b0 <strncpy@plt>\nlea    0x0(%rbp,%r12,1),%rdi\nsub    %rbx,%rdi\nmov    %rbx,%rdx\nmov    %r13,%rsi\ncall   10b0 <strncpy@plt>\nmovb   $0x0,0x0(%rbp,%r12,1)\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncall   10f0 <strstr@plt>\ntest   %rax,%rax\njne    1294 <func0+0xab>\nlea    0x1(%rbx),%rax\ncmp    %r15,%rbx\njne    1230 <func0+0x47>\nmov    %rbp,%rdi\ncall   10a0 <free@plt>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rbp,%rdi\ncall   10a0 <free@plt>\nmov    $0x1,%eax\njmp    1285 <func0+0x9c>\n"
    },
    {
        "task_id": 154,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\nmov    %rsi,%rdi\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   10c0 <strlen@plt>\nlea    0x1(%rax,%rax,1),%edi\nmov    %rax,%rbx\nmovslq %edi,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,%r15\ntest   %ebx,%ebx\njle    1418 <func0+0xb8>\nmovslq %ebx,%r14\nlea    (%rax,%r14,1),%r12\nlea    -0x1(%rbx),%eax\nxor    %ebx,%ebx\nmov    %rax,0x8(%rsp)\njmp    13be <func0+0x5e>\nnopl   (%rax)\nlea    0x1(%rbx),%rax\ncmp    0x8(%rsp),%rbx\nje     1418 <func0+0xb8>\nmov    %rax,%rbx\nmov    %r14,%rdx\nlea    0x0(%rbp,%rbx,1),%rsi\nmov    %r15,%rdi\nsub    %rbx,%rdx\ncall   10b0 <strncpy@plt>\nmov    %r12,%rdi\nmov    %rbp,%rsi\nmov    %rbx,%rdx\nsub    %rbx,%rdi\ncall   10b0 <strncpy@plt>\nmovb   $0x0,(%r12)\nmov    %r15,%rsi\nmov    %r13,%rdi\ncall   10f0 <strstr@plt>\ntest   %rax,%rax\nje     13b0 <func0+0x50>\nmov    %r15,%rdi\ncall   10a0 <free@plt>\nadd    $0x18,%rsp\nmov    $0x1,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    %r15,%rdi\ncall   10a0 <free@plt>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 154,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\nmov    %rsi,%rdi\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   10c0 <strlen@plt>\nlea    0x1(%rax,%rax,1),%edi\nmov    %rax,%rbx\nmovslq %edi,%rdi\ncall   10e0 <malloc@plt>\nmov    %rax,%r15\ntest   %ebx,%ebx\njle    1418 <func0+0xb8>\nmovslq %ebx,%r14\nlea    (%rax,%r14,1),%r12\nlea    -0x1(%rbx),%eax\nxor    %ebx,%ebx\nmov    %rax,0x8(%rsp)\njmp    13be <func0+0x5e>\nnopl   (%rax)\nlea    0x1(%rbx),%rax\ncmp    0x8(%rsp),%rbx\nje     1418 <func0+0xb8>\nmov    %rax,%rbx\nmov    %r14,%rdx\nlea    0x0(%rbp,%rbx,1),%rsi\nmov    %r15,%rdi\nsub    %rbx,%rdx\ncall   10b0 <strncpy@plt>\nmov    %r12,%rdi\nmov    %rbp,%rsi\nmov    %rbx,%rdx\nsub    %rbx,%rdi\ncall   10b0 <strncpy@plt>\nmovb   $0x0,(%r12)\nmov    %r15,%rsi\nmov    %r13,%rdi\ncall   10f0 <strstr@plt>\ntest   %rax,%rax\nje     13b0 <func0+0x50>\nmov    %r15,%rdi\ncall   10a0 <free@plt>\nadd    $0x18,%rsp\nmov    $0x1,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    %r15,%rdi\ncall   10a0 <free@plt>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 155,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nsub    %eax,%edx\nmov    %edx,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    11ee <func0+0x65>\naddl   $0x1,-0xc(%rbp)\njmp    11f2 <func0+0x69>\naddl   $0x1,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     11b3 <func0+0x2a>\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 155,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%edx\nneg    %edx\ncmovs  %edi,%edx\nmov    $0x0,%edi\nmov    $0x0,%r8d\njmp    11c1 <func0+0x38>\nadd    $0x1,%r8d\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\ncmp    $0x9,%edx\njle    11cb <func0+0x42>\nmov    %eax,%edx\ntest   $0x1,%dl\nje     11a1 <func0+0x18>\nadd    $0x1,%edi\njmp    11a5 <func0+0x1c>\nmov    %r8d,(%rsi)\nmov    %edi,0x4(%rsi)\nret\n"
    },
    {
        "task_id": 155,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%edx\nmov    $0xcccccccd,%r8d\nneg    %edx\ncmovs  %edi,%edx\nxor    %ecx,%ecx\nxor    %edi,%edi\njmp    1402 <func0+0x32>\nnopw   0x0(%rax,%rax,1)\n00 00\nimul   %r8,%rax\nadd    $0x1,%edi\nshr    $0x23,%rax\ncmp    $0x9,%edx\njle    1419 <func0+0x49>\nmov    %eax,%edx\nmov    %edx,%eax\ntest   $0x1,%dl\nje     13f0 <func0+0x20>\nimul   %r8,%rax\nadd    $0x1,%ecx\nshr    $0x23,%rax\ncmp    $0x9,%edx\njg     1400 <func0+0x30>\nmov    %edi,(%rsi)\nmov    %ecx,0x4(%rsi)\nret\nnop\n"
    },
    {
        "task_id": 155,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%edx\nmov    $0xcccccccd,%r8d\nneg    %edx\ncmovs  %edi,%edx\nxor    %edi,%edi\nxor    %ecx,%ecx\njmp    1232 <func0+0x32>\nnopw   0x0(%rax,%rax,1)\n00 00\nimul   %r8,%rax\nadd    $0x1,%ecx\nshr    $0x23,%rax\ncmp    $0x9,%edx\njle    1249 <func0+0x49>\nmov    %eax,%edx\nmov    %edx,%eax\ntest   $0x1,%dl\nje     1220 <func0+0x20>\nimul   %r8,%rax\nadd    $0x1,%edi\nshr    $0x23,%rax\ncmp    $0x9,%edx\njg     1230 <func0+0x30>\nmovd   %ecx,%xmm0\nmovd   %edi,%xmm1\npunpckldq %xmm1,%xmm0\nmovq   %xmm0,(%rsi)\nret\nnopw   0x0(%rax,%rax,1)\n"
    },
    {
        "task_id": 156,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xd0,%rsp\nmov    %edi,-0xc4(%rbp)\nmov    %rsi,-0xd0(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0xe29(%rip),%rax\nmov    %rax,-0x70(%rbp)\nlea    0xe20(%rip),%rax\nmov    %rax,-0x68(%rbp)\nlea    0xe18(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0xe0f(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0xe07(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0xdfe(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0xdf6(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0xded(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0xde5(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0xddc(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0xdd4(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0xdcb(%rip),%rax\nmov    %rax,-0x18(%rbp)\nlea    0xdc3(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x3e8,-0xb0(%rbp)\n03 00 00\nmovl   $0x384,-0xac(%rbp)\n03 00 00\nmovl   $0x1f4,-0xa8(%rbp)\n01 00 00\nmovl   $0x190,-0xa4(%rbp)\n01 00 00\nmovl   $0x64,-0xa0(%rbp)\n00 00 00\nmovl   $0x5a,-0x9c(%rbp)\n00 00 00\nmovl   $0x32,-0x98(%rbp)\n00 00 00\nmovl   $0x28,-0x94(%rbp)\n00 00 00\nmovl   $0xa,-0x90(%rbp)\n00 00 00\nmovl   $0x9,-0x8c(%rbp)\n00 00 00\nmovl   $0x5,-0x88(%rbp)\n00 00 00\nmovl   $0x4,-0x84(%rbp)\n00 00 00\nmovl   $0x1,-0x80(%rbp)\nmovl   $0x0,-0xb4(%rbp)\n00 00 00\nmov    -0xd0(%rbp),%rax\nmovb   $0x0,(%rax)\njmp    1353 <func0+0x1aa>\nmov    -0xb4(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,8),%rdx\nmov    -0xd0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10b0 <strcat@plt>\nmov    -0xb4(%rbp),%eax\ncltq\nmov    -0xb0(%rbp,%rax,4),%eax\nsub    %eax,-0xc4(%rbp)\nmov    -0xb4(%rbp),%eax\ncltq\nmov    -0xb0(%rbp,%rax,4),%eax\ncmp    %eax,-0xc4(%rbp)\njge    12f8 <func0+0x14f>\ncmpl   $0x0,-0xc4(%rbp)\njle    1353 <func0+0x1aa>\naddl   $0x1,-0xb4(%rbp)\ncmpl   $0x0,-0xc4(%rbp)\njg     132c <func0+0x183>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\n00 00\nje     1371 <func0+0x1c8>\ncall   1080 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 156,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xb0,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xa8(%rsp)\n00\nxor    %eax,%eax\nlea    0xe2f(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0xe22(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    0xe1a(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0xe0d(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0xe25(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0xdf8(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0xdf0(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0xde3(%rip),%rax\nmov    %rax,0x78(%rsp)\nlea    0xddc(%rip),%rax\nmov    %rax,0x80(%rsp)\n00\nlea    0xdcc(%rip),%rax\nmov    %rax,0x88(%rsp)\n00\nlea    0xf44(%rip),%rax\nmov    %rax,0x90(%rsp)\n00\nlea    0xf34(%rip),%rax\nmov    %rax,0x98(%rsp)\n00\nlea    0xe8d(%rip),%rax\nmov    %rax,0xa0(%rsp)\n00\nmovl   $0x3e8,(%rsp)\nmovl   $0x384,0x4(%rsp)\n00\nmovl   $0x1f4,0x8(%rsp)\n00\nmovl   $0x190,0xc(%rsp)\n00\nmovl   $0x64,0x10(%rsp)\n00\nmovl   $0x5a,0x14(%rsp)\n00\nmovl   $0x32,0x18(%rsp)\n00\nmovl   $0x28,0x1c(%rsp)\n00\nmovl   $0xa,0x20(%rsp)\n00\nmovl   $0x9,0x24(%rsp)\n00\nmovl   $0x5,0x28(%rsp)\n00\nmovl   $0x4,0x2c(%rsp)\n00\nmovl   $0x1,0x30(%rsp)\n00\nmovb   $0x0,(%rsi)\ntest   %edi,%edi\njle    131a <func0+0x171>\nmov    %edi,%ebx\nmov    %rsi,%r13\nmov    %rsp,%r14\nlea    0x40(%rsp),%r12\nmov    (%r14),%ebp\ncmp    %ebx,%ebp\njg     130e <func0+0x165>\nmov    (%r12),%rsi\nmov    %r13,%rdi\ncall   10b0 <strcat@plt>\nsub    %ebp,%ebx\ncmp    %ebp,%ebx\njge    12fc <func0+0x153>\nadd    $0x4,%r14\nadd    $0x8,%r12\ntest   %ebx,%ebx\njg     12f5 <func0+0x14c>\nmov    0xa8(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    133d <func0+0x194>\nadd    $0xb0,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   1080 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 156,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xb0,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xa8(%rsp)\n00\nlea    0xaca(%rip),%rax\nmovb   $0x0,(%rsi)\nmov    %rax,0x40(%rsp)\nlea    0xaba(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    0xab2(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0xaa5(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0xabd(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0xa90(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0xa88(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0xa7b(%rip),%rax\nmov    %rax,0x78(%rsp)\nlea    0xa74(%rip),%rax\nmov    %rax,0x80(%rsp)\n00\nlea    0xa64(%rip),%rax\nmov    %rax,0x88(%rsp)\n00\nlea    0xbdc(%rip),%rax\nmov    %rax,0x90(%rsp)\n00\nlea    0xbcc(%rip),%rax\nmov    %rax,0x98(%rsp)\n00\nlea    0xb25(%rip),%rax\nmov    %rax,0xa0(%rsp)\n00\nmovabs $0x1f400000384,%rax\n01 00 00\nmov    %rax,0x4(%rsp)\nmovabs $0x6400000190,%rax\n00 00 00\nmov    %rax,0xc(%rsp)\nmovabs $0x320000005a,%rax\n00 00 00\nmov    %rax,0x14(%rsp)\nmovabs $0xa00000028,%rax\n00 00 00\nmov    %rax,0x1c(%rsp)\nmovabs $0x500000009,%rax\n00 00 00\nmov    %rax,0x24(%rsp)\nmovabs $0x100000004,%rax\n00 00 00\nmov    %rax,0x2c(%rsp)\ntest   %edi,%edi\njle    1698 <func0+0x188>\nmov    %edi,%ebx\nmov    $0x3e8,%ebp\nmov    %rsi,%rdx\nxor    %r13d,%r13d\nlea    0x40(%rsp),%r14\ncmp    %ebx,%ebp\njg     168c <func0+0x17c>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    (%r14,%r13,2),%r12\nnopl   0x0(%rax)\nmov    %rdx,%rdi\nmov    %r12,%rsi\nsub    %ebp,%ebx\ncall   1090 <strcat@plt>\nmov    %rax,%rdx\ncmp    %ebx,%ebp\njle    1668 <func0+0x158>\nadd    $0x4,%r13\ntest   %ebx,%ebx\nje     1698 <func0+0x188>\nmov    (%rsp,%r13,1),%ebp\ncmp    %ebx,%ebp\njle    1660 <func0+0x150>\nadd    $0x4,%r13\njmp    1684 <func0+0x174>\nnopw   0x0(%rax,%rax,1)\nmov    0xa8(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    16bb <func0+0x1ab>\nadd    $0xb0,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   1070 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 156,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nlea    0xae8(%rip),%rcx\nmov    %rsi,%rdx\npush   %r14\nmovq   %rcx,%xmm0\nlea    0xada(%rip),%rcx\npush   %r13\nxor    %r13d,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nsub    $0xb8,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xa8(%rsp)\n00\nlea    0xaac(%rip),%rax\nlea    0x40(%rsp),%r15\nmovb   $0x0,(%rsi)\nmov    %rsp,%r14\nmovl   $0x1,0x30(%rsp)\n00\nmovq   %rax,%xmm1\nlea    0xa90(%rip),%rax\npunpcklqdq %xmm1,%xmm0\nmovq   %rax,%xmm2\nlea    0xa83(%rip),%rax\nmovaps %xmm0,0x40(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm3\nlea    0xa8e(%rip),%rcx\npunpcklqdq %xmm2,%xmm0\nlea    0xa65(%rip),%rax\nmovaps %xmm0,0x50(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm4\nlea    0xa50(%rip),%rcx\npunpcklqdq %xmm3,%xmm0\nlea    0xa48(%rip),%rax\nmovaps %xmm0,0x60(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm5\nlea    0xa33(%rip),%rcx\npunpcklqdq %xmm4,%xmm0\nlea    0xbad(%rip),%rax\nmovaps %xmm0,0x70(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm6\nlea    0xb98(%rip),%rcx\npunpcklqdq %xmm5,%xmm0\nlea    0xaf4(%rip),%rax\nmovaps %xmm0,0x80(%rsp)\n00\nmovq   %rcx,%xmm0\npunpcklqdq %xmm6,%xmm0\nmov    %rax,0xa0(%rsp)\n00\nmovaps %xmm0,0x90(%rsp)\n00\nmovdqa 0xbac(%rip),%xmm0\n00\nmovaps %xmm0,(%rsp)\nmovdqa 0xbb0(%rip),%xmm0\n00\nmovaps %xmm0,0x10(%rsp)\nmovdqa 0xbb3(%rip),%xmm0\n00\nmovaps %xmm0,0x20(%rsp)\ntest   %edi,%edi\njle    168c <func0+0x17c>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    (%r14,%r13,4),%ebp\ncmp    %ebx,%ebp\njg     16b8 <func0+0x1a8>\nmov    (%r15,%r13,8),%r12\nnopl   0x0(%rax)\nmov    %rdx,%rdi\nmov    %r12,%rsi\nsub    %ebp,%ebx\ncall   1090 <strcat@plt>\nmov    %rax,%rdx\ncmp    %ebp,%ebx\njge    1670 <func0+0x160>\nadd    $0x1,%r13\ntest   %ebx,%ebx\njne    1660 <func0+0x150>\nmov    0xa8(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    16be <func0+0x1ae>\nadd    $0xb8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nadd    $0x1,%r13\njmp    1660 <func0+0x150>\ncall   1070 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 157,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  %xmm2,-0xc(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  %xmm0,%xmm0\naddss  %xmm0,%xmm1\nmovss  -0xc(%rbp),%xmm0\nmovaps %xmm0,%xmm2\nmulss  %xmm0,%xmm2\nsubss  %xmm2,%xmm1\nmovaps %xmm1,%xmm0\nmovss  0xf8c(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtss2sd %xmm0,%xmm1\nmovsd  0xf89(%rip),%xmm0\n00\ncomisd %xmm1,%xmm0\nja     124b <func0+0x102>\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  %xmm0,%xmm1\nmovss  -0xc(%rbp),%xmm0\nmulss  %xmm0,%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm2\nmulss  %xmm0,%xmm2\nsubss  %xmm2,%xmm1\nmovaps %xmm1,%xmm0\nmovss  0xf3b(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtss2sd %xmm0,%xmm1\nmovsd  0xf38(%rip),%xmm0\n00\ncomisd %xmm1,%xmm0\nja     124b <func0+0x102>\nmovss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  %xmm0,%xmm1\nmovss  -0xc(%rbp),%xmm0\nmulss  %xmm0,%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm2\nmulss  %xmm0,%xmm2\nsubss  %xmm2,%xmm1\nmovaps %xmm1,%xmm0\nmovss  0xeee(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtss2sd %xmm0,%xmm1\nmovsd  0xeeb(%rip),%xmm0\n00\ncomisd %xmm1,%xmm0\njbe    1252 <func0+0x109>\nmov    $0x1,%eax\njmp    1257 <func0+0x10e>\nmov    $0x0,%eax\npop    %rbp\nret\n"
    },
    {
        "task_id": 157,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovaps %xmm0,%xmm3\nmulss  %xmm0,%xmm3\nmulss  %xmm1,%xmm1\nmulss  %xmm2,%xmm2\nmovaps %xmm3,%xmm0\naddss  %xmm1,%xmm0\nsubss  %xmm2,%xmm0\nandps  0xec2(%rip),%xmm0\ncvtss2sd %xmm0,%xmm0\nmov    $0x1,%eax\nmovsd  0xec1(%rip),%xmm4\n00\ncomisd %xmm0,%xmm4\nja     119e <func0+0x75>\nmovaps %xmm3,%xmm0\naddss  %xmm2,%xmm0\nsubss  %xmm1,%xmm0\nandps  0xe99(%rip),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd %xmm0,%xmm4\nja     119e <func0+0x75>\naddss  %xmm2,%xmm1\nsubss  %xmm3,%xmm1\nandps  0xe80(%rip),%xmm1\ncvtss2sd %xmm1,%xmm1\ncomisd %xmm1,%xmm4\nseta   %al\nmovzbl %al,%eax\nret\n"
    },
    {
        "task_id": 157,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovaps %xmm0,%xmm3\nmovsd  0xed1(%rip),%xmm4\n00\nmovss  0xeb9(%rip),%xmm5\n00\nmov    $0x1,%eax\nmulss  %xmm0,%xmm3\nmulss  %xmm1,%xmm1\nmulss  %xmm2,%xmm2\nmovaps %xmm3,%xmm0\naddss  %xmm1,%xmm0\nsubss  %xmm2,%xmm0\nandps  %xmm5,%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd %xmm0,%xmm4\nja     11b0 <func0+0x70>\nmovaps %xmm3,%xmm0\naddss  %xmm2,%xmm0\nsubss  %xmm1,%xmm0\nandps  %xmm5,%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd %xmm0,%xmm4\nja     11b0 <func0+0x70>\naddss  %xmm2,%xmm1\nxor    %eax,%eax\nsubss  %xmm3,%xmm1\nandps  %xmm5,%xmm1\ncvtss2sd %xmm1,%xmm1\ncomisd %xmm1,%xmm4\nseta   %al\nret\n"
    },
    {
        "task_id": 157,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovaps %xmm0,%xmm3\nmovsd  0xed1(%rip),%xmm4\n00\nmovss  0xeb9(%rip),%xmm5\n00\nmov    $0x1,%eax\nmulss  %xmm0,%xmm3\nmulss  %xmm1,%xmm1\nmulss  %xmm2,%xmm2\nmovaps %xmm3,%xmm0\naddss  %xmm1,%xmm0\nsubss  %xmm2,%xmm0\nandps  %xmm5,%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd %xmm0,%xmm4\nja     11b0 <func0+0x70>\nmovaps %xmm3,%xmm0\naddss  %xmm2,%xmm0\nsubss  %xmm1,%xmm0\nandps  %xmm5,%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd %xmm0,%xmm4\nja     11b0 <func0+0x70>\naddss  %xmm2,%xmm1\nxor    %eax,%eax\nsubss  %xmm3,%xmm1\nandps  %xmm5,%xmm1\ncvtss2sd %xmm1,%xmm1\ncomisd %xmm1,%xmm4\nseta   %al\nret\n"
    },
    {
        "task_id": 158,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x140,%rsp\nmov    %rdi,-0x138(%rbp)\nmov    %esi,-0x13c(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0xe0d(%rip),%rax\nmov    %rax,-0x118(%rbp)\nmovl   $0x0,-0x12c(%rbp)\n00 00 00\nmovl   $0x0,-0x128(%rbp)\n00 00 00\njmp    14d7 <func0+0x30e>\nmovq   $0x0,-0x110(%rbp)\n00 00 00 00\nmovq   $0x0,-0x108(%rbp)\n00 00 00 00\nmovq   $0x0,-0x100(%rbp)\n00 00 00 00\nmovq   $0x0,-0xf8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xf0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xe8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xe0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xd8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xd0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xc8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xc0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xb8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xb0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xa8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xa0(%rbp)\n00 00 00 00\nmovq   $0x0,-0x98(%rbp)\n00 00 00 00\nmovq   $0x0,-0x90(%rbp)\n00 00 00 00\nmovq   $0x0,-0x88(%rbp)\n00 00 00 00\nmovq   $0x0,-0x80(%rbp)\n00\nmovq   $0x0,-0x78(%rbp)\n00\nmovq   $0x0,-0x70(%rbp)\n00\nmovq   $0x0,-0x68(%rbp)\n00\nmovq   $0x0,-0x60(%rbp)\n00\nmovq   $0x0,-0x58(%rbp)\n00\nmovq   $0x0,-0x50(%rbp)\n00\nmovq   $0x0,-0x48(%rbp)\n00\nmovq   $0x0,-0x40(%rbp)\n00\nmovq   $0x0,-0x38(%rbp)\n00\nmovq   $0x0,-0x30(%rbp)\n00\nmovq   $0x0,-0x28(%rbp)\n00\nmovq   $0x0,-0x20(%rbp)\n00\nmovq   $0x0,-0x18(%rbp)\n00\nmovl   $0x0,-0x124(%rbp)\n00 00 00\nmovl   $0x0,-0x120(%rbp)\n00 00 00\njmp    141e <func0+0x255>\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x120(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nlea    -0x110(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   10b0 <strchr@plt>\ntest   %rax,%rax\njne    1417 <func0+0x24e>\nlea    -0x110(%rbp),%rax\nmov    %rax,%rdi\ncall   1090 <strlen@plt>\nmov    %eax,-0x11c(%rbp)\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x120(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x11c(%rbp),%eax\ncltq\nmov    %dl,-0x110(%rbp,%rax,1)\nmov    -0x11c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmovb   $0x0,-0x110(%rbp,%rax,1)\n00\naddl   $0x1,-0x124(%rbp)\naddl   $0x1,-0x120(%rbp)\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x120(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    136a <func0+0x1a1>\nmov    -0x124(%rbp),%eax\ncmp    -0x12c(%rbp),%eax\njg     14a0 <func0+0x2d7>\nmov    -0x124(%rbp),%eax\ncmp    -0x12c(%rbp),%eax\njne    14d0 <func0+0x307>\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x118(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10d0 <strcmp@plt>\ntest   %eax,%eax\njns    14d0 <func0+0x307>\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x118(%rbp)\nmov    -0x124(%rbp),%eax\nmov    %eax,-0x12c(%rbp)\naddl   $0x1,-0x128(%rbp)\nmov    -0x128(%rbp),%eax\ncmp    -0x13c(%rbp),%eax\njl     121b <func0+0x52>\nmov    -0x118(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\n00 00\nje     1504 <func0+0x33b>\ncall   10a0 <__stack_chk_fail@plt>\nleave\nret\n"
    },
    {
        "task_id": 158,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x138,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x128(%rsp)\n00\nxor    %eax,%eax\nlea    0xe45(%rip),%rax\nmov    %rax,0x10(%rsp)\ntest   %esi,%esi\njle    142e <func0+0x265>\nmov    %rdi,%r14\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%rax\nmov    %rax,0x18(%rsp)\nmovl   $0x0,0xc(%rsp)\n00\nlea    0x20(%rsp),%r12\njmp    12b4 <func0+0xeb>\nmov    %r12,%rdi\ncall   1090 <strlen@plt>\nmovslq %eax,%rdx\nmov    %bl,0x20(%rsp,%rdx,1)\nadd    $0x1,%eax\ncltq\nmovb   $0x0,0x20(%rsp,%rax,1)\nadd    $0x1,%r13d\nadd    $0x1,%rbp\nmovzbl -0x1(%rbp),%ebx\ntest   %bl,%bl\nje     1268 <func0+0x9f>\nmovsbl %bl,%esi\nmov    %r12,%rdi\ncall   10b0 <strchr@plt>\ntest   %rax,%rax\njne    1244 <func0+0x7b>\njmp    1227 <func0+0x5e>\nmov    $0x0,%r13d\nmov    0xc(%rsp),%eax\ncmp    %r13d,%eax\njl     129b <func0+0xd2>\njne    12a5 <func0+0xdc>\nmov    0x10(%rsp),%rbx\nmov    %rbx,%rsi\nmov    %r15,%rdi\ncall   10d0 <strcmp@plt>\ntest   %eax,%eax\ncmovns 0xc(%rsp),%r13d\nmov    %r13d,0xc(%rsp)\ncmovns %rbx,%r15\nmov    %r15,0x10(%rsp)\njmp    12a5 <func0+0xdc>\nmov    %r13d,0xc(%rsp)\nmov    %r15,0x10(%rsp)\nadd    $0x8,%r14\ncmp    0x18(%rsp),%r14\nje     142e <func0+0x265>\nmovq   $0x0,0x20(%rsp)\n00 00\nmovq   $0x0,0x28(%rsp)\n00 00\nmovq   $0x0,0x30(%rsp)\n00 00\nmovq   $0x0,0x38(%rsp)\n00 00\nmovq   $0x0,0x40(%rsp)\n00 00\nmovq   $0x0,0x48(%rsp)\n00 00\nmovq   $0x0,0x50(%rsp)\n00 00\nmovq   $0x0,0x58(%rsp)\n00 00\nmovq   $0x0,0x60(%rsp)\n00 00\nmovq   $0x0,0x68(%rsp)\n00 00\nmovq   $0x0,0x70(%rsp)\n00 00\nmovq   $0x0,0x78(%rsp)\n00 00\nmovq   $0x0,0x80(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x88(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x90(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x98(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xa0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xa8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xb0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xb8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xc0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xc8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xd0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xd8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xe0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xe8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xf0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xf8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x100(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x108(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x110(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x118(%rsp)\n00 00 00 00 00\nmov    (%r14),%r15\nmovzbl (%r15),%ebx\ntest   %bl,%bl\nje     1262 <func0+0x99>\nlea    0x1(%r15),%rbp\nmov    $0x0,%r13d\njmp    1250 <func0+0x87>\nmov    0x128(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    1458 <func0+0x28f>\nmov    0x10(%rsp),%rax\nadd    $0x138,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10a0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 158,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x138,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x128(%rsp)\n00\nlea    0x9d0(%rip),%rax\nmov    %rax,0x18(%rsp)\ntest   %esi,%esi\njle    17af <func0+0x16f>\nlea    -0x1(%rsi),%eax\nmovl   $0x0,0xc(%rsp)\n00\nmov    %rdi,%r12\nlea    0x20(%rsp),%rbx\nlea    0x8(%rdi,%rax,8),%rax\nmov    %rax,0x10(%rsp)\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    (%r12),%r13\npxor   %xmm0,%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovzbl 0x0(%r13),%r15d\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x80(%rsp)\n00\nmovaps %xmm0,0x90(%rsp)\n00\nmovaps %xmm0,0xa0(%rsp)\n00\nmovaps %xmm0,0xb0(%rsp)\n00\nmovaps %xmm0,0xc0(%rsp)\n00\nmovaps %xmm0,0xd0(%rsp)\n00\nmovaps %xmm0,0xe0(%rsp)\n00\nmovaps %xmm0,0xf0(%rsp)\n00\nmovaps %xmm0,0x100(%rsp)\n00\nmovaps %xmm0,0x110(%rsp)\n00\ntest   %r15b,%r15b\nje     17f0 <func0+0x1b0>\nlea    0x1(%r13),%r14\nxor    %ebp,%ebp\njmp    173d <func0+0xfd>\nnopl   0x0(%rax)\nmovzbl (%r14),%r15d\nadd    $0x1,%r14\ntest   %r15b,%r15b\nje     1779 <func0+0x139>\nmovsbl %r15b,%esi\nmov    %rbx,%rdi\ncall   10b0 <strchr@plt>\ntest   %rax,%rax\njne    1730 <func0+0xf0>\nmov    %rbx,%rdi\nadd    $0x1,%r14\nadd    $0x1,%ebp\ncall   1090 <strlen@plt>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmov    %r15b,0x20(%rsp,%rsi,1)\nmovzbl -0x1(%r14),%r15d\ncltq\nmovb   $0x0,0x20(%rsp,%rax,1)\ntest   %r15b,%r15b\njne    173d <func0+0xfd>\ncmp    %ebp,0xc(%rsp)\njl     17e0 <func0+0x1a0>\njne    17a0 <func0+0x160>\nmov    0x18(%rsp),%r14\nmov    %r13,%rdi\nmov    %r14,%rsi\ncall   10d0 <strcmp@plt>\ntest   %eax,%eax\ncmovns %r14,%r13\nmov    %r13,0x18(%rsp)\nnopl   0x0(%rax)\nadd    $0x8,%r12\ncmp    0x10(%rsp),%r12\njne    16a0 <func0+0x60>\nmov    0x128(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    17f4 <func0+0x1b4>\nmov    0x18(%rsp),%rax\nadd    $0x138,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmov    %ebp,0xc(%rsp)\nmov    %r13,0x18(%rsp)\njmp    17a0 <func0+0x160>\nnopl   0x0(%rax,%rax,1)\nxor    %ebp,%ebp\njmp    1779 <func0+0x139>\ncall   10a0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 158,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x138,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x128(%rsp)\n00\nlea    0x8d3(%rip),%rax\nmov    %rax,0x18(%rsp)\ntest   %esi,%esi\njle    1887 <func0+0x147>\nlea    -0x1(%rsi),%eax\nmovl   $0x0,0xc(%rsp)\n00\nmov    %rdi,%r12\nlea    0x20(%rsp),%rbx\nlea    0x8(%rdi,%rax,8),%rax\nmov    %rax,0x10(%rsp)\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    (%r12),%r13\npxor   %xmm0,%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovzbl 0x0(%r13),%r15d\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x80(%rsp)\n00\nmovaps %xmm0,0x90(%rsp)\n00\nmovaps %xmm0,0xa0(%rsp)\n00\nmovaps %xmm0,0xb0(%rsp)\n00\nmovaps %xmm0,0xc0(%rsp)\n00\nmovaps %xmm0,0xd0(%rsp)\n00\nmovaps %xmm0,0xe0(%rsp)\n00\nmovaps %xmm0,0xf0(%rsp)\n00\nmovaps %xmm0,0x100(%rsp)\n00\nmovaps %xmm0,0x110(%rsp)\n00\ntest   %r15b,%r15b\nje     1900 <func0+0x1c0>\nlea    0x1(%r13),%r14\nxor    %ebp,%ebp\nnopw   0x0(%rax,%rax,1)\nmovsbl %r15b,%esi\nmov    %rbx,%rdi\ncall   10b0 <strchr@plt>\ntest   %rax,%rax\nje     18b8 <func0+0x178>\nmovzbl (%r14),%r15d\nadd    $0x1,%r14\ntest   %r15b,%r15b\njne    1830 <func0+0xf0>\ncmp    %ebp,0xc(%rsp)\njl     18f1 <func0+0x1b1>\njne    1878 <func0+0x138>\nmov    0x18(%rsp),%r14\nmov    %r13,%rdi\nmov    %r14,%rsi\ncall   10d0 <strcmp@plt>\ntest   %eax,%eax\ncmovns %r14,%r13\nmov    %r13,0x18(%rsp)\nnopl   (%rax)\nadd    $0x8,%r12\ncmp    0x10(%rsp),%r12\njne    17a0 <func0+0x60>\nmov    0x128(%rsp),%rax\n00\nsub    %fs:0x28,%rax\n00 00\njne    1907 <func0+0x1c7>\nmov    0x18(%rsp),%rax\nadd    $0x138,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmov    %rbx,%rdi\nadd    $0x1,%r14\nadd    $0x1,%ebp\ncall   1090 <strlen@plt>\nmovslq %eax,%rsi\nadd    $0x1,%eax\ncltq\nmov    %r15b,0x20(%rsp,%rsi,1)\nmovb   $0x0,0x20(%rsp,%rax,1)\nmovzbl -0x1(%r14),%r15d\ntest   %r15b,%r15b\njne    1830 <func0+0xf0>\ncmp    %ebp,0xc(%rsp)\njge    1858 <func0+0x118>\nmov    %ebp,0xc(%rsp)\nmov    %r13,0x18(%rsp)\njmp    1878 <func0+0x138>\nnop\nxor    %ebp,%ebp\njmp    184e <func0+0x10e>\ncall   10a0 <__stack_chk_fail@plt>\n"
    },
    {
        "task_id": 159,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    %rcx,-0x18(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njle    11a4 <func0+0x3b>\nmov    -0x4(%rbp),%edx\nmov    -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovl   $0x0,(%rax)\njmp    11c2 <func0+0x59>\nmov    -0x4(%rbp),%edx\nmov    -0x8(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0xc(%rbp),%eax\nsub    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 159,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %edx,%esi\njle    117e <func0+0x15>\nadd    %edx,%edi\nmov    $0x0,%edx\nmov    %edi,(%rcx)\nmov    %edx,0x4(%rcx)\nret\nadd    %esi,%edi\nsub    %esi,%edx\njmp    1178 <func0+0xf>\n"
    },
    {
        "task_id": 159,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %edx,%esi\njle    1158 <func0+0x18>\nadd    %edx,%edi\nxor    %edx,%edx\nmov    %edi,(%rcx)\nmov    %edx,0x4(%rcx)\nret\nnopw   0x0(%rax,%rax,1)\nadd    %esi,%edi\nsub    %esi,%edx\nmov    %edi,(%rcx)\nmov    %edx,0x4(%rcx)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n00 00 00 00\nnopl   (%rax)\n"
    },
    {
        "task_id": 159,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %edx,%esi\njle    1160 <func0+0x20>\nlea    (%rdx,%rdi,1),%eax\nxor    %edx,%edx\nmovd   %eax,%xmm0\nmovd   %edx,%xmm1\npunpckldq %xmm1,%xmm0\nmovq   %xmm0,(%rcx)\nret\nxchg   %ax,%ax\nlea    (%rsi,%rdi,1),%eax\nsub    %esi,%edx\nmovd   %eax,%xmm0\nmovd   %edx,%xmm1\npunpckldq %xmm1,%xmm0\nmovq   %xmm0,(%rcx)\nret\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\n"
    },
    {
        "task_id": 160,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %edx,-0x44(%rbp)\nmov    %ecx,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,-0x10(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    1280 <func0+0x97>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x24(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x10(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x48(%rbp),%eax\njl     1236 <func0+0x4d>\nmovl   $0x0,-0x20(%rbp)\njmp    14c2 <func0+0x2d9>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0xd56(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    14be <func0+0x2d5>\njmp    1307 <func0+0x11e>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x20(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    12c7 <func0+0xde>\njmp    1398 <func0+0x1af>\nmov    -0x20(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x20(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    1350 <func0+0x167>\nmov    -0x20(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\npxor   %xmm2,%xmm2\ncvtsi2sd %eax,%xmm2\nmovq   %xmm2,%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   10b0 <pow@plt>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\ncvttsd2si %xmm0,%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x20(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     1294 <func0+0xab>\nmovl   $0x0,-0x1c(%rbp)\njmp    17cf <func0+0x5e6>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0xb13(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\nje     157a <func0+0x391>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0xae8(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    17cb <func0+0x5e2>\njmp    157a <func0+0x391>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    153a <func0+0x351>\njmp    160b <func0+0x422>\nmov    -0x1c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x1c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    15c3 <func0+0x3da>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x993(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    1714 <func0+0x52b>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rsi\n00\nmov    -0x8(%rbp),%rdx\nadd    %rsi,%rdx\nmov    (%rdx),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rsi\n00\nmov    -0x10(%rbp),%rdx\nadd    %rsi,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\njmp    179a <func0+0x5b1>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x10(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%edi\nmov    -0x1c(%rbp),%ecx\nmovslq %ecx,%rcx\nlea    0x0(,%rcx,4),%rsi\n00\nmov    -0x8(%rbp),%rcx\nadd    %rsi,%rcx\nmov    (%rcx),%ecx\nmovslq %ecx,%rcx\nlea    0x0(,%rcx,4),%rsi\n00\nmov    -0x10(%rbp),%rcx\nadd    %rsi,%rcx\ncltd\nidiv   %edi\nmov    %eax,(%rcx)\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     14da <func0+0x2f1>\nmovl   $0x0,-0x18(%rbp)\njmp    1ad4 <func0+0x8eb>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x80b(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\nje     1887 <func0+0x69e>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x7e0(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    1ad0 <func0+0x8e7>\njmp    1887 <func0+0x69e>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    1847 <func0+0x65e>\njmp    1918 <func0+0x72f>\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    18d0 <func0+0x6e7>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x68b(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    1a1e <func0+0x835>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\n00\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\n00\nmov    -0x10(%rbp),%rax\nadd    %rsi,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\njmp    1a9f <func0+0x8b6>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\n00\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\n00\nmov    -0x10(%rbp),%rax\nadd    %rsi,%rax\nsub    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     17e7 <func0+0x5fe>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   10a0 <free@plt>\nmov    -0x14(%rbp),%eax\nleave\nret\n"
    },
    {
        "task_id": 160,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,0x28(%rsp)\nmov    %rsi,%r12\nmov    %edx,%ebp\nmov    %ecx,%r14d\nmovslq %ecx,%rbx\nshl    $0x2,%rbx\nmov    %rbx,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,%r13\nmov    %rbx,%rdi\ncall   10f0 <malloc@plt>\nmov    %rax,%rbx\ntest   %r14d,%r14d\njle    1247 <func0+0x5e>\nmov    %r14d,%ecx\nmov    $0x0,%eax\nmov    (%r12,%rax,4),%edx\nmov    %edx,0x0(%r13,%rax,4)\nmov    %eax,(%rbx,%rax,4)\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    1232 <func0+0x49>\ntest   %ebp,%ebp\njle    14da <func0+0x2f1>\nmov    0x28(%rsp),%r15\nmov    %r15,0x18(%rsp)\nmov    %rbx,%r14\nmov    %ebp,%ebp\nlea    (%rbx,%rbp,4),%rax\nmov    %rax,0x8(%rsp)\nmov    %rbx,%r12\njmp    12b8 <func0+0xcf>\nmov    0x0(%rbp),%eax\nmov    %eax,0x10(%rsp)\ncltq\nlea    0x0(%r13,%rax,4),%rdi\nmov    %rdi,0x20(%rsp)\npxor   %xmm0,%xmm0\ncvtsi2sdl (%rdi),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sdl 0x0(%r13,%rsi,1),%xmm1\ncall   10b0 <pow@plt>\ncvttsd2si %xmm0,%eax\nmov    0x20(%rsp),%rdi\nmov    %eax,(%rdi)\nmov    0x10(%rsp),%eax\nmov    %eax,0x4(%rbp)\nadd    $0x8,%r15\nadd    $0x4,%r12\ncmp    0x8(%rsp),%r12\nje     131f <func0+0x136>\nlea    0xd45(%rip),%rsi\nmov    (%r15),%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    12a9 <func0+0xc0>\nmov    %r12,%rbp\nmov    (%r12),%edx\nmovslq %edx,%rax\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%edx\nje     12ea <func0+0x101>\nmov    %eax,0x0(%rbp)\nmov    %eax,%edx\ncltq\nmov    (%rbx,%rax,4),%eax\ncmp    %edx,%eax\njne    12dc <func0+0xf3>\nmov    0x4(%rbp),%edx\nmovslq %edx,%rax\nlea    0x0(,%rax,4),%rsi\n00\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%edx\nje     126c <func0+0x83>\nmov    %eax,0x4(%rbp)\nmovslq %eax,%rdx\nlea    0x0(,%rdx,4),%rsi\n00\nmov    %eax,%ecx\nmov    (%rbx,%rdx,4),%eax\ncmp    %ecx,%eax\njne    1303 <func0+0x11a>\njmp    126c <func0+0x83>\nmov    %rbx,%r15\nmov    0x28(%rsp),%rax\nmov    %rax,0x20(%rsp)\njmp    13be <func0+0x1d5>\nmov    %r15,%rbp\nmov    (%r15),%edx\nmovslq %edx,%rax\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%edx\nje     134f <func0+0x166>\nmov    %eax,0x0(%rbp)\nmov    %eax,%edx\ncltq\nmov    (%rbx,%rax,4),%eax\ncmp    %edx,%eax\njne    1341 <func0+0x158>\nmov    0x4(%rbp),%edx\nmovslq %edx,%rax\nlea    0x0(,%rax,4),%r12\n00\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%edx\nje     137b <func0+0x192>\nmov    %eax,0x4(%rbp)\nmovslq %eax,%rdx\nlea    0x0(,%rdx,4),%r12\n00\nmov    %eax,%ecx\nmov    (%rbx,%rdx,4),%eax\ncmp    %ecx,%eax\njne    1364 <func0+0x17b>\nlea    0xc83(%rip),%rsi\nmov    0x10(%rsp),%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    13fc <func0+0x213>\nmovslq 0x0(%rbp),%rax\nlea    0x0(%r13,%rax,4),%rdx\nmov    (%rdx),%eax\nimul   0x0(%r13,%r12,1),%eax\nmov    %eax,(%rdx)\nmov    0x0(%rbp),%eax\nmov    %eax,0x4(%rbp)\naddq   $0x8,0x20(%rsp)\nadd    $0x4,%r15\ncmp    0x8(%rsp),%r15\nje     1493 <func0+0x2aa>\nmov    0x20(%rsp),%rax\nmov    (%rax),%rax\nmov    %rax,0x10(%rsp)\nlea    0xc33(%rip),%rsi\nmov    %rax,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\nje     1331 <func0+0x148>\nlea    0xc1e(%rip),%rsi\nmov    0x10(%rsp),%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    13a9 <func0+0x1c0>\njmp    1331 <func0+0x148>\nmovslq 0x0(%rbp),%rax\nlea    0x0(%r13,%rax,4),%rcx\nmov    (%rcx),%eax\ncltd\nidivl  0x0(%r13,%r12,1)\nmov    %eax,(%rcx)\njmp    13a3 <func0+0x1ba>\nmov    %r14,%rbp\nmov    (%r14),%edx\nmovslq %edx,%rax\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%edx\nje     142f <func0+0x246>\nmov    %eax,0x0(%rbp)\nmov    %eax,%edx\ncltq\nmov    (%rbx,%rax,4),%eax\ncmp    %edx,%eax\njne    1421 <func0+0x238>\nmov    0x4(%rbp),%edx\nmovslq %edx,%rax\nlea    0x0(,%rax,4),%r12\n00\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%edx\nje     145b <func0+0x272>\nmov    %eax,0x4(%rbp)\nmovslq %eax,%rdx\nlea    0x0(,%rdx,4),%r12\n00\nmov    %eax,%ecx\nmov    (%rbx,%rdx,4),%eax\ncmp    %ecx,%eax\njne    1444 <func0+0x25b>\nlea    0xba8(%rip),%rsi\nmov    %r15,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    14ca <func0+0x2e1>\nmovslq 0x0(%rbp),%rax\nmov    0x0(%r13,%r12,1),%edx\nadd    %edx,0x0(%r13,%rax,4)\nmov    0x0(%rbp),%eax\nmov    %eax,0x4(%rbp)\naddq   $0x8,0x18(%rsp)\nadd    $0x4,%r14\ncmp    0x8(%rsp),%r14\nje     14da <func0+0x2f1>\nmov    0x18(%rsp),%rax\nmov    (%rax),%r15\nlea    0xb68(%rip),%rsi\nmov    %r15,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\nje     1411 <func0+0x228>\nlea    0xb53(%rip),%rsi\nmov    %r15,%rdi\ncall   10e0 <strcmp@plt>\ntest   %eax,%eax\njne    1482 <func0+0x299>\njmp    1411 <func0+0x228>\nmovslq 0x0(%rbp),%rax\nmov    0x0(%r13,%r12,1),%edx\nsub    %edx,0x0(%r13,%rax,4)\njmp    147c <func0+0x293>\nmov    0x0(%r13),%ebp\nmov    %r13,%rdi\ncall   10a0 <free@plt>\nmov    %rbx,%rdi\ncall   10a0 <free@plt>\nmov    %ebp,%eax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"
    },
    {
        "task_id": 160,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rsi,%r14\npush   %r13\nmovslq %ecx,%r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x0(,%r13,4),%rbx\n00\nsub    $0x28,%rsp\nmov    %rdi,0x18(%rsp)\nmov    %rbx,%rdi\nmov    %edx,0x14(%rsp)\ncall   10f0 <malloc@plt>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncall   10f0 <malloc@plt>\nmov    %rax,%rbp\ntest   %r13d,%r13d\njle    13e5 <func0+0x65>\nmov    %rbx,%rdx\nmov    %r14,%rsi\nmov    %r12,%rdi\ncall   10e0 <memcpy@plt>\nxor    %eax,%eax\nnopl   0x0(%rax)\nmov    %eax,0x0(%rbp,%rax,4)\nadd    $0x1,%rax\ncmp    %r13,%rax\njne    13d8 <func0+0x58>\nmov    0x14(%rsp),%eax\ntest   %eax,%eax\njle    1643 <func0+0x2c3>\nmov    0x14(%rsp),%eax\nmov    0x18(%rsp),%r14\nlea    0x4(%rbp),%rdx\nsub    $0x1,%eax\nmov    %r14,%r13\nlea    0x8(%r14,%rax,8),%rbx\nnopl   0x0(%rax)\nmov    (%r14),%rax\ncmpb   $0x2a,(%rax)\njne    14c0 <func0+0x140>\ncmpb   $0x2a,0x1(%rax)\njne    14c0 <func0+0x140>\ncmpb   $0x0,0x2(%rax)\njne    14c0 <func0+0x140>\nmovslq -0x4(%rdx),%rax\nmov    %rax,%r15\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%r15d\nje     1451 <func0+0xd1>\ncltq\nmov    %eax,-0x4(%rdx)\nmov    %rax,%r15\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %r15d,%eax\njne    1440 <func0+0xc0>\nmovslq (%rdx),%rax\nmov    %rax,%rcx\nlea    0x0(,%rax,4),%r9\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%ecx\nje     1487 <func0+0x107>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq %eax,%rcx\nmov    %eax,(%rdx)\nmov    %eax,%esi\nmov    0x0(%rbp,%rcx,4),%eax\nlea    0x0(,%rcx,4),%r9\n00\ncmp    %esi,%eax\njne    1470 <func0+0xf0>\nmovslq %r15d,%rax\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\nmov    %rdx,0x8(%rsp)\ncvtsi2sdl (%r12,%r9,1),%xmm1\nlea    (%r12,%rax,4),%rax\ncvtsi2sdl (%rax),%xmm0\nmov    %rax,(%rsp)\ncall   10b0 <pow@plt>\nmov    (%rsp),%rax\nmov    0x8(%rsp),%rdx\ncvttsd2si %xmm0,%ecx\nmov    %r15d,(%rdx)\nmov    %ecx,(%rax)\nadd    $0x8,%r14\nadd    $0x4,%rdx\ncmp    %r14,%rbx\njne    1410 <func0+0x90>\nmov    0x14(%rsp),%r14d\nmov    0x18(%rsp),%rbx\nmov    %rbp,%rdi\nmov    %rbp,%rsi\nlea    0x0(%rbp,%r14,4),%r8\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmov    (%rbx),%r11\nmovzbl (%r11),%r10d\ncmp    $0x2a,%r10d\njne    1688 <func0+0x308>\ncmpb   $0x0,0x1(%r11)\njne    1688 <func0+0x308>\nmovslq (%rsi),%rax\nmov    %rax,%rcx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%ecx\nje     152f <func0+0x1af>\nnopw   0x0(%rax,%rax,1)\ncltq\nmov    %eax,(%rsi)\nmov    %rax,%rcx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %ecx,%eax\njne    1520 <func0+0x1a0>\nmovslq 0x4(%rsi),%rax\nmov    %rax,%rdx\nlea    0x0(,%rax,4),%r14\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\nje     156a <func0+0x1ea>\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovslq %eax,%rdx\nmov    %eax,0x4(%rsi)\nmov    %eax,%r9d\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%r14\n00\ncmp    %r9d,%eax\njne    1550 <func0+0x1d0>\nsub    $0x2a,%r10d\njne    1575 <func0+0x1f5>\nmovzbl 0x1(%r11),%r10d\nadd    %r12,%r14\nmovslq %ecx,%rax\ntest   %r10d,%r10d\njne    16c0 <func0+0x340>\nlea    (%r12,%rax,4),%rdx\nmov    (%rdx),%eax\nimul   (%r14),%eax\nmov    %eax,(%rdx)\nmov    %ecx,0x4(%rsi)\nadd    $0x4,%rsi\nadd    $0x8,%rbx\ncmp    %rsi,%r8\njne    14f0 <func0+0x170>\nnopl   0x0(%rax)\nmov    0x0(%r13),%rax\nmovzbl (%rax),%r10d\ncmp    $0x2b,%r10d\njne    1670 <func0+0x2f0>\ncmpb   $0x0,0x1(%rax)\njne    1670 <func0+0x2f0>\nmovslq (%rdi),%rax\nmov    %rax,%rdx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\nje     15e7 <func0+0x267>\nnopw   0x0(%rax,%rax,1)\ncltq\nmov    %eax,(%rdi)\nmov    %rax,%rdx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\njne    15d8 <func0+0x258>\nmovslq 0x4(%rdi),%rax\nmov    %rax,%rcx\nlea    0x0(,%rax,4),%r9\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%ecx\nje     1618 <func0+0x298>\nxchg   %ax,%ax\nmovslq %eax,%rcx\nmov    %eax,0x4(%rdi)\nmov    %eax,%esi\nmov    0x0(%rbp,%rcx,4),%eax\nlea    0x0(,%rcx,4),%r9\n00\ncmp    %esi,%eax\njne    1600 <func0+0x280>\nadd    %r12,%r9\nmovslq %edx,%rax\nmov    (%r9),%ecx\ncmp    $0x2b,%r10d\njne    16b0 <func0+0x330>\nadd    %ecx,(%r12,%rax,4)\nmov    %edx,0x4(%rdi)\nadd    $0x4,%rdi\nadd    $0x8,%r13\ncmp    %rdi,%r8\njne    15a8 <func0+0x228>\nmov    %r12,%rdi\nmov    (%r12),%r13d\ncall   10a0 <free@plt>\nmov    %rbp,%rdi\ncall   10a0 <free@plt>\nadd    $0x28,%rsp\nmov    %r13d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\ncmp    $0x2d,%r10d\njne    1632 <func0+0x2b2>\ncmpb   $0x0,0x1(%rax)\nje     15c4 <func0+0x244>\njmp    1632 <func0+0x2b2>\nnopw   0x0(%rax,%rax,1)\ncmpb   $0x2f,(%r11)\njne    1593 <func0+0x213>\ncmpb   $0x2f,0x1(%r11)\njne    1593 <func0+0x213>\ncmpb   $0x0,0x2(%r11)\nje     150c <func0+0x18c>\njmp    1593 <func0+0x213>\nnopl   (%rax)\nsub    %ecx,(%r12,%rax,4)\njmp    162f <func0+0x2af>\nnopl   0x0(%rax)\nlea    (%r12,%rax,4),%r9\nmov    (%r9),%eax\ncltd\nidivl  (%r14)\nmov    %eax,(%r9)\njmp    1590 <func0+0x210>\n"
    },
    {
        "task_id": 160,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rsi,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmovslq %ecx,%rbp\npush   %rbx\nmov    %rbp,%r13\nshl    $0x2,%rbp\nsub    $0x28,%rsp\nmov    %rdi,0x18(%rsp)\nmov    %rbp,%rdi\nmov    %edx,0x14(%rsp)\ncall   10f0 <malloc@plt>\nmov    %rbp,%rdi\nmov    %rax,%r12\ncall   10f0 <malloc@plt>\nmov    %rax,%rbp\ntest   %r13d,%r13d\njle    1478 <func0+0xd8>\nmov    %r13d,%edx\nmov    %r15,%rsi\nmov    %r12,%rdi\nshl    $0x2,%rdx\ncall   10e0 <memcpy@plt>\nlea    -0x1(%r13),%eax\ncmp    $0x2,%eax\njbe    1773 <func0+0x3d3>\nmov    %r13d,%edx\nmovdqa 0xc9f(%rip),%xmm0\n00\nmovdqa 0xca7(%rip),%xmm2\n00\nmov    %rbp,%rax\nshr    $0x2,%edx\nshl    $0x4,%rdx\nadd    %rbp,%rdx\ncs nopw 0x0(%rax,%rax,1)\n00 00 00\nmovdqa %xmm0,%xmm1\nadd    $0x10,%rax\npaddd  %xmm2,%xmm0\nmovups %xmm1,-0x10(%rax)\ncmp    %rax,%rdx\njne    1430 <func0+0x90>\nmov    %r13d,%eax\nand    $0xfffffffc,%eax\ntest   $0x3,%r13b\nje     1478 <func0+0xd8>\nmovslq %eax,%rdx\nmov    %eax,0x0(%rbp,%rdx,4)\nlea    0x0(,%rdx,4),%rcx\n00\nlea    0x1(%rax),%edx\ncmp    %edx,%r13d\njle    1478 <func0+0xd8>\nadd    $0x2,%eax\nmov    %edx,0x4(%rbp,%rcx,1)\ncmp    %eax,%r13d\njle    1478 <func0+0xd8>\nmov    %eax,0x8(%rbp,%rcx,1)\nmov    0x14(%rsp),%eax\ntest   %eax,%eax\njle    16e3 <func0+0x343>\nmov    0x14(%rsp),%eax\nmov    0x18(%rsp),%r14\nlea    0x4(%rbp),%r15\nsub    $0x1,%eax\nmov    %r14,%r13\nlea    0x8(%r14,%rax,8),%rbx\nnopl   0x0(%rax)\nmov    (%r14),%rax\ncmpb   $0x2a,(%rax)\njne    156e <func0+0x1ce>\ncmpb   $0x2a,0x1(%rax)\njne    156e <func0+0x1ce>\ncmpb   $0x0,0x2(%rax)\njne    156e <func0+0x1ce>\nmovslq -0x4(%r15),%rax\nmov    %rax,%rcx\nlea    0x0(,%rax,4),%r8\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%ecx\nje     14f9 <func0+0x159>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq %eax,%rdx\nmov    %eax,-0x4(%r15)\nmov    %eax,%ecx\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%r8\n00\ncmp    %ecx,%eax\njne    14e0 <func0+0x140>\nmovslq (%r15),%rax\nmov    %rax,%rdx\nlea    0x0(,%rax,4),%r9\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%edx\nje     1537 <func0+0x197>\nnop\nmovslq %eax,%rdx\nmov    %eax,(%r15)\nmov    %eax,%ecx\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%r9\n00\ncmp    %ecx,%eax\njne    1510 <func0+0x170>\nmovslq -0x4(%r15),%rax\nmov    %rax,%rcx\nlea    0x0(,%rax,4),%r8\n00\nadd    %r12,%r8\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\nmov    %ecx,0x10(%rsp)\ncvtsi2sdl (%r8),%xmm0\nmov    %r8,0x8(%rsp)\ncvtsi2sdl (%r12,%r9,1),%xmm1\ncall   10b0 <pow@plt>\nmov    0x8(%rsp),%r8\nmov    0x10(%rsp),%ecx\ncvttsd2si %xmm0,%edx\nmov    %ecx,(%r15)\nmov    %edx,(%r8)\nadd    $0x8,%r14\nadd    $0x4,%r15\ncmp    %r14,%rbx\njne    14a0 <func0+0x100>\nmov    0x14(%rsp),%r14d\nmov    0x18(%rsp),%rbx\nmov    %rbp,%rdi\nmov    %rbp,%rsi\nlea    0x0(%rbp,%r14,4),%r8\nnopl   0x0(%rax)\nmov    (%rbx),%r11\nmovzbl (%r11),%r10d\ncmp    $0x2a,%r10d\njne    1728 <func0+0x388>\ncmpb   $0x0,0x1(%r11)\njne    1728 <func0+0x388>\nmovslq (%rsi),%rax\nmov    %rax,%rcx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%ecx\nje     15d7 <func0+0x237>\nnopw   0x0(%rax,%rax,1)\ncltq\nmov    %eax,(%rsi)\nmov    %rax,%rcx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %ecx,%eax\njne    15c8 <func0+0x228>\nmovslq 0x4(%rsi),%rax\nmov    %rax,%rdx\nlea    0x0(,%rax,4),%r14\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\nje     160a <func0+0x26a>\nxchg   %ax,%ax\nmovslq %eax,%rdx\nmov    %eax,0x4(%rsi)\nmov    %eax,%r9d\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%r14\n00\ncmp    %r9d,%eax\njne    15f0 <func0+0x250>\nsub    $0x2a,%r10d\njne    1615 <func0+0x275>\nmovzbl 0x1(%r11),%r10d\nadd    %r12,%r14\nmovslq %ecx,%rax\ntest   %r10d,%r10d\njne    1760 <func0+0x3c0>\nlea    (%r12,%rax,4),%rdx\nmov    (%rdx),%eax\nimul   (%r14),%eax\nmov    %eax,(%rdx)\nmov    %ecx,0x4(%rsi)\nadd    $0x4,%rsi\nadd    $0x8,%rbx\ncmp    %rsi,%r8\njne    1598 <func0+0x1f8>\nnopl   0x0(%rax)\nmov    0x0(%r13),%rax\nmovzbl (%rax),%r10d\ncmp    $0x2b,%r10d\njne    1710 <func0+0x370>\ncmpb   $0x0,0x1(%rax)\njne    1710 <func0+0x370>\nmovslq (%rdi),%rax\nmov    %rax,%rdx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\nje     1687 <func0+0x2e7>\nnopw   0x0(%rax,%rax,1)\ncltq\nmov    %eax,(%rdi)\nmov    %rax,%rdx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\njne    1678 <func0+0x2d8>\nmovslq 0x4(%rdi),%rax\nmov    %rax,%rcx\nlea    0x0(,%rax,4),%r9\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%ecx\nje     16b8 <func0+0x318>\nxchg   %ax,%ax\nmovslq %eax,%rcx\nmov    %eax,0x4(%rdi)\nmov    %eax,%esi\nmov    0x0(%rbp,%rcx,4),%eax\nlea    0x0(,%rcx,4),%r9\n00\ncmp    %esi,%eax\njne    16a0 <func0+0x300>\nadd    %r12,%r9\nmovslq %edx,%rax\nmov    (%r9),%ecx\ncmp    $0x2b,%r10d\njne    1750 <func0+0x3b0>\nadd    %ecx,(%r12,%rax,4)\nmov    %edx,0x4(%rdi)\nadd    $0x4,%rdi\nadd    $0x8,%r13\ncmp    %rdi,%r8\njne    1648 <func0+0x2a8>\nmov    %r12,%rdi\nmov    (%r12),%r13d\ncall   10a0 <free@plt>\nmov    %rbp,%rdi\ncall   10a0 <free@plt>\nadd    $0x28,%rsp\nmov    %r13d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\ncmp    $0x2d,%r10d\njne    16d2 <func0+0x332>\ncmpb   $0x0,0x1(%rax)\nje     1664 <func0+0x2c4>\njmp    16d2 <func0+0x332>\nnopw   0x0(%rax,%rax,1)\ncmpb   $0x2f,(%r11)\njne    1633 <func0+0x293>\ncmpb   $0x2f,0x1(%r11)\njne    1633 <func0+0x293>\ncmpb   $0x0,0x2(%r11)\nje     15b4 <func0+0x214>\njmp    1633 <func0+0x293>\nnopl   (%rax)\nsub    %ecx,(%r12,%rax,4)\njmp    16cf <func0+0x32f>\nnopl   0x0(%rax)\nlea    (%r12,%rax,4),%r9\nmov    (%r9),%eax\ncltd\nidivl  (%r14)\nmov    %eax,(%r9)\njmp    1630 <func0+0x290>\nxor    %eax,%eax\njmp    1451 <func0+0xb1>\n"
    },
    {
        "task_id": 161,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   10c0 <strlen@plt>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1331 <func0+0x128>\ncall   1110 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\nje     1329 <func0+0x120>\ncall   1110 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x100,%eax\ntest   %eax,%eax\nje     12cc <func0+0xc3>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   1100 <tolower@plt>\nmov    %eax,%edx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    %dl,(%rax)\njmp    132d <func0+0x124>\ncall   1110 <__ctype_b_loc@plt>\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x200,%eax\ntest   %eax,%eax\nje     132d <func0+0x124>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   10b0 <toupper@plt>\nmov    %eax,%edx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    %dl,(%rax)\njmp    132d <func0+0x124>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     123b <func0+0x32>\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njne    13b4 <func0+0x1ab>\nmovl   $0x0,-0x8(%rbp)\njmp    13a3 <func0+0x19a>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x11(%rbp)\nmov    -0x4(%rbp),%eax\nsub    -0x8(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\nsub    -0x8(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x11(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x8(%rbp)\njl     134e <func0+0x145>\nmov    -0x28(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 161,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r12\ncall   10c0 <strlen@plt>\nmov    %rax,0x8(%rsp)\ntest   %eax,%eax\njle    1298 <func0+0x8f>\nmov    %rax,%r14\ncall   1110 <__ctype_b_loc@plt>\nmov    %rax,%r13\nmov    %r12,%rbx\nlea    -0x1(%r14),%eax\nlea    0x1(%r12,%rax,1),%r15\nmov    $0x0,%r14d\njmp    1270 <func0+0x67>\ntest   $0x2,%ah\nje     1267 <func0+0x5e>\ncall   10b0 <__ctype_toupper_loc@plt>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    (%rsp),%rsi\nmov    %al,(%rsi)\njmp    1267 <func0+0x5e>\nadd    $0x1,%r14d\nadd    $0x1,%rbx\ncmp    %r15,%rbx\nje     129e <func0+0x95>\nmov    %rbx,(%rsp)\nmovzbl (%rbx),%ebp\nmov    0x0(%r13),%rax\nmovzwl (%rax,%rbp,2),%eax\ntest   $0x4,%ah\nje     1263 <func0+0x5a>\ntest   $0x1,%ah\nje     124b <func0+0x42>\ncall   1100 <__ctype_tolower_loc@plt>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    %al,(%rbx)\njmp    1267 <func0+0x5e>\nmov    $0x0,%r14d\ncmp    %r14d,0x8(%rsp)\nje     12b7 <func0+0xae>\nmov    %r12,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x8(%rsp),%rax\nmov    %eax,%edi\nshr    $0x1f,%edi\nadd    %eax,%edi\nsar    %edi\ncmp    $0x1,%eax\njle    12a5 <func0+0x9c>\ncltq\nlea    -0x1(%r12,%rax,1),%rdx\nmov    $0x0,%eax\nmovzbl (%r12,%rax,1),%ecx\nmovzbl (%rdx),%esi\nmov    %sil,(%r12,%rax,1)\nmov    %cl,(%rdx)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%edi\njg     12d6 <func0+0xcd>\njmp    12a5 <func0+0x9c>\n"
    },
    {
        "task_id": 161,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   10c0 <strlen@plt>\nmov    %rax,0x8(%rsp)\ntest   %eax,%eax\njle    15c0 <func0+0x100>\nmov    %rax,%r15\nmov    %r12,%rbx\ncall   1110 <__ctype_b_loc@plt>\nmov    %rax,%r14\nlea    -0x1(%r15),%eax\nxor    %r15d,%r15d\nlea    0x1(%r12,%rax,1),%r13\njmp    1523 <func0+0x63>\nnopl   0x0(%rax,%rax,1)\ntest   $0x1,%ah\nje     1560 <func0+0xa0>\ncall   1100 <__ctype_tolower_loc@plt>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    %al,(%rbx)\nadd    $0x1,%rbx\ncmp    %r13,%rbx\nje     153f <func0+0x7f>\nmovzbl (%rbx),%ebp\nmov    (%r14),%rax\nmovzwl (%rax,%rbp,2),%eax\ntest   $0x4,%ah\njne    1508 <func0+0x48>\nadd    $0x1,%rbx\nadd    $0x1,%r15d\ncmp    %r13,%rbx\njne    1523 <func0+0x63>\ncmp    %r15d,0x8(%rsp)\nje     1578 <func0+0xb8>\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\n00\ntest   $0x2,%ah\nje     151a <func0+0x5a>\ncall   10b0 <__ctype_toupper_loc@plt>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    %al,(%rbx)\njmp    151a <func0+0x5a>\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rax\nmov    %eax,%ecx\nsar    %ecx\nje     1546 <func0+0x86>\nmovslq %eax,%r13\nsub    $0x1,%ecx\nmov    %r12,%rdx\nlea    -0x2(%r12,%r13,1),%rdi\nlea    -0x1(%r12,%r13,1),%rax\nsub    %rcx,%rdi\nnopl   0x0(%rax)\nmovzbl (%rdx),%ecx\nmovzbl (%rax),%esi\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %sil,-0x1(%rdx)\nmov    %cl,0x1(%rax)\ncmp    %rax,%rdi\njne    15a0 <func0+0xe0>\njmp    1546 <func0+0x86>\nnopl   0x0(%rax)\nxor    %r15d,%r15d\njmp    153f <func0+0x7f>\n"
    },
    {
        "task_id": 161,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   10c0 <strlen@plt>\nmov    %rax,0x8(%rsp)\ntest   %eax,%eax\njle    15c0 <func0+0x100>\nmov    %rax,%r15\nmov    %r12,%rbx\ncall   1110 <__ctype_b_loc@plt>\nmov    %rax,%r14\nlea    -0x1(%r15),%eax\nxor    %r15d,%r15d\nlea    0x1(%r12,%rax,1),%r13\njmp    1523 <func0+0x63>\nnopl   0x0(%rax,%rax,1)\ntest   $0x1,%ah\nje     1560 <func0+0xa0>\ncall   1100 <__ctype_tolower_loc@plt>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    %al,(%rbx)\nadd    $0x1,%rbx\ncmp    %rbx,%r13\nje     153f <func0+0x7f>\nmovzbl (%rbx),%ebp\nmov    (%r14),%rax\nmovzwl (%rax,%rbp,2),%eax\ntest   $0x4,%ah\njne    1508 <func0+0x48>\nadd    $0x1,%rbx\nadd    $0x1,%r15d\ncmp    %rbx,%r13\njne    1523 <func0+0x63>\ncmp    %r15d,0x8(%rsp)\nje     1578 <func0+0xb8>\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\n00\ntest   $0x2,%ah\nje     151a <func0+0x5a>\ncall   10b0 <__ctype_toupper_loc@plt>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    %al,(%rbx)\njmp    151a <func0+0x5a>\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rax\nmov    %eax,%ecx\nsar    %ecx\nje     1546 <func0+0x86>\nmovslq %eax,%r13\nsub    $0x1,%ecx\nmov    %r12,%rdx\nlea    -0x2(%r12,%r13,1),%rdi\nlea    -0x1(%r12,%r13,1),%rax\nsub    %rcx,%rdi\nnopl   0x0(%rax)\nmovzbl (%rdx),%ecx\nmovzbl (%rax),%esi\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %sil,-0x1(%rdx)\nmov    %cl,0x1(%rax)\ncmp    %rax,%rdi\njne    15a0 <func0+0xe0>\njmp    1546 <func0+0x86>\nnopl   0x0(%rax)\nxor    %r15d,%r15d\njmp    153f <func0+0x7f>\n"
    },
    {
        "task_id": 162,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1218 <func0+0x2f>\nlea    0xdfd(%rip),%rax\nmov    %rax,%rdi\ncall   10f0 <strdup@plt>\njmp    12bd <func0+0xd4>\nmovl   $0xffffffff,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1272 <func0+0x89>\nmov    -0x10(%rbp),%edx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x15(%rbp)\nmovzbl -0x15(%rbp),%eax\nxor    %eax,-0x14(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1268 <func0+0x7f>\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1261 <func0+0x78>\nmov    -0x14(%rbp),%eax\nshr    %eax\nxor    $0xedb88320,%eax\nmov    %eax,-0x14(%rbp)\njmp    1264 <func0+0x7b>\nshrl   -0x14(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njbe    1248 <func0+0x5f>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%edx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1228 <func0+0x3f>\nnotl   -0x14(%rbp)\nmov    $0x9,%edi\ncall   10d0 <malloc@plt>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     12b9 <func0+0xd0>\nmov    -0x14(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0xd64(%rip),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   10e0 <sprintf@plt>\nmov    -0x8(%rbp),%rax\nleave\nret\n"
    },
    {
        "task_id": 162,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%eax\nmov    $0x0,%esi\nmov    $0xffffffff,%r8d\ntest   %al,%al\njne    1223 <func0+0x3a>\nlea    0xdf8(%rip),%rdi\ncall   10e0 <strdup@plt>\nmov    %rax,%rbp\njmp    1286 <func0+0x9d>\nadd    $0x1,%esi\nmov    %esi,%eax\nmovzbl (%rdi,%rax,1),%eax\ntest   %al,%al\nje     124e <func0+0x65>\nmovzbl %al,%eax\nxor    %eax,%r8d\nmov    $0x8,%edx\nmov    %r8d,%eax\nshr    %eax\nxor    $0xedb88320,%eax\nmov    %r8d,%ecx\nshr    %ecx\ntest   $0x1,%r8b\ncmove  %ecx,%eax\nmov    %eax,%r8d\nsub    $0x1,%edx\njne    122e <func0+0x45>\njmp    1216 <func0+0x2d>\nmov    %r8d,%ebx\nnot    %ebx\nmov    $0x9,%edi\ncall   10d0 <malloc@plt>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1286 <func0+0x9d>\nmov    %ebx,%r8d\nlea    0xd9a(%rip),%rcx\nmov    $0x9,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   10f0 <__sprintf_chk@plt>\nmov    %rbp,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n"
    },
    {
        "task_id": 162,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     141b <func0+0x9b>\npush   %r12\nxor    %esi,%esi\nmov    $0xffffffff,%r8d\npush   %rbx\nsub    $0x8,%rsp\nxchg   %ax,%ax\nxor    %eax,%r8d\nmov    $0x8,%eax\nnopl   0x0(%rax,%rax,1)\n00\nmov    %r8d,%ecx\nshr    %r8d\nmov    %r8d,%edx\nand    $0x1,%ecx\nxor    $0xedb88320,%edx\ntest   %ecx,%ecx\ncmovne %edx,%r8d\nsub    $0x1,%eax\njne    13b0 <func0+0x30>\nlea    0x1(%rsi),%eax\nmov    %rax,%rsi\nmovzbl (%rdi,%rax,1),%eax\ntest   %al,%al\njne    13a0 <func0+0x20>\nmov    $0x9,%edi\nmov    %r8d,%ebx\ncall   10d0 <malloc@plt>\nnot    %ebx\nmov    %rax,%r12\ntest   %rax,%rax\nje     1410 <func0+0x90>\nmov    %rax,%rdi\nmov    %ebx,%r8d\nlea    0xc0a(%rip),%rcx\nxor    %eax,%eax\nmov    $0x9,%edx\nmov    $0x1,%esi\ncall   10f0 <__sprintf_chk@plt>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\nlea    0xbe2(%rip),%rdi\njmp    10e0 <strdup@plt>\n"
    },
    {
        "task_id": 162,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     1487 <func0+0x107>\npush   %r12\nxor    %esi,%esi\nmov    $0xffffffff,%r8d\npush   %rbx\nsub    $0x8,%rsp\nxchg   %ax,%ax\nmovzbl %al,%eax\nxor    %r8d,%eax\nmov    %eax,%ecx\nshr    %ecx\nmov    %ecx,%edx\nxor    $0xedb88320,%edx\ntest   $0x1,%al\ncmovne %edx,%ecx\nmov    %ecx,%edx\nshr    %edx\nmov    %edx,%eax\nxor    $0xedb88320,%eax\nand    $0x1,%ecx\ncmovne %eax,%edx\nmov    %edx,%eax\nshr    %eax\nmov    %eax,%ecx\nxor    $0xedb88320,%ecx\nand    $0x1,%edx\ncmovne %ecx,%eax\nmov    %eax,%edx\nshr    %edx\nmov    %edx,%ecx\nxor    $0xedb88320,%ecx\ntest   $0x1,%al\ncmovne %ecx,%edx\nmov    %edx,%eax\nshr    %eax\nmov    %eax,%ecx\nxor    $0xedb88320,%ecx\nand    $0x1,%edx\ncmovne %ecx,%eax\nmov    %eax,%edx\nshr    %edx\nmov    %edx,%ecx\nxor    $0xedb88320,%ecx\ntest   $0x1,%al\ncmovne %ecx,%edx\nmov    %edx,%eax\nshr    %eax\nmov    %eax,%ecx\nxor    $0xedb88320,%ecx\nand    $0x1,%edx\ncmovne %ecx,%eax\nmov    %eax,%r8d\nshr    %r8d\nmov    %r8d,%edx\nxor    $0xedb88320,%edx\ntest   $0x1,%al\nlea    0x1(%rsi),%eax\nmov    %rax,%rsi\nmovzbl (%rdi,%rax,1),%eax\ncmovne %edx,%r8d\ntest   %al,%al\njne    13a0 <func0+0x20>\nmov    $0x9,%edi\nmov    %r8d,%ebx\ncall   10d0 <malloc@plt>\nnot    %ebx\nmov    %rax,%r12\ntest   %rax,%rax\nje     147c <func0+0xfc>\nmov    %rax,%rdi\nmov    %ebx,%r8d\nlea    0xb9e(%rip),%rcx\nxor    %eax,%eax\nmov    $0x9,%edx\nmov    $0x1,%esi\ncall   10f0 <__sprintf_chk@plt>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\nlea    0xb76(%rip),%rdi\njmp    10e0 <strdup@plt>\n"
    },
    {
        "task_id": 163,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %rdx,-0x20(%rbp)\nmov    %rcx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    11c3 <func0+0x3a>\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x8(%rbp)\njmp    1204 <func0+0x7b>\ncmpl   $0x9,-0x8(%rbp)\njg     1200 <func0+0x77>\nmov    -0x8(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    1200 <func0+0x77>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x28(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njle    11cb <func0+0x42>\nnop\nnop\npop    %rbp\nret\n"
    },
    {
        "task_id": 163,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovl   $0x0,(%rcx)\ncmp    %edi,%esi\njge    11a6 <func0+0x1d>\nmov    %edi,%eax\nmov    %esi,%edi\nmov    %eax,%esi\njmp    11a6 <func0+0x1d>\nadd    $0x1,%edi\ncmp    %edi,%esi\njl     11c1 <func0+0x38>\ncmp    $0x9,%edi\njg     119f <func0+0x16>\ntest   $0x1,%dil\njne    119f <func0+0x16>\nmov    (%rcx),%eax\nlea    0x1(%rax),%r8d\nmov    %r8d,(%rcx)\ncltq\nmov    %edi,(%rdx,%rax,4)\njmp    119f <func0+0x16>\nret\n"
    },
    {
        "task_id": 163,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovl   $0x0,(%rcx)\ncmp    %edi,%esi\njge    13c8 <func0+0x18>\nmov    %edi,%eax\nmov    %esi,%edi\nmov    %eax,%esi\nnopl   0x0(%rax)\ncmp    $0x9,%edi\njg     13e0 <func0+0x30>\ntest   $0x1,%dil\njne    13e0 <func0+0x30>\nmovslq (%rcx),%rax\nlea    0x1(%rax),%r8d\nmov    %r8d,(%rcx)\nmov    %edi,(%rdx,%rax,4)\nadd    $0x1,%edi\ncmp    %edi,%esi\njge    13c8 <func0+0x18>\nret\nnopl   0x0(%rax,%rax,1)\n00\n"
    },
    {
        "task_id": 163,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovl   $0x0,(%rcx)\nmov    %edi,%eax\ncmp    %edi,%esi\njge    1344 <func0+0x14>\nmov    %esi,%eax\nmov    %edi,%esi\ncmp    $0x9,%eax\njg     1378 <func0+0x48>\nmov    $0x9,%edi\ncmp    %edi,%esi\ncmovg  %edi,%esi\nnopl   0x0(%rax,%rax,1)\ntest   $0x1,%al\njne    1369 <func0+0x39>\nmovslq (%rcx),%rdi\nlea    0x1(%rdi),%r8d\nmov    %r8d,(%rcx)\nmov    %eax,(%rdx,%rdi,4)\nadd    $0x1,%eax\ncmp    %esi,%eax\njle    1358 <func0+0x28>\nret\nnopl   0x0(%rax)\nret\nnopl   0x0(%rax)\n"
    }
]